Instructions:
You are an expert Python developer tasked with recreating a complex GUI application's core display logic. Your goal is to generate a complete Python script that precisely matches the functionality, class structure, and design of the provided code snippet. Do not use any external libraries other than the ones explicitly imported. Do not write the if __name__ == "__main__": block; focus only on the class and function definitions.

Anticipated Functionality & Logic to Implement:
The core functionality of the script is to dynamically build a Tkinter GUI by recursively traversing a predefined directory structure. It must also implement "tear-off" tabs that can be moved from the main window to a new, independent Toplevel window.

Here is a step-by-step breakdown of the required logic:

Class Structure:

Create a single class named Application that inherits from tkinter.Tk.

The __init__ constructor must accept a single argument, mqtt_util, and store it as a class attribute.

Inside the constructor, initialize the main Tkinter window with a title, geometry, and a ttk.PanedWindow to hold the main UI and a console output.

Create a ttk.Notebook to act as the primary tabbed interface and add it to the PanedWindow.

Create a scrolledtext.ScrolledText widget for the console output and add it to the PanedWindow as well.

Create and configure a local _print_to_gui_console function that updates the ScrolledText widget.

Initialize three state-management dictionaries as class attributes: _notebooks, _frames_by_path, and _detached_windows.

Styling & Theming:

Implement a private method _apply_styles(self, theme_name: str) that takes a theme name as an argument.

This method should retrieve a color dictionary from a global THEMES constant (assume THEMES and DEFAULT_THEME are available from display.styling.style).

It must use ttk.Style to configure the appearance of widgets, specifically the background, foreground, font, padding, and border of . (all widgets), TFrame, TNotebook, and TNotebook.Tab. Use the theme's color values for these configurations.

The method should return the applied theme's color dictionary.

Recursive GUI Builder (_build_from_directory):

Implement the core recursive function _build_from_directory(self, path: pathlib.Path, parent_widget).

This function should identify and process subdirectories based on specific naming conventions:

Layout Directories: If a directory name starts with left_, right_, top_, or bottom_, create a new ttk.Frame and use the .place() geometry manager with relative coordinates and sizes parsed from the directory name (e.g., left_50 means relwidth=0.5). Recursively call this function on the new frame.

Tab Directories: If a directory name starts with tab_ or sub_tab_, create a new ttk.Notebook and, for each subdirectory, add a new ttk.Frame as a tab. Parse the tab's display name from the folder name (e.g., tab_1_main_page becomes Main Page). Recursively call this function on the new tab's frame.

Child Directories/Files: If a directory or file name starts with child_ or gui_, call the _build_child_container method on it.

Dynamic Component Loader (_build_child_container):

Implement the method _build_child_container(self, path: pathlib.Path, parent_widget).

This function must dynamically import a Python module from the specified path using importlib.util.

It should then inspect the imported module using inspect.getmembers.

The function must search for a class that is a subclass of ttk.Frame. If found, it should instantiate the class, passing the parent_widget and the mqtt_util instance to its constructor.

As a fallback, if no ttk.Frame subclass is found, it should check for a function named create_yo_button_frame and call it with the parent_widget as an argument.

If neither is found, raise an AttributeError.

Tear-off Tab Functionality (_tear_off_tab):

Implement a method _tear_off_tab(self, event).

This method should be triggered by a <<Control-Button-1>> event on a ttk.Notebook tab.

It must identify the clicked tab, get its content frame, and its title.

Create a new tk.Toplevel window, set its title to the tab's title, and move the tab's frame from the notebook to this new window using pack(in_=...).

Store the new window, original notebook, and tab title in the _detached_windows dictionary.

Bind the new window's close protocol ("WM_DELETE_WINDOW") to the _re_attach_tab method, passing the frame as an argument.

Re-attach Tab Functionality (_re_attach_tab):

Implement the method _re_attach_tab(self, frame).

This function should be called when a detached window is closed.

It must retrieve the original notebook and tab title from the _detached_windows dictionary.

Move the frame back to its original notebook using pack(in_=...).

Add the frame back as a tab to the notebook using the stored title.

Clean up the state by deleting the entry from _detached_windows and destroying the Toplevel window.

Event Handling & Logging:

Implement the _on_tab_change(self, event) method to log a debug message whenever a tab is selected. This method should track the last selected tab name.

Ensure all methods include try...except blocks to handle exceptions gracefully, logging both a console-friendly message and a detailed debug message using the provided console_log and debug_log utility functions.

Output Requirements:

The final output should be a single, complete Python script.

All code should be well-commented and follow Python best practices (e.g., snake_case for functions and variables, PascalCase for classes).

The code should be a direct, functional reproduction of the provided snippet's logic. Do not add or remove any functionality.

Include all necessary import statements at the top.

Do not include the if __name__ == "__main__": block.