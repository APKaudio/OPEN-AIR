# └── OPEN-AIR/
#├── DATA/
#├── SUB APP - CSV to json APP/
#├── Sample imports/
#├── build/
#├── datasets/
#├── display/
#├── managers/
#├── workers/
#├── .gitignore (Lines: 2)
#├── OPEN-AIR.spec (Lines: 73)
#├── __init__.py (Lines: 28)
#├── before_main.py (Lines: 268)
#        |   -> Import: datetime
#        |   -> Import: inspect
#        |   -> Import: os
#        |   -> Import: subprocess
#        |   -> Import: sys
#        |   -> Function: _execute_pip_command(action, package_name, console_print_func)
#        |   -> Function: _mock_console_log(message)
#        |   -> Function: _mock_debug_log(message, file, version, function, console_print_func)
#        |   -> Function: action_check_dependancies(should_clean_install)
#├── main.py (Lines: 338)
#        |   -> Import: before_main
#        |   -> Import: datetime
#        |   -> Import: display.logger
#        |   -> Import: display.splash.splash_screen
#        |   -> Import: display.styling.style
#        |   -> Import: importlib
#        |   -> Import: inspect
#        |   -> Import: managers.bandwidth_manager.bandwidth_callbacks
#        |   -> Import: managers.bandwidth_manager.bandwidth_presets
#        |   -> Import: managers.bandwidth_manager.bandwidth_state
#        |   -> Import: managers.bandwidth_manager.bandwidth_yak_communicator
#        |   -> Import: managers.connection.manager_visa_device_search
#        |   -> Import: managers.connection.manager_visa_dispatch_scpi
#        |   -> Import: managers.connection.manager_visa_reset
#        |   -> Import: managers.frequency_manager.frequency_callbacks
#        |   -> Import: managers.frequency_manager.frequency_state
#        |   -> Import: managers.frequency_manager.frequency_yak_communicator
#        |   -> Import: managers.manager_instrument_settings_markers
#        |   -> Import: managers.yak_manager.manager_presets_span
#        |   -> Import: managers.yak_manager.manager_yakety_yak
#        |   -> Import: os
#        |   -> Import: pathlib
#        |   -> Import: sys
#        |   -> Import: time
#        |   -> Import: workers.active.worker_active_marker_tune_and_collect
#        |   -> Import: workers.active.worker_active_peak_publisher
#        |   -> Import: workers.mqtt.worker_mqtt_controller_util
#        |   -> Import: workers.publishers.worker_YAK_publisher
#        |   -> Import: workers.publishers.worker_dataset_publisher
#        |   -> Import: workers.publishers.worker_meta_publisher
#        |   -> Function: action_check_configuration()
#        |   -> Function: action_check_dependancies()
#        |   -> Function: action_open_display(mqtt_util_instance, splash)
#        |   -> Function: main()
#├── pathlib (Lines: 103541)
#└── requirements.txt (Lines: 38)
#└── DATA/
#    ├── debug/
#    ├── MARKERS.csv (Lines: 254)
#    ├── MARKERS.json (Lines: 2536)
#    ├── PRESET.CSV (Lines: 1)
#    └── YAKETYYAK.json (Lines: 1322)
#    └── debug/
#        ├── ERRORS.log (Lines: 66)
#        ├── debug_log_20251214_2258.log (Lines: 21122)
#        └── debug_log_20251214_2259.log (Lines: 25884)
#└── Sample imports/
#    ├── Basic CSV - venue.csv (Lines: 254)
#    ├── IAS report.html (Lines: 2120)
#    ├── SOUND BASE  PDF V1 .pdf (Lines: N/A)
#    └── WWB - venue.shw (Lines: 29787)
#└── managers/
#    ├── bandwidth_manager/
#    ├── connection/
#    ├── frequency_manager/
#    ├── yak_manager/
#    ├── manager_instrument_settings_markers.py (Lines: 109)
#            |   -> Import: display.logger
#            |   -> Import: inspect
#            |   -> Import: json
#            |   -> Import: os
#            |   -> Import: workers.mqtt.worker_mqtt_controller_util
#            |   -> Class: MarkersSettingsManager
#            |   -> Function: __init__(self, mqtt_controller)
#            |   -> Function: _on_message(self, topic, payload)
#            |   -> Function: _subscribe_to_topics(self)
#    └── visa_utils.py (Lines: 125)
#            |   -> Import: display.logger
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: pyvisa
#            |   -> Function: connect_to_instrument(resource_name, console_print_func)
#            |   -> Function: disconnect_instrument(inst, console_print_func)
#            |   -> Function: list_visa_resources(console_print_func)
#    └── frequency_manager/
#        ├── __init__.py (Lines: 0)
#        ├── frequency_callbacks.py (Lines: 236)
#                |   -> Import: display.logger
#                |   -> Import: frequency_state
#                |   -> Import: frequency_yak_communicator
#                |   -> Import: inspect
#                |   -> Import: json
#                |   -> Import: os
#                |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                |   -> Class: FrequencyCallbacks
#                |   -> Function: __init__(self, mqtt_controller, state, yak_communicator)
#                |   -> Function: _update_center_and_span_from_start_stop(self)
#                |   -> Function: _update_start_stop_from_center_span(self)
#                |   -> Function: on_message(self, topic, payload)
#                |   -> Function: subscribe_to_topics(self)
#        ├── frequency_state.py (Lines: 19)
#                |   -> Class: FrequencyState
#                |   -> Function: __init__(self)
#        └── frequency_yak_communicator.py (Lines: 228)
#                |   -> Import: display.logger
#                |   -> Import: frequency_state
#                |   -> Import: inspect
#                |   -> Import: json
#                |   -> Import: os
#                |   -> Import: time
#                |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                |   -> Class: FrequencyYakCommunicator
#                |   -> Function: __init__(self, mqtt_controller, state)
#                |   -> Function: _publish_update(self, topic_suffix, value)
#                |   -> Function: process_yak_output(self, topic, payload)
#                |   -> Function: publish_to_yak_and_trigger(self, value_mhz, input_topic, trigger_topic)
#                |   -> Function: update_all_from_device(self)
#    └── yak_manager/
#        ├── __init__.py (Lines: 0)
#        ├── manager_presets_span.py (Lines: 220)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: json
#                |   -> Import: os
#                |   -> Import: pathlib
#                |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                |   -> Class: SpanSettingsManager
#                |   -> Function: __init__(self, mqtt_controller)
#                |   -> Function: _load_preset_values(self)
#                |   -> Function: _on_preset_message(self, topic, payload)
#                |   -> Function: _publish_update(self, topic, value)
#                |   -> Function: _subscribe_to_topics(self)
#                |   -> Function: _update_span_from_preset(self, topic)
#        ├── manager_yak_rx.py (Lines: 189)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: json
#                |   -> Import: os
#                |   -> Class: YakRxManager
#                |   -> Function: __init__(self, mqtt_controller)
#                |   -> Function: process_response(self, path_parts, command_details, response)
#        ├── manager_yak_tx.py (Lines: 70)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Class: YakTxManager
#                |   -> Function: __init__(self, dispatcher_instance)
#                |   -> Function: execute_command(self, command_type, command_string)
#        ├── manager_yakety_yak.py (Lines: 290)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: json
#                |   -> Import: managers.connection.manager_visa_dispatch_scpi
#                |   -> Import: managers.yak_manager.yak_trigger_handler
#                |   -> Import: os
#                |   -> Import: pathlib
#                |   -> Import: re
#                |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                |   -> Import: workers.utils.worker_project_paths
#                |   -> Class: YaketyYakManager
#                |   -> Function: YAK_LISTEN_TO_MQTT(self, topic, payload)
#                |   -> Function: YAK_SAVE_REPOSITORY(self, topic, payload)
#                |   -> Function: __init__(self, mqtt_controller, dispatcher_instance, app_instance)
#                |   -> Function: _load_repo_from_file(self)
#                |   -> Function: _save_repo_to_file(self)
#        ├── yak_command_builder.py (Lines: 79)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Function: fill_scpi_placeholders(scpi_command_template, scpi_inputs)
#        ├── yak_repository_parser.py (Lines: 147)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: json
#                |   -> Import: os
#                |   -> Function: get_command_node(repo, command_path_parts, function_name)
#                |   -> Function: lookup_inputs(command_node, command_path)
#                |   -> Function: lookup_outputs(command_node, command_path)
#                |   -> Function: lookup_scpi_command(command_node, model_key, command_path)
#        └── yak_trigger_handler.py (Lines: 111)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: json
#                |   -> Import: managers.yak_manager.manager_yak_rx
#                |   -> Import: managers.yak_manager.manager_yak_tx
#                |   -> Import: managers.yak_manager.yak_command_builder
#                |   -> Import: managers.yak_manager.yak_repository_parser
#                |   -> Import: os
#                |   -> Import: workers.utils.worker_project_paths
#                |   -> Function: handle_yak_trigger(yak_manager, topic, payload)
#    └── bandwidth_manager/
#        ├── __init__.py (Lines: 0)
#        ├── bandwidth_callbacks.py (Lines: 110)
#                |   -> Import: bandwidth_presets
#                |   -> Import: bandwidth_state
#                |   -> Import: bandwidth_yak_communicator
#                |   -> Import: json
#                |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                |   -> Class: BandwidthCallbacks
#                |   -> Function: __init__(self, mqtt_controller, state, yak_communicator, presets)
#                |   -> Function: on_message(self, topic, payload)
#                |   -> Function: subscribe_to_topics(self)
#        ├── bandwidth_presets.py (Lines: 111)
#                |   -> Import: bandwidth_state
#                |   -> Import: bandwidth_yak_communicator
#                |   -> Import: display.logger
#                |   -> Import: os
#                |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                |   -> Class: BandwidthPresets
#                |   -> Function: __init__(self, mqtt_controller, state, yak_communicator)
#                |   -> Function: _get_option_number(t)
#                |   -> Function: apply_preset(self, topic, preset_value_map, preset_unit_map, target_suffix, is_rbw)
#                |   -> Function: handle_preset_message(self, topic, value)
#        ├── bandwidth_state.py (Lines: 62)
#                |   -> Class: BandwidthState
#                |   -> Function: __init__(self)
#                |   -> Function: get_multiplier(self, unit_string)
#        └── bandwidth_yak_communicator.py (Lines: 158)
#                |   -> Import: bandwidth_state
#                |   -> Import: display.logger
#                |   -> Import: json
#                |   -> Import: os
#                |   -> Import: time
#                |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                |   -> Class: BandwidthYakCommunicator
#                |   -> Function: __init__(self, mqtt_controller, state)
#                |   -> Function: _publish_update(self, topic_suffix, value)
#                |   -> Function: process_yak_output(self, topic, payload)
#                |   -> Function: publish_rbw_and_trigger(self, value_mhz)
#                |   -> Function: publish_sweep_time_and_trigger(self, value_s)
#                |   -> Function: publish_to_yak_and_trigger(self, value, input_topic, trigger_topic)
#                |   -> Function: publish_vbw_and_trigger(self, value_mhz)
#                |   -> Function: publish_vbw_auto_and_trigger(self, is_auto_on)
#                |   -> Function: update_all_from_device(self)
#    └── connection/
#        ├── __init__.py (Lines: 0)
#        ├── manager_visa_device_search.py (Lines: 336)
#                |   -> Import: datetime
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: json
#                |   -> Import: manager_visa_dispatch_scpi
#                |   -> Import: managers.bandwidth_manager.bandwidth_yak_communicator
#                |   -> Import: managers.frequency_manager.frequency_yak_communicator
#                |   -> Import: managers.visa_utils
#                |   -> Import: os
#                |   -> Import: pyvisa
#                |   -> Import: threading
#                |   -> Import: time
#                |   -> Import: tkinter
#                |   -> Import: traceback
#                |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                |   -> Class: VisaDeviceManager
#                |   -> Function: __init__(self, mqtt_controller, scpi_dispatcher)
#                |   -> Function: _on_connect_request(self, topic, payload)
#                |   -> Function: _on_device_select(self, topic, payload)
#                |   -> Function: _on_disconnect_request(self, topic, payload)
#                |   -> Function: _on_gui_connect_request(self, topic, payload)
#                |   -> Function: _on_gui_disconnect_request(self, topic, payload)
#                |   -> Function: _on_search_request(self, topic, payload)
#                |   -> Function: _publish_status(self, topic_suffix, value)
#                |   -> Function: _setup_mqtt_subscriptions(self)
#                |   -> Function: _update_found_devices_gui(self, resources)
#                |   -> Function: connect_instrument(self, resource_name, console_print_func)
#                |   -> Function: connect_instrument_logic(self, resource_name, console_print_func)
#                |   -> Function: disconnect_instrument(self, console_print_func)
#                |   -> Function: disconnect_instrument_logic(self, console_print_func)
#                |   -> Function: search_resources(self, console_print_func)
#        ├── manager_visa_dispatch_scpi.py (Lines: 222)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: pyvisa
#                |   -> Import: time
#                |   -> Class: ScpiDispatcher
#                |   -> Function: __init__(self, app_instance, console_print_func)
#                |   -> Function: _reset_device(self, inst)
#                |   -> Function: query_safe(self, command)
#                |   -> Function: set_instrument_instance(self, inst)
#                |   -> Function: write_safe(self, command)
#        └── manager_visa_reset.py (Lines: 155)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: json
#                |   -> Import: manager_visa_dispatch_scpi
#                |   -> Import: os
#                |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                |   -> Class: VisaResetManager
#                |   -> Function: __init__(self, mqtt_controller, scpi_dispatcher)
#                |   -> Function: _on_reboot_request(self, topic, payload)
#                |   -> Function: _on_reset_request(self, topic, payload)
#                |   -> Function: _setup_mqtt_subscriptions(self)
#└── build/
#    ├── OPEN-AIR/
#    ├── build_scripts/
#    └── dist/
#    └── dist/
#        ├── DATA/
#        └── OPEN-AIR (Lines: N/A)
#        └── DATA/
#            ├── debug/
#            ├── MARKERS.csv (Lines: 254)
#            ├── MARKERS.json (Lines: 2536)
#            ├── PRESET.csv (Lines: 17)
#            └── YAKETYYAK.json (Lines: 1320)
#            └── debug/
#                ├── ERRORS.log (Lines: 2761)
#                ├── debug_log_20251129_2202.log (Lines: 21)
#                ├── debug_log_20251129_2203.log (Lines: 28775)
#                ├── debug_log_20251129_2204.log (Lines: 2)
#                ├── debug_log_20251129_2205.log (Lines: 12007)
#                ├── debug_log_20251129_2206.log (Lines: 1)
#                ├── debug_log_20251129_2207.log (Lines: 12016)
#                ├── debug_log_20251129_2208.log (Lines: 64)
#                ├── debug_log_20251129_2212.log (Lines: 12028)
#                ├── debug_log_20251129_2213.log (Lines: 11896)
#                ├── debug_log_20251129_2217.log (Lines: 12001)
#                ├── debug_log_20251129_2219.log (Lines: 26826)
#                ├── debug_log_20251129_2220.log (Lines: 37836)
#                ├── debug_log_20251129_2225.log (Lines: 76140)
#                ├── debug_log_20251129_2226.log (Lines: 1)
#                ├── debug_log_20251129_2249.log (Lines: 38077)
#                └── debug_log_20251129_2250.log (Lines: 213)
#    └── OPEN-AIR/
#        ├── localpycs/
#        ├── Analysis-00.toc (Lines: 10344)
#        ├── EXE-00.toc (Lines: 5526)
#        ├── OPEN-AIR.pkg (Lines: N/A)
#        ├── PKG-00.toc (Lines: 5521)
#        ├── PYZ-00.pyz (Lines: N/A)
#        ├── PYZ-00.toc (Lines: 3280)
#        ├── base_library.zip (Lines: N/A)
#        ├── warn-OPEN-AIR.txt (Lines: 330)
#        └── xref-OPEN-AIR.html (Lines: 52434)
#        └── localpycs/
#            ├── pyimod01_archive.pyc (Lines: N/A)
#            ├── pyimod02_importers.pyc (Lines: N/A)
#            ├── pyimod03_ctypes.pyc (Lines: N/A)
#            └── struct.pyc (Lines: N/A)
#    └── build_scripts/
#        ├── build_linux.py (Lines: 82)
#                |   -> Import: os
#                |   -> Import: subprocess
#                |   -> Import: sys
#                |   -> Function: build()
#        └── build_windows.py (Lines: 92)
#                - Syntax Error: invalid syntax (<unknown>, line 1)
#└── workers/
#    ├── Importer/
#    ├── Showtime/
#    ├── active/
#    ├── builder/
#    ├── exporters/
#    ├── importers/
#    ├── markers/
#    ├── mqtt/
#    ├── presets/
#    ├── publishers/
#    ├── trace/
#    ├── ui/
#    └── utils/
#    └── Showtime/
#        ├── worker_showtime_buttons.py (Lines: 49)
#                |   -> Import: PIL
#                |   -> Import: tkinter
#                |   -> Import: workers.Showtime.worker_showtime_draw_bargraph
#                |   -> Function: create_button_with_bar_graph(parent, value, text)
#        ├── worker_showtime_clear_group_buttons.py (Lines: 16)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Function: clear_group_buttons(showtime_tab_instance)
#        ├── worker_showtime_create_device_buttons.py (Lines: 86)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: tkinter
#                |   -> Function: create_device_buttons(showtime_tab_instance)
#        ├── worker_showtime_create_group_buttons.py (Lines: 59)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: tkinter
#                |   -> Import: workers.markers.worker_marker_logic
#                |   -> Function: create_group_buttons(showtime_tab_instance)
#        ├── worker_showtime_create_zone_buttons.py (Lines: 69)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: tkinter
#                |   -> Import: workers.Showtime.worker_showtime_on_zone_toggle
#                |   -> Function: create_zone_buttons(showtime_tab_instance)
#        ├── worker_showtime_draw_bargraph.py (Lines: 74)
#                |   -> Import: PIL
#                |   -> Import: os
#                |   -> Import: workers.utils.worker_project_paths
#                |   -> Function: create_bar_graph_image(value, text, width, height, bg_color, bar_color, text_color)
#        ├── worker_showtime_group.py (Lines: 65)
#                |   -> Import: collections
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Function: process_and_sort_markers(showtime_tab_instance)
#        ├── worker_showtime_on_group_toggle.py (Lines: 42)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: workers.Showtime.worker_showtime_create_device_buttons
#                |   -> Import: workers.Showtime.worker_showtime_create_group_buttons
#                |   -> Import: workers.Showtime.worker_showtime_tune
#                |   -> Function: on_group_toggle(showtime_tab_instance, group_name)
#        ├── worker_showtime_on_marker_button_click.py (Lines: 30)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: workers.Showtime.worker_showtime_tune
#                |   -> Function: on_marker_button_click(showtime_tab_instance, button)
#        ├── worker_showtime_on_zone_toggle.py (Lines: 45)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: workers.Showtime.worker_showtime_create_device_buttons
#                |   -> Import: workers.Showtime.worker_showtime_create_group_buttons
#                |   -> Import: workers.Showtime.worker_showtime_tune
#                |   -> Function: on_zone_toggle(showtime_tab_instance, zone_name)
#        ├── worker_showtime_read.py (Lines: 65)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: workers.importers.worker_marker_file_import_handling
#                |   -> Function: load_marker_data(showtime_tab_instance)
#        └── worker_showtime_tune.py (Lines: 121)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: workers.active.worker_active_marker_tune_and_collect
#                |   -> Import: workers.markers.worker_marker_logic
#                |   -> Function: on_tune_request_from_selection(showtime_tab_instance)
#    └── mqtt/
#        ├── __init__.py (Lines: 0)
#        ├── worker_mqtt_controller_util.py (Lines: 380)
#                |   -> Import: datetime
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: json
#                |   -> Import: os
#                |   -> Import: paho.mqtt.client
#                |   -> Import: pathlib
#                |   -> Import: queue
#                |   -> Import: sys
#                |   -> Import: threading
#                |   -> Class: MqttControllerUtility
#                |   -> Function: __init__(self, print_to_gui_func, log_treeview_func)
#                |   -> Function: _transmitter_thread(self)
#                |   -> Function: add_subscriber(self, topic_filter, callback_func)
#                |   -> Function: connect_mqtt(self)
#                |   -> Function: on_connect(self, client, userdata, flags, rc)
#                |   -> Function: on_message(self, client, userdata, msg)
#                |   -> Function: pause(self)
#                |   -> Function: publish_message(self, topic, subtopic, value, retain)
#                |   -> Function: purge_branch(self, base_topic)
#                |   -> Function: resume(self)
#                |   -> Function: show_topics(self)
#                |   -> Function: subscribe_to_topic(self, topic, callback)
#        └── worker_mqtt_data_flattening.py (Lines: 217)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: json
#                |   -> Import: os
#                |   -> Class: MqttDataFlattenerUtility
#                |   -> Function: __init__(self, print_to_gui_func)
#                |   -> Function: _flush_buffer(self, new_topic, new_data, new_identifier)
#                |   -> Function: clear_buffer(self)
#                |   -> Function: process_mqtt_message_and_pivot(self, topic, payload, topic_prefix)
#    └── active/
#        ├── __init__.py (Lines: 0)
#        ├── worker_active_marker_tune_and_collect.py (Lines: 527)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: json
#                |   -> Import: os
#                |   -> Import: pathlib
#                |   -> Import: threading
#                |   -> Import: time
#                |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                |   -> Class: MarkerGoGetterWorker
#                |   -> Function: Push_Marker_to_Center_Freq(mqtt_controller, marker_data)
#                |   -> Function: Push_Marker_to_Start_Stop_Freq(mqtt_controller, marker_data, buffer)
#                |   -> Function: __init__(self, mqtt_util)
#                |   -> Function: _handle_start_stop(self, topic, payload)
#                |   -> Function: _on_marker_data_update(self, topic, payload)
#                |   -> Function: _on_peak_update_for_event_set(self, topic, payload)
#                |   -> Function: _place_markers_for_batch(self, batch_ids)
#                |   -> Function: _processing_loop(self)
#                |   -> Function: _query_markers_for_batch(self, batch_ids)
#                |   -> Function: _set_instrument_frequency_span(self)
#                |   -> Function: _setup_subscriptions(self)
#        └── worker_active_peak_publisher.py (Lines: 262)
#                |   -> Import: datetime
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: json
#                |   -> Import: math
#                |   -> Import: os
#                |   -> Import: re
#                |   -> Import: threading
#                |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                |   -> Class: ActivePeakPublisher
#                |   -> Function: __init__(self, mqtt_util)
#                |   -> Function: _on_marker_message(self, topic, payload)
#                |   -> Function: _republish_to_hierarchical_topic(self, marker_id, freq_hz, peak_dbm)
#                |   -> Function: _setup_subscriptions(self)
#    └── trace/
#    └── utils/
#        ├── __init__.py (Lines: 0)
#        ├── connection_status_logic.py (Lines: 95)
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: tkinter
#                |   -> Function: update_connection_status_logic(app_instance, is_connected, is_running, console_print_func)
#        ├── worker_project_paths.py (Lines: 85)
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: pathlib
#                |   -> Import: sys
#                |   -> Function: get_absolute_path(relative_path)
#        ├── worker_recon_data_node_builder.py (Lines: 167)
#                |   -> Import: csv
#                |   -> Import: datetime
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: json
#                |   -> Import: os
#                |   -> Import: re
#                |   -> Import: time
#                |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                |   -> Import: workers.utils.worker_project_paths
#                |   -> Class: MockMqttUtility
#                |   -> Function: publish_message(self, topic, subtopic, value, retain)
#                |   -> Function: recon_data_publisher(mqtt_util_instance, console_log_func)
#        └── worker_visa_pre_flight_check.py (Lines: 169)
#                |   -> Import: datetime
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: psutil
#                |   -> Import: pyvisa
#                |   -> Import: sys
#                |   -> Import: usb.core
#                |   -> Import: zeroconf
#                |   -> Function: console_log(message)
#                |   -> Function: debug_log(message, file, version, function, console_print_func)
#                |   -> Function: list_visa_resources()
#    └── exporters/
#        ├── __init__.py (Lines: 0)
#        ├── utils_csv_writer.py (Lines: 143)
#                |   -> Import: csv
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Function: write_scan_data_to_csv(file_path, header, data, app_instance_ref, append_mode, console_print_func)
#        └── worker_file_csv_export.py (Lines: 96)
#                |   -> Import: csv
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Class: CsvExportUtility
#                |   -> Function: __init__(self, print_to_gui_func)
#                |   -> Function: export_data_to_csv(self, data, file_path)
#    └── builder/
#        ├── dynamic_gui_MQTT_subscriber.py (Lines: 147)
#                |   -> Import: datetime
#                |   -> Import: display.logger
#                |   -> Import: display.styling.style
#                |   -> Import: inspect
#                |   -> Import: json
#                |   -> Import: os
#                |   -> Import: paho.mqtt.client
#                |   -> Import: tkinter
#                |   -> Class: MqttSubscriberMixin
#                |   -> Function: __init__(self)
#                |   -> Function: _on_receive_command_message(self, topic, payload)
#                |   -> Function: log_to_gui(builder_instance, message)
#        ├── dynamic_gui_builder.py (Lines: 655)
#                |   -> Import: datetime
#                |   -> Import: display.logger
#                |   -> Import: display.styling.style
#                |   -> Import: dynamic_gui_MQTT_subscriber
#                |   -> Import: dynamic_gui_config_loader
#                |   -> Import: dynamic_gui_create_gui_actuator
#                |   -> Import: dynamic_gui_create_gui_button_toggle
#                |   -> Import: dynamic_gui_create_gui_button_toggler
#                |   -> Import: dynamic_gui_create_gui_checkbox
#                |   -> Import: dynamic_gui_create_gui_dropdown_option
#                |   -> Import: dynamic_gui_create_gui_listbox
#                |   -> Import: dynamic_gui_create_gui_slider_value
#                |   -> Import: dynamic_gui_create_label
#                |   -> Import: dynamic_gui_create_label_from_config
#                |   -> Import: dynamic_gui_create_value_box
#                |   -> Import: dynamic_gui_mousewheel_mixin
#                |   -> Import: inspect
#                |   -> Import: json
#                |   -> Import: os
#                |   -> Import: paho.mqtt.client
#                |   -> Import: pathlib
#                |   -> Import: sys
#                |   -> Import: tkinter
#                |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                |   -> Class: DynamicGuiBuilder
#                |   -> Function: __init__(self, parent, mqtt_util, config)
#                |   -> Function: _apply_styles(self, theme_name)
#                |   -> Function: _create_dynamic_widgets(self, parent_frame, data, path_prefix)
#                |   -> Function: _on_map_event(self, event)
#                |   -> Function: _on_receive_command_message(self, topic, payload)
#                |   -> Function: _rebuild_gui(self)
#                |   -> Function: _transmit_command(self, relative_topic, payload, retain)
#                |   -> Function: _update_nested_dict(self, path_parts, value)
#                |   -> Function: _update_widget_value(self, relative_topic, payload)
#        ├── dynamic_gui_config_loader.py (Lines: 228)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: pathlib
#                |   -> Function: get_json_filepath_from_base_topic(base_topic, class_name, calling_file, calling_version, console_print_func)
#        ├── dynamic_gui_create_gui_actuator.py (Lines: 145)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: json
#                |   -> Import: os
#                |   -> Import: tkinter
#                |   -> Class: GuiActuatorCreatorMixin
#                |   -> Function: _create_gui_actuator(self, parent_frame, label, config, path)
#                |   -> Function: on_press(event)
#                |   -> Function: on_release(event)
#        ├── dynamic_gui_create_gui_button_toggle.py (Lines: 134)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: json
#                |   -> Import: os
#                |   -> Import: tkinter
#                |   -> Class: GuiButtonToggleCreatorMixin
#                |   -> Function: _create_gui_button_toggle(self, parent_frame, label, config, path)
#                |   -> Function: toggle_state_and_publish()
#                |   -> Function: update_button_state()
#        ├── dynamic_gui_create_gui_button_toggler.py (Lines: 180)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: time
#                |   -> Import: tkinter
#                |   -> Class: GuiButtonTogglerCreatorMixin
#                |   -> Function: _create_gui_button_toggler(self, parent_frame, label, config, path)
#                |   -> Function: command()
#                |   -> Function: create_command(key)
#                |   -> Function: update_button_styles()
#        ├── dynamic_gui_create_gui_checkbox.py (Lines: 135)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: json
#                |   -> Import: os
#                |   -> Import: tkinter
#                |   -> Class: GuiCheckboxCreatorMixin
#                |   -> Function: _create_gui_checkbox(self, parent_frame, label, config, path)
#                |   -> Function: get_label_text()
#                |   -> Function: toggle_and_publish()
#                |   -> Function: update_label()
#        ├── dynamic_gui_create_gui_dropdown_option.py (Lines: 224)
#                |   -> Import: decimal
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: tkinter
#                |   -> Class: GuiDropdownOptionCreatorMixin
#                |   -> Function: _create_gui_dropdown_option(self, parent_frame, label, config, path)
#                |   -> Function: on_select(event)
#                |   -> Function: rebuild_options(self, dropdown, config)
#                |   -> Function: update_displayed_text(value)
#        ├── dynamic_gui_create_gui_listbox.py (Lines: 178)
#                |   -> Import: decimal
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: tkinter
#                |   -> Class: GuiListboxCreatorMixin
#                |   -> Function: _create_gui_listbox(self, parent_frame, label, config, path)
#                |   -> Function: on_select(event)
#                |   -> Function: rebuild_options_for_listbox(lb, cfg)
#        ├── dynamic_gui_create_gui_slider_value.py (Lines: 170)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: tkinter
#                |   -> Class: SliderValueCreatorMixin
#                |   -> Function: _create_slider_value(self, parent_frame, label, config, path)
#                |   -> Function: on_entry_change(event)
#                |   -> Function: on_slider_move(val)
#                |   -> Function: on_slider_release(event)
#        ├── dynamic_gui_create_label.py (Lines: 92)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: tkinter
#                |   -> Class: LabelCreatorMixin
#                |   -> Function: _create_label(self, parent_frame, label, value, units, path)
#        ├── dynamic_gui_create_label_from_config.py (Lines: 73)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Class: LabelFromConfigCreatorMixin
#                |   -> Function: _create_label_from_config(self, parent_frame, label, config, path)
#        ├── dynamic_gui_create_value_box.py (Lines: 115)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: tkinter
#                |   -> Class: ValueBoxCreatorMixin
#                |   -> Function: _create_value_box(self, parent_frame, label, config, path)
#                |   -> Function: on_entry_change(event)
#        └── dynamic_gui_mousewheel_mixin.py (Lines: 93)
#                |   -> Import: datetime
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: pathlib
#                |   -> Import: sys
#                |   -> Class: MousewheelScrollMixin
#                |   -> Function: _bind_mousewheel(self, event)
#                |   -> Function: _on_mousewheel(self, event)
#                |   -> Function: _unbind_mousewheel(self, event)
#    └── ui/
#        ├── __init__.py (Lines: 0)
#        ├── utils_display_monitor.py (Lines: 334)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: matplotlib.offsetbox
#                |   -> Import: numpy
#                |   -> Import: os
#                |   -> Import: traceback
#                |   -> Function: _find_and_plot_peaks(ax, data, start_freq_MHz, end_freq_MHz)
#                |   -> Function: _setup_zoom_events(ax, canvas, original_xlim)
#                |   -> Function: clear_monitor_plots(scan_monitor_tab_instance)
#                |   -> Function: on_double_click(event)
#                |   -> Function: on_press(event)
#                |   -> Function: on_release(event)
#                |   -> Function: reset_zoom(ax, canvas)
#                |   -> Function: update_annot(event)
#                |   -> Function: update_annot(event)
#                |   -> Function: update_annot(event)
#                |   -> Function: update_bottom_plot(scan_monitor_tab_instance, data, start_freq_MHz, end_freq_MHz, plot_title)
#                |   -> Function: update_middle_plot(scan_monitor_tab_instance, data, start_freq_MHz, end_freq_MHz, plot_title)
#                |   -> Function: update_top_plot(scan_monitor_tab_instance, data, start_freq_MHz, end_freq_MHz, plot_title)
#        └── utils_scan_view.py (Lines: 188)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: matplotlib.offsetbox
#                |   -> Import: numpy
#                |   -> Import: os
#                |   -> Import: traceback
#                |   -> Function: _find_and_plot_peaks(ax, data, start_freq_MHz, end_freq_MHz)
#                |   -> Function: _setup_zoom_events(ax, canvas, original_xlim)
#                |   -> Function: on_double_click(event)
#                |   -> Function: on_press(event)
#                |   -> Function: on_release(event)
#                |   -> Function: reset_zoom(ax, canvas)
#                |   -> Function: update_annot(event)
#                |   -> Function: update_single_plot(scan_view_tab_instance, data, start_freq_MHz, end_freq_MHz, plot_title, line_color)
#    └── presets/
#        ├── __init__.py (Lines: 0)
#        ├── worker_preset_from_device.py (Lines: 291)
#                |   -> Import: datetime
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: json
#                |   -> Import: os
#                |   -> Import: re
#                |   -> Import: threading
#                |   -> Import: time
#                |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                |   -> Class: MockMqttUtil
#                |   -> Class: PresetFromDeviceWorker
#                |   -> Function: __init__(self)
#                |   -> Function: __init__(self, mqtt_util)
#                |   -> Function: _on_mqtt_message(self, topic, payload)
#                |   -> Function: add_subscriber(self, topic_filter, callback_func)
#                |   -> Function: get_presets_from_device(self)
#                |   -> Function: parse_presets_from_device(self, raw_preset_string)
#                |   -> Function: present_presets_from_device(self, preset_filename)
#                |   -> Function: publish_message(self, topic, subtopic, value, retain)
#                |   -> Function: publish_presets_to_repository(self, preset_list)
#        └── worker_preset_pusher.py (Lines: 203)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: json
#                |   -> Import: os
#                |   -> Import: time
#                |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                |   -> Class: MockMqttUtility
#                |   -> Class: PresetPusherWorker
#                |   -> Function: Tune_to_preset(self, preset_values)
#                |   -> Function: __init__(self, mqtt_controller)
#                |   -> Function: publish_message(self, topic, subtopic, value, retain)
#    └── markers/
#        ├── __init__.py (Lines: 0)
#        ├── worker_marker_logic.py (Lines: 110)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: numpy
#                |   -> Import: os
#                |   -> Function: calculate_frequency_range(marker_data_list)
#        └── worker_marker_peak_re_publisher.py (Lines: 177)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: json
#                |   -> Import: os
#                |   -> Import: re
#                |   -> Import: threading
#                |   -> Import: time
#                |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                |   -> Class: MarkerPeakPublisher
#                |   -> Function: __init__(self, mqtt_util, starting_device_id)
#                |   -> Function: _generate_device_map(self, start_id)
#                |   -> Function: _on_nab_output_and_republish_peak(self, topic, payload)
#                |   -> Function: _setup_subscriptions(self)
#    └── publishers/
#        ├── __init__.py (Lines: 0)
#        ├── worker_YAK_publisher.py (Lines: 201)
#                |   -> Import: display.logger
#                |   -> Import: display.styling.style
#                |   -> Import: inspect
#                |   -> Import: json
#                |   -> Import: os
#                |   -> Import: pathlib
#                |   -> Import: sys
#                |   -> Import: time
#                |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                |   -> Function: main(mqtt_util)
#                |   -> Function: publish_recursive(mqtt_util, base_topic, data)
#        ├── worker_dataset_publisher.py (Lines: 179)
#                |   -> Import: display.logger
#                |   -> Import: display.styling.style
#                |   -> Import: inspect
#                |   -> Import: json
#                |   -> Import: os
#                |   -> Import: pathlib
#                |   -> Import: sys
#                |   -> Import: time
#                |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                |   -> Function: main(mqtt_util)
#                |   -> Function: publish_recursive(mqtt_util, base_topic, data)
#        └── worker_meta_publisher.py (Lines: 193)
#                |   -> Import: display.logger
#                |   -> Import: display.styling.style
#                |   -> Import: inspect
#                |   -> Import: json
#                |   -> Import: os
#                |   -> Import: pathlib
#                |   -> Import: sys
#                |   -> Import: time
#                |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                |   -> Function: main(mqtt_util)
#                |   -> Function: publish_recursive(mqtt_util, base_topic, data)
#    └── Importer/
#        ├── worker_importer_appender.py (Lines: 119)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: tkinter
#                |   -> Import: workers.Importer.worker_importer_saver
#                |   -> Import: workers.importers.worker_marker_file_import_converter
#                |   -> Import: workers.importers.worker_marker_file_import_handling
#                |   -> Function: append_ias_html_action(importer_tab_instance)
#                |   -> Function: append_markers_file_action(importer_tab_instance)
#                |   -> Function: append_sb_pdf_action(importer_tab_instance)
#                |   -> Function: append_sb_v2_pdf_action(importer_tab_instance)
#                |   -> Function: append_wwb_shw_action(importer_tab_instance)
#                |   -> Function: append_wwb_zip_action(importer_tab_instance)
#        ├── worker_importer_editor.py (Lines: 239)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: re
#                |   -> Import: tkinter
#                |   -> Import: workers.Importer.worker_importer_saver
#                |   -> Function: delete_selected_row(importer_tab_instance, event)
#                |   -> Function: get_sort_key(item)
#                |   -> Function: increment_string_with_trailing_digits(text)
#                |   -> Function: navigate_cells(importer_tab_instance, current_item, current_col_index, direction)
#                |   -> Function: on_edit_complete_and_navigate(event, navigate_direction)
#                |   -> Function: on_tree_double_click(importer_tab_instance, event)
#                |   -> Function: on_tree_header_click(importer_tab_instance, event)
#                |   -> Function: populate_marker_tree(importer_tab_instance)
#                |   -> Function: sort_treeview(importer_tab_instance, column_name, ascending)
#                |   -> Function: start_editing_cell(importer_tab_instance, item, col_index, initial_value)
#        ├── worker_importer_loader.py (Lines: 119)
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: tkinter
#                |   -> Import: workers.Importer.worker_importer_saver
#                |   -> Import: workers.importers.worker_marker_file_import_converter
#                |   -> Import: workers.importers.worker_marker_file_import_handling
#                |   -> Function: load_ias_html_action(importer_tab_instance)
#                |   -> Function: load_markers_file_action(importer_tab_instance)
#                |   -> Function: load_sb_pdf_action(importer_tab_instance)
#                |   -> Function: load_sb_v2_pdf_action(importer_tab_instance)
#                |   -> Function: load_wwb_shw_action(importer_tab_instance)
#                |   -> Function: load_wwb_zip_action(importer_tab_instance)
#        └── worker_importer_saver.py (Lines: 46)
#                |   -> Import: display.logger
#                |   -> Import: workers.importers.worker_marker_csv_to_json_mqtt
#                |   -> Import: workers.importers.worker_marker_file_import_handling
#                |   -> Function: publish_markers_to_mqtt(importer_tab_instance)
#                |   -> Function: save_markers_file_internally(importer_tab_instance)
#                |   -> Function: save_open_air_file_action(importer_tab_instance)
#    └── importers/
#        ├── __init__.py (Lines: 0)
#        ├── worker_marker_csv_to_json_mqtt.py (Lines: 196)
#                |   -> Import: collections
#                |   -> Import: csv
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: json
#                |   -> Import: os
#                |   -> Import: pathlib
#                |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                |   -> Import: workers.utils.worker_project_paths
#                |   -> Function: _publish_recursive(mqtt_util, base_topic, data)
#                |   -> Function: csv_to_json_and_publish(mqtt_util)
#        ├── worker_marker_file_import_converter.py (Lines: 888)
#                |   -> Import: bs4
#                |   -> Import: csv
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: io
#                |   -> Import: numpy
#                |   -> Import: os
#                |   -> Import: pdfplumber
#                |   -> Import: re
#                |   -> Import: subprocess
#                |   -> Import: sys
#                |   -> Import: xml.etree.ElementTree
#                |   -> Import: zipfile
#                |   -> Function: Marker_convert_IAShtml_report_to_csv(html_content)
#                |   -> Function: Marker_convert_SB_PDF_File_report_to_csv(pdf_file_path)
#                |   -> Function: Marker_convert_SB_v2_PDF_File_report_to_csv(pdf_file_path)
#                |   -> Function: Marker_convert_WWB_SHW_File_report_to_csv(xml_file_path)
#                |   -> Function: Marker_convert_csv_unknow_report_to_csv(file_path)
#                |   -> Function: Marker_convert_wwb_zip_report_to_csv(file_path)
#        └── worker_marker_file_import_handling.py (Lines: 531)
#                |   -> Import: csv
#                |   -> Import: datetime
#                |   -> Import: display.logger
#                |   -> Import: inspect
#                |   -> Import: json
#                |   -> Import: numpy
#                |   -> Import: os
#                |   -> Import: pandas
#                |   -> Import: pathlib
#                |   -> Import: re
#                |   -> Import: sys
#                |   -> Import: threading
#                |   -> Import: tkinter
#                |   -> Import: workers.importers.worker_marker_file_import_converter
#                |   -> Import: workers.utils.worker_project_paths
#                |   -> Import: xml.etree.ElementTree
#                |   -> Function: maker_file_check_for_markers_file()
#                |   -> Function: maker_file_load_ias_html()
#                |   -> Function: maker_file_load_markers_file()
#                |   -> Function: maker_file_load_sb_pdf()
#                |   -> Function: maker_file_load_wwb_shw()
#                |   -> Function: maker_file_save_intermediate_file(tree_headers, tree_data)
#                |   -> Function: maker_file_save_open_air_file(tree_headers, tree_data)
#└── SUB APP - CSV to json APP/
#    └── csvtojson.py (Lines: 415)
#            |   -> Import: io
#            |   -> Import: json
#            |   -> Import: os
#            |   -> Import: pandas
#            |   -> Import: re
#            |   -> Import: sys
#            |   -> Import: tkinter
#            |   -> Class: CSVToJSONApp
#            |   -> Function: __init__(self)
#            |   -> Function: build_json_hierarchy(self, df, header_map, parent_key)
#            |   -> Function: convert_to_json(self)
#            |   -> Function: create_widgets(self)
#            |   -> Function: generate_json_from_config(self)
#            |   -> Function: insert_items(parent, dictionary)
#            |   -> Function: load_csv_file(self)
#            |   -> Function: load_headers(self)
#            |   -> Function: preview_json(self)
#            |   -> Function: save_json_file(self)
#            |   -> Function: setup_frames(self)
#            |   -> Function: toggle_widgets(event)
#            |   -> Function: update_nested_under_dropdowns(self)
#            |   -> Function: update_output_with_json(self, data)
#└── display/
#    ├── left_50/
#    ├── right_50/
#    ├── splash/
#    ├── styling/
#    ├── gui_display.py (Lines: 894)
#            |   -> Import: datetime
#            |   -> Import: display.logger
#            |   -> Import: display.styling.style
#            |   -> Import: importlib.util
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: pathlib
#            |   -> Import: sys
#            |   -> Import: tkinter
#            |   -> Import: workers.mqtt.worker_mqtt_controller_util
#            |   -> Class: Application
#            |   -> Function: __init__(self, mqtt_util_instance)
#            |   -> Function: _apply_styles(self, theme_name)
#            |   -> Function: _build_child_container(self, path, parent_widget)
#            |   -> Function: _build_from_directory(self, path, parent_widget)
#            |   -> Function: _on_tab_change(self, event)
#            |   -> Function: _re_attach_tab(self, frame)
#            |   -> Function: _tear_off_tab(self, event)
#            |   -> Function: configure_sash(event)
#            |   -> Function: configure_sash(event)
#            |   -> Function: on_sash_drag(event)
#            |   -> Function: on_sash_drag(event)
#    └── logger.py (Lines: 235)
#            |   -> Import: datetime
#            |   -> Import: inspect
#            |   -> Import: json
#            |   -> Import: os
#            |   -> Import: pathlib
#            |   -> Import: sys
#            |   -> Function: _log_to_error_file(message)
#            |   -> Function: _log_to_file(message, log_filename)
#            |   -> Function: _safe_print(message)
#            |   -> Function: _truncate_message(message)
#            |   -> Function: console_log(message, local_debug_enabled)
#            |   -> Function: debug_log(message, file, version, function, console_print_func)
#            |   -> Function: get_log_filename()
#            |   -> Function: log_visa_command(command, direction)
#    └── right_50/
#        ├── bottom_90/
#        └── top_10/
#        └── bottom_90/
#            ├── 1_scan/
#            ├── 2_monitors/
#            ├── 3_debug/
#            ├── 4_conductor/
#            ├── 6_prototype/
#            ├── 8_configuration/
#            └── prototype/
#            └── 3_debug/
#                └── gui_tab_3_debug.py (Lines: 203)
#                        |   -> Import: datetime
#                        |   -> Import: display.logger
#                        |   -> Import: display.right_50.bottom_90.prototype.base_gui_component_rebuilt
#                        |   -> Import: display.styling.style
#                        |   -> Import: inspect
#                        |   -> Import: json
#                        |   -> Import: os
#                        |   -> Import: paho.mqtt.client
#                        |   -> Import: pathlib
#                        |   -> Import: sys
#                        |   -> Import: tkinter
#                        |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                        |   -> Class: DebugTabGUIFrame
#                        |   -> Function: __init__(self, parent, mqtt_util)
#                        |   -> Function: _create_widgets(self)
#                        |   -> Function: _on_mqtt_message(self, topic, payload)
#                        |   -> Function: _publish_custom_message(self)
#                        |   -> Function: _publish_version_message(self)
#                        |   -> Function: debug_button_press(self)
#                        |   -> Function: log_button_press(self)
#            └── 1_scan/
#                └── gui_scan.py (Lines: 84)
#                        |   -> Import: display.logger
#                        |   -> Import: matplotlib.backends.backend_tkagg
#                        |   -> Import: matplotlib.figure
#                        |   -> Import: numpy
#                        |   -> Import: os
#                        |   -> Import: pathlib
#                        |   -> Import: seaborn
#                        |   -> Import: tkinter
#                        |   -> Class: ScanViewGUIFrame
#                        |   -> Function: __init__(self, parent, mqtt_util, config)
#                        |   -> Function: _create_plot_widgets(self)
#            └── 2_monitors/
#                ├── gui_monitor_bottom.py (Lines: 154)
#                        |   -> Import: datetime
#                        |   -> Import: display.logger
#                        |   -> Import: display.styling.style
#                        |   -> Import: inspect
#                        |   -> Import: json
#                        |   -> Import: matplotlib.backends.backend_tkagg
#                        |   -> Import: matplotlib.figure
#                        |   -> Import: os
#                        |   -> Import: pathlib
#                        |   -> Import: sys
#                        |   -> Import: tkinter
#                        |   -> Class: MonitorTopGUIFrame
#                        |   -> Function: __init__(self, parent, mqtt_util, config)
#                        |   -> Function: _apply_styles(self, theme_name)
#                ├── gui_monitor_middle.py (Lines: 154)
#                        |   -> Import: datetime
#                        |   -> Import: display.logger
#                        |   -> Import: display.styling.style
#                        |   -> Import: inspect
#                        |   -> Import: json
#                        |   -> Import: matplotlib.backends.backend_tkagg
#                        |   -> Import: matplotlib.figure
#                        |   -> Import: os
#                        |   -> Import: pathlib
#                        |   -> Import: sys
#                        |   -> Import: tkinter
#                        |   -> Class: MonitorTopGUIFrame
#                        |   -> Function: __init__(self, parent, mqtt_util, config)
#                        |   -> Function: _apply_styles(self, theme_name)
#                └── gui_monitor_top.py (Lines: 154)
#                        |   -> Import: datetime
#                        |   -> Import: display.logger
#                        |   -> Import: display.styling.style
#                        |   -> Import: inspect
#                        |   -> Import: json
#                        |   -> Import: matplotlib.backends.backend_tkagg
#                        |   -> Import: matplotlib.figure
#                        |   -> Import: os
#                        |   -> Import: pathlib
#                        |   -> Import: sys
#                        |   -> Import: tkinter
#                        |   -> Class: MonitorTopGUIFrame
#                        |   -> Function: __init__(self, parent, mqtt_util, config)
#                        |   -> Function: _apply_styles(self, theme_name)
#            └── prototype/
#                └── base_gui_component_rebuilt.py (Lines: 359)
#                        |   -> Import: datetime
#                        |   -> Import: display.logger
#                        |   -> Import: display.styling.style
#                        |   -> Import: inspect
#                        |   -> Import: json
#                        |   -> Import: os
#                        |   -> Import: paho.mqtt.client
#                        |   -> Import: pathlib
#                        |   -> Import: sys
#                        |   -> Import: tkinter
#                        |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                        |   -> Class: BaseGUIFrame
#                        |   -> Function: __init__(self, parent, mqtt_util)
#                        |   -> Function: _apply_styles(self, theme_name)
#                        |   -> Function: _on_mqtt_message(self, topic, payload)
#                        |   -> Function: _publish_custom_message(self)
#                        |   -> Function: _publish_version_message(self)
#                        |   -> Function: debug_button_press(self)
#                        |   -> Function: log_button_press(self)
#            └── 6_prototype/
#                └── gui_prototype.py (Lines: 361)
#                        |   -> Import: datetime
#                        |   -> Import: display.logger
#                        |   -> Import: display.styling.style
#                        |   -> Import: inspect
#                        |   -> Import: json
#                        |   -> Import: os
#                        |   -> Import: paho.mqtt.client
#                        |   -> Import: pathlib
#                        |   -> Import: sys
#                        |   -> Import: tkinter
#                        |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                        |   -> Class: BaseGUIFrame
#                        |   -> Function: __init__(self, parent, mqtt_util)
#                        |   -> Function: _apply_styles(self, theme_name)
#                        |   -> Function: _on_mqtt_message(self, topic, payload)
#                        |   -> Function: _publish_custom_message(self)
#                        |   -> Function: _publish_version_message(self)
#                        |   -> Function: debug_button_press(self)
#                        |   -> Function: log_button_press(self)
#            └── 8_configuration/
#                └── gui_tab_5_configuration.py (Lines: 168)
#                        |   -> Import: datetime
#                        |   -> Import: display.logger
#                        |   -> Import: display.styling.style
#                        |   -> Import: inspect
#                        |   -> Import: json
#                        |   -> Import: os
#                        |   -> Import: paho.mqtt.client
#                        |   -> Import: pathlib
#                        |   -> Import: sys
#                        |   -> Import: tkinter
#                        |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                        |   -> Class: InitialConfigurationTab
#                        |   -> Function: __init__(self, master)
#                        |   -> Function: _create_widgets(self)
#                        |   -> Function: _populate_config_table(self)
#                        |   -> Function: _reload_config_action(self)
#                        |   -> Function: _save_program_configure_action(self)
#            └── 4_conductor/
#                └── gui_mqtt_conductor.py (Lines: 443)
#                        |   -> Import: collections
#                        |   -> Import: datetime
#                        |   -> Import: display.logger
#                        |   -> Import: display.styling.style
#                        |   -> Import: inspect
#                        |   -> Import: json
#                        |   -> Import: os
#                        |   -> Import: pathlib
#                        |   -> Import: tkinter
#                        |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                        |   -> Class: MqttConductorFrame
#                        |   -> Function: __init__(self, parent, mqtt_util)
#                        |   -> Function: _apply_styles(self, theme_name)
#                        |   -> Function: _check_status_request(self)
#                        |   -> Function: _clear_log(self)
#                        |   -> Function: _clear_retained_messages(self)
#                        |   -> Function: _create_widgets(self)
#                        |   -> Function: _on_message(self, topic, payload)
#                        |   -> Function: _on_purge_button_clicked(self)
#                        |   -> Function: _on_sys_message(self, topic, payload)
#                        |   -> Function: _publish_custom_message(self)
#                        |   -> Function: _reset_purge_button_state(self)
#                        |   -> Function: log_to_gui(self, message)
#                        |   -> Function: log_to_table(self, topic, message)
#        └── top_10/
#            └── gui_start_pause_stop.py (Lines: 90)
#                    |   -> Import: display.logger
#                    |   -> Import: inspect
#                    |   -> Import: os
#                    |   -> Import: pathlib
#                    |   -> Import: tkinter
#                    |   -> Import: workers.builder.dynamic_gui_builder
#                    |   -> Class: StartPauseStopGui
#                    |   -> Function: __init__(self, parent, mqtt_util)
#    └── styling/
#        └── style.py (Lines: 256)
#                |   -> Import: copy
#                |   -> Import: os
#                |   -> Import: tkinter
#    └── left_50/
#        └── top_100/
#        └── top_100/
#            ├── 1_Connection/
#            ├── 3_Instrument/
#            ├── 3_markers/
#            ├── 4_presets/
#            ├── 5_sweeping/
#            ├── 6_plotting/
#            ├── 7_meta_Data/
#            └── 8_exepriment/
#            └── 7_meta_Data/
#                ├── 1_meta_data/
#                ├── 2_wireless_components/
#                └── 3_Amplifiers and Antenna/
#                └── 1_meta_data/
#                    └── gui_meta_data.py (Lines: 87)
#                            |   -> Import: display.logger
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: tkinter
#                            |   -> Import: workers.builder.dynamic_gui_builder
#                            |   -> Class: PresetPusherGui
#                            |   -> Function: __init__(self, parent, mqtt_util, config)
#                └── 2_wireless_components/
#                    └── gui_wireless_components.py (Lines: 297)
#                            |   -> Import: datetime
#                            |   -> Import: display.logger
#                            |   -> Import: display.styling.style
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: tkinter
#                            |   -> Import: workers.exporters.worker_file_csv_export
#                            |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                            |   -> Import: workers.mqtt.worker_mqtt_data_flattening
#                            |   -> Class: InstrumentTranslatorGUI
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _apply_styles(self, theme_name)
#                            |   -> Function: _export_table_data(self)
#                            |   -> Function: _on_commands_message(self, topic, payload)
#                └── 3_Amplifiers and Antenna/
#                    ├── gui_meta_devices_amplifier.py (Lines: 292)
#                            |   -> Import: datetime
#                            |   -> Import: display.logger
#                            |   -> Import: display.styling.style
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: tkinter
#                            |   -> Import: workers.exporters.worker_file_csv_export
#                            |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                            |   -> Import: workers.mqtt.worker_mqtt_data_flattening
#                            |   -> Class: InstrumentTranslatorGUI
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _apply_styles(self, theme_name)
#                            |   -> Function: _export_table_data(self)
#                            |   -> Function: _on_commands_message(self, topic, payload)
#                    └── gui_meta_devices_antenna.py (Lines: 300)
#                            |   -> Import: datetime
#                            |   -> Import: display.logger
#                            |   -> Import: display.styling.style
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: tkinter
#                            |   -> Import: workers.exporters.worker_file_csv_export
#                            |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                            |   -> Import: workers.mqtt.worker_mqtt_data_flattening
#                            |   -> Class: InstrumentTranslatorGUI
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _apply_styles(self, theme_name)
#                            |   -> Function: _export_table_data(self)
#                            |   -> Function: _on_commands_message(self, topic, payload)
#            └── 3_Instrument/
#                ├── 1_frequency/
#                ├── 2_bandwidth/
#                ├── 3_amplitude/
#                ├── 4_markers/
#                └── 5_traces/
#                └── 5_traces/
#                    └── gui_traces.py (Lines: 88)
#                            |   -> Import: display.logger
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: tkinter
#                            |   -> Import: workers.builder.dynamic_gui_builder
#                            |   -> Class: TracesGui
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                └── 1_frequency/
#                    └── gui_frequency_1.py (Lines: 81)
#                            |   -> Import: display.logger
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: tkinter
#                            |   -> Import: workers.builder.dynamic_gui_builder
#                            |   -> Class: PresetPusherGui
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                └── 4_markers/
#                    └── gui_markers.py (Lines: 88)
#                            |   -> Import: display.logger
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: tkinter
#                            |   -> Import: workers.builder.dynamic_gui_builder
#                            |   -> Class: MarkersGui
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                └── 3_amplitude/
#                    └── gui_amplitude.py (Lines: 88)
#                            |   -> Import: display.logger
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: tkinter
#                            |   -> Import: workers.builder.dynamic_gui_builder
#                            |   -> Class: AmplitudeGui
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                └── 2_bandwidth/
#                    └── gui_bandwidth.py (Lines: 93)
#                            |   -> Import: display.logger
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: tkinter
#                            |   -> Import: workers.builder.dynamic_gui_builder
#                            |   -> Class: PresetPusherGui
#                            |   -> Function: __init__(self, parent, mqtt_util)
#            └── 5_sweeping/
#                ├── 0_bands/
#                └── 2_configuration/
#                └── 0_bands/
#                    └── gui_bands.py (Lines: 297)
#                            |   -> Import: datetime
#                            |   -> Import: display.logger
#                            |   -> Import: display.styling.style
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: tkinter
#                            |   -> Import: workers.exporters.worker_file_csv_export
#                            |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                            |   -> Import: workers.mqtt.worker_mqtt_data_flattening
#                            |   -> Class: InstrumentTranslatorGUI
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _apply_styles(self, theme_name)
#                            |   -> Function: _export_table_data(self)
#                            |   -> Function: _on_commands_message(self, topic, payload)
#                └── 2_configuration/
#                    └── gui_configuration.py (Lines: 84)
#                            |   -> Import: display.logger
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: tkinter
#                            |   -> Import: workers.builder.dynamic_gui_builder
#                            |   -> Class: PresetPusherGui
#                            |   -> Function: __init__(self, parent, mqtt_util, config)
#            └── 3_markers/
#                ├── 1_showtime/
#                ├── 2_peak_hunter/
#                └── 3_Importer/
#                └── 2_peak_hunter/
#                    └── gui_peak_hunter.py (Lines: 298)
#                            |   -> Import: datetime
#                            |   -> Import: display.logger
#                            |   -> Import: display.styling.style
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: tkinter
#                            |   -> Import: workers.exporters.worker_file_csv_export
#                            |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                            |   -> Import: workers.mqtt.worker_mqtt_data_flattening
#                            |   -> Class: MarkerPeakHunterGUI
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _apply_styles(self, theme_name)
#                            |   -> Function: _export_table_data(self)
#                            |   -> Function: _on_commands_message(self, topic, payload)
#                └── 1_showtime/
#                    └── gui_showtime.py (Lines: 192)
#                            |   -> Import: collections
#                            |   -> Import: datetime
#                            |   -> Import: display.logger
#                            |   -> Import: display.styling.style
#                            |   -> Import: inspect
#                            |   -> Import: numpy
#                            |   -> Import: os
#                            |   -> Import: pandas
#                            |   -> Import: pathlib
#                            |   -> Import: tkinter
#                            |   -> Import: workers.Showtime.worker_showtime_clear_group_buttons
#                            |   -> Import: workers.Showtime.worker_showtime_create_device_buttons
#                            |   -> Import: workers.Showtime.worker_showtime_create_group_buttons
#                            |   -> Import: workers.Showtime.worker_showtime_create_zone_buttons
#                            |   -> Import: workers.Showtime.worker_showtime_group
#                            |   -> Import: workers.Showtime.worker_showtime_on_group_toggle
#                            |   -> Import: workers.Showtime.worker_showtime_on_marker_button_click
#                            |   -> Import: workers.Showtime.worker_showtime_on_zone_toggle
#                            |   -> Import: workers.Showtime.worker_showtime_read
#                            |   -> Import: workers.Showtime.worker_showtime_tune
#                            |   -> Import: workers.active.worker_active_marker_tune_and_collect
#                            |   -> Import: workers.importers.worker_marker_file_import_handling
#                            |   -> Import: workers.markers.worker_marker_logic
#                            |   -> Class: ShowtimeTab
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _apply_styles(self, theme_name)
#                            |   -> Function: _create_widgets(self)
#                            |   -> Function: _on_tab_selected(self, event)
#                └── 3_Importer/
#                    └── gui_importer.py (Lines: 270)
#                            |   -> Import: display.logger
#                            |   -> Import: display.styling.style
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: pandas
#                            |   -> Import: pathlib
#                            |   -> Import: tkinter
#                            |   -> Import: workers.Importer.worker_importer_appender
#                            |   -> Import: workers.Importer.worker_importer_editor
#                            |   -> Import: workers.Importer.worker_importer_loader
#                            |   -> Import: workers.Importer.worker_importer_saver
#                            |   -> Import: workers.importers.worker_marker_file_import_handling
#                            |   -> Class: MarkerImporterTab
#                            |   -> Function: __init__(self, master, app_instance, mqtt_util)
#                            |   -> Function: _apply_styles(self, theme_name)
#                            |   -> Function: _create_widgets(self)
#                            |   -> Function: _update_treeview(self)
#            └── 6_plotting/
#                ├── 1_from_file/
#                ├── 1_single/
#                ├── 2_3d/
#                ├── 2_statistical/
#                └── 3_averaging/
#                └── 3_averaging/
#                    └── gui_averaging.py (Lines: 89)
#                            |   -> Import: display.logger
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: tkinter
#                            |   -> Import: workers.builder.dynamic_gui_builder
#                            |   -> Class: PresetPusherGui
#                            |   -> Function: __init__(self, parent, mqtt_util, config)
#                └── 1_from_file/
#                    └── gui_from_file.py (Lines: 362)
#                            |   -> Import: datetime
#                            |   -> Import: display.logger
#                            |   -> Import: display.styling.style
#                            |   -> Import: inspect
#                            |   -> Import: json
#                            |   -> Import: os
#                            |   -> Import: paho.mqtt.client
#                            |   -> Import: pathlib
#                            |   -> Import: sys
#                            |   -> Import: tkinter
#                            |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                            |   -> Class: BaseGUIFrame
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _apply_styles(self, theme_name)
#                            |   -> Function: _on_mqtt_message(self, topic, payload)
#                            |   -> Function: _publish_custom_message(self)
#                            |   -> Function: _publish_version_message(self)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#                └── 2_statistical/
#                    └── gui_statistical.py (Lines: 361)
#                            |   -> Import: datetime
#                            |   -> Import: display.logger
#                            |   -> Import: display.styling.style
#                            |   -> Import: inspect
#                            |   -> Import: json
#                            |   -> Import: os
#                            |   -> Import: paho.mqtt.client
#                            |   -> Import: pathlib
#                            |   -> Import: sys
#                            |   -> Import: tkinter
#                            |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                            |   -> Class: BaseGUIFrame
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _apply_styles(self, theme_name)
#                            |   -> Function: _on_mqtt_message(self, topic, payload)
#                            |   -> Function: _publish_custom_message(self)
#                            |   -> Function: _publish_version_message(self)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#                └── 2_3d/
#                    └── gui_3d.py (Lines: 90)
#                            |   -> Import: display.logger
#                            |   -> Import: display.styling.style
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: tkinter
#                            |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                            |   -> Class: Plotting3DTab
#                            |   -> Function: __init__(self, master, mqtt_util)
#                            |   -> Function: _apply_styles(self, theme_name)
#                            |   -> Function: _create_widgets(self)
#                            |   -> Function: _get_topic_prefix(self)
#                            |   -> Function: _publish_value(self, element_name, value)
#                └── 1_single/
#                    └── gui_single.py (Lines: 89)
#                            |   -> Import: display.logger
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: tkinter
#                            |   -> Import: workers.builder.dynamic_gui_builder
#                            |   -> Class: PresetPusherGui
#                            |   -> Function: __init__(self, parent, mqtt_util, config)
#            └── 8_exepriment/
#                ├── 1_mosquitto/
#                ├── 2_file Paths/
#                ├── 3_Application Configuration/
#                ├── 4_intermod/
#                └── 4_one million nodes/
#                └── 4_one million nodes/
#                    └── gui_recon_data_publisher.py (Lines: 428)
#                            |   -> Import: datetime
#                            |   -> Import: display.logger
#                            |   -> Import: display.styling.style
#                            |   -> Import: inspect
#                            |   -> Import: json
#                            |   -> Import: os
#                            |   -> Import: paho.mqtt.client
#                            |   -> Import: pathlib
#                            |   -> Import: sys
#                            |   -> Import: tkinter
#                            |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                            |   -> Class: BaseGUIFrame
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _apply_styles(self, theme_name)
#                            |   -> Function: _check_thread_status(self, thread)
#                            |   -> Function: _on_mqtt_message(self, topic, payload)
#                            |   -> Function: _publish_custom_message(self)
#                            |   -> Function: _publish_version_message(self)
#                            |   -> Function: _run_recon_publisher(self)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#                └── 4_intermod/
#                    ├── 1_calculator/
#                    └── 2_future/
#                    └── 1_calculator/
#                        └── gui_child_1_calculator.py (Lines: 361)
#                                |   -> Import: datetime
#                                |   -> Import: display.logger
#                                |   -> Import: display.styling.style
#                                |   -> Import: inspect
#                                |   -> Import: json
#                                |   -> Import: os
#                                |   -> Import: paho.mqtt.client
#                                |   -> Import: pathlib
#                                |   -> Import: sys
#                                |   -> Import: tkinter
#                                |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                                |   -> Class: BaseGUIFrame
#                                |   -> Function: __init__(self, parent, mqtt_util)
#                                |   -> Function: _apply_styles(self, theme_name)
#                                |   -> Function: _on_mqtt_message(self, topic, payload)
#                                |   -> Function: _publish_custom_message(self)
#                                |   -> Function: _publish_version_message(self)
#                                |   -> Function: debug_button_press(self)
#                                |   -> Function: log_button_press(self)
#                    └── 2_future/
#                        ├── gui_1_top.py (Lines: 361)
#                                |   -> Import: datetime
#                                |   -> Import: display.logger
#                                |   -> Import: display.styling.style
#                                |   -> Import: inspect
#                                |   -> Import: json
#                                |   -> Import: os
#                                |   -> Import: paho.mqtt.client
#                                |   -> Import: pathlib
#                                |   -> Import: sys
#                                |   -> Import: tkinter
#                                |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                                |   -> Class: BaseGUIFrame
#                                |   -> Function: __init__(self, parent, mqtt_util)
#                                |   -> Function: _apply_styles(self, theme_name)
#                                |   -> Function: _on_mqtt_message(self, topic, payload)
#                                |   -> Function: _publish_custom_message(self)
#                                |   -> Function: _publish_version_message(self)
#                                |   -> Function: debug_button_press(self)
#                                |   -> Function: log_button_press(self)
#                        ├── gui_2_bottom copy.py (Lines: 361)
#                                |   -> Import: datetime
#                                |   -> Import: display.logger
#                                |   -> Import: display.styling.style
#                                |   -> Import: inspect
#                                |   -> Import: json
#                                |   -> Import: os
#                                |   -> Import: paho.mqtt.client
#                                |   -> Import: pathlib
#                                |   -> Import: sys
#                                |   -> Import: tkinter
#                                |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                                |   -> Class: BaseGUIFrame
#                                |   -> Function: __init__(self, parent, mqtt_util)
#                                |   -> Function: _apply_styles(self, theme_name)
#                                |   -> Function: _on_mqtt_message(self, topic, payload)
#                                |   -> Function: _publish_custom_message(self)
#                                |   -> Function: _publish_version_message(self)
#                                |   -> Function: debug_button_press(self)
#                                |   -> Function: log_button_press(self)
#                        └── gui_44_last.py (Lines: 361)
#                                |   -> Import: datetime
#                                |   -> Import: display.logger
#                                |   -> Import: display.styling.style
#                                |   -> Import: inspect
#                                |   -> Import: json
#                                |   -> Import: os
#                                |   -> Import: paho.mqtt.client
#                                |   -> Import: pathlib
#                                |   -> Import: sys
#                                |   -> Import: tkinter
#                                |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                                |   -> Class: BaseGUIFrame
#                                |   -> Function: __init__(self, parent, mqtt_util)
#                                |   -> Function: _apply_styles(self, theme_name)
#                                |   -> Function: _on_mqtt_message(self, topic, payload)
#                                |   -> Function: _publish_custom_message(self)
#                                |   -> Function: _publish_version_message(self)
#                                |   -> Function: debug_button_press(self)
#                                |   -> Function: log_button_press(self)
#                └── 1_mosquitto/
#                    └── gui_7_experiment.py (Lines: 361)
#                            |   -> Import: datetime
#                            |   -> Import: display.logger
#                            |   -> Import: display.styling.style
#                            |   -> Import: inspect
#                            |   -> Import: json
#                            |   -> Import: os
#                            |   -> Import: paho.mqtt.client
#                            |   -> Import: pathlib
#                            |   -> Import: sys
#                            |   -> Import: tkinter
#                            |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                            |   -> Class: BaseGUIFrame
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _apply_styles(self, theme_name)
#                            |   -> Function: _on_mqtt_message(self, topic, payload)
#                            |   -> Function: _publish_custom_message(self)
#                            |   -> Function: _publish_version_message(self)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#                └── 2_file Paths/
#                    └── gui_file_paths.py (Lines: 57)
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: tkinter
#                            |   -> Import: workers.builder.dynamic_gui_builder
#                            |   -> Class: PresetPusherGui
#                            |   -> Function: __init__(self, parent, mqtt_util, config)
#                └── 3_Application Configuration/
#                    └── gui_application_configuration.py (Lines: 88)
#                            |   -> Import: display.logger
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: tkinter
#                            |   -> Import: workers.builder.dynamic_gui_builder
#                            |   -> Class: PresetPusherGui
#                            |   -> Function: __init__(self, parent, mqtt_util, config)
#            └── 1_Connection/
#                ├── 1_Device/
#                ├── 4_YAK/
#                └── 5_translator/
#                └── 1_Device/
#                    └── gui_Device.py (Lines: 86)
#                            |   -> Import: display.logger
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: tkinter
#                            |   -> Import: workers.builder.dynamic_gui_builder
#                            |   -> Class: ActiveInstrumentGui
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                └── 4_YAK/
#                    ├── 0_Frequency/
#                    ├── 1_Bandwidth/
#                    ├── 2_Amplitude/
#                    ├── 3_Trace/
#                    ├── 7_Markers/
#                    ├── 8_Memory/
#                    └── 9_System/
#                    └── 8_Memory/
#                        └── gui_memory.py (Lines: 88)
#                                |   -> Import: display.logger
#                                |   -> Import: inspect
#                                |   -> Import: os
#                                |   -> Import: pathlib
#                                |   -> Import: tkinter
#                                |   -> Import: workers.builder.dynamic_gui_builder
#                                |   -> Class: YakMemoryGui
#                                |   -> Function: __init__(self, parent, mqtt_util)
#                    └── 7_Markers/
#                        └── gui_yak_markers.py (Lines: 88)
#                                |   -> Import: display.logger
#                                |   -> Import: inspect
#                                |   -> Import: os
#                                |   -> Import: pathlib
#                                |   -> Import: tkinter
#                                |   -> Import: workers.builder.dynamic_gui_builder
#                                |   -> Class: YakMarkersGui
#                                |   -> Function: __init__(self, parent, mqtt_util)
#                    └── 2_Amplitude/
#                        └── gui_yak_amplitude.py (Lines: 88)
#                                |   -> Import: display.logger
#                                |   -> Import: inspect
#                                |   -> Import: os
#                                |   -> Import: pathlib
#                                |   -> Import: tkinter
#                                |   -> Import: workers.builder.dynamic_gui_builder
#                                |   -> Class: YakAmplitudeGui
#                                |   -> Function: __init__(self, parent, mqtt_util)
#                    └── 0_Frequency/
#                        └── gui_yak_frequency.py (Lines: 88)
#                                |   -> Import: display.logger
#                                |   -> Import: inspect
#                                |   -> Import: os
#                                |   -> Import: pathlib
#                                |   -> Import: tkinter
#                                |   -> Import: workers.builder.dynamic_gui_builder
#                                |   -> Class: YakFrequencyGui
#                                |   -> Function: __init__(self, parent, mqtt_util)
#                    └── 3_Trace/
#                        └── gui_yak_trace.py (Lines: 88)
#                                |   -> Import: display.logger
#                                |   -> Import: inspect
#                                |   -> Import: os
#                                |   -> Import: pathlib
#                                |   -> Import: tkinter
#                                |   -> Import: workers.builder.dynamic_gui_builder
#                                |   -> Class: YakTraceGui
#                                |   -> Function: __init__(self, parent, mqtt_util)
#                    └── 9_System/
#                        └── gui_yak_system.py (Lines: 88)
#                                |   -> Import: display.logger
#                                |   -> Import: inspect
#                                |   -> Import: os
#                                |   -> Import: pathlib
#                                |   -> Import: tkinter
#                                |   -> Import: workers.builder.dynamic_gui_builder
#                                |   -> Class: YakSystemGui
#                                |   -> Function: __init__(self, parent, mqtt_util)
#                    └── 1_Bandwidth/
#                        └── gui_yak_bandwidth.py (Lines: 88)
#                                |   -> Import: display.logger
#                                |   -> Import: inspect
#                                |   -> Import: os
#                                |   -> Import: pathlib
#                                |   -> Import: tkinter
#                                |   -> Import: workers.builder.dynamic_gui_builder
#                                |   -> Class: YakBandwidthGui
#                                |   -> Function: __init__(self, parent, mqtt_util)
#                └── 5_translator/
#                    └── gui_intrument_translator.py (Lines: 304)
#                            |   -> Import: datetime
#                            |   -> Import: display.logger
#                            |   -> Import: display.styling.style
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: tkinter
#                            |   -> Import: workers.exporters.worker_file_csv_export
#                            |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                            |   -> Import: workers.mqtt.worker_mqtt_data_flattening
#                            |   -> Class: InstrumentTranslatorGUI
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _apply_styles(self, theme_name)
#                            |   -> Function: _export_table_data(self)
#                            |   -> Function: _on_commands_message(self, topic, payload)
#            └── 4_presets/
#                ├── 1_pusher/
#                ├── 2_editor/
#                └── 3_collector/
#                └── 1_pusher/
#                    └── gui_pusher.py (Lines: 314)
#                            |   -> Import: csv
#                            |   -> Import: display.logger
#                            |   -> Import: display.styling.style
#                            |   -> Import: inspect
#                            |   -> Import: json
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: tkinter
#                            |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                            |   -> Import: workers.presets.worker_preset_pusher
#                            |   -> Import: workers.utils.worker_project_paths
#                            |   -> Class: PresetPusherGui
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _apply_styles(self, theme_name)
#                            |   -> Function: _create_widgets(self)
#                            |   -> Function: _format_button_text(self, preset)
#                            |   -> Function: _get_info_keys(self)
#                            |   -> Function: _load_presets_from_repo(self)
#                            |   -> Function: _rebuild_gui(self)
#                            |   -> Function: _setup_info_labels(self)
#                            |   -> Function: _update_info_labels(self, preset)
#                            |   -> Function: select_preset(self, selected_preset)
#                            |   -> Function: selected_preset(self, preset_values)
#                └── 2_editor/
#                    └── gui_editor.py (Lines: 587)
#                            |   -> Import: csv
#                            |   -> Import: datetime
#                            |   -> Import: decimal
#                            |   -> Import: display.logger
#                            |   -> Import: display.styling.style
#                            |   -> Import: inspect
#                            |   -> Import: json
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: tkinter
#                            |   -> Import: workers.exporters.worker_file_csv_export
#                            |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                            |   -> Import: workers.utils.worker_project_paths
#                            |   -> Import: workers.worker_project_paths
#                            |   -> Class: PresetEditorGUI
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _apply_styles(self, theme_name)
#                            |   -> Function: _create_headers(self)
#                            |   -> Function: _delete_preset(self, preset_key)
#                            |   -> Function: _export_table_data(self)
#                            |   -> Function: _load_data_from_csv(self)
#                            |   -> Function: _on_commands_message(self, topic, payload)
#                            |   -> Function: _on_edit_cell(self, event)
#                            |   -> Function: _on_tab_change_save_data(self, event)
#                            |   -> Function: _resolve_preset_repo_path(self)
#                            |   -> Function: _save_data_to_csv_from_normalized_model(self, file_path)
#                            |   -> Function: _sort_treeview(self, column_name, ascending)
#                            |   -> Function: _update_treeview(self)
#                            |   -> Function: on_update_cell(event)
#                └── 3_collector/
#                    └── gui_collector.py (Lines: 116)
#                            |   -> Import: collections
#                            |   -> Import: datetime
#                            |   -> Import: display.logger
#                            |   -> Import: display.styling.style
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: tkinter
#                            |   -> Import: workers.mqtt.worker_mqtt_controller_util
#                            |   -> Import: workers.presets.worker_preset_from_device
#                            |   -> Class: DevicePresetsTab
#                            |   -> Class: MockMqttUtil
#                            |   -> Function: __init__(self)
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _apply_styles(self, theme_name)
#                            |   -> Function: _on_collect_button_click(self)
#                            |   -> Function: add_subscriber(self, topic_filter, callback_func)
#                            |   -> Function: create_widgets(self)
#                            |   -> Function: publish_message(self, topic, subtopic, value, retain)
#                            |   -> Function: setup_layout(self)
#    └── splash/
#        ├── OPEN AIR LOGO.png (Lines: N/A)
#        └── splash_screen.py (Lines: 414)
#                |   -> Import: PIL
#                |   -> Import: display.logger
#                |   -> Import: os
#                |   -> Import: pathlib
#                |   -> Import: queue
#                |   -> Import: sys
#                |   -> Import: threading
#                |   -> Import: time
#                |   -> Import: tkinter
#                |   -> Class: SplashScreen
#                |   -> Function: __init__(self)
#                |   -> Function: _destroy_splash(self)
#                |   -> Function: _fade_in(self, alpha)
#                |   -> Function: _fade_out(self, alpha)
#                |   -> Function: _init_ui(self)
#                |   -> Function: _start_status_updates(self)
#                |   -> Function: _update_status(self)
#                |   -> Function: hide(self)
#                |   -> Function: run(self)
#                |   -> Function: set_status(self, message)
#└── datasets/
#    ├── Orchestration/
#    ├── Presets/
#    ├── Reports/
#    ├── YAK/
#    ├── configuration/
#    ├── meta/
#    ├── __init__.py (Lines: 33)
#    ├── constants.json (Lines: 55)
#    └── notes about data sets.txt (Lines: 34)
#    └── meta/
#        ├── Bands/
#        ├── Government/
#        ├── RfComponents/
#        └── Television/
#        └── Government/
#            ├── meta_government_Australia.json (Lines: 164)
#            ├── meta_government_Brazil.json (Lines: 77)
#            ├── meta_government_Canada.json (Lines: 190)
#            ├── meta_government_China.json (Lines: 88)
#            ├── meta_government_Germany.json (Lines: 78)
#            ├── meta_government_India.json (Lines: 73)
#            ├── meta_government_Japan.json (Lines: 72)
#            ├── meta_government_Mexico.json (Lines: 78)
#            ├── meta_government_Russia.json (Lines: 63)
#            ├── meta_government_SouthAfrica.json (Lines: 73)
#            ├── meta_government_UK.json (Lines: 63)
#            └── meta_government_USA.json (Lines: 143)
#        └── Television/
#            ├── meta_tv_Europe.json (Lines: 2057)
#            ├── meta_tv_Oceania.json (Lines: 206)
#            ├── meta_tv_africa.json (Lines: 1769)
#            ├── meta_tv_europe.json (Lines: 174)
#            ├── meta_tv_northAmerica.json (Lines: 286)
#            ├── meta_tv_northamerica.json (Lines: 1268)
#            └── meta_tv_south_america.json (Lines: 1544)
#        └── RfComponents/
#            ├── meta_components.json (Lines: 4154)
#            ├── meta_components_amplifier.json (Lines: 28)
#            └── meta_components_antenna.json (Lines: 44)
#        └── Bands/
#            └── meta_Bands.json (Lines: 142)
#    └── Reports/
#        └── meta_report.json (Lines: 228)
#    └── Orchestration/
#        └── dataset_configuration_orchestration.json (Lines: 30)
#    └── YAK/
#        ├── dataset_YAK_yak_Amplitude.json (Lines: 227)
#        ├── dataset_YAK_yak_Bandwidth.json (Lines: 168)
#        ├── dataset_YAK_yak_Frequency.json (Lines: 258)
#        ├── dataset_YAK_yak_Markers.json (Lines: 238)
#        ├── dataset_YAK_yak_Memory.json (Lines: 66)
#        ├── dataset_YAK_yak_System.json (Lines: 86)
#        └── dataset_YAK_yak_Trace.json (Lines: 387)
#    └── configuration/
#        ├── dataset_configuration_application.json (Lines: 145)
#        ├── dataset_configuration_application_filepaths.json (Lines: 94)
#        ├── dataset_configuration_instrument_active.json (Lines: 469)
#        ├── dataset_configuration_instrument_amplitude.json (Lines: 314)
#        ├── dataset_configuration_instrument_bandwidth.json (Lines: 253)
#        ├── dataset_configuration_instrument_frequency.json (Lines: 127)
#        ├── dataset_configuration_instrument_marker.json (Lines: 208)
#        └── dataset_configuration_instrument_trace.json (Lines: 342)
#    └── Presets/
#        ├── meta_dataset_configuration_presets.json (Lines: 0)
#        └── repository_presets.json (Lines: 354)


--------------------------------------------------

# ====================================================================================
# EVERYTHING.py.LOG
# This file contains the complete content of all Python, CSV, and INI files found during the crawl.
# Each file's content is separated by its path and a dashed line.
#
# Log started at: 2025-12-14 23:01:11
# ====================================================================================

#####################################
### File: OPEN-AIR/before_main.py
#####################################
# OPEN-AIR/before_main.py
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# A standalone script to verify the installation of all critical external
# dependencies before launching the main application. This script will attempt to
# uninstall and then reinstall external packages to ensure version freshness.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251026.225541.2
import sys
import inspect
import datetime
import os
import subprocess 

# --- Global Scope Variables (as per Protocol 4.4) ---
current_version = "20251026.225541.2"
# The hash calculation drops the leading zero from the hour (22 -> 22)
current_version_hash = (20251026 * 225541 * 2)
current_file = f"{os.path.basename(__file__)}"

# --- Mock Logging Functions (for standalone operation before app logger is active) ---
def _mock_console_log(message):
    """Prints a user-facing message."""
    print(message)

def _mock_debug_log(message, file, version, function, console_print_func):
    """Prints a detailed debug log entry."""
    if "--debug" in sys.argv:
        print(f"DEBUG: {message} | {file} | {version} Function: {function}")
        
# --- Constants (No Magic Numbers) ---
# Packages that require pip install/uninstall/reinstall
EXTERNAL_PACKAGES = {
    # --- CORE PROJECT DEPENDENCIES ---
    "numpy": "numpy",
    "pandas": "pandas",
    "matplotlib": "matplotlib",
    "Pillow (for Matplotlib/Tkinter image support)": "PIL", 
    "paho-mqtt": "paho.mqtt.client",
    "pdfplumber": "pdfplumber",
    "beautifulsoup4 (bs4)": "bs4",
    # --- VISA/SCPI DEPENDENCIES (PyVISA-py backend requires all of these) ---
    "pyvisa": "pyvisa",
    "pyusb": "usb.core",
    "python-usbtmc": "usbtmc",
    "python-vxi11": "vxi11",
    "pyserial": "serial",
   
    "psutil": "psutil",
    "zeroconf": "zeroconf",
}
# Packages that are generally built-in and only require an import check
BUILTIN_PACKAGES = {
    "python-csv": "csv",
    "python-threading": "threading",
    "python-subprocess": "subprocess",
    "python-pathlib": "pathlib", 
    "python-json": "json" 
}

# --- PIP Command Actions ---
ACTION_INSTALL = "install"
ACTION_UNINSTALL = "uninstall"
FLAG_BREAK_SYSTEM_PACKAGES = "--break-system-packages"
FLAG_ASSUME_YES = "-y"
ERROR_NOT_INSTALLED = "not installed"
CRITICAL_FAILURE_MESSAGE = "❌ CRITICAL FAILURE: Missing/Failed Dependencies!"
MANUAL_INSTALL_INSTRUCTION = "\nManual installation may be required. Remember to use a virtual environment or the '--break-system-packages' flag."


def _execute_pip_command(action, package_name, console_print_func):
    """Safely executes a pip install or uninstall command."""
    current_function_name = inspect.currentframe().f_code.co_name
    command = [sys.executable, "-m", "pip", action, package_name]
    
    # MANDATORY FIX: Add the flag to override system package management (PEP 668)
    command.append(FLAG_BREAK_SYSTEM_PACKAGES) 

    if action == ACTION_UNINSTALL:
        command.append(FLAG_ASSUME_YES) # Assume yes for uninstall
        
    log_message = f"🛠️ Running 'pip {action}' for {package_name}..."
    console_print_func(log_message)
    _mock_debug_log(
        message=f"🛠️🟢 Running pip command: {' '.join(command)}",
        file=current_file,
        version=current_version,
        function=current_function_name,
        console_print_func=console_print_func
    )

    try:
        # Capture output for debugging but suppress standard output
        result = subprocess.run(command, capture_output=True, text=True, check=False)
        
        if result.returncode == 0:
            console_print_func(f"✅ Pip {action} successful for {package_name}.")
            return True
        else:
            # Suppress "Package not installed" errors for uninstall, but report others
            if action == ACTION_UNINSTALL and ERROR_NOT_INSTALLED in result.stderr.lower():
                console_print_func(f"🟡 {package_name} was not installed. Skipping uninstall.")
                return True
            else:
                console_print_func(f"❌ Pip {action} failed for {package_name}. Error: {result.stderr.strip()}")
                return False

    except FileNotFoundError:
        console_print_func("❌ Error: pip command not found. Ensure Python and pip are correctly installed and in PATH.")
        return False
    except Exception as e:
        console_print_func(f"❌ An unexpected error occurred during pip operation for {package_name}: {e}")
        return False


def action_check_dependancies(should_clean_install=False): # Add argument with default
    # Checks for required external library dependencies and forces a reinstall if found.
    current_function_name = inspect.currentframe().f_code.co_name
    _mock_debug_log(
        message=f"🖥️🟢 Ah, good, we're entering '{current_function_name}' to examine and refresh the raw materials, shall we?",
        file=current_file,
        version=current_version,
        function=current_function_name,
        console_print_func=_mock_console_log
    )
    
    _mock_console_log(f"🔍 Starting dependency check ({len(EXTERNAL_PACKAGES) + len(BUILTIN_PACKAGES)} modules required). Clean Install Mode: {should_clean_install}")
    
    missing_packages = []

    try:
        # --- 1. Process External Packages (Conditional Refresh) ---
        _mock_console_log("\n--- Checking/Refreshing External Packages ---")
        for friendly_name, import_name in EXTERNAL_PACKAGES.items():
            
            # --- Dynamically Determine the PyPI Package Name ---
            package_name_for_pip = import_name.split('.')[0]
            
            # Overrides for cases where PyPI name differs from import root or module
            if friendly_name == "paho-mqtt":
                package_name_for_pip = "paho-mqtt"
            elif friendly_name == "python-usbtmc":
                package_name_for_pip = "python-usbtmc"
            elif friendly_name == "python-vxi11":
                package_name_for_pip = "python-vxi11"
            elif friendly_name == "pyserial":
                package_name_for_pip = "pyserial"
            elif friendly_name == "beautifulsoup4 (bs4)":
                 package_name_for_pip = "beautifulsoup4"
            elif friendly_name == "Pillow (for Matplotlib/Tkinter image support)":
                package_name_for_pip = "Pillow" 
            # --- End Overrides ---
            
            try:
                __import__(import_name)
                is_installed = True
            except ImportError:
                is_installed = False
     
            
            if is_installed and should_clean_install: # Use should_clean_install here
                # Scenario A: Installed, running in fresh mode -> Force uninstall/reinstall
                _mock_console_log(f"✅ Found '{friendly_name}'. Forcing refresh...")
                
                _execute_pip_command(ACTION_UNINSTALL, package_name_for_pip, _mock_console_log)
                
                if not _execute_pip_command(ACTION_INSTALL, package_name_for_pip, _mock_console_log):
                    missing_packages.append(friendly_name) 

            elif not is_installed:
                # Scenario B: Not installed -> Attempt install
                _mock_console_log(f"❌ '{friendly_name}' is missing. Attempting install...")
                if not _execute_pip_command(ACTION_INSTALL, package_name_for_pip, _mock_console_log):
                    missing_packages.append(friendly_name)
            
            elif is_installed and not should_clean_install: # Use should_clean_install here
                # Scenario C: Installed, not in fresh mode -> Skip, treat as success
                _mock_console_log(f"✅ Found '{friendly_name}'. Skipping refresh (Non-fresh mode).")


        # --- 2. Process Built-in Packages (Simple Check) ---
        _mock_console_log("\n--- Checking Standard Python Modules ---")
        for friendly_name, import_name in BUILTIN_PACKAGES.items():
            try:
                __import__(import_name)
                _mock_console_log(f"✅ Found '{friendly_name}'.")
            except ImportError:
                missing_packages.append(friendly_name)

        # --- 3. Final Result ---
        if missing_packages:
            _mock_console_log("\n" + "="*50)
            _mock_console_log(CRITICAL_FAILURE_MESSAGE)
            _mock_console_log("The following critical packages failed to install or are missing:")
            for pkg in missing_packages:
                _mock_console_log(f" - {pkg}")
            
            # --- INCORPORATED USER'S REQUESTED MESSAGE HERE ---
            _mock_console_log(MANUAL_INSTALL_INSTRUCTION)
            # --- END INCORPORATED MESSAGE ---
            
            _mock_console_log("="*50 + "\n")
            
            # Allow the main application to handle the error
            return False

        
        # --- Celebration of Success ---
        _mock_console_log("\n✅ A most glorious success! All critical dependencies are verified and refreshed.")
        _mock_debug_log(
            message="🖥️✅ All raw materials secured! Proceeding to next phase.",
            file=current_file,
            version=current_version,
            function=current_function_name,
            console_print_func=_mock_console_log
        )
        return True

    except Exception as e:
        _mock_console_log(f"\n❌ UNEXPECTED FATAL ERROR during dependency check: {e}")
        _mock_debug_log(
            message=f"🖥️🔴 Heavens to Betsy! An unknown error has torpedoed the dependency check! The error be: {e}",
            file=current_file,
            version=current_version,
            function=current_function_name,
            console_print_func=_mock_console_log
        )
        # Allows the main application to handle the error
        return False


if __name__ == "__main__":
    _mock_console_log("🚀 Starting dependency pre-check for OPEN-AIR. 🚀")
    
    # Prompt user for action
    user_choice = input("Do you want to [C]lean install (uninstall and reinstall all external libraries) or just [V]erify and install missing ones? (C/V): ").strip().lower()

    should_clean_install = False
    if user_choice == 'c':
        should_clean_install = True
        _mock_console_log("💡 Clean install mode selected. All external libraries will be reinstalled.")
    else:
        _mock_console_log("💡 Verify and install missing libraries mode selected.")

    # Pass should_clean_install to the dependency check function
    if not action_check_dependancies(should_clean_install):
        sys.exit(1)

#####################################
### File: OPEN-AIR/main.py
#####################################
# main.py
#
# This file (main.py) serves as the main entry point for the application, orchestrating startup checks and GUI launch.
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 44 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#


import os
import inspect
import datetime
import sys
import pathlib
import importlib
import time


# --- TEMPORARY IMPORTS (Only standard library imports are safe here) ---
# Project-specific imports are commented out or moved to avoid crashing before sys.path is set.
# from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility 
from display.logger import debug_log, console_log, log_visa_command
# ... (rest of initial imports) ...


# --- GLOBAL PATH ANCHOR (CRITICAL FIX: Ensure this runs first!) ---
# This defines the absolute, true root path of the project, irrespective of the CWD.
try:
    GLOBAL_PROJECT_ROOT = pathlib.Path(__file__).resolve().parent
    # Add the project's root directory to the system path to allow for imports from
    # all sub-folders (e.g., 'configuration' and 'display'). This is a robust way to handle imports.
    if str(GLOBAL_PROJECT_ROOT) not in sys.path:
        sys.path.append(str(GLOBAL_PROJECT_ROOT))
    
    # --- Project-specific Imports (SAFE TO RUN NOW) ---
    # Import core application modules
    from display.logger import debug_log, console_log, log_visa_command
    from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
    from display.styling.style import THEMES, DEFAULT_THEME
    from display.splash.splash_screen import SplashScreen
    from before_main import action_check_dependancies as check_dependencies_before_main
    
    # workers
    from workers.active.worker_active_marker_tune_and_collect import MarkerGoGetterWorker
    from workers.active.worker_active_peak_publisher import ActivePeakPublisher  
    from workers.publishers.worker_dataset_publisher import main as dataset_publisher_main
    from workers.publishers.worker_meta_publisher import main as meta_publisher_main
    from workers.publishers.worker_YAK_publisher import main as repository_publisher_main
    
    # managers
    from managers.frequency_manager.frequency_state import FrequencyState
    from managers.frequency_manager.frequency_yak_communicator import FrequencyYakCommunicator
    from managers.frequency_manager.frequency_callbacks import FrequencyCallbacks
    # from managers.manager_instrument_settings_frequency import FrequencySettingsManager
    from managers.bandwidth_manager.bandwidth_state import BandwidthState
    from managers.bandwidth_manager.bandwidth_yak_communicator import BandwidthYakCommunicator
    from managers.bandwidth_manager.bandwidth_presets import BandwidthPresets
    from managers.bandwidth_manager.bandwidth_callbacks import BandwidthCallbacks
    # from managers.manager_instrument_settings_bandwidth import BandwidthSettingsManager
    from managers.yak_manager.manager_presets_span import SpanSettingsManager
    from managers.connection.manager_visa_device_search import VisaDeviceManager
    from managers.connection.manager_visa_dispatch_scpi import ScpiDispatcher
    from managers.yak_manager.manager_yakety_yak import YaketyYakManager
    from managers.connection.manager_visa_reset import VisaResetManager
    from managers.manager_instrument_settings_markers import MarkersSettingsManager

    Local_Debug_Enable = True

    # --- Set DATA_DIR ---
    if getattr(sys, 'frozen', False) and hasattr(sys, '_MEIPASS'):
        # Running as a bundled executable
        DATA_DIR = os.path.join(os.path.dirname(sys.executable), 'DATA')
    else:
        # Running from source
        DATA_DIR = os.path.join(GLOBAL_PROJECT_ROOT, 'DATA')

except Exception as e:
    # Fallback logging if the path and initial imports failCreate GEMINI.md files to customize your interactions with Gemini.
    print(f"❌ CRITICAL INITIALIZATION ERROR: {e}", file=sys.stderr)
    print("Application halted at startup due to module import failure.")
    sys.exit(1)


# This block ensures the console can handle UTF-8 characters, preventing encoding errors.
if os.name == 'nt':
    try:
        sys.stdout.reconfigure(encoding='utf-8')
        sys.stderr.reconfigure(encoding='utf-8')
    except AttributeError:
        # Fallback for older Python versions that don't have reconfigure
        pass


current_file = f"{os.path.basename(__file__)}" 




def action_check_dependancies():
    # Checks for required system and library dependencies.
    current_function_name = inspect.currentframe().f_code.co_name
    if Local_Debug_Enable:
        debug_log(
            message=f"🖥️🟢 Ah, good, we're entering '{current_function_name}'! Let's examine the raw materials, shall we?",
            file=current_file,
            version=current_version,
            function=current_function_name,
            console_print_func=console_log
        )

    try:
        # --- Function logic goes here ---
        # Placeholder for dependency checking logic
        console_log("✅ A most glorious success! Dependencies are in order.")
        return True

    except Exception as e:
        console_log(f"❌ Error in {current_function_name}: {e}")
        if Local_Debug_Enable:
            debug_log(
                message=f"🖥️🔴 Heavens to Betsy! We've hit a snag in the dependencies! The error be: {e}",
                file=current_file,
                version=current_version,
                function=current_function_name,
                console_print_func=console_log
            )
        return False
def action_check_configuration():
    # Validates the application's configuration files.
    current_function_name = inspect.currentframe().f_code.co_name


    if Local_Debug_Enable:
        debug_log(
            message=f"🖥️🟢 Ahem, commencing the configuration validation experiment in '{current_function_name}'.",
            file=current_file,
            version=current_version,
            function=current_function_name,
            console_print_func=console_log
        )

   
    try:

        # Placeholder for configuration validation
        console_log("✅ Excellent! The configuration is quite, quite brilliant.")
        return True

    except Exception as e:
        console_log(f"❌ Error in {current_function_name}: {e}")
        if Local_Debug_Enable:
            debug_log(
                message=f"🖥️🔴 By Jove! The configuration is in shambles! The error be: {e}",
                file=current_file,
                version=current_version,
                function=current_function_name,
                console_print_func=console_log
            )
        return False
def action_open_display(mqtt_util_instance, splash): # Added splash parameter
    # Initializes and opens the main graphical user interface and then publishes the dataset.
    current_function_name = inspect.currentframe().f_code.co_name
    if Local_Debug_Enable:
        debug_log(
            message=f"🖥️🟢 The final step! Activating the main display in '{current_function_name}'!",
            file=current_file,
            version=current_version,
            function=current_function_name,
            console_print_func=console_log
        )

    try:
        # SplashScreen().run() # REMOVED THIS CALL
        splash.set_status("Building GUI...")

        ApplicationModule = importlib.import_module("display.gui_display")
        Application = getattr(ApplicationModule, "Application")
        
        app = Application(mqtt_util_instance=mqtt_util_instance)
        splash.set_status("GUI constructed.")

        splash.set_status("Initializing managers...")

        scpi_dispatcher = ScpiDispatcher(
            app_instance=app,
            console_print_func=console_log
        )
        splash.set_status("SCPI Dispatcher initialized.")

        frequency_state = FrequencyState()
        frequency_yak_communicator = FrequencyYakCommunicator(mqtt_controller=mqtt_util_instance, state=frequency_state)
        frequency_callbacks = FrequencyCallbacks(mqtt_controller=mqtt_util_instance, state=frequency_state, yak_communicator=frequency_yak_communicator)
        frequency_callbacks.subscribe_to_topics()
        splash.set_status("Frequency manager initialized.")

        bandwidth_state = BandwidthState()
        bandwidth_yak_communicator = BandwidthYakCommunicator(mqtt_controller=mqtt_util_instance, state=bandwidth_state)
        bandwidth_presets = BandwidthPresets(mqtt_controller=mqtt_util_instance, state=bandwidth_state, yak_communicator=bandwidth_yak_communicator)
        bandwidth_callbacks = BandwidthCallbacks(mqtt_controller=mqtt_util_instance, state=bandwidth_state, yak_communicator=bandwidth_yak_communicator, presets=bandwidth_presets)
        bandwidth_callbacks.subscribe_to_topics()
        splash.set_status("Bandwidth manager initialized.")

        span_manager = SpanSettingsManager(mqtt_controller=mqtt_util_instance)
        splash.set_status("Span manager initialized.")

        manager_visa_connection = VisaDeviceManager(
            mqtt_controller=mqtt_util_instance,
            scpi_dispatcher=scpi_dispatcher
        )
        splash.set_status("VISA connection manager initialized.")

        manager_visa_reset = VisaResetManager(
            mqtt_controller=mqtt_util_instance,
            scpi_dispatcher=scpi_dispatcher
        )
        splash.set_status("VISA reset manager initialized.")

        manager_yakety_yak = YaketyYakManager(
            mqtt_controller=mqtt_util_instance,
            dispatcher_instance=scpi_dispatcher,
            app_instance=app
        )
        splash.set_status("Yakety Yak manager initialized.")

        marker_settings_manager = MarkersSettingsManager(mqtt_controller=mqtt_util_instance)
        splash.set_status("Marker settings manager initialized.")
        
        marker_go_getter = MarkerGoGetterWorker(mqtt_util=mqtt_util_instance)
        splash.set_status("Marker Go-Getter worker initialized.")
        
        active_peak_publisher = ActivePeakPublisher(mqtt_util=mqtt_util_instance)
        splash.set_status("Active Peak Publisher initialized.")

        # Publish the dataset after the GUI is created but before mainloop() starts
        splash.set_status("Publishing initial dataset...")
        dataset_publisher_main(mqtt_util_instance)
        meta_publisher_main(mqtt_util_instance)
        repository_publisher_main(mqtt_util_instance)
        splash.set_status("Dataset published.")

        mqtt_util_instance.resume()
        splash.set_status("MQTT message processing resumed.")
        splash.hide() # Hide splash screen

        console_log("DEBUG: Reached app.mainloop(). Attempting to display GUI.")
        app.mainloop() # This is the main GUI loop, should run indefinitely
        console_log("✅ The grand spectacle begins! GUI is now open.")
        return True

    except Exception as e:
        console_log(f"❌ Error in {current_function_name}: {e}")
        if Local_Debug_Enable:
            debug_log(
                message=f"🖥️🔴 Blast and barnacles! The display has failed to materialize! The error be: {e}",
                file=current_file,
                version=current_version,
                function=current_function_name,
                console_print_func=console_log
            )
        splash.hide() # Hide splash on error
        return False

def main():
    """The main execution function for the application."""
    console_log(f"🚀 Launch sequence initiated for version {current_version}.")

    debug_dir = os.path.join(DATA_DIR, 'debug')
    if os.path.exists(debug_dir):
        for filename in os.listdir(debug_dir):
            file_path = os.path.join(debug_dir, filename)
            try:
                if os.path.isfile(file_path):
                    os.unlink(file_path)
            except Exception as e:
                console_log(f"Failed to delete {file_path}. Reason: {e}")

    # Initialize and start splash screen early
    splash = SplashScreen()
    splash.start()
    splash.set_status("Initializing application...") # Initial status update

    if action_check_dependancies():
        splash.set_status("Dependencies checked.")
        if action_check_configuration():
            splash.set_status("Configuration validated.")
            mqtt_util_instance = MqttControllerUtility(console_log, console_log)
            
            # Pause MQTT immediately after initialization
            mqtt_util_instance.pause() 
            splash.set_status("MQTT client initialized and paused.")

            if hasattr(mqtt_util_instance, 'start_mosquitto'):
                mqtt_util_instance.start_mosquitto()
                time.sleep(1)
            
            mqtt_util_instance.connect_mqtt()
            splash.set_status("Connecting to MQTT broker...")

            # print("--- DEBUG: Main thread past connect_mqtt() ---") # REMOVED
            action_open_display(mqtt_util_instance, splash) # Pass splash to action_open_display
            
            # AFTER GUI is built and data published, resume MQTT and hide splash
            # These actions are now handled within action_open_display()


        else:
            splash.set_status("Halting startup due to configuration errors.")
            splash.hide() # Hide splash on error
            console_log("❌ Halting startup due to configuration errors.")
    else:
        splash.set_status("Halting startup due to missing dependencies.")
        splash.hide() # Hide splash on error
        console_log("❌ Halting startup due to missing dependencies.")

    # mainloop will be called by app instance in action_open_display

if __name__ == "__main__":
    main()

#####################################
### File: OPEN-AIR/DATA/MARKERS.csv
#####################################
ZONE,GROUP,DEVICE,NAME,FREQ_MHZ,PEAK
10 STATION AXIENT MICS,,None - None - G10,,472.55,nan
10 STATION AXIENT MICS,,None - None - G10,,473.525,nan
10 STATION AXIENT MICS,,None - None - G10,,478.55,nan
10 STATION AXIENT MICS,,None - None - G10,,479.05,nan
10 STATION AXIENT MICS,,None - None - G10,,483.15,nan
10 STATION AXIENT MICS,,None - None - G10,,484.225,nan
10 STATION AXIENT MICS,,None - None - G10,,486.075,nan
00.TechStores,,Shure - PSM900 - G7,Shure IEM 1,513.35,nan
00.TechStores,,Shure - PSM900 - G7,Shure IEM 2,514.575,nan
00.TechStores,,None - None - G7,,515.175,nan
00.TechStores,,Shure - PSM900 - G7,Shure IEM 4,525.6,nan
01.STUDIO.55.FLOOR.K,,None - None - 42,,653.075,nan
10.ST.41.ROGERS.IFB15.20,,None - None - G10,,521.325,nan
10.ST.41.ROGERS.IFB15.20,,None - None - G10,,528.775,nan
10.ST.41.ROGERS.MICS.20,,None - None - G57,,599.75,nan
STATION ENG,,None - None - TV14-36,,519.3,nan
STATION ENG,,None - None - TV14-36,,520.2,nan
STATION ENG,,None - None - TV14-36,,520.75,nan
STATION ENG,,None - None - TV14-36,,521.575,nan
STATION ENG,,None - None - TV14-36,,522.925,nan
STATION ENG,,None - None - TV14-36,,524.025,nan
STATION ENG,,None - None - TV14-36,,525.125,nan
STATION ENG,,None - None - TV14-36,,527.0,nan
STATION ENG,,None - None - TV14-36,,527.975,nan
STATION ENG,,None - None - TV14-36,,528.85,nan
01.STUDIO.55.FLOOR.K,,None - None - 43,,654.75,nan
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-21,587.3,nan
06.ST.38.WEATHER CENTER,,Sennheiser - EM 3732-II - L,Sennheiser,588.19,nan
01.STUDIO.55.FLOOR.K,,None - None - 43,,658.025,nan
10.ST.41.ROGERS.IFB.J8E,,None - None - J8E,,616.95,nan
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-S1,600.3,nan
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-S2,600.7,nan
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-S3,601.1,nan
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-S4,572.475,nan
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,OMPENG-6,534.3,nan
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,OMPENG-7,535.775,nan
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,OMPENG-5,533.825,nan
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,OMPENG-8,535.175,nan
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,DSQENG-8,533.35,nan
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,DSQENG-7,532.925,nan
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,DSQENG-6,532.525,nan
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,DSQENG-5,531.725,nan
10.ST.41.ROGERS.IFB14.20,,Shure - PSM1000 - G10,IFB-01,470.3,nan
10.ST.41.ROGERS.IFB14.20,,Shure - PSM1000 - G10,IFB-02,470.7,nan
10.ST.41.ROGERS.IFB14.20,,Shure - PSM1000 - G10,IFB-03,471.4,nan
10.ST.41.ROGERS.IFB14.20,,Shure - PSM1000 - G10,IFB-04,471.75,nan
10.ST.41.ROGERS.IFB14.20,,Shure - PSM1000 - G10,IFB-05,473.925,nan
10.ST.41.ROGERS.IFB14.20,,Shure - PSM1000 - G10,IFB-06,474.475,nan
10.ST.41.ROGERS.IFB14.20,,Shure - PSM1000 - G10,IFB-07,475.275,nan
10.ST.41.ROGERS.IFB14.20,,Shure - PSM1000 - G10,IFB-08,475.775,nan
10.ST.41.ROGERS.IFB15.20,,Shure - PSM1000 - G10,IFB-09,476.225,nan
10.ST.41.ROGERS.IFB15.20,,Shure - PSM1000 - G10,IFB-10,476.575,nan
10.ST.41.ROGERS.IFB15.20,,Shure - PSM1000 - G10,IFB-11,477.575,nan
10.ST.41.ROGERS.IFB15.20,,Shure - PSM1000 - G10,IFB-12,477.975,nan
10.ST.41.ROGERS.IFB15.20,,Shure - PSM1000 - G10,IFB-13,480.175,nan
10.ST.41.ROGERS.IFB15.20,,Shure - PSM1000 - G10,IFB-14,480.625,nan
10.ST.41.ROGERS.IFB15.20,,Shure - PSM1000 - G10,IFB-15,481.375,nan
10.ST.41.ROGERS.IFB15.20,,Shure - PSM1000 - G10,IFB-16,481.875,nan
10.ST.41.ROGERS.IFB16.20,,Shure - PSM1000 - G10,IFB-17,482.3,nan
10.ST.41.ROGERS.IFB16.20,,Shure - PSM1000 - G10,IFB-18,482.95,nan
10.ST.41.ROGERS.IFB16.20,,Shure - PSM1000 - G10,IFB-19,483.35,nan
10.ST.41.ROGERS.IFB16.20,,Shure - PSM1000 - G10,IFB-20,484.9,nan
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,DSQENG-1,530.55,nan
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,DSQENG-2,531.025,nan
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,DSQENG-3,531.65,nan
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,DSQENG-4,532.1,nan
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,OMPENG-3,529.3,nan
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,OMPENG-2,530.05,nan
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,OMPENG-4,534.775,nan
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,OMPENG-1,535.825,nan
01.STUDIO.55.FLOOR.K,,Sony - DWR-R02DN - 42,Sony Mic 1,654.45,nan
01.STUDIO.55.FLOOR.K,,Sony - DWR-R02DN - 42,Sony Mic 3,656.175,nan
01.STUDIO.55.FLOOR.K,,Sony - DWR-R02DN - 42,Sony Mic 5,657.2,nan
01.STUDIO.55.FLOOR.K,,Sony - DWR-R02DN - 42,Sony Mic 7,660.45,nan
01.STUDIO.55.FLOOR.K,,Sony - DWR-R02DN - 42,Sony Mic 2,661.55,nan
01.STUDIO.55.FLOOR.K,,Sony - DWR-R02DN - 42,Sony Mic 4,642.25,nan
01.STUDIO.55.FLOOR.K,,Sony - DWR-R02DN - 42,Sony Mic 6,643.25,nan
01.STUDIO.55.FLOOR.K,,Sony - DWR-R02DN - 43,Sony Mic 8,645.5,nan
04.ST.50.FLOOR.A.NEWSNET,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 1,574.88,nan
04.ST.50.FLOOR.A.NEWSNET,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 2,575.55,nan
04.ST.50.FLOOR.A.NEWSNET,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 3,575.885,nan
04.ST.50.FLOOR.A.NEWSNET,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 4,579.86,nan
04.ST.50.FLOOR.A.NEWSNET,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 5,585.76,nan
04.ST.50.FLOOR.A.NEWSNET,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 6,590.225,nan
04.ST.50.FLOOR.A.NEWSNET,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 7,592.995,nan
04.ST.50.FLOOR.A.NEWSNET,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 8,616.61,nan
04.ST.53.FLOOR.B.FISHBOWL,,None - None - L,,589.28,nan
04.ST.53.FLOOR.B.FISHBOWL,,None - None - L,,593.725,nan
04.ST.53.FLOOR.B.FISHBOWL,,None - None - L,,595.83,nan
04.ST.53.FLOOR.B.FISHBOWL,,None - None - L,,616.99,nan
04.ST.53.FLOOR.B.FISHBOWL,,Sennheiser - SR 2050 - Bw,Sennheiser,654.825,nan
04.ST.53.FLOOR.B.FISHBOWL,,Sennheiser - SR 2050 - Bw,Sennheiser,657.95,nan
04.ST.53.FLOOR.B.FISHBOWL,,Sennheiser - SR 2050 - Bw,Sennheiser,658.95,nan
04.ST.53.FLOOR.B.FISHBOWL,,Sennheiser - SR 2050 - Bw,Sennheiser,660.6,nan
06.ST.38.WEATHER CENTER,,Sennheiser - EM 3732-II - L,Sennheiser,590.08,nan
06.ST.38.WEATHER CENTER,,Sennheiser - EM 3732-II - L,Sennheiser,591.64,nan
06.ST.211.RADIO RECORDING,,Shure - PSM900 - G6,IEM - MOB 1,490.225,nan
06.ST.211.RADIO RECORDING,,Shure - PSM900 - G6,IEM - MOB 2,500.575,nan
06.ST.38.WEATHER CENTER,,Sennheiser - SR 2000 - Aw,Sennheiser,537.6,nan
06.ST.211.RADIO RECORDING,,Shure - ULXD4 - G50,IN RACK ,530.3,nan
06.ST.211.RADIO RECORDING,,Shure - PSM900 - G6,IN RACK,476.45,nan
06.ST.211.RADIO RECORDING,,Shure - ULXD4 - G50,MOBILE 1,531.75,nan
06.ST.211.RADIO RECORDING,,Shure - ULXD4 - G50,MOBILE 2,532.725,nan
04.WB13.ST.F.LOCAL NEWS,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 1 - PRI,582.95,nan
04.WB13.ST.F.LOCAL NEWS,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 1 - BKUP,586.835,nan
04.WB13.ST.F.LOCAL NEWS,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 2,594.69,nan
04.WB13.ST.F.LOCAL NEWS,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 3,599.895,nan
10.CONF.ARTIST LOUNGE,,Shure - SLX_master_list - G5,Shure - MIC 1,494.3,nan
10.CONF.ARTIST LOUNGE,,Shure - SLX_master_list - G5,Shure - MIC 2,496.025,nan
10.CONF.ARTIST LOUNGE,,Shure - SLX_master_list - G5,Shure - MIC 3,498.35,nan
10.CONF.ARTIST LOUNGE,,Shure - SLX_master_list - G5,Shure - MIC 4,499.8,nan
05.ST.54.FLOOR.E.SRC NEWS,,Sony - DWR-R02DN - 34-36,Sony - MIC 1,592.075,nan
05.ST.54.FLOOR.E.SRC NEWS,,Sony - DWR-R02DN - 34-36,Sony - MIC 5,594.3,nan
05.ST.54.FLOOR.E.SRC NEWS,,Sennheiser - EM 2000 - Aw,Sennheiser - MIC 2,532.075,nan
05.ST.54.FLOOR.E.SRC NEWS,,Sennheiser - EM 2000 - Aw,Sennheiser - MIC 3,554.45,nan
05.ST.54.FLOOR.E.SRC NEWS,,Sennheiser - EM 2000 - Aw,Sennheiser - MIC 4,517.725,nan
05.ST.54.FLOOR.E.SRC NEWS,,Sennheiser - SR 2000 - Gw,Sennheiser - IEM 3,598.275,nan
05.ST.54.FLOOR.E.SRC NEWS,,Sennheiser - SR 2000 - Gw,Sennheiser - IEM 4,601.55,nan
05.ST.54.FLOOR.E.SRC NEWS,,Sennheiser - SR 2000 - Gw,Sennheiser - IEM 5,616.325,nan
05.ST.54.FLOOR.E.SRC NEWS,,Sennheiser - SR 2000 - Bw,Sennheiser - IEM 1,654.175,nan
05.ST.54.FLOOR.E.SRC NEWS,,Sennheiser - SR 2000 - Bw,Sennheiser - IEM 2,659.425,nan
09.CONF.DIGITAL SERVICES,,Shure - BLX4 - H10,Shure,571.675,nan
09.CONF.DIGITAL SERVICES,,Shure - BLX4 - H9,Shure,537.0,nan
09.CONF.DIGITAL SERVICES,,Shure - BLX4 - H9,Shure,534.85,nan
04.ST.55.FLOOR.D.NATIONAL,,Sennheiser - EM 3732-II - L,Sennheiser - RF 3,574.58,nan
04.ST.55.FLOOR.D.NATIONAL,,Sennheiser - EM 3732-II - L,Sennheiser - RF 4,589.84,nan
04.ST.55.FLOOR.D.NATIONAL,,Sennheiser - EM 3732 - C,Sennheiser - RF 1,580.115,nan
04.ST.55.FLOOR.D.NATIONAL,,Sennheiser - EM 3732 - C,Sennheiser - RF 2,586.52,nan
04.ST.55.FLOOR.D.NATIONAL,,Sennheiser - EM 3732 - C,Sennheiser - RF 5,590.28,nan
04.ST.55.FLOOR.D.NATIONAL,,Sennheiser - EM 3732 - C,Sennheiser - RF 6,616.135,nan
00.TechStores,,Sony - DWR-R02D - 42-45,Sony Rental 1,654.05,nan
00.TechStores,,Sony - DWR-R02D - 42-45,Sony Rental 2,656.825,nan
00.TechStores,,Sony - DWR-R02D - 42-45,Sony Rental 3,661.075,nan
00.TechStores,,Sony - DWR-R02D - 42-45,Sony Rental 4,661.8,nan
10.ST.41.ROGERS.IFB.J8E,10.Rogers 2020,Shure - PSM1000 - J8E,IFB-23,579.6,nan
10.ST.41.ROGERS.IFB.J8E,10.Rogers 2020,Shure - PSM1000 - J8E,IFB-24,582.35,nan
10.ST.41.ROGERS.IFB.J8E,10.Rogers 2020,Shure - PSM1000 - J8E,IFB-22,586.025,nan
10.ST.41.ROGERS.IFB.J8E,10.Rogers 2020,None - None - J8E,,592.325,nan
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-27,574.125,nan
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-28,574.7,nan
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-25,576.875,nan
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-26,579.175,nan
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-23,579.8,nan
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-24,580.7,nan
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-22,581.075,nan
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-19,582.525,nan
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-20,583.75,nan
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-17,584.45,nan
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-18,584.825,nan
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-15,585.25,nan
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-16,585.65,nan
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,None - None - G57,,586.025,nan
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-14,586.425,nan
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-11,601.475,nan
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-12,587.95,nan
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-09,590.8,nan
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-10,591.4,nan
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-07,591.75,nan
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-08,592.2,nan
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-05,594.25,nan
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-06,595.225,nan
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-03,597.375,nan
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-04,598.1,nan
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-01,598.9,nan
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-02,599.35,nan
06.ST.38.WEATHER CENTER,06.WeatherStudi,Sennheiser - EM 3732-II - L,Sennheiser,594.28,nan
00.TechStores,,None - None - A1A4,,522.975,nan
00.TechStores,,Sennheiser - EM6000 - A1A4, Sennheiser 4,523.475,nan
00.TechStores,,None - None - A1A4,,526.35,nan
00.TechStores,,Sennheiser - EM6000 - A1A4,Sennheiser 3,527.8,nan
00.TechStores,,Sennheiser - EM6000 - A1A4,Sennheiser 1,528.675,nan
00.TechStores,,Sennheiser - EM6000 - A1A4,Sennheiser 2,530.275,nan
10.SYS.1.GOULD MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 2 - MIC 01,574.455,nan
10.SYS.1.GOULD MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 2 - MIC 02,575.305,nan
10.SYS.1.GOULD MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 2 - MIC 03,576.73,nan
10.SYS.1.GOULD MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 2 - MIC 04,578.655,nan
10.SYS.1.GOULD MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 2 - MIC 05,583.4,nan
10.SYS.1.GOULD MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 2 - MIC 06,589.325,nan
10.SYS.1.GOULD MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 2 - MIC 07,593.7,nan
10.SYS.1.GOULD MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 2 - MIC 09,597.715,nan
10.SYS.1.GOULD MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 2 - MIC 08,596.465,nan
10.SYS.1.GOULD MICS,,None - None - L,,601.55,nan
10 STATION AXIENT MICS,,Shure - PSM1000 - G10,IFB 3,513.175,nan
10 STATION AXIENT MICS,,Shure - PSM1000 - G10,IFB 4,513.625,nan
10 STATION AXIENT MICS,,None - None - G10,,515.175,nan
10 STATION AXIENT MICS,,Shure - PSM1000 - G10,IFB 1,515.55,nan
10.SYS.2 SENN.MOBILE MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 1 - MIC 02,573.085,nan
10.SYS.2 SENN.MOBILE MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 1 - MIC 03,573.995,nan
10.SYS.2 SENN.MOBILE MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 1 - MIC 04,578.205,nan
10.SYS.2 SENN.MOBILE MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 1 - MIC 05,581.35,nan
10.SYS.2 SENN.MOBILE MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 1 - MIC 06,589.42,nan
10.SYS.2 SENN.MOBILE MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 1 - MIC 07,590.18,nan
10.SYS.2 SENN.MOBILE MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 1 - MIC 08,597.31,nan
10.SYS.2 SENN.MOBILE MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 1 - MIC 09,599.86,nan
10.SYS.2 SENN.MOBILE MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 1 - MIC 10,601.675,nan
10.SYS.2 SENN.MOBILE MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 1 - MIC 01,572.71,nan
10.SYS.1.GOULD MICS,,Sennheiser - SR 2050 - Bw,Sennheiser - IEM - 1,653.875,nan
10.SYS.1.GOULD MICS,,Sennheiser - SR 2050 - Bw,Sennheiser - IEM - 2,655.55,nan
10.SYS.1.GOULD MICS,,Sennheiser - SR 2050 - Bw,Sennheiser - IEM - 3,655.975,nan
10.SYS.1.GOULD MICS,,Sennheiser - SR 2050 - Bw,Sennheiser - IEM - 4,659.15,nan
10 STATION AXIENT MICS,,Shure - AD4Q-A - G57,LAV 4,574.075,nan
10 STATION AXIENT MICS,,Shure - AD4Q-A - G57,STICK 5,575.0,nan
10 STATION AXIENT MICS,,Shure - AD4Q-A - G57,LAV 1,575.7,nan
10 STATION AXIENT MICS,,Shure - AD4Q-A - G57,STICK 6,577.65,nan
10 STATION AXIENT MICS,,Shure - AD4Q-A - G57,STICK 7,578.1,nan
10 STATION AXIENT MICS,,Shure - AD4Q-A - G57,LAV 5,579.025,nan
10 STATION AXIENT MICS,,Shure - AD4Q-A - G57,LAV 3,581.0,nan
10 STATION AXIENT MICS,,Shure - AD4Q-A - G57,STICK 3,582.425,nan
10 STATION AXIENT MICS,,Shure - AD4Q-A - G57,LAV 2,582.85,nan
10 STATION AXIENT MICS,,Shure - AD4Q-A - G57,STICK 1,581.675,nan
10 STATION AXIENT MICS,,Shure - AD4Q-A - G57,STICK 4,584.575,nan
10 STATION AXIENT MICS,,Shure - AD4Q-A - G57,STICK 2,585.6,nan
10 STATION AXIENT MICS,,Shure - AD4Q-A - G57,Shure,576.05,nan
10 STATION AXIENT MICS,,Shure - AD4Q-A - G57,Shure,576.5,nan
10 STATION AXIENT MICS,,Shure - AD4Q-A - G57,Shure,586.925,nan
10 STATION AXIENT MICS,,Shure - AD4Q-A - G57,Shure,588.575,nan
10 STATION AXIENT MICS,,Shure - AD4Q-A - G57,Shure,589.075,nan
10 STATION AXIENT MICS,,Shure - AD4Q-A - G57,Shure,589.725,nan
10 STATION AXIENT MICS,,Shure - AD4Q-A - G57,Shure,593.025,nan
10 STATION AXIENT MICS,,Shure - AD4Q-A - G57,Shure,593.65,nan
10 STATION AXIENT MICS,,Shure - AD4Q-A - G57,Shure,595.65,nan
10 STATION AXIENT MICS,,Shure - AD4Q-A - G57,Shure,596.05,nan
10 STATION AXIENT MICS,,Shure - AD4Q-A - G57,Shure,596.725,nan
10 STATION AXIENT MICS,,Shure - AD4Q-A - G57,Shure,598.525,nan
10 STATION AXIENT MICS,,Shure - PSM1000 - G10,Shure,516.475,nan
10 STATION AXIENT MICS,23,Shure - PSM1000 - G10,Shure,523.825,nan
10 STATION AXIENT MICS,24,Shure - PSM1000 - G10,Shure,526.3,nan
10 STATION AXIENT MICS,25,Shure - PSM1000 - G10,Shure,527.525,nan
10 STATION AXIENT MICS,26,Shure - PSM1000 - G10,Shure,512.475,nan
00.TechStores,27,Sennheiser - EM 9046 - A1,Sennheiser 1,512.476,nan
00.TechStores,28,Sennheiser - EM 9046 - A1,Sennheiser 2,512.477,nan
00.TechStores,29,Sennheiser - EM 9046 - A2,Sennheiser 3,512.478,nan
00.TechStores,30,Sennheiser - EM 9046 - A3,Sennheiser 4,512.479,nan
00.TechStores,,Sennheiser - EM 9046 - A4,Sennheiser 5,512.480,nan
00.TechStores,,Sennheiser - EM 9046 - A5,Sennheiser 6,512.481,nan
00.TechStores,,Sennheiser - EM 9046 - A6,Sennheiser 7,512.482,nan
00.TechStores,,Sennheiser - EM 9046 - A7,Sennheiser 8,487.025,nan
01.STUDIO.ATRIUM,,Sennheiser - EM 9046 - A8,Sennheiser IFB 2,577.5,nan
01.STUDIO.ATRIUM,,Sennheiser - EM 9046 - A9,Sennheiser IFB 3,580.05,nan
01.STUDIO.ATRIUM,,Sennheiser - EM 9046 - A10,Sennheiser IFB 4,581.25,nan
01.STUDIO.ATRIUM,,Sennheiser - EM 9046 - A11,Sennheiser IFB 5,584.45,nan
01.STUDIO.ATRIUM,,Sennheiser - EM 9046 - A12,Sennheiser IFB 6,593.225,nan
01.STUDIO.ATRIUM,,Sennheiser - EM 9046 - A13,Sennheiser IFB 7,595.625,nan
01.STUDIO.ATRIUM,,Sennheiser - EM 9046 - A14,Sennheiser IFB 8,600.975,nan
01.STUDIO.ATRIUM,,Sennheiser - EM 9046 - A15,Sennheiser IFB 9,572.75,nan
01.STUDIO.ATRIUM,,Sennheiser - EM 9046 - A16,Sennheiser IFB 10,470.225,nan
01.STUDIO.ATRIUM,,Sennheiser - EM 9046 - A17,Sennheiser IFB 3,471.05,nan
01.STUDIO.ATRIUM,,Sennheiser - EM 9046 - A18,Sennheiser IFB 4,474.075,nan
01.STUDIO.ATRIUM,,Sennheiser - EM 9046 - A19,Sennheiser IFB 5,478.775,nan
01.STUDIO.ATRIUM,,Sennheiser - EM 9046 - A20,Sennheiser IFB 6,482.725,nan
01.STUDIO.ATRIUM,,Sennheiser - EM 9046 - A21,Sennheiser IFB 7,484.35,nan
01.STUDIO.ATRIUM,,Sennheiser - EM 9046 - A1,Sennheiser 7,485.55,nan
01.STUDIO.ATRIUM,,Sennheiser - EM 9046 - A1,Sennheiser 8,487.85,nan


#####################################
### File: OPEN-AIR/DATA/PRESET.CSV
#####################################
Parameter,Active,FileName,NickName,Start,Stop,Center,Span,RBW,VBW,RefLevel,Attenuation,MaxHold,HighSens,PreAmp,Trace1Mode,Trace2Mode,Trace3Mode,Trace4Mode


#####################################
### File: OPEN-AIR/Sample imports/Basic CSV - venue.csv
#####################################
ZONE,GROUP,DEVICE,NAME,FREQ
10 CBC AXIENT MICS,,None - None - G10,,472.55
10 CBC AXIENT MICS,,None - None - G10,,473.525
10 CBC AXIENT MICS,,None - None - G10,,478.55
10 CBC AXIENT MICS,,None - None - G10,,479.05
10 CBC AXIENT MICS,,None - None - G10,,483.15
10 CBC AXIENT MICS,,None - None - G10,,484.225
10 CBC AXIENT MICS,,None - None - G10,,486.075
00.TechStores,,Shure - PSM900 - G7,Shure IEM 1,513.35
00.TechStores,,Shure - PSM900 - G7,Shure IEM 2,514.575
00.TechStores,,None - None - G7,,515.175
00.TechStores,,Shure - PSM900 - G7,Shure IEM 4,525.6
01.STUDIO.55.FLOOR.K,,None - None - 42,,653.075
10.ST.41.ROGERS.IFB15.20,,None - None - G10,,521.325
10.ST.41.ROGERS.IFB15.20,,None - None - G10,,528.775
10.ST.41.ROGERS.MICS.20,,None - None - G57,,599.75
CBC ENG,,None - None - TV14-36,,519.3
CBC ENG,,None - None - TV14-36,,520.2
CBC ENG,,None - None - TV14-36,,520.75
CBC ENG,,None - None - TV14-36,,521.575
CBC ENG,,None - None - TV14-36,,522.925
CBC ENG,,None - None - TV14-36,,524.025
CBC ENG,,None - None - TV14-36,,525.125
CBC ENG,,None - None - TV14-36,,527.0
CBC ENG,,None - None - TV14-36,,527.975
CBC ENG,,None - None - TV14-36,,528.85
01.STUDIO.55.FLOOR.K,,None - None - 43,,654.75
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-21,587.3
06.ST.38.WEATHER CENTER,,Sennheiser - EM 3732-II - L,Sennheiser,588.19
01.STUDIO.55.FLOOR.K,,None - None - 43,,658.025
10.ST.41.ROGERS.IFB.J8E,,None - None - J8E,,616.95
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-S1,600.3
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-S2,600.7
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-S3,601.1
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-S4,572.475
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,OMPENG-6,534.3
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,OMPENG-7,535.775
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,OMPENG-5,533.825
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,OMPENG-8,535.175
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,DSQENG-8,533.35
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,DSQENG-7,532.925
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,DSQENG-6,532.525
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,DSQENG-5,531.725
10.ST.41.ROGERS.IFB14.20,,Shure - PSM1000 - G10,IFB-01,470.3
10.ST.41.ROGERS.IFB14.20,,Shure - PSM1000 - G10,IFB-02,470.7
10.ST.41.ROGERS.IFB14.20,,Shure - PSM1000 - G10,IFB-03,471.4
10.ST.41.ROGERS.IFB14.20,,Shure - PSM1000 - G10,IFB-04,471.75
10.ST.41.ROGERS.IFB14.20,,Shure - PSM1000 - G10,IFB-05,473.925
10.ST.41.ROGERS.IFB14.20,,Shure - PSM1000 - G10,IFB-06,474.475
10.ST.41.ROGERS.IFB14.20,,Shure - PSM1000 - G10,IFB-07,475.275
10.ST.41.ROGERS.IFB14.20,,Shure - PSM1000 - G10,IFB-08,475.775
10.ST.41.ROGERS.IFB15.20,,Shure - PSM1000 - G10,IFB-09,476.225
10.ST.41.ROGERS.IFB15.20,,Shure - PSM1000 - G10,IFB-10,476.575
10.ST.41.ROGERS.IFB15.20,,Shure - PSM1000 - G10,IFB-11,477.575
10.ST.41.ROGERS.IFB15.20,,Shure - PSM1000 - G10,IFB-12,477.975
10.ST.41.ROGERS.IFB15.20,,Shure - PSM1000 - G10,IFB-13,480.175
10.ST.41.ROGERS.IFB15.20,,Shure - PSM1000 - G10,IFB-14,480.625
10.ST.41.ROGERS.IFB15.20,,Shure - PSM1000 - G10,IFB-15,481.375
10.ST.41.ROGERS.IFB15.20,,Shure - PSM1000 - G10,IFB-16,481.875
10.ST.41.ROGERS.IFB16.20,,Shure - PSM1000 - G10,IFB-17,482.3
10.ST.41.ROGERS.IFB16.20,,Shure - PSM1000 - G10,IFB-18,482.95
10.ST.41.ROGERS.IFB16.20,,Shure - PSM1000 - G10,IFB-19,483.35
10.ST.41.ROGERS.IFB16.20,,Shure - PSM1000 - G10,IFB-20,484.9
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,DSQENG-1,530.55
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,DSQENG-2,531.025
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,DSQENG-3,531.65
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,DSQENG-4,532.1
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,OMPENG-3,529.3
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,OMPENG-2,530.05
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,OMPENG-4,534.775
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,OMPENG-1,535.825
01.STUDIO.55.FLOOR.K,,Sony - DWR-R02DN - 42,Sony Mic 1,654.45
01.STUDIO.55.FLOOR.K,,Sony - DWR-R02DN - 42,Sony Mic 3,656.175
01.STUDIO.55.FLOOR.K,,Sony - DWR-R02DN - 42,Sony Mic 5,657.2
01.STUDIO.55.FLOOR.K,,Sony - DWR-R02DN - 42,Sony Mic 7,660.45
01.STUDIO.55.FLOOR.K,,Sony - DWR-R02DN - 42,Sony Mic 2,661.55
01.STUDIO.55.FLOOR.K,,Sony - DWR-R02DN - 42,Sony Mic 4,642.25
01.STUDIO.55.FLOOR.K,,Sony - DWR-R02DN - 42,Sony Mic 6,643.25
01.STUDIO.55.FLOOR.K,,Sony - DWR-R02DN - 43,Sony Mic 8,645.5
04.ST.50.FLOOR.A.NEWSNET,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 1,574.88
04.ST.50.FLOOR.A.NEWSNET,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 2,575.55
04.ST.50.FLOOR.A.NEWSNET,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 3,575.885
04.ST.50.FLOOR.A.NEWSNET,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 4,579.86
04.ST.50.FLOOR.A.NEWSNET,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 5,585.76
04.ST.50.FLOOR.A.NEWSNET,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 6,590.225
04.ST.50.FLOOR.A.NEWSNET,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 7,592.995
04.ST.50.FLOOR.A.NEWSNET,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 8,616.61
04.ST.53.FLOOR.B.FISHBOWL,,None - None - L,,589.28
04.ST.53.FLOOR.B.FISHBOWL,,None - None - L,,593.725
04.ST.53.FLOOR.B.FISHBOWL,,None - None - L,,595.83
04.ST.53.FLOOR.B.FISHBOWL,,None - None - L,,616.99
04.ST.53.FLOOR.B.FISHBOWL,,Sennheiser - SR 2050 - Bw,Sennheiser,654.825
04.ST.53.FLOOR.B.FISHBOWL,,Sennheiser - SR 2050 - Bw,Sennheiser,657.95
04.ST.53.FLOOR.B.FISHBOWL,,Sennheiser - SR 2050 - Bw,Sennheiser,658.95
04.ST.53.FLOOR.B.FISHBOWL,,Sennheiser - SR 2050 - Bw,Sennheiser,660.6
06.ST.38.WEATHER CENTER,,Sennheiser - EM 3732-II - L,Sennheiser,590.08
06.ST.38.WEATHER CENTER,,Sennheiser - EM 3732-II - L,Sennheiser,591.64
06.ST.211.RADIO RECORDING,,Shure - PSM900 - G6,IEM - MOB 1,490.225
06.ST.211.RADIO RECORDING,,Shure - PSM900 - G6,IEM - MOB 2,500.575
06.ST.38.WEATHER CENTER,,Sennheiser - SR 2000 - Aw,Sennheiser,537.6
06.ST.211.RADIO RECORDING,,Shure - ULXD4 - G50,IN RACK ,530.3
06.ST.211.RADIO RECORDING,,Shure - PSM900 - G6,IN RACK,476.45
06.ST.211.RADIO RECORDING,,Shure - ULXD4 - G50,MOBILE 1,531.75
06.ST.211.RADIO RECORDING,,Shure - ULXD4 - G50,MOBILE 2,532.725
04.WB13.ST.F.LOCAL NEWS,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 1 - PRI,582.95
04.WB13.ST.F.LOCAL NEWS,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 1 - BKUP,586.835
04.WB13.ST.F.LOCAL NEWS,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 2,594.69
04.WB13.ST.F.LOCAL NEWS,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 3,599.895
10.CONF.ARTIST LOUNGE,,Shure - SLX_master_list - G5,Shure - MIC 1,494.3
10.CONF.ARTIST LOUNGE,,Shure - SLX_master_list - G5,Shure - MIC 2,496.025
10.CONF.ARTIST LOUNGE,,Shure - SLX_master_list - G5,Shure - MIC 3,498.35
10.CONF.ARTIST LOUNGE,,Shure - SLX_master_list - G5,Shure - MIC 4,499.8
05.ST.54.FLOOR.E.SRC NEWS,,Sony - DWR-R02DN - 34-36,Sony - MIC 1,592.075
05.ST.54.FLOOR.E.SRC NEWS,,Sony - DWR-R02DN - 34-36,Sony - MIC 5,594.3
05.ST.54.FLOOR.E.SRC NEWS,,Sennheiser - EM 2000 - Aw,Sennheiser - MIC 2,532.075
05.ST.54.FLOOR.E.SRC NEWS,,Sennheiser - EM 2000 - Aw,Sennheiser - MIC 3,554.45
05.ST.54.FLOOR.E.SRC NEWS,,Sennheiser - EM 2000 - Aw,Sennheiser - MIC 4,517.725
05.ST.54.FLOOR.E.SRC NEWS,,Sennheiser - SR 2000 - Gw,Sennheiser - IEM 3,598.275
05.ST.54.FLOOR.E.SRC NEWS,,Sennheiser - SR 2000 - Gw,Sennheiser - IEM 4,601.55
05.ST.54.FLOOR.E.SRC NEWS,,Sennheiser - SR 2000 - Gw,Sennheiser - IEM 5,616.325
05.ST.54.FLOOR.E.SRC NEWS,,Sennheiser - SR 2000 - Bw,Sennheiser - IEM 1,654.175
05.ST.54.FLOOR.E.SRC NEWS,,Sennheiser - SR 2000 - Bw,Sennheiser - IEM 2,659.425
09.CONF.DIGITAL SERVICES,,Shure - BLX4 - H10,Shure,571.675
09.CONF.DIGITAL SERVICES,,Shure - BLX4 - H9,Shure,537.0
09.CONF.DIGITAL SERVICES,,Shure - BLX4 - H9,Shure,534.85
04.ST.55.FLOOR.D.NATIONAL,,Sennheiser - EM 3732-II - L,Sennheiser - RF 3,574.58
04.ST.55.FLOOR.D.NATIONAL,,Sennheiser - EM 3732-II - L,Sennheiser - RF 4,589.84
04.ST.55.FLOOR.D.NATIONAL,,Sennheiser - EM 3732 - C,Sennheiser - RF 1,580.115
04.ST.55.FLOOR.D.NATIONAL,,Sennheiser - EM 3732 - C,Sennheiser - RF 2,586.52
04.ST.55.FLOOR.D.NATIONAL,,Sennheiser - EM 3732 - C,Sennheiser - RF 5,590.28
04.ST.55.FLOOR.D.NATIONAL,,Sennheiser - EM 3732 - C,Sennheiser - RF 6,616.135
00.TechStores,,Sony - DWR-R02D - 42-45,Sony Rental 1,654.05
00.TechStores,,Sony - DWR-R02D - 42-45,Sony Rental 2,656.825
00.TechStores,,Sony - DWR-R02D - 42-45,Sony Rental 3,661.075
00.TechStores,,Sony - DWR-R02D - 42-45,Sony Rental 4,661.8
10.ST.41.ROGERS.IFB.J8E,10.Rogers 2020,Shure - PSM1000 - J8E,IFB-23,579.6
10.ST.41.ROGERS.IFB.J8E,10.Rogers 2020,Shure - PSM1000 - J8E,IFB-24,582.35
10.ST.41.ROGERS.IFB.J8E,10.Rogers 2020,Shure - PSM1000 - J8E,IFB-22,586.025
10.ST.41.ROGERS.IFB.J8E,10.Rogers 2020,None - None - J8E,,592.325
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-27,574.125
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-28,574.7
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-25,576.875
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-26,579.175
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-23,579.8
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-24,580.7
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-22,581.075
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-19,582.525
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-20,583.75
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-17,584.45
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-18,584.825
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-15,585.25
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-16,585.65
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,None - None - G57,,586.025
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-14,586.425
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-11,601.475
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-12,587.95
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-09,590.8
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-10,591.4
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-07,591.75
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-08,592.2
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-05,594.25
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-06,595.225
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-03,597.375
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-04,598.1
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-01,598.9
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-02,599.35
06.ST.38.WEATHER CENTER,06.WeatherStudi,Sennheiser - EM 3732-II - L,Sennheiser,594.28
00.TechStores,,None - None - A1A4,,522.975
00.TechStores,,Sennheiser - EM6000 - A1A4, Sennheiser 4,523.475
00.TechStores,,None - None - A1A4,,526.35
00.TechStores,,Sennheiser - EM6000 - A1A4,Sennheiser 3,527.8
00.TechStores,,Sennheiser - EM6000 - A1A4,Sennheiser 1,528.675
00.TechStores,,Sennheiser - EM6000 - A1A4,Sennheiser 2,530.275
10.SYS.1.GOULD MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 2 - MIC 01,574.455
10.SYS.1.GOULD MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 2 - MIC 02,575.305
10.SYS.1.GOULD MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 2 - MIC 03,576.73
10.SYS.1.GOULD MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 2 - MIC 04,578.655
10.SYS.1.GOULD MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 2 - MIC 05,583.4
10.SYS.1.GOULD MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 2 - MIC 06,589.325
10.SYS.1.GOULD MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 2 - MIC 07,593.7
10.SYS.1.GOULD MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 2 - MIC 09,597.715
10.SYS.1.GOULD MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 2 - MIC 08,596.465
10.SYS.1.GOULD MICS,,None - None - L,,601.55
10 CBC AXIENT MICS,,Shure - PSM1000 - G10,IFB 3,513.175
10 CBC AXIENT MICS,,Shure - PSM1000 - G10,IFB 4,513.625
10 CBC AXIENT MICS,,None - None - G10,,515.175
10 CBC AXIENT MICS,,Shure - PSM1000 - G10,IFB 1,515.55
10.SYS.2 SENN.MOBILE MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 1 - MIC 02,573.085
10.SYS.2 SENN.MOBILE MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 1 - MIC 03,573.995
10.SYS.2 SENN.MOBILE MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 1 - MIC 04,578.205
10.SYS.2 SENN.MOBILE MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 1 - MIC 05,581.35
10.SYS.2 SENN.MOBILE MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 1 - MIC 06,589.42
10.SYS.2 SENN.MOBILE MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 1 - MIC 07,590.18
10.SYS.2 SENN.MOBILE MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 1 - MIC 08,597.31
10.SYS.2 SENN.MOBILE MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 1 - MIC 09,599.86
10.SYS.2 SENN.MOBILE MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 1 - MIC 10,601.675
10.SYS.2 SENN.MOBILE MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 1 - MIC 01,572.71
10.SYS.1.GOULD MICS,,Sennheiser - SR 2050 - Bw,Sennheiser - IEM - 1,653.875
10.SYS.1.GOULD MICS,,Sennheiser - SR 2050 - Bw,Sennheiser - IEM - 2,655.55
10.SYS.1.GOULD MICS,,Sennheiser - SR 2050 - Bw,Sennheiser - IEM - 3,655.975
10.SYS.1.GOULD MICS,,Sennheiser - SR 2050 - Bw,Sennheiser - IEM - 4,659.15
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,LAV 4,574.075
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,STICK 5,575.0
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,LAV 1,575.7
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,STICK 6,577.65
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,STICK 7,578.1
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,LAV 5,579.025
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,LAV 3,581.0
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,STICK 3,582.425
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,LAV 2,582.85
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,STICK 1,581.675
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,STICK 4,584.575
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,STICK 2,585.6
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,Shure,576.05
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,Shure,576.5
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,Shure,586.925
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,Shure,588.575
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,Shure,589.075
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,Shure,589.725
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,Shure,593.025
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,Shure,593.65
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,Shure,595.65
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,Shure,596.05
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,Shure,596.725
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,Shure,598.525
10 CBC AXIENT MICS,,Shure - PSM1000 - G10,Shure,516.475
10 CBC AXIENT MICS,,Shure - PSM1000 - G10,Shure,523.825
10 CBC AXIENT MICS,,Shure - PSM1000 - G10,Shure,526.3
10 CBC AXIENT MICS,,Shure - PSM1000 - G10,Shure,527.525
10 CBC AXIENT MICS,,Shure - PSM1000 - G10,Shure,512.475
00.TechStores,,Sennheiser - EM 9046 - A1,Sennheiser 1,472.125
00.TechStores,,Sennheiser - EM 9046 - A1,Sennheiser 2,473.25
00.TechStores,,Sennheiser - EM 9046 - A1,Sennheiser 3,474.975
00.TechStores,,Sennheiser - EM 9046 - A1,Sennheiser 4,477.3
00.TechStores,,Sennheiser - EM 9046 - A1,Sennheiser 5,480.775
00.TechStores,,Sennheiser - EM 9046 - A1,Sennheiser 6,481.925
00.TechStores,,Sennheiser - EM 9046 - A1,Sennheiser 7,483.55
00.TechStores,,Sennheiser - EM 9046 - A1,Sennheiser 8,487.025
01.STUDIO.ATRIUM,,Sennheiser - EM 2050 - Gw,Sennheiser IFB 2,577.5
01.STUDIO.ATRIUM,,Sennheiser - EM 2050 - Gw,Sennheiser IFB 3,580.05
01.STUDIO.ATRIUM,,Sennheiser - EM 2050 - Gw,Sennheiser IFB 4,581.25
01.STUDIO.ATRIUM,,Shure - AD4D-A - Gw,R-MC-17,584.45
01.STUDIO.ATRIUM,,Sennheiser - EM 2050 - Gw,Sennheiser IFB 6,593.225
01.STUDIO.ATRIUM,,None - None - Gw,,595.625
01.STUDIO.ATRIUM,,None - None - Gw,,600.975
01.STUDIO.ATRIUM,,Sennheiser - EM 2050 - Gw,Sennheiser IFB 1,572.75
01.STUDIO.ATRIUM,,Sennheiser - EM 9046 - A1,Sennheiser 1,470.225
01.STUDIO.ATRIUM,,Sennheiser - EM 9046 - A1,Sennheiser 2,471.05
01.STUDIO.ATRIUM,,Sennheiser - EM 9046 - A1,Sennheiser 3,474.075
01.STUDIO.ATRIUM,,Sennheiser - EM 9046 - A1,Sennheiser 4,478.775
01.STUDIO.ATRIUM,,Sennheiser - EM 9046 - A1,Sennheiser 5,482.725
01.STUDIO.ATRIUM,,Sennheiser - EM 9046 - A1,Sennheiser 6,484.35
01.STUDIO.ATRIUM,,Sennheiser - EM 9046 - A1,Sennheiser 7,485.55
01.STUDIO.ATRIUM,,Sennheiser - EM 9046 - A1,Sennheiser 8,487.85


#####################################
### File: OPEN-AIR/managers/manager_instrument_settings_markers.py
#####################################
# managers/manager_instrument_settings_markers.py
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# A manager for marker-related settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251124.150000.1

import os
import inspect
import json

from display.logger import debug_log, console_log
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility

# --- Global Scope Variables ---
current_version = "20251213.000000.1"
current_version_hash = (20251124 * 150000 * 1)
current_file = f"{os.path.basename(__file__)}"
Local_Debug_Enable = True


class MarkersSettingsManager:
    """
    Manages the logic and synchronization of all marker-related settings.
    """

    def __init__(self, mqtt_controller: MqttControllerUtility):
        # Initializes the manager and subscribes to relevant topics.
        current_function_name = inspect.currentframe().f_code.co_name
        
        self.mqtt_controller = mqtt_controller
        self.base_topic = "OPEN-AIR/configuration/instrument/marker"
        
        if Local_Debug_Enable:
            debug_log(
                message=f"🛠️🟢 Initializing MarkersSettingsManager and setting up subscriptions.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
        
        self._subscribe_to_topics()

    def _subscribe_to_topics(self):
        # Subscribes to all necessary marker topics.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Example topic subscription
        topic = f"{self.base_topic}/#"
        self.mqtt_controller.add_subscriber(topic_filter=topic, callback_func=self._on_message)
        if Local_Debug_Enable:
            debug_log(
                message=f"🔍 Subscribed to '{topic}'.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_message(self, topic, payload):
        # The main message processing callback.
        current_function_name = inspect.currentframe().f_code.co_name
        
        if Local_Debug_Enable:
            debug_log(
                message=f"🛠️🔵 Received message on topic '{topic}' with payload '{payload}'.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
        
        try:
            # Placeholder for marker logic
            if Local_Debug_Enable:
                console_log(f"✅ Marker setting updated on topic: {topic}")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"🛠️🔴 Arrr, the code be capsized! The marker logic has failed! The error be: {e}",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

#####################################
### File: OPEN-AIR/managers/visa_utils.py
#####################################
# managers/visa_utils.py
#
# This file (visa_utils.py) provides utility functions for listing and connecting to VISA (Virtual Instrument Software Architecture) resources.
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 44 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#


import pyvisa
import os
import inspect

from display.logger import debug_log, console_log, log_visa_command

Local_Debug_Enable = True

current_file = f"{os.path.basename(__file__)}"

def list_visa_resources(console_print_func=None):
    # Lists available VISA resources (instruments).
    console_print_func = console_print_func if console_print_func else console_log
    current_function = inspect.currentframe().f_code.co_name
    if Local_Debug_Enable:
        debug_log(message="Listing VISA resources... Let's find some devices!", file=f"{os.path.basename(__file__)}", version=current_version, function=current_function, console_print_func=console_print_func)
    try:
        rm = pyvisa.ResourceManager()
        
        # KEY CHANGE: Explicitly search for all instrument types, especially TCPIP.
        # '?*::INSTR' is the wildcard search pattern for all resource types supported by the backend.
        all_resources = rm.list_resources('?*::INSTR') 

        # --- Resource Reordering Logic (FIX) ---
        usb_resources = []
        tcpip_resources = []
        other_resources = []

        for res in all_resources:
            if res.startswith('USB'):
                usb_resources.append(res)
            elif res.startswith('TCPIP'):
                tcpip_resources.append(res)
            else: # Catches ASRL, GPIB, etc.
                other_resources.append(res)
        
        # Prioritize list: USB -> TCPIP -> Other (ASRL)
        resources = usb_resources + tcpip_resources + other_resources
        # --- End Resource Reordering Logic ---
        
        if Local_Debug_Enable:
            debug_log(message=f"Found VISA resources (Reordered): {resources}.", file=f"{os.path.basename(__file__)}", version=current_version, function=current_function, console_print_func=console_print_func)
        return list(resources)
    except Exception as e:
        error_msg = f"❌ Error listing VISA resources: {e}."
        console_print_func(error_msg)
        if Local_Debug_Enable:
            debug_log(message=error_msg, file=f"{os.path.basename(__file__)}", version=current_version, function=current_function, console_print_func=console_print_func)
        return []

def connect_to_instrument(resource_name, console_print_func=None):
    # Establishes a connection to a VISA instrument.
    console_print_func = console_print_func if console_print_func else console_log
    current_function = inspect.currentframe().f_code.co_name
    if Local_Debug_Enable:
        debug_log(message=f"Connecting to instrument: {resource_name}. Fingers crossed!", file=f"{os.path.basename(__file__)}", version=current_version, function=current_function, console_print_func=console_print_func)
    try:
        rm = pyvisa.ResourceManager()
        inst = rm.open_resource(resource_name)
        inst.timeout = 5000
        inst.read_termination = '\n'
        inst.write_termination = '\n'
        inst.query_delay = 0.1
        console_print_func(f"✅ Successfully connected to {resource_name}.")
        if Local_Debug_Enable:
            debug_log(message=f"Connection successful to {resource_name}. We're in!", file=f"{os.path.basename(__file__)}", version=current_version, function=current_function, console_print_func=console_print_func)
        return inst
    except Exception as e:
        error_msg = f"❌ An unexpected error occurred while connecting to {resource_name}: {e}."
        console_print_func(error_msg)
        if Local_Debug_Enable:
            debug_log(message=error_msg, file=f"{os.path.basename(__file__)}", version=current_version, function=current_function, console_print_func=console_print_func)
        return None

def disconnect_instrument(inst, console_print_func=None):
    # Closes the connection to a VISA instrument.
    console_print_func = console_print_func if console_print_func else console_log
    current_function = inspect.currentframe().f_code.co_name
    if Local_Debug_Enable:
        debug_log(message="Disconnecting instrument... Saying goodbye!", file=f"{os.path.basename(__file__)}", version=current_version, function=current_function, console_print_func=console_print_func)
    if inst:
        try:
            inst.close()
            console_print_func("✅ Instrument disconnected.")
            if Local_Debug_Enable:
                debug_log(message="Instrument connection closed. All done!", file=f"{os.path.basename(__file__)}", version=current_version, function=current_function, console_print_func=console_print_func)
            return True
        except Exception as e:
            error_msg = f"❌ An unexpected error occurred while disconnecting instrument: {e}."
            console_print_func(error_msg)
            if Local_Debug_Enable:
                debug_log(message=error_msg, file=f"{os.path.basename(__file__)}", version=current_version, function=current_function, console_print_func=console_print_func)
            return False
    if Local_Debug_Enable:
        debug_log(message="No instrument to disconnect. Already gone!", file=f"{os.path.basename(__file__)}", version=current_version, function=current_function, console_print_func=console_print_func)
    return False


#####################################
### File: OPEN-AIR/managers/frequency_manager/frequency_callbacks.py
#####################################
# managers/frequency_manager/frequency_callbacks.py
#
# This file (frequency_callbacks.py) handles MQTT message callbacks and logic for frequency settings within the frequency manager.
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 44 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#


import json
import os
import inspect

from display.logger import debug_log, console_log, log_visa_command
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from .frequency_state import FrequencyState
from .frequency_yak_communicator import FrequencyYakCommunicator

# --- Global Scope Variables ---
current_file = f"{os.path.basename(__file__)}"
Local_Debug_Enable = True





class FrequencyCallbacks:
    """Handles MQTT message callbacks and logic for frequency settings."""

    def __init__(self, mqtt_controller: MqttControllerUtility, state: FrequencyState, yak_communicator: FrequencyYakCommunicator):
        self.mqtt_controller = mqtt_controller
        self.state = state
        self.yak_communicator = yak_communicator
        self.base_topic = self.state.base_topic

    def subscribe_to_topics(self):
        current_function_name = inspect.currentframe().f_code.co_name
        
        topic_list = [
            f"{self.base_topic}/Settings/fields/center_freq_MHz/value",
            f"{self.base_topic}/Settings/fields/span_freq_MHz/value",
            f"{self.base_topic}/Settings/fields/start_freq_MHz/value",
            f"{self.base_topic}/Settings/fields/stop_freq_MHz/value",
        ]
        
        for topic in topic_list:
            self.mqtt_controller.add_subscriber(topic_filter=topic, callback_func=self.on_message)
            if Local_Debug_Enable:
                debug_log(
                    message=f"🔍 Subscribed to '{topic}'.",
                    file=current_file,
                    version="N/A",
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
            
        for yak_suffix in self.yak_communicator.YAK_NAB_OUTPUTS.keys():
            yak_topic = f"{self.yak_communicator.YAK_BASE}/nab/NAB_Frequency_settings/scpi_outputs/{yak_suffix}"
            self.mqtt_controller.add_subscriber(topic_filter=yak_topic, callback_func=self.on_message)
            if Local_Debug_Enable:
                debug_log(
                    message=f"🔍 Subscribed to YAK output '{yak_topic}'.",
                    file=current_file,
                    version="N/A",
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

    def on_message(self, topic, payload):
        current_function_name = inspect.currentframe().f_code.co_name
        
        if topic.startswith(f"{self.yak_communicator.YAK_BASE}/nab/NAB_Frequency_settings/scpi_outputs"):
            self.yak_communicator.process_yak_output(topic, payload)
            return

        if self.state._locked_state.get(topic, False):
            if Local_Debug_Enable:
                debug_log(
                    message=f"🟡 Message on locked topic '{topic}' received. Ignoring to prevent loop.",
                    file=current_file,
                    version="N/A",
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
            self.state._locked_state[topic] = False
            return
            
        if Local_Debug_Enable:
            debug_log(
                message=f"🛠️🔵 Received message on topic '{topic}' with payload '{payload}'. Executing synchronization logic.",
                file=current_file,
                version="N/A",
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
        
        try:
            try:
                parsed_payload = json.loads(payload)
                value_str = parsed_payload.get('value', payload)
            except (json.JSONDecodeError, TypeError):
                value_str = payload

            value = str(value_str).strip().strip('"').strip("'")

            if "center_freq_MHz/value" in topic:
                new_val = float(value)
                if self.state.center_freq is None or abs(self.state.center_freq - new_val) > 0.001:
                    self.state.center_freq = new_val
                    self._update_start_stop_from_center_span()
                    self.yak_communicator.publish_to_yak_and_trigger(new_val, self.yak_communicator.YAK_CENTER_INPUT, self.yak_communicator.YAK_CENTER_TRIGGER)
            elif "span_freq_MHz/value" in topic:
                new_val = float(value)
                if self.state.span_freq is None or abs(self.state.span_freq - new_val) > 0.001:
                    self.state.span_freq = new_val
                    self._update_start_stop_from_center_span()
                    self.yak_communicator.publish_to_yak_and_trigger(new_val, self.yak_communicator.YAK_SPAN_INPUT, self.yak_communicator.YAK_SPAN_TRIGGER)
            elif "start_freq_MHz/value" in topic:
                new_val = float(value)
                if self.state.start_freq is None or abs(self.state.start_freq - new_val) > 0.001:
                    self.state.start_freq = new_val
                    self._update_center_and_span_from_start_stop()
                    self.yak_communicator.publish_to_yak_and_trigger(new_val, self.yak_communicator.YAK_START_INPUT, self.yak_communicator.YAK_START_TRIGGER)
            elif "stop_freq_MHz/value" in topic:
                new_val = float(value)
                if self.state.stop_freq is None or abs(self.state.stop_freq - new_val) > 0.001:
                    self.state.stop_freq = new_val
                    self._update_center_and_span_from_start_stop()
                    self.yak_communicator.publish_to_yak_and_trigger(new_val, self.yak_communicator.YAK_STOP_INPUT, self.yak_communicator.YAK_STOP_TRIGGER)
            
            console_log("✅ Celebration of success! The frequency settings did synchronize!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"🛠️🔴 Arrr, the code be capsized! The frequency logic has failed! The error be: {e}",
                    file=current_file,
                    version="N/A",
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

    def _update_start_stop_from_center_span(self):
        current_function_name = inspect.currentframe().f_code.co_name
        
        if self.state.center_freq is not None and self.state.span_freq is not None:
            if self.state.span_freq <= 0:
                console_log(f"❌ Error: Frequency span cannot be zero or negative. Value received: {self.state.span_freq}")
                if Local_Debug_Enable:
                    debug_log(f"🟡 Warning! Invalid span value ({self.state.span_freq}) received. Ignoring update.",
                                  file=current_file,
                                  version="N/A",
                                  function=f"{self.__class__.__name__}.{current_function_name}",
                                  console_print_func=console_log)
                return

            new_start = round(self.state.center_freq - (self.state.span_freq / 2.0), 3)
            new_stop = round(self.state.center_freq + (self.state.span_freq / 2.0), 3)
            
            self.state._locked_state[f"{self.base_topic}/Settings/fields/start_freq_MHz/value"] = True
            self.state._locked_state[f"{self.base_topic}/Settings/fields/stop_freq_MHz/value"] = True

            self.state.start_freq = new_start
            self.state.stop_freq = new_stop

            if Local_Debug_Enable:
                debug_log(
                    message=f"🔁 Recalculated start/stop from center/span. Start: {new_start}, Stop: {new_stop}.",
                    file=current_file,
                    version="N/A",
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

    def _update_center_and_span_from_start_stop(self):
        current_function_name = inspect.currentframe().f_code.co_name
        
        if self.state.start_freq is not None and self.state.stop_freq is not None:
            if self.state.start_freq < 0 or self.state.stop_freq < 0:
                console_log(f"❌ Error: Start and stop frequencies cannot be negative. Start: {self.state.start_freq}, Stop: {self.state.stop_freq}.")
                if Local_Debug_Enable:
                    debug_log(f"🟡 Warning! Invalid negative frequency values received. Ignoring update.",
                                  file=current_file,
                                  version="N/A",
                                  function=f"{self.__class__.__name__}.{current_function_name}",
                                  console_print_func=console_log)
                return
            
            if self.state.stop_freq < self.state.start_freq:
                console_log(f"❌ Error: Stop frequency ({self.state.stop_freq}) cannot be less than start frequency ({self.state.start_freq}).")
                if Local_Debug_Enable:
                    debug_log(f"🟡 Warning! Invalid start/stop combination received. Ignoring update.",
                                  file=current_file,
                                  version="N/A",
                                  function=f"{self.__class__.__name__}.{current_function_name}",
                                  console_print_func=console_log)
                return
                
            new_span = round(self.state.stop_freq - self.state.start_freq, 3)
            new_center = round(self.state.start_freq + (new_span / 2.0), 3)
            
            self.state._locked_state[f"{self.base_topic}/Settings/fields/span_freq_MHz/value"] = True
            self.state._locked_state[f"{self.base_topic}/Settings/fields/center_freq_MHz/value"] = True

            self.state.span_freq = new_span
            self.state.center_freq = new_center

            if Local_Debug_Enable:
                debug_log(
                    message=f"🔁 Recalculated center/span from start/stop. Center: {new_center}, Span: {new_span}.",
                    file=current_file,
                    version="N/A",
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )


#####################################
### File: OPEN-AIR/managers/frequency_manager/frequency_state.py
#####################################
Local_Debug_Enable = True

# managers/frequency_manager/frequency_state.py

class FrequencyState:
    """Holds the state for frequency-related settings."""
    def __init__(self):
        self.base_topic = "OPEN-AIR/configuration/instrument/frequency"
        self.center_freq = None
        self.span_freq = None
        self.start_freq = None
        self.stop_freq = None
        self.preset_values = {}
        self._locked_state = {
            f"{self.base_topic}/Settings/fields/center_freq_MHz/value": False,
            f"{self.base_topic}/Settings/fields/span_freq_MHz/value": False,
            f"{self.base_topic}/Settings/fields/start_freq_MHz/value": False,
            f"{self.base_topic}/Settings/fields/stop_freq_MHz/value": False,
        }


#####################################
### File: OPEN-AIR/managers/frequency_manager/frequency_yak_communicator.py
#####################################
# managers/frequency_manager/frequency_yak_communicator.py
#
# This file (frequency_yak_communicator.py) handles communication with the YAK repository for frequency settings within the frequency manager.
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 44 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#


import time
import json
import os
import inspect

from display.logger import debug_log, console_log, log_visa_command
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from .frequency_state import FrequencyState

# --- Global Scope Variables ---
current_file = f"{os.path.basename(__file__)}"
Local_Debug_Enable = True





class FrequencyYakCommunicator:
    """Handles communication with the YAK repository for frequency settings."""
    
    HZ_TO_MHZ = 1_000_000
    YAK_BASE = "OPEN-AIR/yak/Frequency"
    YAK_UPDATE_TOPIC = f"{YAK_BASE}/nab/NAB_Frequency_settings/scpi_details/generic_model/trigger"
    
    YAK_CENTER_INPUT = f"{YAK_BASE}/set/set_center_freq_MHz/scpi_inputs/hz_value/value"
    YAK_CENTER_TRIGGER = f"{YAK_BASE}/set/set_center_freq_MHz/scpi_details/generic_model/trigger"

    YAK_SPAN_INPUT = f"{YAK_BASE}/set/set_span_freq_MHz/scpi_inputs/hz_value/value"
    YAK_SPAN_TRIGGER = f"{YAK_BASE}/set/set_span_freq_MHz/scpi_details/generic_model/trigger"

    YAK_START_INPUT = f"{YAK_BASE}/set/set_start_freq_MHz/scpi_inputs/hz_value/value"
    YAK_START_TRIGGER = f"{YAK_BASE}/set/set_start_freq_MHz/scpi_details/generic_model/trigger"

    YAK_STOP_INPUT = f"{YAK_BASE}/set/set_stop_freq_MHz/scpi_inputs/hz_value/value"
    YAK_STOP_TRIGGER = f"{YAK_BASE}/set/set_stop_freq_MHz/scpi_details/generic_model/trigger"
    
    YAK_NAB_OUTPUTS = {
        "start_freq/value": "Settings/fields/start_freq_MHz/value",
        "stop_freq/value": "Settings/fields/stop_freq_MHz/value",
        "center_freq/value": "Settings/fields/center_freq_MHz/value",
        "span_freq/value": "Settings/fields/span_freq_MHz/value",
    }

    def __init__(self, mqtt_controller: MqttControllerUtility, state: FrequencyState):
        self.mqtt_controller = mqtt_controller
        self.state = state
        self.base_topic = self.state.base_topic

    def publish_to_yak_and_trigger(self, value_mhz, input_topic, trigger_topic):
        current_function_name = inspect.currentframe().f_code.co_name
        
        try:
            value_hz = int(round(float(value_mhz) * self.HZ_TO_MHZ))
            
            self.mqtt_controller.publish_message(
                topic=input_topic,
                subtopic="",
                value=value_hz,
                retain=True
            )

            self.mqtt_controller.publish_message(
                topic=trigger_topic,
                subtopic="",
                value=True,
                retain=False
            )
            time.sleep(0.01)
            self.mqtt_controller.publish_message(
                topic=trigger_topic,
                subtopic="",
                value=False,
                retain=False
            )
            
            if Local_Debug_Enable:
                debug_log(
                    message=f"🐐✅ YAK command dispatched. Sent {value_hz} Hz to {input_topic}.",
                    file=current_file,
                    version="N/A",
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
            
            self.update_all_from_device()

        except Exception as e:
            console_log(f"❌ Error dispatching YAK command: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"🛠️🔴 YAK dispatch failed! The error be: {e}",
                    file=current_file,
                    version="N/A",
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

    def update_all_from_device(self):
        current_function_name = inspect.currentframe().f_code.co_name
        if Local_Debug_Enable:
            debug_log(
                message=f"🐐🟢 Triggering NAB_Frequency_settings to synchronize all 4 frequency values.",
                file=current_file,
                version="N/A",
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
        
        self.mqtt_controller.publish_message(
            topic=self.YAK_UPDATE_TOPIC,
            subtopic="",
            value=True,
            retain=False
        )
        time.sleep(0.01)
        self.mqtt_controller.publish_message(
            topic=self.YAK_UPDATE_TOPIC,
            subtopic="",
            value=False,
            retain=False
        )
        
        console_log("✅ UPDATE ALL command sent to refresh frequency values from device.")

    def process_yak_output(self, topic, payload):
        current_function_name = inspect.currentframe().f_code.co_name
        
        try:
            yak_suffix = topic.split('/scpi_outputs/')[1]
            gui_suffix = self.YAK_NAB_OUTPUTS.get(yak_suffix)
            
            if not gui_suffix:
                if Local_Debug_Enable:
                    debug_log(
                        message=f"🟡 Unknown YAK output suffix: {yak_suffix}. Ignoring.",
                        file=current_file,
                        version="N/A",
                        function=f"{self.__class__.__name__}.{current_function_name}",
                        console_print_func=console_log
                    )
                return

            try:
                parsed_payload = json.loads(payload)
                value_str = parsed_payload.get('value', payload)
            except (json.JSONDecodeError, ValueError, TypeError):
                value_str = payload

            cleaned_value = str(value_str).strip().strip('"').strip("'").strip('\\').strip()
            
            try:
                value_hz = float(cleaned_value)
                value_mhz = value_hz / self.HZ_TO_MHZ
                
                full_gui_topic = f"{self.base_topic}/{gui_suffix}"
                self.state._locked_state[full_gui_topic] = True
                
                self._publish_update(topic_suffix=gui_suffix, value=value_mhz)
                
                if Local_Debug_Enable:
                    debug_log(
                        message=f"🐐✅ YAK output processed. Synced {gui_suffix} with {value_mhz} MHz.",
                        file=current_file,
                        version="N/A",
                        function=f"{self.__class__.__name__}.{current_function_name}",
                        console_print_func=console_log
                    )
            except ValueError:
                if Local_Debug_Enable:
                    debug_log(
                        message=f"🛠️🟡 Could not convert YAK output '{cleaned_value}' to float for topic {topic}. Skipping update.",
                        file=current_file,
                        version="N/A",
                        function=f"{self.__class__.__name__}.{current_function_name}",
                        console_print_func=console_log
                    )
            
            
        except Exception as e:
            console_log(f"❌ Error processing YAK output for {topic}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"🛠️🔴 NAB synchronization failed! The error be: {e}",
                    file=current_file,
                    version="N/A",
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

    def _publish_update(self, topic_suffix, value):
        full_topic = f"{self.base_topic}/{topic_suffix}"
        rounded_value = round(value, 3)
        
        self.mqtt_controller.publish_message(
            topic=full_topic,
            subtopic="",
            value=rounded_value,
            retain=False
        )


#####################################
### File: OPEN-AIR/managers/yak_manager/manager_presets_span.py
#####################################
# managers/manager_presets_span.py
#
# This file (manager_presets_span.py) manages span preset buttons and publishes the selected value to the main span frequency control.
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 44 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#


import os
import inspect
import json
import pathlib

# Assume these are imported from a central logging utility and MQTT controller
from display.logger import debug_log, console_log, log_visa_command
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility

Local_Debug_Enable = True

current_file = f"{os.path.basename(__file__)}"


class SpanSettingsManager:
    """
    Manages the logic for span presets.
    """

    def __init__(self, mqtt_controller: MqttControllerUtility):
        # Initializes the manager and subscribes to relevant topics.
        current_function_name = inspect.currentframe().f_code.co_name

        self.mqtt_controller = mqtt_controller
        self.base_topic = "OPEN-AIR/configuration/instrument/frequency"
        self.span_presets_topic = f"{self.base_topic}/Presets/fields/SPAN/options"
        self.target_span_topic = f"{self.base_topic}/Settings/fields/span_freq_MHz/value"

        # Dictionary to store preset values dynamically
        self.preset_values = {}

        if Local_Debug_Enable:
            debug_log(
                message=f"🛠️🟢 Initializing SpanSettingsManager and setting up subscriptions.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

        self._load_preset_values()
        self._subscribe_to_topics()

    def _load_preset_values(self):
        """
        Loads the preset values directly from the configuration file.
        This makes the manager self-sufficient and prevents timing issues.
        """
        try:
            # FIX: Replaced fragile os.path.join with a robust pathlib implementation.
            project_root = pathlib.Path(__file__).resolve().parents[2]
            config_file_path = project_root / "datasets" / "configuration" / "dataset_configuration_instrument_frequency.json"

            if not config_file_path.is_file():
                if Local_Debug_Enable:
                    debug_log(
                        message=f"❌ Configuration file not found at '{config_file_path}'. Cannot load presets.",
                        file=current_file,
                        version=current_version,
                        function=f"{self.__class__.__name__}._load_preset_values",
                        console_print_func=console_log
                    )
                return

            with open(config_file_path, 'r') as f:
                config_data = json.load(f)

            span_options = config_data.get("Presets", {}).get("fields", {}).get("SPAN", {}).get("options", {})
            for key, option in span_options.items():
                self.preset_values[int(key)] = float(option.get('value'))

            if Local_Debug_Enable:
                debug_log(
                    message=f"💾 Successfully loaded {len(self.preset_values)} span preset values.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}._load_preset_values",
                    console_print_func=console_log
                )

        except Exception as e:
            if Local_Debug_Enable:
                debug_log(
                    message=f"🛠️🔴 Failed to load preset values from file. The error be: {e}",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}._load_preset_values",
                    console_print_func=console_log
                )


    def _subscribe_to_topics(self):
        # Subscribes to the preset topics.
        current_function_name = inspect.currentframe().f_code.co_name

        # Subscribe only to the 'selected' topics, as we no longer need the 'value' topics.
        for i in range(1, 8):
            self.mqtt_controller.add_subscriber(topic_filter=f"{self.span_presets_topic}/{i}/selected", callback_func=self._on_preset_message)

            if Local_Debug_Enable:
                debug_log(
                    message=f"🔍 Subscribed to span preset topics for option {i}.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

    def _on_preset_message(self, topic, payload):
        # The main message processing callback for presets.
        current_function_name = inspect.currentframe().f_code.co_name

        try:
            parsed_payload = json.loads(payload)
            value = parsed_payload.get('value', payload)

            if topic.endswith("/selected") and str(value).lower() == 'true':
                self._update_span_from_preset(topic=topic)

            console_log("✅ Celebration of success! The span settings did synchronize!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"🛠️🔴 Arrr, the code be capsized! The span preset logic has failed! The error be: {e}",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

    def _update_span_from_preset(self, topic):
        # Extracts the value from the preset topic and updates the main span topic.
        current_function_name = inspect.currentframe().f_code.co_name

        try:
            option_number = int(topic.split('/')[-2])
            new_span_value = self.preset_values.get(option_number)

            if new_span_value is not None:
                self._publish_update(topic=self.target_span_topic, value=new_span_value)
                if Local_Debug_Enable:
                    debug_log(
                        message=f"🔁 Preset selected! Published new span value to '{self.target_span_topic}'.",
                        file=current_file,
                        version=current_version,
                        function=f"{self.__class__.__name__}.{current_function_name}",
                        console_print_func=console_log
                    )
            else:
                if Local_Debug_Enable:
                    debug_log(
                        message=f"🟡 Warning: Preset value for option {option_number} has not been received yet.",
                        file=current_file,
                        version=current_version,
                        function=f"{self.__class__.__name__}.{current_function_name}",
                        console_print_func=console_log
                    )

        except Exception as e:
            if Local_Debug_Enable:
                debug_log(
                    message=f"🛠️🔴 Failed to apply preset from topic '{topic}'. The error be: {e}",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

    def _publish_update(self, topic, value):
        # Publishes a message to the specified topic.
        current_function_name = inspect.currentframe().f_code.co_name

        rounded_value = round(value, 3)

        if Local_Debug_Enable:
            debug_log(
                message=f"💾 Publishing new value '{rounded_value}' to topic '{topic}'.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

        self.mqtt_controller.publish_message(
            topic=topic,
            subtopic="",
            value=rounded_value,
            retain=False
        )

#####################################
### File: OPEN-AIR/managers/yak_manager/manager_yak_rx.py
#####################################
# managers/yak_manager/manager_yak_rx.py
#
# This file (manager_yak_rx.py) processes the response from an SCPI query and publishes the parsed output values to MQTT.
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 44 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#

import os
import inspect
from display.logger import debug_log, console_log, log_visa_command
import json


Local_Debug_Enable = True





current_file = f"{os.path.basename(__file__)}"

class YakRxManager:
    """
    Processes responses from the instrument and publishes outputs to MQTT.
    """
    def __init__(self, mqtt_controller):
        self.mqtt_util = mqtt_controller
        self.NAB_BANDWIDTH_TRIGGER_PATH = ['yak', 'Bandwidth', 'nab', 'NAB_bandwidth_settings', 'scpi_details', 'generic_model', 'trigger']

    def process_response(self, path_parts, command_details, response):
        """
        Parses the response and publishes the results to MQTT topics.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        if Local_Debug_Enable:
            debug_log(
                message=f"🐐🐐🐐📡 The agent reports back! Response from device: '{response}'",
                file=current_file, version=current_version, function=current_function_name, console_print_func=console_log
            )

        outputs = command_details.get("scpi_outputs", {})
        if Local_Debug_Enable:
            debug_log(
                message=f"ℹ️ YakRxManager received a response from the device.",
                file=current_file, version=current_version, function=current_function_name, console_print_func=console_log
            )
        if Local_Debug_Enable:
            debug_log(
                message=f"ℹ️ Path Parts: {path_parts}",
                file=current_file, version=current_version, function=current_function_name, console_print_func=console_log
            )
        if Local_Debug_Enable:
            debug_log(
                message=f"ℹ️ Command Details: {json.dumps(outputs, indent=2)}",
                file=current_file, version=current_version, function=current_function_name, console_print_func=console_log
            )
        if Local_Debug_Enable:
            debug_log(
                message=f"ℹ️ Raw Response: {response}",
                file=current_file, version=current_version, function=current_function_name, console_print_func=console_log
            )
        
        try:
            # Split the response into individual parts
            response_parts = [p.strip() for p in response.split(';')]
            output_keys = list(outputs.keys())
            
            # --- START FIX: Order Correction for NAB_bandwidth_settings ---
            
            # Check if this is the specific command with the known key swap issue
            if path_parts == self.NAB_BANDWIDTH_TRIGGER_PATH and len(output_keys) >= 5:
                if Local_Debug_Enable:
                    debug_log(
                        message=f"🔍🔵 Detected NAB_bandwidth_settings command with key order issue. Keys before fix: {output_keys}",
                        file=current_file, version=current_version, function=current_function_name, console_print_func=console_log
                    )
                
                # Check the order of the 4th and 5th items in the output_keys list
                # Based on the device response, the order is: ..., Continuous_Mode_On, Sweep_Time_s
                # The current YAK metadata order is likely: ..., Sweep_Time_s, Continuous_Mode_On
                
                # The assumption is that output_keys[3] is 'Sweep_Time_s' and output_keys[4] is 'Continuous_Mode_On'
                # if the original YAK metadata was incorrectly specified.
                
                # Since the device sends: [..., VBW_Auto_On, Continuous_Mode_On, Sweep_Time_s]
                # We force the key list to match this order, assuming the metadata stores them as:
                # 0, 1, 2, 4, 3 (for continuous and sweep time)
                
                if output_keys[3].endswith("Time_s") and output_keys[4].endswith("On"):
                    # This indicates the keys are likely SWAPPED in the metadata relative to the SCPI response order.
                    
                    # Create a corrected key list
                    temp_keys = list(output_keys)
                    
                    # Swap keys at index 3 (Continuous_Mode_On) and 4 (Sweep_Time_s) to match device response order
                    # The device gives: [..., val3, val4, val5]
                    # We assume YAK metadata gives: [..., key3, key4, key5]
                    # If key4 and key5 are the ones swapped, we swap them back in the list
                    
                    # NOTE: Since the key definitions in the metadata are fixed, and the SCPI output order is fixed:
                    # SCPI Order (Response Parts Index): 3 = Continuous_Mode_On, 4 = Sweep_Time_s
                    # The YAK metadata is misaligned.
                    
                    # Let's verify what keys are at the incorrect indices and swap them to match the SCPI order
                    
                    # Expected Key at Index 3 (Response Part 4): Continuous_Mode_On/value
                    # Expected Key at Index 4 (Response Part 5): Sweep_Time_s/value

                    key_at_index_3 = output_keys[3]
                    key_at_index_4 = output_keys[4]

                    if key_at_index_3.startswith("Sweep_Time_s") and key_at_index_4.startswith("Continuous_Mode_On"):
                         # SWAP REQUIRED: Swap the 4th and 5th keys in the list to match SCPI order
                        temp_keys[3], temp_keys[4] = temp_keys[4], temp_keys[3]
                        output_keys = temp_keys
                        if Local_Debug_Enable:
                            debug_log(
                                message=f"🛠️🟡 Corrected YAK key swap. Keys after fix: {output_keys}",
                                file=current_file, version=current_version, function=current_function_name, console_print_func=console_log
                            )
                    
            # --- END FIX ---


            if len(response_parts) != len(output_keys):
                if Local_Debug_Enable:
                    debug_log(
                        message=f"❌🔴 Mismatched response length after potential correction! Expected {len(output_keys)} parts, but received {len(response_parts)}.",
                        file=current_file, version=current_version, function=current_function_name, console_print_func=console_log
                    )
                return

            # FIX: Correctly rebuild the base topic by joining the initial path parts
            # The base output topic should be constructed up to '/scpi_outputs'
            # path_parts looks like: ['yak', 'Bandwidth', 'nab', 'NAB_bandwidth_settings', 'scpi_details', 'generic_model', 'trigger']
            # We want: OPEN-AIR/repository/yak/Bandwidth/nab/NAB_bandwidth_settings/scpi_outputs
            base_output_topic_parts = ['OPEN-AIR', 'yak'] + path_parts[:4] + ['scpi_outputs']
            base_output_topic = '/'.join(base_output_topic_parts)
            
            # Match and publish each part of the response
            for i, key in enumerate(output_keys):
                raw_value = response_parts[i]
                
                # Construct the full topic for the specific output value
                output_topic = f"{base_output_topic}/{key}/value"
                
                # Publish the value to the MQTT topic
                self.mqtt_util.publish_message(
                    topic=output_topic,
                    subtopic="",
                    value=raw_value,
                    retain=True
                )
                if Local_Debug_Enable:
                    debug_log(
                        message=f"💾 Published to '{output_topic}' with value: '{raw_value}'.",
                        file=current_file, version=current_version, function=current_function_name, console_print_func=console_log
                    )
            
            console_log("✅ Response processed and all output values published to MQTT.")

        except Exception as e:
            console_log(f"❌ Error processing response: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 The response processing has been shipwrecked! The error be: {e}",
                    file=current_file, version=current_version, function=current_function_name, console_print_func=console_log
                )

#####################################
### File: OPEN-AIR/managers/yak_manager/manager_yak_tx.py
#####################################
# managers/yak_manager/manager_yak_tx.py
#
# This file (manager_yak_tx.py) is responsible for transmitting the final SCPI command to the device via the ScpiDispatcher.
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 44 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#


import os
import inspect
from display.logger import debug_log, console_log, log_visa_command

Local_Debug_Enable = True

current_file = f"{os.path.basename(__file__)}"


class YakTxManager:
    """
    Transmits SCPI commands to the instrument using the ScpiDispatcher.
    """
    def __init__(self, dispatcher_instance):
        self.dispatcher = dispatcher_instance

    def execute_command(self, command_type, command_string):
        """
        Executes a command based on the presence of a '?' to determine if it is a query.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        # --- FIX: Clean the command string before sending ---
        cleaned_command = command_string.strip()
        # --- END FIX ---
        
        # Check if the command string contains a '?' to identify it as a query
        if '?' in cleaned_command:
            if Local_Debug_Enable:
                debug_log(
                    message=f"🐐🐐🐐🚀 Engaging the '{command_type}' API! Dispatching query command now!",
                    file=current_file, version=current_version, function=current_function_name, console_print_func=console_log
                )
            return self.dispatcher.query_safe(cleaned_command)
        else:
            if Local_Debug_Enable:
                debug_log(
                    message=f"🐐🐐🐐🚀 Engaging the '{command_type}' API! Dispatching write command now!",
                    file=current_file, version=current_version, function=current_function_name, console_print_func=console_log
                )
            return self.dispatcher.write_safe(cleaned_command)

#####################################
### File: OPEN-AIR/managers/yak_manager/manager_yakety_yak.py
#####################################
# managers/manager_yakety_yak.py
#
# This file (manager_yakety_yak.py) listens for MQTT messages and dynamically builds and updates a local JSON repository based on the incoming topic and payload data.
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 44 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#


import os
import inspect
import json
import pathlib
import re

# --- Utility and Manager Imports ---
from display.logger import debug_log, console_log, log_visa_command
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from managers.connection.manager_visa_dispatch_scpi import ScpiDispatcher
from managers.yak_manager.yak_trigger_handler import handle_yak_trigger
# FIXED: Re-import YAKETY_YAK_REPO_PATH after circular dependency fix
from workers.utils.worker_project_paths import YAKETY_YAK_REPO_PATH 


Local_Debug_Enable = True





current_file = f"{os.path.basename(__file__)}"
# DELETED: YAKETY_YAK_REPO_PATH is now imported from worker_project_paths.py
repo_topic_filter = "OPEN-AIR/yak/#"
save_action_topic = "OPEN-AIR/actions/yak/save/trigger"


class YaketyYakManager:
    """
    Manages the creation and updating of the YAK command repository via MQTT.
    """
    def __init__(self, mqtt_controller: MqttControllerUtility, dispatcher_instance: ScpiDispatcher, app_instance):
        current_function_name = inspect.currentframe().f_code.co_name
        if Local_Debug_Enable:
            debug_log(
                message=f"🐐🐐🐐🟢 Entering {current_function_name}. The Yakety Yak manager is coming to life! My creation awakens!",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
        try:
            self.mqtt_util = mqtt_controller
            self.dispatcher = dispatcher_instance
            self.app_instance = app_instance
            
            # FIXED: Ensure the repository folder exists before trying to load or save.
            if not YAKETY_YAK_REPO_PATH.parent.exists():
                YAKETY_YAK_REPO_PATH.parent.mkdir(parents=True, exist_ok=True)
                
            self.repo_memory = self._load_repo_from_file()

            # Subscribe to the master topic for all repository commands
            self.mqtt_util.add_subscriber(
                topic_filter=repo_topic_filter,
                callback_func=self.YAK_LISTEN_TO_MQTT
            )
            if Local_Debug_Enable:
                debug_log(
                    message=f"🐐🐐🐐🔍 I've set a trap! Listening for all repository messages on topic '{repo_topic_filter}'.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

            # Subscribe to the explicit save topic
            self.mqtt_util.add_subscriber(
                topic_filter=save_action_topic,
                callback_func=self.YAK_SAVE_REPOSITORY
            )
            if Local_Debug_Enable:
                debug_log(
                    message=f"🐐🐐🐐💾 A new trap is set! Listening for an explicit save command on topic '{save_action_topic}'.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
            
            console_log("✅ The YaketyYak Manager has initialized and is listening for commands.")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"🐐🐐🐐🔴 Initialization failed! The error be: {e}",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

    def _load_repo_from_file(self):
        """
        Loads the repository from the JSON file into memory on initialization.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        # The check for directory existence is now in __init__
        
        if YAKETY_YAK_REPO_PATH.is_file() and YAKETY_YAK_REPO_PATH.stat().st_size > 0:
            try:
                # Use the imported path constant
                with open(YAKETY_YAK_REPO_PATH, 'r') as f:
                    return json.load(f)
            except json.JSONDecodeError as e:
                if Local_Debug_Enable:
                    debug_log(
                        message=f"🐐🐐🐐🟡 Failed to decode JSON from file. Creating an empty repository. The error be: {e}",
                        file=current_file, version=current_version, function=current_function_name, console_print_func=console_log
                    )
                return {}
        else:
            return {}

    def _save_repo_to_file(self):
        """
        Writes the current in-memory repository to the JSON file.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        if Local_Debug_Enable:
            debug_log(
                # UPDATED: Use the imported path constant
                message=f"🐐🐐🐐💾 Writing the current repository to '{YAKETY_YAK_REPO_PATH}'.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
        try:
            # Ensure the parent directory exists (already checked in __init__, but good to be safe)
            if not YAKETY_YAK_REPO_PATH.parent.exists():
                YAKETY_YAK_REPO_PATH.parent.mkdir(parents=True, exist_ok=True)

            # UPDATED: Use the imported path constant
            with open(YAKETY_YAK_REPO_PATH, 'w') as f:
                json.dump(self.repo_memory, f, indent=4)
            
            console_log("✅ Repository saved successfully!")
            return True
        except Exception as e:
            console_log(f"❌ Error saving repository to file: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"🐐🐐🐐🔴 The quill broke! Failed to save the repository! The error be: {e}",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
        return False

    def YAK_LISTEN_TO_MQTT(self, topic, payload):
        """
        Processes incoming MQTT messages and updates the in-memory repository.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        if Local_Debug_Enable:
            debug_log(
                message=f"🐐🐐🐐⚡️ An announcement has arrived! Topic: '{topic}', Payload: '{payload}'",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

        try:
            # Attempt to parse payload as JSON
            try:
                parsed_payload = json.loads(payload)
            except json.JSONDecodeError:
                # If it's not valid JSON, treat it as an empty dictionary for the check.
                # However, if the intent is to store the raw string, we'll use 'payload' directly later.
                parsed_payload = payload # Store raw payload if not JSON
                
            # Check for a "trigger" in the topic AND the value being explicitly True
            if "trigger" in topic.lower() and isinstance(parsed_payload, dict) and parsed_payload.get('value', False) is True:
                if Local_Debug_Enable:
                    debug_log(
                        message="🐐🐐🐐🟢 Trigger event detected with a 'true' value. Initiating command orchestration!",
                        file=current_file,
                        version=current_version,
                        function=f"{self.__class__.__name__}.{current_function_name}",
                        console_print_func=console_log
                    )
                handle_yak_trigger(self, topic, payload)

            # Deconstruct the topic to form the nested path in our repository
            path_parts = topic.replace("OPEN-AIR/repository/", "").split('/')
            
            current_node = self.repo_memory
            for part in path_parts[:-1]:
                # Sanitize part for use as a dictionary key
                part = re.sub(r'[^a-zA-Z0-9_]', '', part)
                # Ensure current_node[part] is always a dictionary, even if it was previously a non-dict value
                if part not in current_node or not isinstance(current_node[part], dict):
                    current_node[part] = {}
                current_node = current_node[part]
           
            last_key = path_parts[-1]
            
            # Determine the value to be stored in the repository
            if isinstance(parsed_payload, dict) and 'value' in parsed_payload:
                value_to_store = parsed_payload['value']
            elif isinstance(parsed_payload, dict): # If it's a parsed dict but no 'value' key, store the whole dict
                value_to_store = parsed_payload
            else: # If parsing failed or it was a simple string (not JSON), use the raw payload
                value_to_store = payload
            
            # REFINEMENT: Remove leading and trailing double quotes if they exist if it's a string
            if isinstance(value_to_store, str) and value_to_store.startswith('"') and value_to_store.endswith('"'):
                value_to_store = value_to_store.strip('"')

            # Update the in-memory dictionary
            current_node[last_key] = value_to_store
            
            # NOW THE AUTOMATIC SAVE OCCURS HERE
            self._save_repo_to_file()
            
            console_log(f"✅ Repository updated in memory and saved to file from message on topic: {topic}")
        
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"🐐🐐🐐🔴 A fatal error occurred while processing the MQTT message! The error be: {e}",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
            
    def YAK_SAVE_REPOSITORY(self, topic, payload):
        """
        Saves the current in-memory repository to a local JSON file.
        This is an explicit action triggered by an MQTT command.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        if Local_Debug_Enable:
            debug_log(
                # UPDATED: Use the imported path constant
                message=f"🐐🐐🐐💾 An explicit save command has been received! Writing the current repository to '{YAKETY_YAK_REPO_PATH}'.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
        try:
            data = json.loads(payload)
            if str(data.get("value")).lower() == 'true':
                self._save_repo_to_file()
        except Exception as e:
            console_log(f"❌ Error saving repository to file: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"🐐🐐🐐🔴 The quill broke! Failed to save the repository! The error be: {e}",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

#####################################
### File: OPEN-AIR/managers/yak_manager/yak_command_builder.py
#####################################
# managers/yak_manager/yak_command_builder.py
#
# This file (yak_command_builder.py) provides functionality to build SCPI commands by filling placeholders in a template with values from inputs.
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 44 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#


import os
import inspect
from display.logger import debug_log, console_log, log_visa_command

Local_Debug_Enable = True

current_file = f"{os.path.basename(__file__)}"


def fill_scpi_placeholders(scpi_command_template: str, scpi_inputs: dict):
    """
    Takes an SCPI command template and replaces placeholders with values from inputs.
    """
    current_function_name = inspect.currentframe().f_code.co_name
    if Local_Debug_Enable:
        debug_log(f"🔍🔵 Entering {current_function_name} to fill SCPI placeholders.",
                  file=current_file,
                  version=current_version,
                  function=current_function_name,
                  console_print_func=console_log)
              
    filled_command = scpi_command_template
    
    if scpi_inputs:
        for key, details in scpi_inputs.items():
            placeholder = f"<{key}>"
            value_to_substitute = str(details.get("value", ""))
            
            # --- NEW FIX: Replace the placeholder value with a single double quote for the path terminator ---
            filled_command = filled_command.replace('\"', '"')
            
            if placeholder == "<path_terminator>" and placeholder in filled_command:
                filled_command = filled_command.replace(placeholder, '"')
                value_to_substitute = '"'
            
            if placeholder == "<path_starter>" and placeholder in filled_command:
                filled_command = filled_command.replace(placeholder, '"')
                value_to_substitute = '"'
            
            if placeholder in filled_command:
                filled_command = filled_command.replace(placeholder, value_to_substitute)
                if Local_Debug_Enable:
                    debug_log(f"🔁 Replaced placeholder '{placeholder}' with value '{value_to_substitute}'.",
                              file=current_file,
                              version=current_version,
                              function=current_function_name,
                              console_print_func=console_log)

    console_log(f"✅ Filled SCPI Command: {filled_command}")
    return filled_command


#####################################
### File: OPEN-AIR/managers/yak_manager/yak_repository_parser.py
#####################################
# managers/yak_manager/yak_repository_parser.py
#
# This file (yak_repository_parser.py) provides utility functions for parsing the YAK repository, enabling lookup of SCPI commands, inputs, and outputs based on a given command node.
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 44 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#


import os
import inspect
import json

from display.logger import debug_log, console_log, log_visa_command

Local_Debug_Enable = True

current_file = f"{os.path.basename(__file__)}"


def get_command_node(repo, command_path_parts, function_name):
    """
    Traverses the repository to find the base node for a command and logs each step.
    Returns the command's base dictionary or None if not found.
    """
    if Local_Debug_Enable:
        debug_log(f"🔍🔵 Entering {function_name} to get command node for path: {command_path_parts}.",
                  file=current_file,
                  version=current_version,
                  function=function_name,
                  console_print_func=console_log)
    
    current_node = repo
    
    for part in command_path_parts:
        if Local_Debug_Enable:
            debug_log(f"🔍 Trying to get part: '{part}' from current_node.",
                      file=current_file,
                      version=current_version,
                      function=function_name,
                      console_print_func=console_log)
        
        current_node = current_node.get(part)
        
        if not current_node:
            console_log(f"❌ Error: Command path not found at intermediate step.")
            return None
        
        if Local_Debug_Enable:
            debug_log(f"🔍 Succeeded. Current node keys are now: {list(current_node.keys())}",
                      file=current_file,
                      version=current_version,
                      function=function_name,
                      console_print_func=console_log)
    
    return current_node


def lookup_scpi_command(command_node, model_key, command_path):
    """
    Looks up and returns the SCPI command string from a given command node.
    """
    current_function_name = inspect.currentframe().f_code.co_name
    
    scpi_details = command_node.get("scpi_details", {})
    scpi_value = scpi_details.get(model_key, {}).get("SCPI_value")
    
    scpi_path = command_path + [f"scpi_details/{model_key}/SCPI_value"]
    
    if scpi_value:
        if Local_Debug_Enable:
            debug_log(f"✅ SCPI Command found at path: {'/'.join(scpi_path)}",
                      file=current_file, version=current_version, function=current_function_name, console_print_func=console_log)
        if Local_Debug_Enable:
            debug_log(f"✅ SCPI Command: {scpi_value}",
                      file=current_file, version=current_version, function=current_function_name, console_print_func=console_log)
        return scpi_value
    else:
        console_log(f"🟡 SCPI Command not found for model '{model_key}' at path: {'/'.join(scpi_path)}")
        return None

def lookup_inputs(command_node, command_path):
    """
    Looks up and returns the inputs for a given command node.
    """
    current_function_name = inspect.currentframe().f_code.co_name
    
    scpi_inputs_path = command_path + ["scpi_inputs"]
    scpi_inputs = command_node.get("scpi_inputs")
    
    if scpi_inputs:
        inputs_count = len(scpi_inputs)
        input_details = " ".join([f"({key} = {details.get('value', 'N/A')})" for key, details in scpi_inputs.items()])
        if Local_Debug_Enable:
            debug_log(f"✅ Inputs found at path: {'/'.join(scpi_inputs_path)}",
                      file=current_file, version=current_version, function=current_function_name, console_print_func=console_log)
        if Local_Debug_Enable:
            debug_log(f"➡️ scpi_inputs = {inputs_count} {input_details}",
                      file=current_file, version=current_version, function=current_function_name, console_print_func=console_log)
        return scpi_inputs
    else:
        console_log("🟡 No inputs found.")
        return None


def lookup_outputs(command_node, command_path):
    """
    Looks up and returns the outputs for a given command node.
    """
    current_function_name = inspect.currentframe().f_code.co_name
    
    scpi_outputs_path = command_path + ["scpi_outputs"]
    scpi_outputs = command_node.get("scpi_outputs")
    
    if scpi_outputs:
        outputs_count = len(scpi_outputs)
        output_details = " ".join([f"({key} = {details.get('value', 'N/A')})" for key, details in scpi_outputs.items()])
        if Local_Debug_Enable:
            debug_log(f"✅ Outputs found at path: {'/'.join(scpi_outputs_path)}",
                      file=current_file, version=current_version, function=current_function_name, console_print_func=console_log)
        if Local_Debug_Enable:
            debug_log(f"⬅️ scpi_outputs = {outputs_count} {output_details}",
                      file=current_file, version=current_version, function=current_function_name, console_print_func=console_log)
        return scpi_outputs
    else:
        console_log("🟡 No outputs found.")
        return None


#####################################
### File: OPEN-AIR/managers/yak_manager/yak_trigger_handler.py
#####################################
# managers/yak_manager/yak_trigger_handler.py
#
# This file (yak_trigger_handler.py) orchestrates command execution by processing YAK triggers from MQTT, looking up SCPI command details, building the final command, and dispatching it to the instrument.
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 44 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#


import os
import inspect
import json

from display.logger import debug_log, console_log, log_visa_command
from managers.yak_manager.yak_repository_parser import get_command_node, lookup_scpi_command, lookup_inputs, lookup_outputs
from managers.yak_manager.yak_command_builder import fill_scpi_placeholders
from managers.yak_manager.manager_yak_tx import YakTxManager
from managers.yak_manager.manager_yak_rx import YakRxManager
from workers.utils.worker_project_paths import YAKETY_YAK_REPO_PATH 

Local_Debug_Enable = True

current_file = f"{os.path.basename(__file__)}"


def handle_yak_trigger(yak_manager, topic, payload):
    """
    Orchestrates the command details lookup by first getting the base node
    and then calling the specialized lookup functions.
    """
    current_function_name = inspect.currentframe().f_code.co_name
    if Local_Debug_Enable:
        debug_log(
            message="TRIGGER TRIGGER TRIGGER",
            file=current_file,
            version=current_version,
            function=current_function_name,
            console_print_func=console_log
        )

    try:
        if not YAKETY_YAK_REPO_PATH.is_file():
            console_log(f"❌ Error: Repository file not found at {YAKETY_YAK_REPO_PATH}")
            return

        with open(YAKETY_YAK_REPO_PATH, 'r') as f:
            repo = json.load(f)

        repo_path_parts = topic.replace("OPEN-AIR/repository/", "").split('/')
        
        command_path_to_node = [part.replace(' ', '_') for part in repo_path_parts[:-3]]
        model_key = repo_path_parts[-2]
        
        command_node = get_command_node(repo=repo, command_path_parts=command_path_to_node, function_name=current_function_name)
        if command_node is None:
            return

        scpi_template = lookup_scpi_command(command_node=command_node, model_key=model_key, command_path=command_path_to_node)
        scpi_inputs = lookup_inputs(command_node=command_node, command_path=command_path_to_node)
        command_outputs = lookup_outputs(command_node=command_node, command_path=command_path_to_node)
        
        if scpi_template:
            final_scpi_command = fill_scpi_placeholders(scpi_command_template=scpi_template, scpi_inputs=scpi_inputs)
            
            yak_tx_manager = YakTxManager(dispatcher_instance=yak_manager.dispatcher)
            command_type = repo_path_parts[1]
            response_value = yak_tx_manager.execute_command(command_type=command_type, command_string=final_scpi_command)
            
            if response_value and response_value != "FAILED":
                yak_rx_manager = YakRxManager(mqtt_controller=yak_manager.mqtt_util)
                yak_rx_manager.process_response(path_parts=repo_path_parts, command_details={"scpi_outputs": command_outputs}, response=response_value)
        
        if Local_Debug_Enable:
            debug_log(
                message=f"🔍 Processed trigger for topic: {topic}",
                file=current_file,
                version=current_version,
                function=current_function_name,
                console_print_func=console_log
            )
    except Exception as e:
        console_log(f"❌ Error processing trigger for topic {topic}: {e}")
        if Local_Debug_Enable:
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=current_function_name,
                console_print_func=console_log
            )
    


#####################################
### File: OPEN-AIR/managers/bandwidth_manager/bandwidth_callbacks.py
#####################################
# managers/bandwidth_manager/bandwidth_callbacks.py
#
# This file is part of the OPEN-AIR project.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251213.120000.44

# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213
Current_Time = 120000
Current_iteration = 44

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)

import json
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from .bandwidth_state import BandwidthState
from .bandwidth_yak_communicator import BandwidthYakCommunicator
from .bandwidth_presets import BandwidthPresets

Local_Debug_Enable = True

class BandwidthCallbacks:
    """Handles MQTT message callbacks and logic for bandwidth settings."""

    def __init__(self, mqtt_controller: MqttControllerUtility, state: BandwidthState, yak_communicator: BandwidthYakCommunicator, presets: BandwidthPresets):
        self.mqtt_controller = mqtt_controller
        self.state = state
        self.yak_communicator = yak_communicator
        self.presets = presets
        self.base_topic = self.state.base_topic

    def subscribe_to_topics(self):
        topic_list = [
            f"{self.base_topic}/Settings/fields/Resolution Bandwidth/fields/RBW/value",
            f"{self.base_topic}/Settings/fields/Sweep_time_s/value",
            f"{self.base_topic}/Settings/fields/Video Bandwidth/fields/vbw_MHz/value",
            
            f"{self.base_topic}/Settings/fields/Resolution Bandwidth/fields/Resolution Band Width/options/+/selected",
            self.presets.TOPIC_RBW_PRESET_WILDCARD, 
            self.presets.TOPIC_RBW_UNITS_WILDCARD,  
            
            f"{self.base_topic}/Settings/fields/Video Bandwidth/fields/Video Band Width /options/+/selected",
            self.presets.TOPIC_VBW_PRESET_WILDCARD, 
            self.presets.TOPIC_VBW_UNITS_WILDCARD,  
            
            f"{self.base_topic}/Settings/fields/Video Bandwidth/fields/VBW_Automatic/options/ON/selected",
            f"{self.base_topic}/Settings/fields/Video Bandwidth/fields/VBW_Automatic/options/OFF/selected",
            
            f"{self.base_topic}/Settings/fields/Sweep_Mode/options/Continuous/selected", 
            f"{self.base_topic}/Settings/fields/Sweep_Mode/options/Single/selected", 
        ]
        
        for topic in topic_list:
            self.mqtt_controller.add_subscriber(topic_filter=topic, callback_func=self.on_message)
            
        for yak_suffix in self.yak_communicator.YAK_NAB_OUTPUTS.keys():
            yak_topic = f"{self.yak_communicator.YAK_BASE}/nab/NAB_bandwidth_settings/scpi_outputs/{yak_suffix}"
            self.mqtt_controller.add_subscriber(topic_filter=yak_topic, callback_func=self.on_message)

        self.yak_communicator.update_all_from_device()

    def on_message(self, topic, payload):
        if topic.startswith(f"{self.yak_communicator.YAK_BASE}/nab/NAB_bandwidth_settings/scpi_outputs"):
            self.yak_communicator.process_yak_output(topic, payload)
            return
        
        try:
            value = json.loads(payload).get('value', payload)
        except (json.JSONDecodeError, TypeError):
            value = payload

        if self.state._locked_state.get(topic, False):
            self.state._locked_state[topic] = False
            return

        if self.presets.handle_preset_message(topic, value):
            return

        topic_map = {
            "Resolution Bandwidth/fields/RBW/value": ("rbw_value", 0.1, self.yak_communicator.publish_rbw_and_trigger),
            "Sweep_time_s/value": ("sweep_time_value", 0.001, self.yak_communicator.publish_sweep_time_and_trigger),
            "Video Bandwidth/fields/vbw_MHz/value": ("vbw_value", 0.001, self.yak_communicator.publish_vbw_and_trigger)
        }

        for suffix, (attr, threshold, func) in topic_map.items():
            if topic.endswith(f"/{suffix}"):
                new_val = float(value)
                if getattr(self.state, attr) is None or abs(getattr(self.state, attr) - new_val) > threshold:
                    setattr(self.state, attr, new_val)
                    func(new_val)
                return

        if "Video Bandwidth/fields/VBW_Automatic/options" in topic and topic.endswith("/selected") and str(value).lower() == 'true':
            is_on = "ON" in topic
            self.yak_communicator.publish_vbw_auto_and_trigger(is_auto_on=is_on)
            return


#####################################
### File: OPEN-AIR/managers/bandwidth_manager/bandwidth_presets.py
#####################################
# managers/bandwidth_manager/bandwidth_presets.py
#
# This file (bandwidth_presets.py) handles preset logic for bandwidth settings, including RBW and VBW, and applies them via MQTT.
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 44 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#


import os
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from .bandwidth_state import BandwidthState
from .bandwidth_yak_communicator import BandwidthYakCommunicator
from display.logger import debug_log, console_log, log_visa_command

Local_Debug_Enable = True

current_file = f"{os.path.basename(__file__)}"


class BandwidthPresets:
    """Handles preset logic for bandwidth settings."""

    TOPIC_RBW_PRESET_WILDCARD = "OPEN-AIR/configuration/instrument/bandwidth/Settings/fields/Resolution Bandwidth/fields/Resolution Band Width/options/+/value"
    TOPIC_VBW_PRESET_WILDCARD = "OPEN-AIR/configuration/instrument/bandwidth/Settings/fields/Video Bandwidth/fields/Video Band Width /options/+/value"
    
    TOPIC_RBW_UNITS_WILDCARD = "OPEN-AIR/configuration/instrument/bandwidth/Settings/fields/Resolution Bandwidth/fields/Resolution Band Width/options/+/units"
    TOPIC_VBW_UNITS_WILDCARD = "OPEN-AIR/configuration/instrument/bandwidth/Settings/fields/Video Bandwidth/fields/Video Band Width /options/+/units"

    def __init__(self, mqtt_controller: MqttControllerUtility, state: BandwidthState, yak_communicator: BandwidthYakCommunicator):
        self.mqtt_controller = mqtt_controller
        self.state = state
        self.yak_communicator = yak_communicator
        self.base_topic = self.state.base_topic

    def handle_preset_message(self, topic, value):
        def _get_option_number(t):
            try: return int(t.split('/')[-2])
            except (ValueError, IndexError): return None

        if "Resolution Bandwidth/fields/Resolution Band Width/options" in topic:
            if topic.endswith("/value"):
                opt_num = _get_option_number(topic)
                if opt_num is not None: self.state.rbw_preset_values[opt_num] = float(value)
            elif topic.endswith("/units"):
                opt_num = _get_option_number(topic)
                if opt_num is not None: self.state.rbw_preset_units[opt_num] = str(value)
            elif topic.endswith("/selected") and str(value).lower() == 'true':
                self.apply_preset(topic, self.state.rbw_preset_values, self.state.rbw_preset_units, "Settings/fields/Resolution Bandwidth/fields/RBW/value", is_rbw=True)
            return True

        if "Video Bandwidth/fields/Video Band Width /options" in topic:
            if topic.endswith("/value"):
                opt_num = _get_option_number(topic)
                if opt_num is not None: self.state.vbw_preset_values[opt_num] = float(value)
            elif topic.endswith("/units"):
                opt_num = _get_option_number(topic)
                if opt_num is not None: self.state.vbw_preset_units[opt_num] = str(value)
            elif topic.endswith("/selected") and str(value).lower() == 'true':
                self.apply_preset(topic, self.state.vbw_preset_values, self.state.vbw_preset_units, "Settings/fields/Video Bandwidth/fields/vbw_MHz/value", is_rbw=False)
            return True
        
        return False

    def apply_preset(self, topic, preset_value_map, preset_unit_map, target_suffix, is_rbw: bool):
        try:
            option_number = int(topic.split('/')[-2])
            raw_value = preset_value_map.get(option_number)
            unit_string = preset_unit_map.get(option_number)
            
            if raw_value is not None and unit_string is not None:
                multiplier = self.state.get_multiplier(unit_string=unit_string)
                final_value_hz = raw_value * multiplier
                new_value_mhz = final_value_hz / self.yak_communicator.HZ_TO_MHZ
                
                full_target_topic = f"{self.base_topic}/{target_suffix}"
                if full_target_topic in self.state._locked_state:
                    self.state._locked_state[full_target_topic] = True
                
                self.yak_communicator._publish_update(topic_suffix=target_suffix, value=new_value_mhz)
                self.mqtt_controller.publish_message(topic=topic, subtopic="", value=True, retain=False)
                
                yak_input = self.yak_communicator.YAK_RBW_INPUT if is_rbw else self.yak_communicator.YAK_VBW_INPUT
                yak_trigger = self.yak_communicator.YAK_RBW_TRIGGER if is_rbw else self.yak_communicator.YAK_VBW_TRIGGER
                self.yak_communicator.publish_to_yak_and_trigger(value=final_value_hz, input_topic=yak_input, trigger_topic=yak_trigger)
            else:
                console_log(f"❌ Error: Preset data missing for option {option_number}.")
                self.mqtt_controller.publish_message(topic=topic, subtopic="", value=False, retain=False)
                self.yak_communicator.update_all_from_device()
        except Exception as e:
            console_log(f"❌ Error applying preset: {e}")


#####################################
### File: OPEN-AIR/managers/bandwidth_manager/bandwidth_state.py
#####################################
# managers/bandwidth_manager/bandwidth_state.py
#
# This file is part of the OPEN-AIR project.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251213.120000.44

# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213
Current_Time = 120000
Current_iteration = 44

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)

Local_Debug_Enable = True

class BandwidthState:
    """Holds the state for bandwidth-related settings."""
    def __init__(self):
        self.base_topic = "OPEN-AIR/configuration/instrument/bandwidth"
        
        self.rbw_value = None 
        self.vbw_value = None 
        self.sweep_time_value = None
        
        self.rbw_preset_values = {} 
        self.vbw_preset_values = {} 
        
        self.rbw_preset_units = {}
        self.vbw_preset_units = {}
        
        self._locked_state = {
            f"{self.base_topic}/Settings/fields/Resolution Bandwidth/fields/RBW/value": False,
            f"{self.base_topic}/Settings/fields/Sweep_time_s/value": False,
            f"{self.base_topic}/Settings/fields/Video Bandwidth/fields/vbw_MHz/value": False,
            f"{self.base_topic}/Settings/fields/Video Bandwidth/fields/VBW_Automatic/options/ON/selected": False,
            f"{self.base_topic}/Settings/fields/Video Bandwidth/fields/VBW_Automatic/options/OFF/selected": False,
            f"{self.base_topic}/Settings/fields/Sweep_Mode/options/Continuous/selected": False, 
            f"{self.base_topic}/Settings/fields/Sweep_Mode/options/Single/selected": False, 
        }

    UNIT_MULTIPLIERS = {
        "HZ": 1, "KHZ": 1000, "MHZ": 1000000, "GHZ": 1000000000,
        "S": 1, "MS": 0.001, "US": 0.000001
    }

    def get_multiplier(self, unit_string: str) -> float:
        clean_unit = unit_string.strip().upper()
        return self.UNIT_MULTIPLIERS.get(clean_unit, 1.0)


#####################################
### File: OPEN-AIR/managers/bandwidth_manager/bandwidth_yak_communicator.py
#####################################
# managers/bandwidth_manager/bandwidth_yak_communicator.py
#
# This file (bandwidth_yak_communicator.py) handles communication with the YAK repository for bandwidth settings, including publishing RBW, VBW, and sweep time values.
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 44 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#


import time
import json
import os

from display.logger import debug_log, console_log, log_visa_command
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from .bandwidth_state import BandwidthState

Local_Debug_Enable = True

current_file = f"{os.path.basename(__file__)}"



class BandwidthYakCommunicator:
    """Handles communication with the YAK repository for bandwidth settings."""
    
    HZ_TO_MHZ = 1_000_000.0 
    YAK_BASE = "OPEN-AIR/yak/Bandwidth"
    
    YAK_UPDATE_TOPIC = f"{YAK_BASE}/nab/NAB_bandwidth_settings/scpi_details/generic_model/trigger"
    YAK_RBW_TRIGGER = f"{YAK_BASE}/set/Set_RBW/scpi_details/generic_model/trigger"
    YAK_SWEEP_TIME_TRIGGER = f"{YAK_BASE}/set/Set_Sweep_time/scpi_details/generic_model/trigger"
    YAK_VBW_TRIGGER = f"{YAK_BASE}/set/Set_VBW/scpi_details/generic_model/trigger"
    YAK_VBW_AUTO_ON_TRIGGER = f"{YAK_BASE}/set/do_Video_Bandwidth_Auto_ON/scpi_details/generic_model/trigger"
    YAK_VBW_AUTO_OFF_TRIGGER = f"{YAK_BASE}/set/do_Video_Bandwidth_Auto_OFF/scpi_details/generic_model/trigger"

    YAK_RBW_INPUT = f"{YAK_BASE}/set/Set_RBW/scpi_inputs/hz_value/value"
    YAK_SWEEP_TIME_INPUT = f"{YAK_BASE}/set/Set_Sweep_time/scpi_inputs/s_value/value"
    YAK_VBW_INPUT = f"{YAK_BASE}/set/Set_VBW/scpi_inputs/hz_value/value"

    YAK_NAB_OUTPUTS = {
        "RBW_Hz/value": "Settings/fields/Resolution Bandwidth/fields/RBW/value",
        "VBW_Hz/value": "Settings/fields/Video Bandwidth/fields/vbw_MHz/value",
        "VBW_Auto_On/value": "Settings/fields/Video Bandwidth/fields/VBW_Automatic/options/ON/selected",
        "Continuous_Mode_On/value": "Settings/fields/Sweep_Mode/options/Continuous/selected", 
        "Sweep_Time_s/value": "Settings/fields/Sweep_time_s/value",
    }

    def __init__(self, mqtt_controller: MqttControllerUtility, state: BandwidthState):
        self.mqtt_controller = mqtt_controller
        self.state = state
        self.base_topic = self.state.base_topic

    def publish_rbw_and_trigger(self, value_mhz):
        value_hz = int(round(value_mhz * self.HZ_TO_MHZ))
        self.publish_to_yak_and_trigger(
            value=value_hz, 
            input_topic=self.YAK_RBW_INPUT,
            trigger_topic=self.YAK_RBW_TRIGGER
        )
        
    def publish_sweep_time_and_trigger(self, value_s):
        self.publish_to_yak_and_trigger(
            value=float(value_s),
            input_topic=self.YAK_SWEEP_TIME_INPUT,
            trigger_topic=self.YAK_SWEEP_TIME_TRIGGER
        )

    def publish_vbw_and_trigger(self, value_mhz):
        value_hz = int(round(value_mhz * self.HZ_TO_MHZ))
        self.publish_to_yak_and_trigger(
            value=value_hz, 
            input_topic=self.YAK_VBW_INPUT,
            trigger_topic=self.YAK_VBW_TRIGGER
        )

    def publish_vbw_auto_and_trigger(self, is_auto_on):
        trigger_topic = self.YAK_VBW_AUTO_ON_TRIGGER if is_auto_on else self.YAK_VBW_AUTO_OFF_TRIGGER
        self.mqtt_controller.publish_message(topic=trigger_topic, subtopic="", value=True, retain=False)
        time.sleep(0.01)
        self.mqtt_controller.publish_message(topic=trigger_topic, subtopic="", value=False, retain=False)
        self.update_all_from_device()

    def publish_to_yak_and_trigger(self, value, input_topic, trigger_topic):
        self.mqtt_controller.publish_message(topic=input_topic, subtopic="", value=value, retain=True)
        self.mqtt_controller.publish_message(topic=trigger_topic, subtopic="", value=True, retain=False)
        time.sleep(0.01)
        self.mqtt_controller.publish_message(topic=trigger_topic, subtopic="", value=False, retain=False)
        self.update_all_from_device()
            
    def update_all_from_device(self):
        self.mqtt_controller.publish_message(topic=self.YAK_UPDATE_TOPIC, subtopic="", value=True, retain=False)
        time.sleep(0.01)
        self.mqtt_controller.publish_message(topic=self.YAK_UPDATE_TOPIC, subtopic="", value=False, retain=False)
        console_log("✅ UPDATE ALL command sent to refresh bandwidth settings from device.")

    def process_yak_output(self, topic, payload):
        try:
            yak_suffix = topic.split('/scpi_outputs/')[1]
            gui_suffix = self.YAK_NAB_OUTPUTS.get(yak_suffix)
            if not gui_suffix: return

            try:
                raw_value = json.loads(payload).get('value', payload)
            except (json.JSONDecodeError, TypeError):
                raw_value = payload
            
            full_gui_topic = f"{self.base_topic}/{gui_suffix}"
            if full_gui_topic in self.state._locked_state:
                self.state._locked_state[full_gui_topic] = True
            
            if "RBW_Hz" in yak_suffix:
                final_value_mhz = float(raw_value) / self.HZ_TO_MHZ
                self.state.rbw_value = final_value_mhz 
                self._publish_update(topic_suffix=gui_suffix, value=final_value_mhz)
            elif "VBW_Hz" in yak_suffix:
                final_value_mhz = float(raw_value) / self.HZ_TO_MHZ
                self.state.vbw_value = final_value_mhz
                self._publish_update(topic_suffix=gui_suffix, value=final_value_mhz)
            elif "VBW_Auto_On" in yak_suffix:
                is_on = (str(raw_value).strip() == '1')
                self._publish_update(topic_suffix="Settings/fields/Video Bandwidth/fields/VBW_Automatic/options/ON/selected", value=is_on)
                self._publish_update(topic_suffix="Settings/fields/Video Bandwidth/fields/VBW_Automatic/options/OFF/selected", value=not is_on)
            elif "Continuous_Mode_On" in yak_suffix:
                is_on = (str(raw_value).strip() == '1')
                self._publish_update(topic_suffix="Settings/fields/Sweep_Mode/options/Continuous/selected", value=is_on)
                self._publish_update(topic_suffix="Settings/fields/Sweep_Mode/options/Single/selected", value=not is_on)
            elif "Sweep_Time_s" in yak_suffix:
                final_value = float(raw_value)
                self.state.sweep_time_value = final_value
                self._publish_update(topic_suffix=gui_suffix, value=final_value)
        except Exception as e:
            console_log(f"❌ Error processing YAK output for {topic}: {e}")

    def _publish_update(self, topic_suffix, value):
        full_topic = f"{self.base_topic}/{topic_suffix}"
        rounded_value = round(float(value), 6) 
        self.mqtt_controller.publish_message(topic=full_topic, subtopic="", value=rounded_value, retain=False)


#####################################
### File: OPEN-AIR/managers/connection/manager_visa_device_search.py
#####################################
# managers/manager_visa_device_search.py
#
# This manager handles all low-level VISA instrument search and connection logic,
# now publishing all device status and information to the MQTT broker.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250907.002515.6 (Fixed GUI slot mapping to start at option 1)

import inspect
import os
import traceback
import pyvisa
import tkinter as tk
import json
import datetime
import time
import threading
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from .manager_visa_dispatch_scpi import ScpiDispatcher
from managers.visa_utils import list_visa_resources, connect_to_instrument, disconnect_instrument
from managers.frequency_manager.frequency_yak_communicator import FrequencyYakCommunicator
from managers.bandwidth_manager.bandwidth_yak_communicator import BandwidthYakCommunicator

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command


# --- Global Scope Variables --
current_version = "20250907.002515.6"
current_version_hash = (20250907 * 2515 * 6)
current_file = f"{os.path.basename(__file__)}"

# Constants for MQTT Topics
MQTT_TOPIC_SEARCH_TRIGGER = "OPEN-AIR/configuration/instrument/active/Instrument_Connection/Search_and_Connect/Search_For_devices/trigger"
MQTT_TOPIC_DEVICE_SELECT = "OPEN-AIR/configuration/instrument/active/Instrument_Connection/Search_and_Connect/Found_devices/options/+/selected"
MQTT_TOPIC_CONNECT_TRIGGER = "OPEN-AIR/configuration/instrument/active/Instrument_Connection/Search_and_Connect/Connect_to_Device/trigger"
MQTT_TOPIC_DISCONNECT_TRIGGER = "OPEN-AIR/configuration/instrument/active/Instrument_Connection/Search_and_Connect/Disconnect_device/trigger"

# --- New Constant for Max Devices ---
MAX_GUI_DEVICE_SLOTS = 40


class VisaDeviceManager:
    """
    Manages VISA device discovery and connection logic.
    """

    def __init__(self, mqtt_controller: MqttControllerUtility, scpi_dispatcher: ScpiDispatcher):
        # Initializes the manager, sets up state variables and MQTT subscriptions.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🛠️🟢 Initiating the grand VISA device management experiment!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            self.mqtt_util = mqtt_controller
            self.scpi_dispatcher = scpi_dispatcher
            self.inst = None
            self.found_resources = []
            self.selected_device_resource = None
            self._setup_mqtt_subscriptions()
            console_log("✅ The magnificent VISA Device Manager is online and ready for action!")
        except Exception as e:
            console_log(f"❌ Error in {self.__class__.__name__}.{current_function_name}: {e}")
            debug_log(
                message=f"🛠️🔴 By Jove, the initialization has gone haywire! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def search_resources(self, console_print_func):
        # Performs the search and directly returns a list of resources.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"GUI command received: initiating VISA resource search.",
            file=current_file,
            version=current_version,
            function=current_function,
            console_print_func=console_print_func
        )
        resources = list_visa_resources(console_print_func)
        return resources

    def connect_instrument(self, resource_name, console_print_func):
        # Triggers a connection to a specific resource by publishing a command.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"Command received: initiating connection to {resource_name}.",
            file=current_file,
            version=current_version,
            function=current_function,
            console_print_func=console_print_func
        )
        payload = json.dumps({"resource": resource_name})
        self.mqtt_util.publish_message(topic="OPEN-AIR/commands/instrument/connect", subtopic="", value=payload)

    def disconnect_instrument(self, console_print_func):
        # Triggers a disconnection by publishing a command.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"Command received: initiating disconnection.",
            file=current_file,
            version=current_version,
            function=current_function,
            console_print_func=console_print_func
        )
        self.mqtt_util.publish_message(topic="OPEN-AIR/commands/instrument/disconnect", subtopic="", value="disconnect")

    def _setup_mqtt_subscriptions(self):
        # Subscribes to MQTT topics for receiving commands from the GUI.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🛠️🔵 My minions are tuning the receivers! Subscribing to command topics.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # FIXED: Subscribing to the new '/trigger' subtopic
            self.mqtt_util.add_subscriber(topic_filter=MQTT_TOPIC_SEARCH_TRIGGER, callback_func=self._on_search_request)
            self.mqtt_util.add_subscriber(topic_filter=MQTT_TOPIC_DEVICE_SELECT, callback_func=self._on_device_select)
            self.mqtt_util.add_subscriber(topic_filter=MQTT_TOPIC_CONNECT_TRIGGER, callback_func=self._on_gui_connect_request)
            self.mqtt_util.add_subscriber(topic_filter=MQTT_TOPIC_DISCONNECT_TRIGGER, callback_func=self._on_gui_disconnect_request)
            
            console_log("✅ VisaDeviceManager subscribed to all necessary GUI and command topics.")
        except Exception as e:
            console_log(f"❌ Error in {self.__class__.__name__}.{current_function_name}: {e}")

    def _on_search_request(self, topic, payload):
        # Handles the 'Search_For_devices' button press from the GUI.
        try:
            payload_data = json.loads(payload)
            # FIXED: Look for an explicit 'true' value
            if str(payload_data.get('value')).lower() == 'true':
                console_log("🔍 Search for devices initiated from GUI.")
                self.found_resources = self.search_resources(console_log)
                self._update_found_devices_gui(self.found_resources)
        except (json.JSONDecodeError, AttributeError):
            pass

    def _on_device_select(self, topic, payload):
        # Handles a device selection from the listbox.
        try:
            payload_data = json.loads(payload)
            # FIXED: Look for an explicit 'true' value
            if str(payload_data.get('value')).lower() == 'true':
                parts = topic.split('/')
                option_index = int(parts[-2]) - 1
                if 0 <= option_index < len(self.found_resources):
                    self.selected_device_resource = self.found_resources[option_index]
                    console_log(f"✅ Device selected: {self.selected_device_resource}")
                else:
                    self.selected_device_resource = None
        except (json.JSONDecodeError, IndexError, ValueError, AttributeError):
            pass

    def _on_gui_connect_request(self, topic, payload):
        # Handles the 'Connect_to_Device' button press.
        try:
            payload_data = json.loads(payload)
            # FIXED: Look for an explicit 'true' value
            if str(payload_data.get('value')).lower() == 'true':
                if self.selected_device_resource:
                    console_log(f"🔵 Initiating connection to {self.selected_device_resource}...")
                    thread = threading.Thread(target=self.connect_instrument_logic, args=(self.selected_device_resource, console_log,), daemon=True)
                    thread.start()
                else:
                    console_log("🟡 No device selected to connect.")
        except (json.JSONDecodeError, AttributeError):
            pass

    def _on_gui_disconnect_request(self, topic, payload):
        # Handles the 'Disconnect_device' button press.
        try:
            payload_data = json.loads(payload)
            # FIXED: Look for an explicit 'true' value
            if str(payload_data.get('value')).lower() == 'true':
                if self.inst:
                    console_log("🔵 Initiating disconnection...")
                    thread = threading.Thread(target=self.disconnect_instrument_logic, args=(console_log,), daemon=True)
                    thread.start()
                else:
                    console_log("🟡 No device is currently connected.")
        except Exception as e:
            console_log(f"❌ Error in _on_gui_disconnect_request: {e}")
            
    def _update_found_devices_gui(self, resources):
        # Updates the GUI's `Found_devices` listbox based on the search results,
        # supporting up to MAX_GUI_DEVICE_SLOTS (40) devices.
        try:
            base_topic = "OPEN-AIR/configuration/instrument/active/Instrument_Connection/Search_and_Connect/Found_devices"
            
            # Use min() to ensure we don't try to fill more slots than exist or are needed
            num_resources_to_show = min(len(resources), MAX_GUI_DEVICE_SLOTS)
            
            # 1. Populate the slots with found resources
            # NOTE: range starts at 1 and goes up to num_resources_to_show + 1
            for i in range(1, num_resources_to_show + 1):
                option_topic_prefix = f"{base_topic}/options/{i}"
                device_name = resources[i-1]
                
                # Activate slot and set labels
                self.mqtt_util.publish_message(topic=f"{option_topic_prefix}/active", subtopic="", value="true", retain=False)
                self.mqtt_util.publish_message(topic=f"{option_topic_prefix}/label_active", subtopic="", value=device_name, retain=False)
                self.mqtt_util.publish_message(topic=f"{option_topic_prefix}/label_inactive", subtopic="", value=device_name, retain=False)
                
            # 2. Deactivate remaining slots (from num_resources_to_show + 1 up to MAX_GUI_DEVICE_SLOTS)
            for i in range(num_resources_to_show + 1, MAX_GUI_DEVICE_SLOTS + 1):
                option_topic_prefix = f"{base_topic}/options/{i}"
                
                # Deactivate slot and clear labels
                self.mqtt_util.publish_message(topic=f"{option_topic_prefix}/active", subtopic="", value="false", retain=False)
                self.mqtt_util.publish_message(topic=f"{option_topic_prefix}/label_active", subtopic="", value="", retain=False)
                self.mqtt_util.publish_message(topic=f"{option_topic_prefix}/label_inactive", subtopic="", value="", retain=False)
            
            # Set the first item as selected if any were found
            if resources:
                first_device_topic = f"{base_topic}/options/1/selected"
                self.mqtt_util.publish_message(topic=first_device_topic, subtopic="", value='true', retain=False)
                console_log("✅ First device automatically selected after search.")
            
            console_log("✅ GUI device list updated with search results (up to 40 slots used).")
        except Exception as e:
            console_log(f"❌ Error in _update_found_devices_gui: {e}")

    def _publish_status(self, topic_suffix, value):
        # Helper function to publish a value to a specific status topic.
        if self.mqtt_util:
            base_topic = "OPEN-AIR/configuration/instrument/active/Instrument_Connection/Search_and_Connect/Device_status"
            self.mqtt_util.publish_message(topic=f"{base_topic}/{topic_suffix}", subtopic="value", value=value, retain=False)

    def _on_connect_request(self, topic, payload):
        # Handles an MQTT connect request to a specific VISA resource.
        try:
            payload_data = json.loads(payload)
            resource_name = payload_data.get('resource')
            if resource_name:
                thread = threading.Thread(target=self.connect_instrument_logic, args=(resource_name, console_log,), daemon=True)
                thread.start()
        except json.JSONDecodeError:
            console_log("❌ Failed to decode JSON payload for connect request.")

    def connect_instrument_logic(self, resource_name, console_print_func):
        # Handles the full connection sequence to a VISA instrument.
        try:
            self.inst = connect_to_instrument(resource_name, console_print_func)
            if not self.inst:
                # Tell the dispatcher we are not connected
                self.scpi_dispatcher.set_instrument_instance(inst=None)
                self._publish_status("connected", False)
                self._publish_status("disconnected", True)
                return False
            # Update the dispatcher with the new instrument instance
            self.scpi_dispatcher.set_instrument_instance(inst=self.inst)

            # Trigger YAK NAB updates for Frequency and Bandwidth to refresh GUI
            self.mqtt_util.publish_message(
                topic=FrequencyYakCommunicator.YAK_UPDATE_TOPIC, subtopic="", value=True, retain=False
            )
            time.sleep(0.01)
            self.mqtt_util.publish_message(
                topic=FrequencyYakCommunicator.YAK_UPDATE_TOPIC, subtopic="", value=False, retain=False
            )
            self.mqtt_util.publish_message(
                topic=BandwidthYakCommunicator.YAK_UPDATE_TOPIC, subtopic="", value=True, retain=False
            )
            time.sleep(0.01)
            self.mqtt_util.publish_message(
                topic=BandwidthYakCommunicator.YAK_UPDATE_TOPIC, subtopic="", value=False, retain=False
            )


            idn_response = self.inst.query('*IDN?')
            idn_parts = idn_response.strip().split(',')
            manufacturer = idn_parts[0].strip() if len(idn_parts) >= 1 else "N/A"
            model = idn_parts[1].strip() if len(idn_parts) >= 2 else "N/A"
            serial_number = idn_parts[2].strip() if len(idn_parts) >= 3 else "N/A"
            firmware = idn_parts[3].strip() if len(idn_parts) >= 4 else "N/A"
            self._publish_status("brand", manufacturer)
            self._publish_status("device_model", model)
            self._publish_status("device_series", model)
            self._publish_status("device_serial_number", serial_number)
            self._publish_status("device_firmware", firmware)
            self._publish_status("visa_resource", resource_name)
            self._publish_status("Time_connected", datetime.datetime.now().strftime("%H:%M:%S"))
            self._publish_status("connected", True)
            self._publish_status("disconnected", False)
            return True
        except Exception as e:
            console_log(f"❌ Error during connection logic: {e}")
            self.disconnect_instrument_logic(console_print_func)
            return False

    def _on_disconnect_request(self, topic, payload):
        # Handles an MQTT disconnect request.
        if self.inst:
            thread = threading.Thread(target=self.disconnect_instrument_logic, args=(console_log,), daemon=True)
            thread.start()
        else:
            console_log("⚠️ No instrument is currently connected to disconnect.")

    def disconnect_instrument_logic(self, console_print_func):
        # Disconnects the application from the currently connected VISA instrument.
        if not self.inst:
            return True
        result = disconnect_instrument(self.inst, console_print_func)
        self.inst = None
        # Tell the dispatcher we are disconnected
        self.scpi_dispatcher.set_instrument_instance(inst=None)
        self.selected_device_resource = None
        self._publish_status("disconnected", True)
        self._publish_status("connected", False)
        self._publish_status("brand", "N/A")
        self._publish_status("device_model", "N/A")
        self._publish_status("device_series", "N/A")
        self._publish_status("device_serial_number", "N/A")
        self._publish_status("device_firmware", "N/A")
        self._publish_status("visa_resource", "N/A")
        self._publish_status("Time_connected", "N/A")
        return result


#####################################
### File: OPEN-AIR/managers/connection/manager_visa_dispatch_scpi.py
#####################################
# managers/manager_visa_dispatch_scpi.py
#
# This manager provides a safe, low-level interface for executing SCPI write
# and query commands via PyVISA.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251009.214021.4
# FIXED: Added a check to reject commands containing placeholders (< or >) before sending.
# FIXED: Implemented a call to the new log_visa_command utility function for logging SCPI I/O.

import os
import inspect
import pyvisa
import time

# --- Utility and Worker Imports ---
# UPDATED: Import the centralized log_visa_command
from display.logger import debug_log, console_log, log_visa_command


# --- Global Scope Variables (as per Protocol 4.4) ---
current_version = "20251009.214021.4"
current_version_hash = (20251009 * 214021 * 4)
current_file = f"{os.path.basename(__file__)}"


class ScpiDispatcher:
    """
    Manages the PyVISA connection and provides safe, low-level command execution.
    """
    def __init__(self, app_instance, console_print_func):
        # Initializes the SCPI dispatcher manager.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🛠️🟢 Entering {current_function_name}. The grand SCPI experiment begins!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_print_func
        )
        try:
            self.app_instance = app_instance
            self._print_to_gui_console = console_print_func
            # self.rm = pyvisa.ResourceManager() # No longer needed here
            self.inst = None
            self.model = ""
            self.manufacturer = ""

            console_log("✅ Success! The SCPI Dispatcher has initialized its core components.")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"🛠️🔴 By Jove, the apparatus has failed to initialize! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self._print_to_gui_console
            )

   

    def set_instrument_instance(self, inst):
        """
        Sets the PyVISA instrument instance for the dispatcher to use.
        This function is called by the VisaDeviceManager upon connection/disconnection.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🛠️🔵 Received new instrument instance. It's now my time to shine!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=self._print_to_gui_console
        )
        self.inst = inst
        if self.inst:
            console_log("✅ SCPI Dispatcher is now linked to an instrument.")
        else:
            console_log("✅ SCPI Dispatcher has been unlinked from the instrument.")


    def _reset_device(self, inst):
        # Sends a soft reset command to the instrument to restore a known state after an error.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🛠️🟠 Entering {current_function_name}. Attempting a system-wide reset!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=self._print_to_gui_console
        )
        try:
            console_log("⚠️ Command failed. Attempting to reset the instrument with '*RST'...")
            reset_success = self.write_safe(command="*RST")

            if reset_success:
                console_log("✅ Success! The device reset command was sent successfully.")
            else:
                console_log("❌ Failure! The device did not respond to the reset command.")
            return reset_success

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"🛠️🔴 The reset protocol has failed catastrophically! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self._print_to_gui_console
            )
            return False

    def write_safe(self, command):
        # Safely writes a SCPI command to the instrument.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🐐 📝 Entering {current_function_name} to transmit command: {command}",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=self._print_to_gui_console
        )
        if not self.inst:
            self._print_to_gui_console("❌ Error: Instrument not connected. Cannot write command.")
            debug_log(f"🐐 ❌ No instrument connected. Aborting command write.", file=current_file, version=current_version, function=current_function_name, console_print_func=self._print_to_gui_console)
            return False
        
        # --- Reject command if it contains placeholders. ---
        if "<" in command or ">" in command:
            error_message = f"❌ Error: Command rejected. Unresolved placeholders found: '{command}'."
            self._print_to_gui_console(error_message)
            debug_log(
                message=f"🐐 ❌ Command rejected! Unresolved placeholders found. The offending command be: {command}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self._print_to_gui_console
            )
            return False
        # --- END NEW FIX ---

        try:
            self.inst.write(command)
            # NEW: Log the command sent to the device
            log_visa_command(command=command, direction="SENT") 
            self._print_to_gui_console(f"✅ Sent command: {command}")
            return True
        except Exception as e:
            self._print_to_gui_console(f"❌ Error writing command '{command}': {e}")
            debug_log(
                message=f"🐐 🔴 Blast and barnacles! The write command has gone awry! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self._print_to_gui_console
            )
            # Prevent infinite loop if the reset command itself fails
            if command != "*RST":
                self._reset_device(inst=self.inst)
            return False

    def query_safe(self, command):
        # Safely queries the instrument with a SCPI command and returns the response.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🐐 📝 Entering {current_function_name} to query command: {command}",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=self._print_to_gui_console
        )
        if not self.inst:
            self._print_to_gui_console("❌ Error: Instrument not connected. Cannot query command.")
            debug_log(f"🐐 ❌ No instrument connected. Aborting command query.", file=current_file, version=current_version, function=current_function_name, console_print_func=self._print_to_gui_console)
            return None
            
        # --- Reject command if it contains placeholders. ---
        if "<" in command or ">" in command:
            error_message = f"❌ Error: Query rejected. Unresolved placeholders found: '{command}'."
            self._print_to_gui_console(error_message)
            debug_log(
                message=f"🐐 ❌ Query rejected! Unresolved placeholders found. The offending command be: {command}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self._print_to_gui_console
            )
            return None
        # --- END NEW FIX ---
        
        try:
            # NEW: Log the query command sent
            log_visa_command(command=command, direction="SENT")
            response = self.inst.query(command).strip()
            # NEW: Log the response received
            log_visa_command(command=response, direction="RECEIVED")
            
            self._print_to_gui_console(f"✅ Sent query: {command}")
            self._print_to_gui_console(f"✅ Received response: {response}")
            return response
        except Exception as e:
            self._print_to_gui_console(f"❌ Error querying command '{command}': {e}")
            debug_log(
                message=f"🐐 🔴 Confound it! The query has returned naught but static! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self._print_to_gui_console
            )
            self._reset_device(inst=self.inst)
            return None

#####################################
### File: OPEN-AIR/managers/connection/manager_visa_reset.py
#####################################
# managers/manager_visa_reset.py
#
# A dedicated manager to handle device reset and reboot commands received via MQTT.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250907.002515.4
# FIXED: Updated subscriptions and callbacks to listen for the new '/trigger' subtopic,
# aligning with the updated actuator logic.

import os
import inspect
import json

# --- Utility and Worker Imports ---
from display.logger import debug_log, console_log, log_visa_command
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from .manager_visa_dispatch_scpi import ScpiDispatcher

# --- Global Scope Variables (as per Protocol 4.4) ---
current_version = "20250907.002515.4"
current_version_hash = (20250907 * 2515 * 4)
current_file = f"{os.path.basename(__file__)}"


class VisaResetManager:
    """
    Listens for MQTT commands to reset or reboot the instrument and dispatches them.
    """
    def __init__(self, mqtt_controller: MqttControllerUtility, scpi_dispatcher: ScpiDispatcher):
        # Initializes the manager, linking it to the MQTT controller and SCPI dispatcher.
        current_function_name = inspect.currentframe().f_code.co_name
        self.current_class_name = self.__class__.__name__

        debug_log(
            message=f"🛠️🟢 Initiating the {self.current_class_name}. The enforcer of resets is online!",
            file=current_file,
            version=current_version,
            function=f"{self.current_class_name}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            self.mqtt_controller = mqtt_controller
            self.scpi_dispatcher = scpi_dispatcher
            
            # --- SCPI Command Constants (No Magic Numbers) ---
            self.CMD_RESET_DEVICE = "*RST"
            self.CMD_REBOOT_DEVICE = ":SYSTem:POWer:RESet" # Per user instruction for power cycle

            # --- MQTT Topic Constants ---
            self.BASE_TOPIC = "OPEN-AIR/configuration/instrument/active/Instrument_Connection/System_Reset/fields"
            self.TOPIC_RESET = f"{self.BASE_TOPIC}/Reset_device/trigger"
            self.TOPIC_REBOOT = f"{self.BASE_TOPIC}/Reboot_device/trigger"

            self._setup_mqtt_subscriptions()
            console_log(f"✅ {self.current_class_name} initialized and listening.")

        except Exception as e:
            console_log(f"❌ Error in {self.current_class_name}.{current_function_name}: {e}")
            debug_log(
                message=f"🛠️🔴 Catastrophic failure during {self.current_class_name} initialization! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.current_class_name}.{current_function_name}",
                console_print_func=console_log
            )

    def _setup_mqtt_subscriptions(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"Entering {current_function_name} to subscribe to reset/reboot topics.",
            file=current_file,
            version=current_version,
            function=f"{self.current_class_name}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # FIXED: Subscribing to the new '/trigger' subtopic
            self.mqtt_controller.add_subscriber(topic_filter=self.TOPIC_RESET, callback_func=self._on_reset_request)
            self.mqtt_controller.add_subscriber(topic_filter=self.TOPIC_REBOOT, callback_func=self._on_reboot_request)
            console_log("✅ Celebration of success! The reset manager did subscribe to its topics.")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"🛠️🔴 The subscription circuits are fried! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.current_class_name}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_reset_request(self, topic, payload):
        # Handles a request to perform a soft reset (*RST) on the instrument.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"Entering {current_function_name} due to message on topic: {topic}",
            file=current_file,
            version=current_version,
            function=f"{self.current_class_name}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # FIXED: Check if the payload value is explicitly 'true'
            data = json.loads(payload)
            if str(data.get("value")).lower() == 'true':
                console_log(f"🔵 Command received: Soft Reset. Dispatching '{self.CMD_RESET_DEVICE}'.")
                self.scpi_dispatcher.write_safe(command=self.CMD_RESET_DEVICE)
                
        except (json.JSONDecodeError, AttributeError) as e:
            console_log(f"❌ Error processing reset request payload: {payload}. Error: {e}")
            debug_log(
                message=f"🛠️🔴 A garbled message! The reset contraption is confused! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.current_class_name}.{current_function_name}",
                console_print_func=console_log
            )
            
    def _on_reboot_request(self, topic, payload):
        # Handles a request to perform a power cycle on the instrument.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"Entering {current_function_name} due to message on topic: {topic}",
            file=current_file,
            version=current_version,
            function=f"{self.current_class_name}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # FIXED: Check if the payload value is explicitly 'true'
            data = json.loads(payload)
            if str(data.get("value")).lower() == 'true':
                console_log(f"🔵 Command received: Power Cycle. Dispatching '{self.CMD_REBOOT_DEVICE}'.")
                self.scpi_dispatcher.write_safe(command=self.CMD_REBOOT_DEVICE)

        except (json.JSONDecodeError, AttributeError) as e:
            console_log(f"❌ Error processing reboot request payload: {payload}. Error: {e}")
            debug_log(
                message=f"🛠️🔴 The reboot sequence has short-circuited! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.current_class_name}.{current_function_name}",
                console_print_func=console_log
            )

#####################################
### File: OPEN-AIR/build/dist/DATA/MARKERS.csv
#####################################
ZONE,GROUP,DEVICE,NAME,FREQ_MHZ,PEAK
10 CBC AXIENT MICS,,None - None - G10,,,
10 CBC AXIENT MICS,,None - None - G10,,,
10 CBC AXIENT MICS,,None - None - G10,,,
10 CBC AXIENT MICS,,None - None - G10,,,
10 CBC AXIENT MICS,,None - None - G10,,,
10 CBC AXIENT MICS,,None - None - G10,,,
10 CBC AXIENT MICS,,None - None - G10,,,
00.TechStores,,Shure - PSM900 - G7,Shure IEM 1,,
00.TechStores,,Shure - PSM900 - G7,Shure IEM 2,,
00.TechStores,,None - None - G7,,,
00.TechStores,,Shure - PSM900 - G7,Shure IEM 4,,
01.STUDIO.55.FLOOR.K,,None - None - 42,,,
10.ST.41.ROGERS.IFB15.20,,None - None - G10,,,
10.ST.41.ROGERS.IFB15.20,,None - None - G10,,,
10.ST.41.ROGERS.MICS.20,,None - None - G57,,,
CBC ENG,,None - None - TV14-36,,,
CBC ENG,,None - None - TV14-36,,,
CBC ENG,,None - None - TV14-36,,,
CBC ENG,,None - None - TV14-36,,,
CBC ENG,,None - None - TV14-36,,,
CBC ENG,,None - None - TV14-36,,,
CBC ENG,,None - None - TV14-36,,,
CBC ENG,,None - None - TV14-36,,,
CBC ENG,,None - None - TV14-36,,,
CBC ENG,,None - None - TV14-36,,,
01.STUDIO.55.FLOOR.K,,None - None - 43,,,
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-21,,
06.ST.38.WEATHER CENTER,,Sennheiser - EM 3732-II - L,Sennheiser,,
01.STUDIO.55.FLOOR.K,,None - None - 43,,,
10.ST.41.ROGERS.IFB.J8E,,None - None - J8E,,,
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-S1,,
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-S2,,
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-S3,,
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-S4,,
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,OMPENG-6,,
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,OMPENG-7,,
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,OMPENG-5,,
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,OMPENG-8,,
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,DSQENG-8,,
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,DSQENG-7,,
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,DSQENG-6,,
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,DSQENG-5,,
10.ST.41.ROGERS.IFB14.20,,Shure - PSM1000 - G10,IFB-01,,
10.ST.41.ROGERS.IFB14.20,,Shure - PSM1000 - G10,IFB-02,,
10.ST.41.ROGERS.IFB14.20,,Shure - PSM1000 - G10,IFB-03,,
10.ST.41.ROGERS.IFB14.20,,Shure - PSM1000 - G10,IFB-04,,
10.ST.41.ROGERS.IFB14.20,,Shure - PSM1000 - G10,IFB-05,,
10.ST.41.ROGERS.IFB14.20,,Shure - PSM1000 - G10,IFB-06,,
10.ST.41.ROGERS.IFB14.20,,Shure - PSM1000 - G10,IFB-07,,
10.ST.41.ROGERS.IFB14.20,,Shure - PSM1000 - G10,IFB-08,,
10.ST.41.ROGERS.IFB15.20,,Shure - PSM1000 - G10,IFB-09,,
10.ST.41.ROGERS.IFB15.20,,Shure - PSM1000 - G10,IFB-10,,
10.ST.41.ROGERS.IFB15.20,,Shure - PSM1000 - G10,IFB-11,,
10.ST.41.ROGERS.IFB15.20,,Shure - PSM1000 - G10,IFB-12,,
10.ST.41.ROGERS.IFB15.20,,Shure - PSM1000 - G10,IFB-13,,
10.ST.41.ROGERS.IFB15.20,,Shure - PSM1000 - G10,IFB-14,,
10.ST.41.ROGERS.IFB15.20,,Shure - PSM1000 - G10,IFB-15,,
10.ST.41.ROGERS.IFB15.20,,Shure - PSM1000 - G10,IFB-16,,
10.ST.41.ROGERS.IFB16.20,,Shure - PSM1000 - G10,IFB-17,,
10.ST.41.ROGERS.IFB16.20,,Shure - PSM1000 - G10,IFB-18,,
10.ST.41.ROGERS.IFB16.20,,Shure - PSM1000 - G10,IFB-19,,
10.ST.41.ROGERS.IFB16.20,,Shure - PSM1000 - G10,IFB-20,,
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,DSQENG-1,,
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,DSQENG-2,,
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,DSQENG-3,,
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,DSQENG-4,,
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,OMPENG-3,,
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,OMPENG-2,,
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,OMPENG-4,,
10.ST.41.ROGERS.ENG.20,,Sony - DWR-S02DN - TV22-25,OMPENG-1,,
01.STUDIO.55.FLOOR.K,,Sony - DWR-R02DN - 42,Sony Mic 1,,
01.STUDIO.55.FLOOR.K,,Sony - DWR-R02DN - 42,Sony Mic 3,,
01.STUDIO.55.FLOOR.K,,Sony - DWR-R02DN - 42,Sony Mic 5,,
01.STUDIO.55.FLOOR.K,,Sony - DWR-R02DN - 42,Sony Mic 7,,
01.STUDIO.55.FLOOR.K,,Sony - DWR-R02DN - 42,Sony Mic 2,,
01.STUDIO.55.FLOOR.K,,Sony - DWR-R02DN - 42,Sony Mic 4,,
01.STUDIO.55.FLOOR.K,,Sony - DWR-R02DN - 42,Sony Mic 6,,
01.STUDIO.55.FLOOR.K,,Sony - DWR-R02DN - 43,Sony Mic 8,,
04.ST.50.FLOOR.A.NEWSNET,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 1,,
04.ST.50.FLOOR.A.NEWSNET,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 2,,
04.ST.50.FLOOR.A.NEWSNET,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 3,,
04.ST.50.FLOOR.A.NEWSNET,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 4,,
04.ST.50.FLOOR.A.NEWSNET,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 5,,
04.ST.50.FLOOR.A.NEWSNET,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 6,,
04.ST.50.FLOOR.A.NEWSNET,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 7,,
04.ST.50.FLOOR.A.NEWSNET,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 8,,
04.ST.53.FLOOR.B.FISHBOWL,,None - None - L,,,
04.ST.53.FLOOR.B.FISHBOWL,,None - None - L,,,
04.ST.53.FLOOR.B.FISHBOWL,,None - None - L,,,
04.ST.53.FLOOR.B.FISHBOWL,,None - None - L,,,
04.ST.53.FLOOR.B.FISHBOWL,,Sennheiser - SR 2050 - Bw,Sennheiser,,
04.ST.53.FLOOR.B.FISHBOWL,,Sennheiser - SR 2050 - Bw,Sennheiser,,
04.ST.53.FLOOR.B.FISHBOWL,,Sennheiser - SR 2050 - Bw,Sennheiser,,
04.ST.53.FLOOR.B.FISHBOWL,,Sennheiser - SR 2050 - Bw,Sennheiser,,
06.ST.38.WEATHER CENTER,,Sennheiser - EM 3732-II - L,Sennheiser,,
06.ST.38.WEATHER CENTER,,Sennheiser - EM 3732-II - L,Sennheiser,,
06.ST.211.RADIO RECORDING,,Shure - PSM900 - G6,IEM - MOB 1,,
06.ST.211.RADIO RECORDING,,Shure - PSM900 - G6,IEM - MOB 2,,
06.ST.38.WEATHER CENTER,,Sennheiser - SR 2000 - Aw,Sennheiser,,
06.ST.211.RADIO RECORDING,,Shure - ULXD4 - G50,IN RACK,,
06.ST.211.RADIO RECORDING,,Shure - PSM900 - G6,IN RACK,,
06.ST.211.RADIO RECORDING,,Shure - ULXD4 - G50,MOBILE 1,,
06.ST.211.RADIO RECORDING,,Shure - ULXD4 - G50,MOBILE 2,,
04.WB13.ST.F.LOCAL NEWS,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 1 - PRI,,
04.WB13.ST.F.LOCAL NEWS,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 1 - BKUP,,
04.WB13.ST.F.LOCAL NEWS,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 2,,
04.WB13.ST.F.LOCAL NEWS,,Sennheiser - EM 3732-II - L,Sennheiser - MIC 3,,
10.CONF.ARTIST LOUNGE,,Shure - SLX_master_list - G5,Shure - MIC 1,,
10.CONF.ARTIST LOUNGE,,Shure - SLX_master_list - G5,Shure - MIC 2,,
10.CONF.ARTIST LOUNGE,,Shure - SLX_master_list - G5,Shure - MIC 3,,
10.CONF.ARTIST LOUNGE,,Shure - SLX_master_list - G5,Shure - MIC 4,,
05.ST.54.FLOOR.E.SRC NEWS,,Sony - DWR-R02DN - 34-36,Sony - MIC 1,,
05.ST.54.FLOOR.E.SRC NEWS,,Sony - DWR-R02DN - 34-36,Sony - MIC 5,,
05.ST.54.FLOOR.E.SRC NEWS,,Sennheiser - EM 2000 - Aw,Sennheiser - MIC 2,,
05.ST.54.FLOOR.E.SRC NEWS,,Sennheiser - EM 2000 - Aw,Sennheiser - MIC 3,,
05.ST.54.FLOOR.E.SRC NEWS,,Sennheiser - EM 2000 - Aw,Sennheiser - MIC 4,,
05.ST.54.FLOOR.E.SRC NEWS,,Sennheiser - SR 2000 - Gw,Sennheiser - IEM 3,,
05.ST.54.FLOOR.E.SRC NEWS,,Sennheiser - SR 2000 - Gw,Sennheiser - IEM 4,,
05.ST.54.FLOOR.E.SRC NEWS,,Sennheiser - SR 2000 - Gw,Sennheiser - IEM 5,,
05.ST.54.FLOOR.E.SRC NEWS,,Sennheiser - SR 2000 - Bw,Sennheiser - IEM 1,,
05.ST.54.FLOOR.E.SRC NEWS,,Sennheiser - SR 2000 - Bw,Sennheiser - IEM 2,,
09.CONF.DIGITAL SERVICES,,Shure - BLX4 - H10,Shure,,
09.CONF.DIGITAL SERVICES,,Shure - BLX4 - H9,Shure,,
09.CONF.DIGITAL SERVICES,,Shure - BLX4 - H9,Shure,,
04.ST.55.FLOOR.D.NATIONAL,,Sennheiser - EM 3732-II - L,Sennheiser - RF 3,,
04.ST.55.FLOOR.D.NATIONAL,,Sennheiser - EM 3732-II - L,Sennheiser - RF 4,,
04.ST.55.FLOOR.D.NATIONAL,,Sennheiser - EM 3732 - C,Sennheiser - RF 1,,
04.ST.55.FLOOR.D.NATIONAL,,Sennheiser - EM 3732 - C,Sennheiser - RF 2,,
04.ST.55.FLOOR.D.NATIONAL,,Sennheiser - EM 3732 - C,Sennheiser - RF 5,,
04.ST.55.FLOOR.D.NATIONAL,,Sennheiser - EM 3732 - C,Sennheiser - RF 6,,
00.TechStores,,Sony - DWR-R02D - 42-45,Sony Rental 1,,
00.TechStores,,Sony - DWR-R02D - 42-45,Sony Rental 2,,
00.TechStores,,Sony - DWR-R02D - 42-45,Sony Rental 3,,
00.TechStores,,Sony - DWR-R02D - 42-45,Sony Rental 4,,
10.ST.41.ROGERS.IFB.J8E,10.Rogers 2020,Shure - PSM1000 - J8E,IFB-23,,
10.ST.41.ROGERS.IFB.J8E,10.Rogers 2020,Shure - PSM1000 - J8E,IFB-24,,
10.ST.41.ROGERS.IFB.J8E,10.Rogers 2020,Shure - PSM1000 - J8E,IFB-22,,
10.ST.41.ROGERS.IFB.J8E,10.Rogers 2020,None - None - J8E,,,
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-27,,
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-28,,
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-25,,
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-26,,
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-23,,
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-24,,
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-22,,
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-19,,
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-20,,
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-17,,
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-18,,
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-15,,
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-16,,
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,None - None - G57,,,
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-14,,
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-11,,
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-12,,
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-09,,
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-10,,
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-07,,
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-08,,
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-05,,
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-06,,
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-03,,
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-04,,
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-01,,
10.ST.41.ROGERS.MICS.20,10.Rogers 2020,Shure - AD4D-A - G57,R-MC-02,,
06.ST.38.WEATHER CENTER,06.WeatherStudi,Sennheiser - EM 3732-II - L,Sennheiser,,
00.TechStores,,None - None - A1A4,,,
00.TechStores,,Sennheiser - EM6000 - A1A4,Sennheiser 4,,
00.TechStores,,None - None - A1A4,,,
00.TechStores,,Sennheiser - EM6000 - A1A4,Sennheiser 3,,
00.TechStores,,Sennheiser - EM6000 - A1A4,Sennheiser 1,,
00.TechStores,,Sennheiser - EM6000 - A1A4,Sennheiser 2,,
10.SYS.1.GOULD MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 2 - MIC 01,,
10.SYS.1.GOULD MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 2 - MIC 02,,
10.SYS.1.GOULD MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 2 - MIC 03,,
10.SYS.1.GOULD MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 2 - MIC 04,,
10.SYS.1.GOULD MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 2 - MIC 05,,
10.SYS.1.GOULD MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 2 - MIC 06,,
10.SYS.1.GOULD MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 2 - MIC 07,,
10.SYS.1.GOULD MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 2 - MIC 09,,
10.SYS.1.GOULD MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 2 - MIC 08,,
10.SYS.1.GOULD MICS,,None - None - L,,,
10 CBC AXIENT MICS,,Shure - PSM1000 - G10,IFB 3,,
10 CBC AXIENT MICS,,Shure - PSM1000 - G10,IFB 4,,
10 CBC AXIENT MICS,,None - None - G10,,,
10 CBC AXIENT MICS,,Shure - PSM1000 - G10,IFB 1,,
10.SYS.2 SENN.MOBILE MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 1 - MIC 02,,
10.SYS.2 SENN.MOBILE MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 1 - MIC 03,,
10.SYS.2 SENN.MOBILE MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 1 - MIC 04,,
10.SYS.2 SENN.MOBILE MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 1 - MIC 05,,
10.SYS.2 SENN.MOBILE MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 1 - MIC 06,,
10.SYS.2 SENN.MOBILE MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 1 - MIC 07,,
10.SYS.2 SENN.MOBILE MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 1 - MIC 08,,
10.SYS.2 SENN.MOBILE MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 1 - MIC 09,,
10.SYS.2 SENN.MOBILE MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 1 - MIC 10,,
10.SYS.2 SENN.MOBILE MICS,,Sennheiser - EM 3732-II - L,Sennheiser SYS 1 - MIC 01,,
10.SYS.1.GOULD MICS,,Sennheiser - SR 2050 - Bw,Sennheiser - IEM - 1,,
10.SYS.1.GOULD MICS,,Sennheiser - SR 2050 - Bw,Sennheiser - IEM - 2,,
10.SYS.1.GOULD MICS,,Sennheiser - SR 2050 - Bw,Sennheiser - IEM - 3,,
10.SYS.1.GOULD MICS,,Sennheiser - SR 2050 - Bw,Sennheiser - IEM - 4,,
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,LAV 4,,
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,STICK 5,,
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,LAV 1,,
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,STICK 6,,
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,STICK 7,,
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,LAV 5,,
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,LAV 3,,
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,STICK 3,,
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,LAV 2,,
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,STICK 1,,
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,STICK 4,,
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,STICK 2,,
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,Shure,,
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,Shure,,
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,Shure,,
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,Shure,,
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,Shure,,
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,Shure,,
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,Shure,,
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,Shure,,
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,Shure,,
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,Shure,,
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,Shure,,
10 CBC AXIENT MICS,,Shure - AD4Q-A - G57,Shure,,
10 CBC AXIENT MICS,,Shure - PSM1000 - G10,Shure,,
10 CBC AXIENT MICS,,Shure - PSM1000 - G10,Shure,,
10 CBC AXIENT MICS,,Shure - PSM1000 - G10,Shure,,
10 CBC AXIENT MICS,,Shure - PSM1000 - G10,Shure,,
10 CBC AXIENT MICS,,Shure - PSM1000 - G10,Shure,,
00.TechStores,,Sennheiser - EM 9046 - A1,Sennheiser 1,,
00.TechStores,,Sennheiser - EM 9046 - A1,Sennheiser 2,,
00.TechStores,,Sennheiser - EM 9046 - A1,Sennheiser 3,,
00.TechStores,,Sennheiser - EM 9046 - A1,Sennheiser 4,,
00.TechStores,,Sennheiser - EM 9046 - A1,Sennheiser 5,,
00.TechStores,,Sennheiser - EM 9046 - A1,Sennheiser 6,,
00.TechStores,,Sennheiser - EM 9046 - A1,Sennheiser 7,,
00.TechStores,,Sennheiser - EM 9046 - A1,Sennheiser 8,,
01.STUDIO.ATRIUM,,Sennheiser - EM 2050 - Gw,Sennheiser IFB 2,,
01.STUDIO.ATRIUM,,Sennheiser - EM 2050 - Gw,Sennheiser IFB 3,,
01.STUDIO.ATRIUM,,Sennheiser - EM 2050 - Gw,Sennheiser IFB 4,,
01.STUDIO.ATRIUM,,Shure - AD4D-A - Gw,R-MC-17,,
01.STUDIO.ATRIUM,,Sennheiser - EM 2050 - Gw,Sennheiser IFB 6,,
01.STUDIO.ATRIUM,,None - None - Gw,,,
01.STUDIO.ATRIUM,,None - None - Gw,,,
01.STUDIO.ATRIUM,,Sennheiser - EM 2050 - Gw,Sennheiser IFB 1,,
01.STUDIO.ATRIUM,,Sennheiser - EM 9046 - A1,Sennheiser 1,,
01.STUDIO.ATRIUM,,Sennheiser - EM 9046 - A1,Sennheiser 2,,
01.STUDIO.ATRIUM,,Sennheiser - EM 9046 - A1,Sennheiser 3,,
01.STUDIO.ATRIUM,,Sennheiser - EM 9046 - A1,Sennheiser 4,,
01.STUDIO.ATRIUM,,Sennheiser - EM 9046 - A1,Sennheiser 5,,
01.STUDIO.ATRIUM,,Sennheiser - EM 9046 - A1,Sennheiser 6,,
01.STUDIO.ATRIUM,,Sennheiser - EM 9046 - A1,Sennheiser 7,,
01.STUDIO.ATRIUM,,Sennheiser - EM 9046 - A1,Sennheiser 8,,


#####################################
### File: OPEN-AIR/build/dist/DATA/PRESET.csv
#####################################
Parameter,Active,FileName,NickName,Start,Stop,Center,Span,RBW,VBW,RefLevel,Attenuation,MaxHold,HighSens,PreAmp,Trace1Mode,Trace2Mode,Trace3Mode,Trace4Mode
PRESET_001,True,14MON.STA,470-530    14 MON,470,530,500,60,30000,,-50,20,,,1,WRITE,MAXhold,MINhold,BLANK
PRESET_002,True,24MON.STA,530-590     24MON,530,590,560,60,30000,,-50,20,,,1,WRITE,MAXhold,MINhold,BLANK
PRESET_003,True,34MON.STA,590 - 650      34MON,590,650,620,60,30000,,-50,20,,,1,WRITE,MAXhold,MINhold,BLANK
PRESET_004,True,44MON.STA,650 - 710      44MON,650,710,680,60,30000,,-50,20,,,1,WRITE,MAXhold,MINhold,BLANK
PRESET_005,True,470608MON.STA,470-608 MON,470,608,539,138,30000,,-50,20,,,1,WRITE,MAXhold,MINhold,BLANK
PRESET_006,True,44.STA,650-710,650,710,680,60,300000,,-50,20,,,1,WRITE,MAXhold,MINhold,BLANK
PRESET_007,True,02.STA,54-88 MHz,54,88,71,34,300000,,-50,20,,,1,WRITE,MAXhold,MINhold,BLANK
PRESET_008,True,450-470LMR.STA,450-470 LMR,450,470,460,20,1000,,-50,20,,,1,WRITE,MAXhold,MINhold,BLANK
PRESET_009,True,34.STA,34,590,650,620,60,300000,,-50,20,,,1,WRITE,MAXhold,MINhold,BLANK
PRESET_010,True,14.STA,14,470,530,500,60,300000,,-50,20,,,1,WRITE,MAXhold,MINhold,BLANK
PRESET_011,True,07.STA,7,174,218,196,44,300000,,-50,20,,,1,WRITE,MAXhold,MINhold,BLANK
PRESET_012,True,DECT_NA.STA,DECT NA,1920,1930,1925,10,100000,,-50,20,,,1,WRITE,MAXhold,MINhold,BLANK
PRESET_013,True,DECT_EU.STA,DECT EU,1880,1900,1890,20,300000,,-50,20,,,1,WRITE,MAXhold,MINhold,BLANK
PRESET_014,True,22GHZCAMS.STA,22GHZCAMS,2200,2300,2250,100,1000000,,-50,20,,,1,WRITE,MAXhold,MINhold,BLANK
PRESET_015,True,2GHZCAMS.STA,Wireless cameras,2050,2300,2175,250,1000000,,-50,20,,,1,WRITE,MAXhold,MINhold,BLANK
PRESET_016,True,3GHZCAMS.STA,3GHZCAMS,3150,3300,3225,150,1000000,,-50,20,,,1,WRITE,MAXhold,MINhold,BLANK


#####################################
### File: OPEN-AIR/build/build_scripts/build_linux.py
#####################################
# build/build_scripts/build_linux.py
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)

import subprocess
import sys
import os

def build():
    """
    Builds the OPEN-AIR executable for Linux using PyInstaller.
    """
    print("Starting Linux build process...")

    project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..'))
    venv_path = os.path.join(project_root, '.venv')
    
    if not os.path.exists(venv_path):
        print(f"ERROR: Virtual environment not found at '{venv_path}'")
        print("Please create a virtual environment and install the dependencies from requirements.txt")
        sys.exit(1)

    # Construct the path to the pyinstaller executable within the virtual environment
    pyinstaller_executable = os.path.join(venv_path, 'bin', 'pyinstaller')

    if not os.path.exists(pyinstaller_executable):
        print(f"ERROR: PyInstaller command not found at '{pyinstaller_executable}'. Make sure PyInstaller is installed in your virtual environment.")
        sys.exit(1)

    # Path to the spec file
    spec_file = os.path.join(project_root, 'OPEN-AIR.spec')

    if not os.path.exists(spec_file):
        print(f"ERROR: Could not find spec file at {spec_file}")
        sys.exit(1)

    print(f"Using PyInstaller from: {pyinstaller_executable}")
    print(f"Using spec file: {spec_file}")

    dist_path = os.path.join(project_root, 'build', 'dist')

    command = [
        pyinstaller_executable,
        spec_file,
        '--noconfirm', # Overwrite previous builds without asking
        '--distpath',
        dist_path
    ]

    print(f"Running command: {' '.join(command)}")

    try:
        process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, bufsize=1, universal_newlines=True)
        
        while True:
            output = process.stdout.readline()
            if output == '' and process.poll() is not None:
                break
            if output:
                print(output.strip(), flush=True)
        
        return_code = process.poll()

        if return_code == 0:
            print("\nBuild completed successfully!")
            print(f"Executable is available in the '{dist_path}' directory.")
        else:
            print(f"\nBuild failed with return code: {return_code}")

    except Exception as e:
        print(f"An unexpected error occurred: {e}")

if __name__ == "__main__":
    build()


#####################################
### File: OPEN-AIR/build/build_scripts/build_windows.py
#####################################
<<<<<<< Updated upstream
import subprocess
import sys
import os

def build():
    """
    Builds the OPEN-AIR executable for Windows using PyInstaller.
    
    IMPORTANT: This script must be run on a Windows machine with a properly
               configured Python environment and all project dependencies installed.
    """
    print("Starting Windows build process...")

    project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
    venv_path = os.path.join(project_root, '.venv')

    if not os.path.exists(venv_path):
        print(f"ERROR: Virtual environment not found at '{venv_path}'")
        sys.exit(1)

    # Construct the path to the pyinstaller executable within the virtual environment
    pyinstaller_executable = os.path.join(venv_path, 'Scripts', 'pyinstaller.exe')

    if not os.path.exists(pyinstaller_executable):
        print(f"ERROR: PyInstaller command not found at '{pyinstaller_executable}'. Make sure PyInstaller is installed in your virtual environment.")
        sys.exit(1)

    # Path to the spec file
    spec_file = os.path.join(project_root, 'OPEN-AIR.spec')

    if not os.path.exists(spec_file):
        print(f"ERROR: Could not find spec file at {spec_file}")
        sys.exit(1)
        
    print(f"Using PyInstaller from: {pyinstaller_executable}")
    print(f"Using spec file: {spec_file}")

    # Note: The OPEN-AIR.spec file will need to be adjusted for Windows.
    # Specifically, the 'datas' section for tcl/tk libraries will need
    # to point to the correct paths in your Windows Python environment.
    # For example:
    # datas=[
    #     ('C:\Users\YourUser\AppData\Local\Programs\Python\Python39\tcl\tcl8.6', 'tcl'),
    #     ('C:\Users\YourUser\AppData\Local\Programs\Python\Python39\tcl\tk8.6', 'tk')
    # ],
    print("IMPORTANT: Ensure the tcl/tk paths in OPEN-AIR.spec are correct for your Windows environment.")

    command = [
        pyinstaller_executable,
        spec_file,
        '--noconfirm' # Overwrite previous builds without asking
    ]

    print(f"Running command: {' '.join(command)}")

    try:
        process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, bufsize=1, universal_newlines=True)
        
        while True:
            output = process.stdout.readline()
            if output == '' and process.poll() is not None:
                break
            if output:
                print(output.strip(), flush=True)
        
        return_code = process.poll()

        if return_code == 0:
            print("\nBuild completed successfully!")
            print(f"Executable is available in the '{os.path.join(project_root, 'dist')}' directory.")
        else:
            print(f"\nBuild failed with return code: {return_code}")

    except Exception as e:
        print(f"An unexpected error occurred: {e}")

if __name__ == "__main__":
    build()
=======
from workers.active.worker_active_logging import debug_log, console_log
ENABLE_DEBUG = False

def debug_log_switch(message, file, version, function, console_print_func):
    if ENABLE_DEBUG:
        debug_log_switch(message, file, version, function, console_print_func)

def console_log_switch(message):
    if ENABLE_DEBUG:
        console_log_switch(message)

>>>>>>> Stashed changes


#####################################
### File: OPEN-AIR/workers/Showtime/worker_showtime_buttons.py
#####################################
# workers/worker_showtime_buttons.py
#
# A worker to create buttons with dynamically generated bar graph images.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)

import tkinter as tk
from tkinter import ttk
from PIL import Image, ImageTk
from workers.Showtime.worker_showtime_draw_bargraph import create_bar_graph_image

def create_button_with_bar_graph(parent, value, text):
    """
    Creates a button with a bar graph image.

    Args:
        parent: The parent widget for the button.
        value (int): The value to represent on the bar graph, from -100 to 0.
        text (str): The text to display on the button.

    Returns:
        ttk.Button: The created button.
    """
    image_path = create_bar_graph_image(value, text)
    img = Image.open(image_path)
    photo = ImageTk.PhotoImage(img)

    button = ttk.Button(parent, image=photo)
    button.image = photo  # Keep a reference to the image to prevent garbage collection

    return button


#####################################
### File: OPEN-AIR/workers/Showtime/worker_showtime_clear_group_buttons.py
#####################################

import inspect
from display.logger import debug_log, console_log

def clear_group_buttons(showtime_tab_instance):
    current_function = inspect.currentframe().f_code.co_name
    if showtime_tab_instance.Local_Debug_Enable:
        debug_log(
            message="🛠️🔵 Clearing group buttons.",
            file=showtime_tab_instance.current_file,
            version=showtime_tab_instance.current_version,
            function=f"{showtime_tab_instance.__class__.__name__}.{current_function}",
            console_print_func=console_log
        )
    for widget in showtime_tab_instance.group_frame.winfo_children():
        widget.destroy()


#####################################
### File: OPEN-AIR/workers/Showtime/worker_showtime_create_device_buttons.py
#####################################

import inspect
import tkinter as tk
from tkinter import ttk
from display.logger import debug_log, console_log

def create_device_buttons(showtime_tab_instance):
    current_function = inspect.currentframe().f_code.co_name
    if showtime_tab_instance.Local_Debug_Enable:
        debug_log(
            message="🛠️🟢 Creating Device buttons.",
            file=showtime_tab_instance.current_file,
            version=showtime_tab_instance.current_version,
            function=f"{showtime_tab_instance.__class__.__name__}.{current_function}",
            console_print_func=console_log
        )
    
    if showtime_tab_instance.selected_device_button:
        showtime_tab_instance.selected_device_button.config(style='Custom.TButton')
    showtime_tab_instance.selected_device_button = None

    for widget in showtime_tab_instance.device_frame.winfo_children():
        widget.destroy()
    
    filtered_devices = []
    if showtime_tab_instance.selected_zone and showtime_tab_instance.selected_group:
        filtered_devices = showtime_tab_instance.grouped_markers[showtime_tab_instance.selected_zone][showtime_tab_instance.selected_group]
        if showtime_tab_instance.Local_Debug_Enable:
            debug_log(
                message=f"🔍 Showing devices for Zone: {showtime_tab_instance.selected_zone} and Group: {showtime_tab_instance.selected_group}.",
                file=showtime_tab_instance.current_file,
                version=showtime_tab_instance.current_version,
                function=f"{showtime_tab_instance.__class__.__name__}.{current_function}",
                console_print_func=console_log
            )
    elif showtime_tab_instance.selected_zone:
        for group_name in showtime_tab_instance.grouped_markers[showtime_tab_instance.selected_zone]:
            filtered_devices.extend(showtime_tab_instance.grouped_markers[showtime_tab_instance.selected_zone][group_name])
        if showtime_tab_instance.Local_Debug_Enable:
            debug_log(
                message=f"🔍 Showing all devices for selected Zone: {showtime_tab_instance.selected_zone}.",
                file=showtime_tab_instance.current_file,
                version=showtime_tab_instance.current_version,
                function=f"{showtime_tab_instance.__class__.__name__}.{current_function}",
                console_print_func=console_log
            )
    else:
        filtered_devices = showtime_tab_instance.marker_data
        if showtime_tab_instance.Local_Debug_Enable:
            debug_log(
                message="🔍 Showing all devices from MARKERS.csv.",
                file=showtime_tab_instance.current_file,
                version=showtime_tab_instance.current_version,
                function=f"{showtime_tab_instance.__class__.__name__}.{current_function}",
                console_print_func=console_log
            )

    for i, row_data in enumerate(filtered_devices):
        button_text = (
                       f"{row_data.get('NAME', 'N/A')}\n"
                       f"{row_data.get('DEVICE', 'N/A')}\n"
                       f"{row_data.get('FREQ_MHZ', 'N/A')} MHz\n"
                       f"[********************]"
                      )
        
        button = ttk.Button(
            showtime_tab_instance.device_frame,
            text=button_text,
            style='Custom.TButton'
        )
        # Store data directly on the button object
        button.marker_data = row_data
        button.configure(command=lambda b=button: showtime_tab_instance._on_marker_button_click(b))
        
        row = i // 4
        col = i % 4
        button.grid(row=row, column=col, padx=5, pady=5, sticky="ew")

    if showtime_tab_instance.Local_Debug_Enable:
        debug_log(
            message=f"✅ Created {len(filtered_devices)} device buttons.",
            file=showtime_tab_instance.current_file,
            version=showtime_tab_instance.current_version,
            function=f"{showtime_tab_instance.__class__.__name__}.{current_function}",
            console_print_func=console_log
        )


#####################################
### File: OPEN-AIR/workers/Showtime/worker_showtime_create_group_buttons.py
#####################################

import inspect
import tkinter as tk
from tkinter import ttk
from display.logger import debug_log, console_log
from workers.markers.worker_marker_logic import calculate_frequency_range

def create_group_buttons(showtime_tab_instance):
    current_function = inspect.currentframe().f_code.co_name
    if showtime_tab_instance.Local_Debug_Enable:
        debug_log(
            message="🛠️🟢 Creating Group filter buttons.",
            file=showtime_tab_instance.current_file,
            version=showtime_tab_instance.current_version,
            function=f"{showtime_tab_instance.__class__.__name__}.{current_function}",
            console_print_func=console_log
        )
    
    for widget in showtime_tab_instance.group_frame.winfo_children():
        widget.destroy()
    
    if showtime_tab_instance.selected_zone:
        showtime_tab_instance.group_frame.configure(text=f"GROUPS")
        showtime_tab_instance.group_frame.grid(row=2, column=0, padx=5, pady=5, sticky="nsew")
        
        sorted_groups = sorted(showtime_tab_instance.grouped_markers[showtime_tab_instance.selected_zone].keys())
        for i, group_name in enumerate(sorted_groups):
            is_selected = showtime_tab_instance.selected_group == group_name

            group_devices = showtime_tab_instance.grouped_markers[showtime_tab_instance.selected_zone][group_name]
            # UPDATED: Use the imported utility function
            min_freq, max_freq = calculate_frequency_range(group_devices)
            
            freq_range_text = ""
            if min_freq is not None and max_freq is not None:
                freq_range_text = f"\n{min_freq} MHz - {max_freq} MHz"
            
            button_text = f"{group_name}{freq_range_text}"
            
            button = ttk.Button(
                showtime_tab_instance.group_frame,
                text=button_text,
                command=lambda g=group_name: showtime_tab_instance._on_group_toggle(g),
                style='Custom.TButton' if not is_selected else 'Custom.Selected.TButton'
            )
            row = i // 4
            col = i % 4
            button.grid(row=row, column=col, padx=5, pady=5, sticky="ew")
    else:
        showtime_tab_instance.group_frame.grid_remove()
        
    if showtime_tab_instance.Local_Debug_Enable:
        debug_log(
            message=f"✅ Group buttons updated for selected zone.",
            file=showtime_tab_instance.current_file,
            version=showtime_tab_instance.current_version,
            function=f"{showtime_tab_instance.__class__.__name__}.{current_function}",
            console_print_func=console_log
        )


#####################################
### File: OPEN-AIR/workers/Showtime/worker_showtime_create_zone_buttons.py
#####################################
# workers/Showtime/worker_showtime_create_zone_buttons.py
#
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213
Current_Time = 120000
Current_iteration = 44

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#

import inspect
import tkinter as tk
from tkinter import ttk
from display.logger import debug_log, console_log
from workers.Showtime.worker_showtime_on_zone_toggle import on_zone_toggle

Local_Debug_Enable = True

def create_zone_buttons(showtime_tab_instance):
    current_function = inspect.currentframe().f_code.co_name
    if Local_Debug_Enable:
        debug_log(
            message="🛠️🟢 Creating Zone buttons.",
            file=showtime_tab_instance.current_file,
            version=showtime_tab_instance.current_version,
            function=f"{current_function}",
            console_print_func=console_log
        )
    
    # Clear existing zone buttons
    for widget in showtime_tab_instance.zones_frame.winfo_children():
        widget.destroy()

    zone_buttons_frame = ttk.Frame(showtime_tab_instance.zones_frame)
    zone_buttons_frame.pack(fill=tk.X, padx=5, pady=2)

    for zone_name in sorted(showtime_tab_instance.grouped_markers.keys()):
        zone_button = ttk.Button(
            zone_buttons_frame,
            text=zone_name,
            command=lambda zn=zone_name: on_zone_toggle(showtime_tab_instance, zn),
            style='Custom.TButton'
        )
        zone_button.pack(side=tk.LEFT, padx=2, pady=2)
        if Local_Debug_Enable:
            debug_log(
                message=f"✅ Created button for Zone: {zone_name}.",
                file=showtime_tab_instance.current_file,
                version=showtime_tab_instance.current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )


#####################################
### File: OPEN-AIR/workers/Showtime/worker_showtime_draw_bargraph.py
#####################################
# workers/worker_draw_bargraph.py
#
# A worker to generate a horizontal bar graph image.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)

import os
from PIL import Image, ImageDraw, ImageFont
import workers.utils.worker_project_paths as project_paths

def create_bar_graph_image(value, text, width=200, height=60, bg_color=(200, 200, 200), bar_color=(0, 0, 255), text_color=(0, 0, 0)):
    """
    Creates a horizontal bar graph image with text.

    Args:
        value (int): The value to represent, from -100 to 0.
        text (str): The text to display on the image.
        width (int): The width of the image.
        height (int): The height of the image.
        bg_color (tuple): The background color of the image.
        bar_color (tuple): The color of the bar.
        text_color (tuple): The color of the text.

    Returns:
        str: The path to the saved image.
    """
    if not -100 <= value <= 0:
        raise ValueError("Value must be between -100 and 0.")

    # Create a new image with a light gray background
    img = Image.new('RGB', (width, height), color=bg_color)
    draw = ImageDraw.Draw(img)

    # Calculate the width of the bar
    bar_height = 10
    bar_y_position = height - bar_height - 5
    bar_width = (value + 100) * width / 100

    # Draw the bar
    draw.rectangle([(0, bar_y_position), (bar_width, bar_y_position + bar_height)], fill=bar_color)

    # Draw the text
    try:
        font = ImageFont.truetype("arial.ttf", 10)
    except IOError:
        font = ImageFont.load_default()
    
    draw.text((5, 5), text, font=font, fill=text_color)


    # Save the image to the DATA folder
    image_name = f"bar_graph_{value}.png"
    image_path = os.path.join(project_paths.DATA_DIR, image_name)
    img.save(image_path)

    return image_path


#####################################
### File: OPEN-AIR/workers/Showtime/worker_showtime_group.py
#####################################
# workers/Showtime/worker_showtime_group.py
#
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213
Current_Time = 120000
Current_iteration = 44

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#

import inspect
from collections import defaultdict
from display.logger import debug_log, console_log

Local_Debug_Enable = True



def process_and_sort_markers(showtime_tab_instance):
    current_function = inspect.currentframe().f_code.co_name
    if Local_Debug_Enable:
        debug_log(
            message="🛠️🔵 Processing and sorting marker data by Zone, Group, and Device.",
            file=showtime_tab_instance.current_file,
            version=showtime_tab_instance.current_version,
            function=f"{showtime_tab_instance.__class__.__name__}.{current_function}",
            console_print_func=console_log
        )

    showtime_tab_instance.grouped_markers = defaultdict(lambda: defaultdict(list))
    
    for row in showtime_tab_instance.marker_data:
        zone = row.get('ZONE', 'N/A')
        group = row.get('GROUP', 'N/A')
        showtime_tab_instance.grouped_markers[zone][group].append(row)
    
    for zone, groups in showtime_tab_instance.grouped_markers.items():
        for group, devices in groups.items():
            devices.sort(key=lambda x: x.get('NAME', ''))
    
    if Local_Debug_Enable:
        debug_log(
            message="✅ Markers grouped and sorted successfully.",
            file=showtime_tab_instance.current_file,
            version=showtime_tab_instance.current_version,
            function=f"{showtime_tab_instance.__class__.__name__}.{current_function}",
            console_print_func=console_log
        )

#####################################
### File: OPEN-AIR/workers/Showtime/worker_showtime_on_group_toggle.py
#####################################

import inspect
from display.logger import debug_log, console_log
from workers.Showtime.worker_showtime_create_group_buttons import create_group_buttons
from workers.Showtime.worker_showtime_create_device_buttons import create_device_buttons
from workers.Showtime.worker_showtime_tune import on_tune_request_from_selection

def on_group_toggle(showtime_tab_instance, group_name):
    current_function = inspect.currentframe().f_code.co_name
    if showtime_tab_instance.Local_Debug_Enable:
        debug_log(
            message=f"🛠️🔵 Group toggle clicked for: {group_name}. Current selection: {showtime_tab_instance.selected_group}.",
            file=showtime_tab_instance.current_file,
            version=showtime_tab_instance.current_version,
            function=f"{showtime_tab_instance.__class__.__name__}.{current_function}",
            console_print_func=console_log
        )
    if showtime_tab_instance.selected_group == group_name:
        showtime_tab_instance.selected_group = None
        if showtime_tab_instance.Local_Debug_Enable:
            debug_log(
                message="🛠️🟡 Deselected Group. Showing all devices for the current Zone.",
                file=showtime_tab_instance.current_file,
                version=showtime_tab_instance.current_version,
                function=f"{showtime_tab_instance.__class__.__name__}.{current_function}",
                console_print_func=console_log
            )
    else:
        showtime_tab_instance.selected_group = group_name
        if showtime_tab_instance.Local_Debug_Enable:
            debug_log(
                message=f"🛠️🟢 Selected new Group: {showtime_tab_instance.selected_group}.",
                file=showtime_tab_instance.current_file,
                version=showtime_tab_instance.current_version,
                function=f"{showtime_tab_instance.__class__.__name__}.{current_function}",
                console_print_func=console_log
            )
    
    create_group_buttons(showtime_tab_instance)
    create_device_buttons(showtime_tab_instance)
    
    on_tune_request_from_selection(showtime_tab_instance)


#####################################
### File: OPEN-AIR/workers/Showtime/worker_showtime_on_marker_button_click.py
#####################################

import inspect
from display.logger import debug_log, console_log
from workers.Showtime.worker_showtime_tune import on_tune_request_from_selection

def on_marker_button_click(showtime_tab_instance, button):
    current_function = inspect.currentframe().f_code.co_name
    if showtime_tab_instance.Local_Debug_Enable:
        debug_log(
            message="🛠️🔵 Device button clicked. Toggling selection.",
            file=showtime_tab_instance.current_file,
            version=showtime_tab_instance.current_version,
            function=f"{showtime_tab_instance.__class__.__name__}.{current_function}",
            console_print_func=console_log
        )
    marker_data = button.marker_data
    
    if showtime_tab_instance.selected_device_button == button:
        showtime_tab_instance.selected_device_button.config(style='Custom.TButton')
        showtime_tab_instance.selected_device_button = None
        console_log(f"🟡 Deselected device: {marker_data.get('NAME', 'N/A')}.")
    else:
        if showtime_tab_instance.selected_device_button:
            showtime_tab_instance.selected_device_button.config(style='Custom.TButton')
        
        showtime_tab_instance.selected_device_button = button
        showtime_tab_instance.selected_device_button.config(style='Custom.Selected.TButton')
        console_log(f"✅ Selected device: {marker_data.get('NAME', 'N/A')} at {marker_data.get('FREQ_MHZ', 'N/A')} MHz.")
    
    on_tune_request_from_selection(showtime_tab_instance)


#####################################
### File: OPEN-AIR/workers/Showtime/worker_showtime_on_zone_toggle.py
#####################################

import inspect
from display.logger import debug_log, console_log
from workers.Showtime.worker_showtime_create_group_buttons import create_group_buttons
from workers.Showtime.worker_showtime_create_device_buttons import create_device_buttons
from workers.Showtime.worker_showtime_tune import on_tune_request_from_selection

def on_zone_toggle(showtime_tab_instance, zone_name):
    current_function = inspect.currentframe().f_code.co_name
    if showtime_tab_instance.Local_Debug_Enable:
        debug_log(
            message=f"🛠️🔵 Zone toggle clicked for: {zone_name}. Current selection: {showtime_tab_instance.selected_zone}.",
            file=showtime_tab_instance.current_file,
            version=showtime_tab_instance.current_version,
            function=f"{showtime_tab_instance.__class__.__name__}.{current_function}",
            console_print_func=console_log
        )
    if showtime_tab_instance.selected_zone == zone_name:
        showtime_tab_instance.selected_zone = None
        showtime_tab_instance.selected_group = None
        if showtime_tab_instance.Local_Debug_Enable:
            debug_log(
                message="🛠️🟡 Deselected Zone. Clearing Group selection.",
                file=showtime_tab_instance.current_file,
                version=showtime_tab_instance.current_version,
                function=f"{showtime_tab_instance.__class__.__name__}.{current_function}",
                console_print_func=console_log
            )
    else:
        showtime_tab_instance.selected_zone = zone_name
        showtime_tab_instance.selected_group = None
        if showtime_tab_instance.Local_Debug_Enable:
            debug_log(
                message=f"🛠️🟢 Selected new Zone: {showtime_tab_instance.selected_zone}. Clearing Group selection.",
                file=showtime_tab_instance.current_file,
                version=showtime_tab_instance.current_version,
                function=f"{showtime_tab_instance.__class__.__name__}.{current_function}",
                console_print_func=console_log
            )
    
    showtime_tab_instance._create_zone_buttons()
    create_group_buttons(showtime_tab_instance)
    create_device_buttons(showtime_tab_instance)
    
    on_tune_request_from_selection(showtime_tab_instance)


#####################################
### File: OPEN-AIR/workers/Showtime/worker_showtime_read.py
#####################################
# workers/Showtime/worker_showtime_read.py
#
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213
Current_Time = 120000
Current_iteration = 44

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#

import inspect
from display.logger import debug_log, console_log
from workers.importers.worker_marker_file_import_handling import maker_file_check_for_markers_file

Local_Debug_Enable = True



def load_marker_data(showtime_tab_instance):
    current_function = inspect.currentframe().f_code.co_name
    if Local_Debug_Enable:
        debug_log(
            message="🛠️🟢 Loading raw marker data from file.",
            file=showtime_tab_instance.current_file,
            version=showtime_tab_instance.current_version,
            function=f"{showtime_tab_instance.__class__.__name__}.{current_function}",
            console_print_func=console_log
        )
    
    raw_headers, raw_data = maker_file_check_for_markers_file()
    
    if not raw_data:
        showtime_tab_instance.marker_data = []
        showtime_tab_instance.column_headers = []
        console_log("🟡 No marker data found in MARKERS.csv. No buttons will be created.")
        return

    showtime_tab_instance.marker_data = [dict(zip(raw_headers, row)) for row in raw_data if len(row) == len(raw_headers)]
    showtime_tab_instance.column_headers = raw_headers

    if Local_Debug_Enable:
        debug_log(
            message=f"✅ Loaded {len(showtime_tab_instance.marker_data)} rows. Converted to dictionaries for sorting and display.",
            file=showtime_tab_instance.current_file,
            version=showtime_tab_instance.current_version,
            function=f"{showtime_tab_instance.__class__.__name__}.{current_function}",
            console_print_func=console_log
        )

#####################################
### File: OPEN-AIR/workers/Showtime/worker_showtime_tune.py
#####################################
# workers/Showtime/worker_showtime_tune.py
#
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213
Current_Time = 120000
Current_iteration = 44

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#

import inspect
from display.logger import debug_log, console_log
from workers.active.worker_active_marker_tune_and_collect import Push_Marker_to_Center_Freq, Push_Marker_to_Start_Stop_Freq
from workers.markers.worker_marker_logic import calculate_frequency_range

Local_Debug_Enable = True



def on_tune_request_from_selection(showtime_tab_instance):
    """
    Tunes the instrument based on the current selections.
    """
    current_function = inspect.currentframe().f_code.co_name
    if Local_Debug_Enable:
        debug_log(
            message="🛠️🟢 Initiating tuning request based on current selection.",
            file=showtime_tab_instance.current_file,
            version=showtime_tab_instance.current_version,
            function=f"{showtime_tab_instance.__class__.__name__}.{current_function}",
            console_print_func=console_log
        )
    
    if showtime_tab_instance.selected_device_button:
        # Case 1: A specific device is selected
        marker_data = showtime_tab_instance.selected_device_button.marker_data
        if Local_Debug_Enable:
            debug_log(
                message=f"🔍 Device button selected. Tuning to center frequency of {marker_data.get('NAME', 'N/A')}.",
                file=showtime_tab_instance.current_file,
                version=showtime_tab_instance.current_version,
                function=f"{showtime_tab_instance.__class__.__name__}.{current_function}",
                console_print_func=console_log
            )
        Push_Marker_to_Center_Freq(mqtt_controller=showtime_tab_instance.mqtt_util, marker_data=marker_data)
    elif showtime_tab_instance.selected_group:
        # Case 2: A group is selected, but no device
        if Local_Debug_Enable:
            debug_log(
                message=f"🔍 No device selected. Tuning to start/stop frequency of selected Group: {showtime_tab_instance.selected_group}.",
                file=showtime_tab_instance.current_file,
                version=showtime_tab_instance.current_version,
                function=f"{showtime_tab_instance.__class__.__name__}.{current_function}",
                console_print_func=console_log
            )
        group_devices = showtime_tab_instance.grouped_markers[showtime_tab_instance.selected_zone][showtime_tab_instance.selected_group]
        # UPDATED: Use the imported utility function
        min_freq, max_freq = calculate_frequency_range(group_devices)
        
        if min_freq is not None and max_freq is not None:
            mock_marker_data = {'FREQ_MHZ': (min_freq + max_freq) / 2}
            Push_Marker_to_Start_Stop_Freq(mqtt_controller=showtime_tab_instance.mqtt_util, marker_data=mock_marker_data, buffer=(max_freq - min_freq) * 1e6)
        else:
            console_log("❌ Failed to tune: No valid frequencies found in selected group.")
            
    elif showtime_tab_instance.selected_zone:
        # Case 3: A zone is selected, but no group or device
        if Local_Debug_Enable:
            debug_log(
                message=f"🔍 No group selected. Tuning to start/stop frequency of selected Zone: {showtime_tab_instance.selected_zone}.",
                file=showtime_tab_instance.current_file,
                version=showtime_tab_instance.current_version,
                function=f"{showtime_tab_instance.__class__.__name__}.{current_function}",
                console_print_func=console_log
            )
        all_zone_devices = []
        for group_name in showtime_tab_instance.grouped_markers[showtime_tab_instance.selected_zone]:
            all_zone_devices.extend(showtime_tab_instance.grouped_markers[showtime_tab_instance.selected_zone][group_name])
        # UPDATED: Use the imported utility function
        min_freq, max_freq = calculate_frequency_range(all_zone_devices)
        
        if min_freq is not None and max_freq is not None:
            mock_marker_data = {'FREQ_MHZ': (min_freq + max_freq) / 2}
            Push_Marker_to_Start_Stop_Freq(mqtt_controller=showtime_tab_instance.mqtt_util, marker_data=mock_marker_data, buffer=(max_freq - min_freq) * 1e6)
        else:
            console_log("❌ Failed to tune: No valid frequencies found in selected zone.")
    else:
        # Case 4: No filters selected, tune to all markers
        if Local_Debug_Enable:
            debug_log(
                message="🔍 No filters selected. Tuning to start/stop frequency of all markers.",
                file=showtime_tab_instance.current_file,
                version=showtime_tab_instance.current_version,
                function=f"{self.__class__.__name__}.{current_function}",
                console_print_func=console_log
            )
        # UPDATED: Use the imported utility function
        min_freq, max_freq = calculate_frequency_range(showtime_tab_instance.marker_data)
        
        if min_freq is not None and max_freq is not None:
            mock_marker_data = {'FREQ_MHZ': (min_freq + max_freq) / 2}
            Push_Marker_to_Start_Stop_Freq(mqtt_controller=showtime_tab_instance.mqtt_util, marker_data=mock_marker_data, buffer=(max_freq - min_freq) * 1e6)
        else:
            console_log("❌ Failed to tune: No valid frequencies found in marker data.")

#####################################
### File: OPEN-AIR/workers/mqtt/worker_mqtt_controller_util.py
#####################################
# workers/worker_mqtt_controller_util.py
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# A utility module to handle the logic for interfacing with an external MQTT broker.
# This version refactors the client to centrally manage subscriptions and dispatch messages.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250902.100615.5
# FIXED: The publish_message function now correctly handles boolean False values. The check
#        for a valid value has been updated to prevent False from being interpreted as a missing value.

import os
import inspect
import datetime
import paho.mqtt.client as mqtt
import threading
import json
import pathlib
import sys
import queue

# --- Module Imports ---
# Path manipulation is now handled by main.py
from display.logger import debug_log, console_log, log_visa_command

print(f"DEBUG: Loading MqttControllerUtility from: {__file__}")

# --- Global Scope Variables (as per your instructions) ---
current_version = "20251213.000000.1" # Updated version based on current date
current_version_hash = (20251213 * 0 * 1) # Updated hash
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\\\", "/")
Local_Debug_Enable = True




# --- Constant Variables (No Magic Numbers) ---
# MQTT Broker settings
#BROKER_ADDRESS = "44.44.44.159"
BROKER_ADDRESS = "localhost"
BROKER_PORT = 1883
BROKER_TIMEOUT = 60
# Logging messages and colors
BROKER_RUNNING_MSG = "Broker is running"
BROKER_NOT_RUNNING_MSG = "Broker is not running"
NOT_CONNECTED_MSG = "Not connected to broker."
NO_TOPIC_OR_VALUE_MSG = "Please enter a topic and a value."


class MqttControllerUtility:
    """
    Manages all communication logic for the MQTT broker and client.
    This class is the central point for all functions to push a message or subscribe to messages.
    It adheres to the "Utilities" layer principles of your protocol.
    """
    def __init__(self, print_to_gui_func, log_treeview_func):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        if Local_Debug_Enable:
            debug_log(
                message=f"🛠️🟢 Initializing the '{self.__class__.__name__}' utility class. Powering up the flux capacitor!",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=print_to_gui_func
            )
        
        try:
            # --- Function logic goes here ---
            self.mqtt_client = None
            self._print_to_gui_console = print_to_gui_func
            self._log_to_treeview = log_treeview_func
            self.topics_seen = set()
            self._subscribers = {} # A new dictionary to hold subscribers and their callbacks
            # [A] New list to store pending subscriptions before connection is made.
            self._pending_subscriptions = {}
            self.publish_queue = queue.Queue()
            self._paused = False
            self._pause_lock = threading.Lock()

            console_log("✅ Celebration of success!")
        except Exception as e:
            self._print_to_gui_console(f"❌ Error in {current_function_name}: {e}") # Always show errors
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=self._print_to_gui_console
                )
            
    def add_subscriber(self, topic_filter: str, callback_func):
        """
        Stores a callback function for a given topic filter. Subscriptions are now
        processed in bulk after a successful connection.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        # [A] First, we store the subscription request.
        self._subscribers[topic_filter] = callback_func
        
        if Local_Debug_Enable:
            debug_log(
                message=f"🛠️🟢 Subscription request stored for topic filter: '{topic_filter}'.",
                file=current_file,
                version=current_version,
                function=current_function_name,
                console_print_func=self._print_to_gui_console
            )

        # [A] Only subscribe immediately if the client is already connected.
        if self.mqtt_client and self.mqtt_client.is_connected():
            self.mqtt_client.subscribe(topic_filter)
            if Local_Debug_Enable:
                debug_log(
                    message=f"🔍 Subscribed immediately to '{topic_filter}'.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.add_subscriber",
                    console_print_func=self._print_to_gui_console
                )
        # [A] If not connected, add it to the pending list for later.
        else:
            self._pending_subscriptions[topic_filter] = callback_func

    def on_connect(self, client, userdata, flags, rc):
        """
        Callback for when the MQTT client connects to the broker.
        We now subscribe to all stored topics here.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        if Local_Debug_Enable:
            debug_log(
                message=f"🛠️🔵 MQTT client connected with rc={rc}. Subscribing to all topics!",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self._print_to_gui_console
            )
        
        # [A] Subscribe to all stored topics on connection.
        if self._pending_subscriptions:
            for topic_filter in self._pending_subscriptions.keys():
                 client.subscribe(topic_filter)
            self._pending_subscriptions.clear()

        # We subscribe to a wildcard topic once to catch everything.
        client.subscribe("#")
        console_log(f"✅ Connected to broker with rc={rc}") # Informational

    def on_message(self, client, userdata, msg):
        """Callback for when an MQTT message is received."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        with self._pause_lock:
            if self._paused:
                if Local_Debug_Enable:
                    debug_log(
                        message=f"MQTT message for topic '{msg.topic}' received but processing is paused.",
                        file=current_file,
                        version=current_version,
                        function=f"{self.__class__.__name__}.{current_function_name}",
                        console_print_func=self._print_to_gui_console
                    )
                return # Do not process message if paused

        # We process the message payload here for all listeners
        topic = msg.topic
        payload = msg.payload.decode()
        self.topics_seen.add(topic)
        
        # Now we dispatch the message to all registered subscribers.
        for topic_filter, callback_func in list(self._subscribers.items()):
            # The paho-mqtt library provides a topic_matches_sub function to check for wildcards.
            if mqtt.topic_matches_sub(topic_filter, topic):
                #debug_log(
                #    message=f"🛠️🔵 Dispatching message to subscriber for topic '{topic_filter}'.",
                #    file=current_file,
                #    version=current_version,
                #    function=f"{self.__class__.__name__}.on_message",
                #    console_print_func=self._print_to_gui_console
                #)
                callback_func(topic, payload)


    def connect_mqtt(self):
        """Connects the MQTT client to the broker in a separate thread."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        if Local_Debug_Enable:
            debug_log(
                message=f"🛠️🟢 Entering '{current_function_name}' to connect MQTT client.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self._print_to_gui_console
            )
        try:
            self.mqtt_client = mqtt.Client()
            self.mqtt_client.on_connect = self.on_connect
            self.mqtt_client.on_message = self.on_message
            self.mqtt_client.connect(host=BROKER_ADDRESS, port=BROKER_PORT, keepalive=BROKER_TIMEOUT)
            
            receiver_thread = threading.Thread(target=self.mqtt_client.loop_forever, daemon=True)
            receiver_thread.start()

            transmitter_thread = threading.Thread(target=self._transmitter_thread, daemon=True)
            transmitter_thread.start()
            console_log("✅ MQTT client connection initiated in a background thread.") # Informational
        except Exception as e:
            self._print_to_gui_console(f"❌ Error in {current_function_name}: {e}") # Always show errors
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=self._print_to_gui_console
                )

    def _transmitter_thread(self):
        """
        A thread that continuously gets messages from the publish queue and publishes them.
        """
        while True:
            try:
                topic, subtopic, value, retain = self.publish_queue.get()
                if self.mqtt_client and self.mqtt_client.is_connected():
                    full_topic = f"{topic}/{subtopic}" if subtopic else topic
                    payload = json.dumps({"value": value})
                    self.mqtt_client.publish(full_topic, payload, retain=retain)
                    if Local_Debug_Enable:
                        console_log(f"Published to {full_topic}: {payload} with retain={retain}")
                else:
                    self._print_to_gui_console(f"❌ {NOT_CONNECTED_MSG}")
            except Exception as e:
                self._print_to_gui_console(f"❌ Error in _transmitter_thread: {e}")

    def show_topics(self):
        """Displays a list of all topics seen by the MQTT client."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        if Local_Debug_Enable:
            debug_log(
                message=f"🛠️🟢 Entering '{current_function_name}' to display topics.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self._print_to_gui_console
            )
        try:
            if self.topics_seen:
                                console_log(f"Observed Topics:\n{'\n'.join(sorted(self.topics_seen))}") # Informational
            else:
                console_log("⚠️ No topics observed yet.") # Warning

        except Exception as e:
            self._print_to_gui_console(f"❌ Error in {current_function_name}: {e}") # Always show errors
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=self._print_to_gui_console
                )

    def publish_message(self, topic: str, subtopic: str, value, retain=False):
        """Puts a message into the publish queue."""
        current_function_name = inspect.currentframe().f_code.co_name
        try:
            if not topic or (value is None and value != False and value != 0):
                self._print_to_gui_console(f"❌ {NO_TOPIC_OR_VALUE_MSG}")
                return
            self.publish_queue.put((topic, subtopic, value, retain))
        except Exception as e:
            self._print_to_gui_console(f"❌ Error in {current_function_name}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=self._print_to_gui_console
                )

    def subscribe_to_topic(self, topic, callback):
        # Subscribes to a given topic and registers a callback.
        # [A] The old logic here is no longer needed. The on_connect callback handles subscriptions.
        # [A] This method existed as a simple wrapper. The core logic has been moved to add_subscriber and on_connect.
        pass

    def purge_branch(self, base_topic):
        """Publishes a null, retained payload to all seen topics under a base topic."""
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🛠️🟢 Entering '{current_function_name}' to purge topics under '{base_topic}'.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=self._print_to_gui_console
        )
        try:
            if self.mqtt_client and self.mqtt_client.is_connected():
                
                topics_to_purge = [t for t in self.topics_seen if t.startswith(base_topic)]
                
                if not topics_to_purge:
                    # Also try to purge the base topic itself just in case
                    self.mqtt_client.publish(base_topic, payload=b'', retain=True)
                
                for topic in topics_to_purge:
                    self.mqtt_client.publish(topic, payload=b'', retain=True)

                self._print_to_gui_console(f"✅ Purge signal sent for {len(topics_to_purge)} topics under '{base_topic}'.")

            else:
                self._print_to_gui_console(f"❌ {NOT_CONNECTED_MSG}")

        except Exception as e:
            self._print_to_gui_console(f"❌ Error in {current_function_name}: {e}")

    def pause(self):
        """
        Pauses the processing of incoming MQTT messages.
        Messages will still be received by the client but not processed by the callbacks.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        with self._pause_lock:
            self._paused = True
            if Local_Debug_Enable:
                debug_log(
                    message="MQTT message processing paused.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=self._print_to_gui_console
                )

    def resume(self):
        """
        Resumes the processing of incoming MQTT messages.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        with self._pause_lock:
            self._paused = False
            if Local_Debug_Enable:
                debug_log(
                    message="MQTT message processing resumed.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=self._print_to_gui_console
                )



#####################################
### File: OPEN-AIR/workers/mqtt/worker_mqtt_data_flattening.py
#####################################
# workers/worker_mqtt_data_flattening.py
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# A utility module to process and flatten nested MQTT payloads into a format
# suitable for display in a flat table or export to CSV. It buffers incoming
# messages until a complete set is received, then pivots the data.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250825.151032.21

import os
import inspect
import json

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command

# --- Global Scope Variables ---
CURRENT_DATE = 20250825
CURRENT_TIME = 151032
CURRENT_TIME_HASH = 151032
REVISION_NUMBER = 21
current_version = "20250825.151032.21"
current_version_hash = 63895914278400
current_file = f"{os.path.basename(__file__)}"
Local_Debug_Enable = True


class MqttDataFlattenerUtility:
    """
    Manages the buffering and flattening of incoming MQTT messages based on dynamic
    topic identifiers.
    """
    def __init__(self, print_to_gui_func):
        self._print_to_gui_console = print_to_gui_func
        self.data_buffer = {}
        self.current_class_name = self.__class__.__name__
        self.last_unique_identifier = None
        self.FLUSH_COMMAND = "FLUSH_BUFFER"

    def clear_buffer(self):
        """
        Clears the internal data buffer.
        """
        if Local_Debug_Enable:
            debug_log(
                message="🛠️🔍 The data buffer has been wiped clean. A fresh start for our experiments!",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.clear_buffer",
                console_print_func=self._print_to_gui_console
            )
        self.data_buffer = {}
        self.last_unique_identifier = None

    def process_mqtt_message_and_pivot(self, topic: str, payload: str, topic_prefix: str) -> list:
        """
        Processes a single MQTT message. It triggers flattening when it detects the
        start of a new data set based on the unique identifier.

        Args:
            topic (str): The MQTT topic of the message.
            payload (str): The JSON payload of the message.
            topic_prefix (str): The root topic to be used for filtering.

        Returns:
            list: A list of dictionaries representing the flattened, pivoted data,
                  or an empty list if not all messages have been received.
        """
        current_function_name = inspect.currentframe().f_code.co_name

        # Check for the manual flush command
        if payload == self.FLUSH_COMMAND:
            if self.data_buffer:
                return self._flush_buffer()
            else:
                if Local_Debug_Enable:
                    debug_log(
                        message="🛠️🟡 Flush command received, but buffer is empty. Nothing to do.",
                        file=current_file,
                        version=current_version,
                        function=f"{self.__class__.__name__}.{current_function_name}",
                        console_print_func=self._print_to_gui_console
                    )
                return []
        
        try:
            data = json.loads(payload)
            
            # --- Corrected logic for 'Active' status check ---
            if topic.endswith('/Active') and isinstance(data, dict) and data.get('value') == 'false':
                console_log(f"🟡 Skipping transaction for '{topic}' because 'Active' is false.")
                self.clear_buffer()
                return []
            
            if Local_Debug_Enable:
                debug_log(
                    message=f"🛠️🔵 Received data for '{topic}'. Storing in buffer. Payload: {payload}",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=self._print_to_gui_console
                )

            # Extract the unique data set identifier (the second-to-last node)
            relative_topic = topic.replace(f"{topic_prefix}/", "", 1)
            identifier_path = relative_topic.rsplit('/', 1)[0]
            
            # This is the primary trigger for a new data set.
            if self.last_unique_identifier and identifier_path != self.last_unique_identifier:
                return self._flush_buffer(new_topic=topic, new_data=data, new_identifier=identifier_path)

            
            # If this is the very first message, set the first key name and buffer it
            if self.last_unique_identifier is None:
                self.last_unique_identifier = identifier_path

            # Add the message to the buffer
            self.data_buffer[topic] = data

            return []
            
        except json.JSONDecodeError as e:
            console_log(f"❌ Error decoding JSON payload for topic '{topic}': {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"🛠️🔴 The JSON be a-sailing to its doom! The error be: {e}",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=self._print_to_gui_console
                )
            self.clear_buffer()
            return []
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"🛠️🔴 Arrr, the code be capsized! The error be: {e}",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=self._print_to_gui_console
                )
            self.clear_buffer()
            return []

    def _flush_buffer(self, new_topic=None, new_data=None, new_identifier=None):
        """
        Processes and flattens the current buffer.
        """
        current_function_name = inspect.currentframe().f_code.co_name

        if Local_Debug_Enable:
            debug_log(
                message="🛠️🟢 Processing buffer and commencing pivoting and flattening!",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self._print_to_gui_console
            )
        
        flattened_data = {}
        flattened_data['Parameter'] = self.last_unique_identifier
        
        for t, p in self.data_buffer.items():
            data_key = t.rsplit('/', 1)[-1]
            
            value = None
            if isinstance(p, dict) and 'value' in p:
                value = p['value']
            elif isinstance(p, str):
                value = p
            
            if isinstance(value, str) and value.startswith('"') and value.endswith('"'):
                value = value.strip('"')
            
            if value is not None:
                flattened_data[data_key] = value

        self.clear_buffer()
        
        if new_topic and new_data:
            self.data_buffer[new_topic] = new_data
            self.last_unique_identifier = new_identifier
        
        if Local_Debug_Enable:
            debug_log(
                message="🛠️✅ Behold! I have transmogrified the data! The final payload is below.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self._print_to_gui_console
            )
        
        console_log(json.dumps(flattened_data, indent=2))
        return [flattened_data]

#####################################
### File: OPEN-AIR/workers/active/worker_active_marker_tune_and_collect.py
#####################################
# workers/worker_active_marker_tune_and_collect.py

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# This worker listens for a start command and then continuously loops through all
# markers from the repository, gets their peak values from the instrument, and
# updates the repository with the new peak data.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#


import os
import inspect
import json
import pathlib
import threading
import time

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility


# --- Global Scope Variables ---
current_version = "20251006.225130.6"
# The hash calculation drops the leading zero from the hour (e.g., 083015 becomes 83015).
current_version_hash = (20251006 * 225130 * 6)
current_file = f"{os.path.basename(__file__)}"
HZ_TO_MHZ = 1_000_000
Local_Debug_Enable = True





# --- NEW CONSTANT: Frequency Buffer (in MHz) ---
BUFFER_START_STOP_MHZ = 0.1

# --- MQTT Topic Constants (UPDATED FOR /IDENTITY NESTING) ---
# Control Topics
TOPIC_START_STOP = "OPEN-AIR/configuration/Start-Stop-Pause/Buttons/options/START/selected"

# Marker Repository Topics
TOPIC_MARKERS_ROOT = "OPEN-AIR/repository/markers"
TOPIC_TOTAL_DEVICES = f"{TOPIC_MARKERS_ROOT}/total_devices"
TOPIC_MIN_FREQ = f"{TOPIC_MARKERS_ROOT}/min_frequency_mhz"
TOPIC_MAX_FREQ = f"{TOPIC_MARKERS_ROOT}/max_frequency_mhz"

# FIX: Update topic to search for frequency inside the /IDENTITY node
TOPIC_DEVICE_FREQ_WILDCARD = f"{TOPIC_MARKERS_ROOT}/+/IDENTITY/FREQ_MHZ"


# YAK Frequency Topics
TOPIC_FREQ_START_INPUT = "OPEN-AIR/yak/Frequency/rig/Rig_freq_start_stop/scpi_inputs/start_freq/value"
TOPIC_FREQ_STOP_INPUT = "OPEN-AIR/yak/Frequency/rig/Rig_freq_start_stop/scpi_inputs/stop_freq/value"
TOPIC_FREQ_TRIGGER = "OPEN-AIR/yak/Frequency/rig/Rig_freq_start_stop/scpi_details/generic_model/trigger"

# YAK Marker Placement Topics
TOPIC_MARKER_PLACE_BASE = "OPEN-AIR/yak/Markers/beg/Beg_Place_All_markers/scpi_inputs"
TOPIC_MARKER_PLACE_TRIGGER = "OPEN-AIR/yak/Markers/beg/Beg_Place_All_markers/scpi_details/generic_model/trigger"

# YAK Marker Value Retrieval (NAB) Topics
TOPIC_MARKER_NAB_TRIGGER = "OPEN-AIR/yak/Markers/nab/NAB_all_marker_settings/scpi_details/generic_model/trigger"
TOPIC_MARKER_NAB_OUTPUT_WILDCARD = "OPEN-AIR/yak/Markers/nab/NAB_all_marker_settings/scpi_outputs/Marker_*/value"


class MarkerGoGetterWorker:
    """
    A worker that, when started, continuously fetches peak values for all markers.
    """
    def __init__(self, mqtt_util: MqttControllerUtility):
        # Initializes the worker, sets up state variables, and subscribes to topics.
        current_function_name = inspect.currentframe().f_code.co_name
        if Local_Debug_Enable:
            debug_log(
                message=f"🛠️🟢 Initializing the tireless Marker Go-Getter!",
                file=current_file, version=current_version, function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

        self.mqtt_util = mqtt_util
        self.processing_thread = None
        self.stop_event = threading.Event()

        # State variables populated by MQTT
        self.total_devices = 0
        self.min_frequency_mhz = 0.0
        self.max_frequency_mhz = 0.0
        self.marker_frequencies = {}
        
        # New variables to track frequency state for conditional updates
        self.last_min_freq = None
        self.last_max_freq = None
        self.first_run = True

        # For flow control signaling
        self.peaks_received_event = threading.Event() 

        self._setup_subscriptions()

    def _setup_subscriptions(self):
        # Subscribes to all topics required for operation.
        self.mqtt_util.add_subscriber(TOPIC_START_STOP, self._handle_start_stop)
        self.mqtt_util.add_subscriber(TOPIC_TOTAL_DEVICES, self._on_marker_data_update)
        self.mqtt_util.add_subscriber(TOPIC_MIN_FREQ, self._on_marker_data_update)
        self.mqtt_util.add_subscriber(TOPIC_MAX_FREQ, self._on_marker_data_update)
        # FIX: Subscribes to the new wildcard topic for marker frequency
        self.mqtt_util.add_subscriber(TOPIC_DEVICE_FREQ_WILDCARD, self._on_marker_data_update)
        
        # Subscribe to the NAB outputs directly to set the flow control event.
        # FIXED: This method was missing but is now the target of the NAB outputs.
        self.mqtt_util.add_subscriber(TOPIC_MARKER_NAB_OUTPUT_WILDCARD, self._on_peak_update_for_event_set)
        
        console_log("✅ Go-Getter is now listening for commands and marker data.")


    def _on_peak_update_for_event_set(self, topic, payload):
        """
        A placeholder method to satisfy the subscription. In a non-mock setup,
        this would signal a threading event to continue the main processing loop.
        """
        self.peaks_received_event.set()
        
    def _on_marker_data_update(self, topic, payload):
        # Callback to update internal state from the markers repository.
        try:
            # Safely attempt to extract value from a potential JSON payload
            try:
                value = json.loads(payload).get("value")
            except (json.JSONDecodeError, AttributeError):
                value = payload # Fallback to raw payload if not a JSON object

            if topic == TOPIC_TOTAL_DEVICES:
                self.total_devices = int(value)
            elif topic == TOPIC_MIN_FREQ:
                self.min_frequency_mhz = float(value)
            elif topic == TOPIC_MAX_FREQ:
                self.max_frequency_mhz = float(value)
            # FIX: Check if the topic structure matches a device frequency update inside /IDENTITY
            elif topic.endswith("/IDENTITY/FREQ_MHZ"):
                topic_parts = topic.split('/')
                # The Device-XXX ID is the third part from the end: .../Device-XXX/IDENTITY/FREQ_MHZ
                if len(topic_parts) >= 4 and topic_parts[-3].startswith("Device-"):
                    device_id = topic_parts[-3]
                    self.marker_frequencies[device_id] = float(value)
        except (json.JSONDecodeError, ValueError, TypeError) as e:
            console_log(f"🟡 Warning: Could not process marker data update from topic '{topic}': {e}")

    def _handle_start_stop(self, topic, payload):
        # Starts or stops the main processing loop in a separate thread.
        try:
            # Safely extract boolean value
            try:
                is_start_command = str(json.loads(payload).get("value")).lower() == 'true'
            except (json.JSONDecodeError, AttributeError):
                is_start_command = str(payload).lower() == 'true'

            if is_start_command and (self.processing_thread is None or not self.processing_thread.is_alive()):
                console_log("🟢 START command received. Beginning marker peak acquisition loop.")
                self.stop_event.clear()
                # Reset first run flag when starting a new sequence
                self.first_run = True
                self.processing_thread = threading.Thread(target=self._processing_loop, daemon=True)
                self.processing_thread.start()
            elif not is_start_command:
                console_log("🔴 STOP command received. Halting marker peak acquisition loop.")
                self.stop_event.set()
                if self.processing_thread and self.processing_thread.is_alive():
                    # Give the thread a moment to self-terminate gracefully
                    self.processing_thread.join(timeout=0.5) 
                self.processing_thread = None

        except (json.JSONDecodeError, ValueError, TypeError) as e:
            console_log(f"❌ Error processing start/stop command: {e}")

    
    def _place_markers_for_batch(self, batch_ids):
        """
        MODULAR FUNCTION: Sets the frequency of up to 6 markers and triggers the 
        placement command.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        # --- 1. Place Markers: Publish each marker's frequency (in Hz) ---
        for j, device_id in enumerate(batch_ids, 1):
            marker_topic = f"{TOPIC_MARKER_PLACE_BASE}/marker_{j}_freq_hz/value"
            freq_mhz = self.marker_frequencies.get(device_id, 0)
            freq_hz = int(freq_mhz * HZ_TO_MHZ)
            
            self.mqtt_util.publish_message(topic=marker_topic, subtopic="", value=freq_hz, retain=True)
            
            if Local_Debug_Enable:
                debug_log(
                    message=f"🐐🔵 Place Marker {j}: {device_id} sent {freq_mhz} MHz ({freq_hz} Hz).",
                    file=current_file, version=current_version, function=current_function_name,
                    console_print_func=console_log
                )
        
        time.sleep(0.2) # Short delay to let the place markers inputs set

        # --- 2. Trigger Place Markers command to set them on device ---
        self.mqtt_util.publish_message(TOPIC_MARKER_PLACE_TRIGGER, "", True, retain=False)
        self.mqtt_util.publish_message(TOPIC_MARKER_PLACE_TRIGGER, "", False, retain=False)
        
        # --- 3. CRITICAL FIX: Add recovery sleep to allow the crash to clear ---
        console_log("🟠 Recovering after Marker Placement to clear potential downstream crash...")
        time.sleep(0.3) # Allow 4 seconds for the internal exception/crash to resolve
        
    def _query_markers_for_batch(self, batch_ids):
        """
        NEW FUNCTION: Triggers the NAB query to read the marker peak values.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        # --- 1. Trigger NAB to collect current peaks ---
        console_log("🔵 Sending NAB query to retrieve current peak markers...")
        self.mqtt_util.publish_message(TOPIC_MARKER_NAB_TRIGGER, "", True, retain=False)
        self.mqtt_util.publish_message(TOPIC_MARKER_NAB_TRIGGER, "", False, retain=False)
        
        # --- 2. Flow Control: Wait for NAB query and publishing to complete ---
        console_log("🟠 Waiting for NAB query and publishing to complete...")
        time.sleep(0.2) # A minimal, safe wait to ensure messages hit the system.

        console_log(f"✅ Peak retrieval process initiated for batch: {', '.join(batch_ids)}.")
        
    def _set_instrument_frequency_span(self):
        """
        Sets the instrument to the full frequency span of all markers, 
        but only if the min/max frequency has changed or if it's the first run.
        """
        current_function_name = inspect.currentframe().f_code.co_name

        if (self.min_frequency_mhz == self.last_min_freq and
            self.max_frequency_mhz == self.last_max_freq and
            not self.first_run):
            
            if Local_Debug_Enable:
                debug_log(
                    message="🛠️🟡 Min/Max frequencies unchanged. Skipping span update.",
                    file=current_file, version=current_version, function=current_function_name,
                    console_print_func=console_log
                )
            return

        # Update last known state
        self.last_min_freq = self.min_frequency_mhz
        self.last_max_freq = self.max_frequency_mhz
    
        # --- APPLY THE BUFFER HERE ---
        # Add buffer to the maximum frequency
        new_max_freq = self.max_frequency_mhz + BUFFER_START_STOP_MHZ
        # Subtract buffer from the minimum frequency (ensuring it doesn't go below zero)
        new_min_freq = max(0, self.min_frequency_mhz - BUFFER_START_STOP_MHZ)
        
        console_log(f"🔵 Setting instrument span from {new_min_freq} MHz to {new_max_freq} MHz (with {BUFFER_START_STOP_MHZ} MHz buffer).")
        self.mqtt_util.publish_message(TOPIC_FREQ_START_INPUT, "", int(new_min_freq * HZ_TO_MHZ), retain=True)
        self.mqtt_util.publish_message(TOPIC_FREQ_STOP_INPUT, "", int(new_max_freq * HZ_TO_MHZ), retain=True)
        self.mqtt_util.publish_message(TOPIC_FREQ_TRIGGER, "", True, retain=False)
        self.mqtt_util.publish_message(TOPIC_FREQ_TRIGGER, "", False, retain=False)
        time.sleep(0.1) # Short delay to let the frequency rig command process
        
        self.first_run = False
        console_log("✅ Instrument span set successfully.")
        


    def _processing_loop(self):
        # The main logic loop that runs in a thread.
        console_log("✅ Peak Hunter loop started.")
        
        # --- Loop Control: Check the stop event first ---
        while not self.stop_event.is_set():
            # NOTE: Removed redundant check on TOPIC_START_STOP as stop_event handles thread control.
            
            # --- Step 1: Set the instrument to the full frequency span of all markers (Conditional) ---
            self._set_instrument_frequency_span()
            
            # --- Step 2: Loop through markers in batches of 6 ---
            device_ids = sorted(self.marker_frequencies.keys())

            for i in range(0, len(device_ids), 6):
                if self.stop_event.is_set():
                    console_log("Loop terminated by STOP command during batch processing.")
                    break

                batch_ids = device_ids[i:i+6]
                
                # Use the dedicated modular function to handle marker placement
                self._place_markers_for_batch(batch_ids=batch_ids)

                # --- DELAY as requested ---
                time.sleep(0.5)
                
                # Use the dedicated modular function to query the batch
                self._query_markers_for_batch(batch_ids=batch_ids)

                # --- Confirmation log and flow control ---
                console_log(f"✅ Batch {i//6 + 1} processed. Continuing to next batch.")


            console_log("✅ Peak Hunter loop finished a full pass.")
            


# --- TUNING HELPER FUNCTIONS (Moved from worker_marker_tune_to_marker.py) ---

def Push_Marker_to_Center_Freq(mqtt_controller, marker_data):
    """
    Publishes MQTT messages to set the instrument's center frequency and span
    based on a selected marker, and then triggers the SCPI command.
    """
    current_function = inspect.currentframe().f_code.co_name
    if Local_Debug_Enable:
        debug_log(
            message="🛠️🟢 Received request to tune to marker. Processing data...",
            file=current_file,
            version=current_version,
            function=f"{current_function}",
            console_print_func=console_log
        )

    try:
        # Define the MQTT topics as constants
        CENTER_FREQ_TOPIC = "OPEN-AIR/yak/Frequency/beg/Beg_freq_center_span/scpi_inputs/center_freq/value"
        SPAN_FREQ_TOPIC = "OPEN-AIR/yak/Frequency/beg/Beg_freq_center_span/scpi_inputs/span_freq/value"
        TRIGGER_TOPIC = "OPEN-AIR/yak/Frequency/beg/Beg_freq_center_span/scpi_details/generic_model/trigger"
        
        DEFAULT_SPAN_HZ = 1000000 # 1 MHz
        
        freq_mhz = marker_data.get('FREQ_MHZ', None)
        if freq_mhz is None:
            if Local_Debug_Enable:
                debug_log(
                    message="❌🔴 Error: Marker data is missing the 'FREQ_MHZ' key.",
                    file=current_file,
                    version=current_version,
                    function=f"{current_function}",
                    console_print_func=console_log
                )
            console_log("❌ Failed to tune: Marker data is incomplete.")
            return

        try:
            freq_mhz = float(freq_mhz)
            # FIX: Convert to integer for HZ value
            center_freq_hz = int(freq_mhz * HZ_TO_MHZ)
        except (ValueError, TypeError) as e:
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 Error converting frequency to float: {e}",
                    file=current_file,
                    version=current_version,
                    function=f"{current_function}",
                    console_print_func=console_log
                )
            console_log("❌ Failed to tune: Invalid frequency value.")
            return

        if Local_Debug_Enable:
            debug_log(
                message=f"🔍 Freq from marker: {freq_mhz} MHz -> {center_freq_hz} Hz. Setting Span to {DEFAULT_SPAN_HZ} Hz.",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
        
        # FIX: Ensure all values published are integers
        mqtt_controller.publish_message(topic=CENTER_FREQ_TOPIC, subtopic="", value=center_freq_hz)
        console_log(f"✅ Set CENTER_FREQ to {center_freq_hz} Hz.")
        
        mqtt_controller.publish_message(topic=SPAN_FREQ_TOPIC, subtopic="", value=int(DEFAULT_SPAN_HZ))
        console_log(f"✅ Set SPAN_FREQ to {int(DEFAULT_SPAN_HZ)} Hz.")
        
        mqtt_controller.publish_message(topic=TRIGGER_TOPIC, subtopic="", value=True)
        if Local_Debug_Enable:
            debug_log(
                message="🛠️🔵 Trigger set to True. Awaiting instrument response.",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
        
        mqtt_controller.publish_message(topic=TRIGGER_TOPIC, subtopic="", value=False)
        if Local_Debug_Enable:
            debug_log(
                message="🛠️🔵 Trigger reset to False. Command sequence complete.",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
        
        console_log("✅ Tuning command sequence complete.")

    except Exception as e:
        if Local_Debug_Enable:
            debug_log(
                message=f"❌🔴 Critical error during marker tuning: {e}",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
        console_log(f"❌ An error occurred while tuning to the marker: {e}")

def Push_Marker_to_Start_Stop_Freq(mqtt_controller, marker_data, buffer=1e6):
    """
    Calculates start and stop frequencies based on a marker frequency and a buffer,
    then publishes the values and triggers the SCPI command.
    """
    current_function = inspect.currentframe().f_code.co_name
    if Local_Debug_Enable:
        debug_log(
            message=f"🛠️🟢 Received request to tune with a buffer. Buffer is {buffer} Hz. Processing data...",
            file=current_file,
            version=current_version,
            function=f"{current_function}",
            console_print_func=console_log
        )

    try:
        # Define the MQTT topics as constants
        START_FREQ_TOPIC = "OPEN-AIR/yak/Frequency/beg/Beg_freq_start_stop/scpi_inputs/start_freq/value"
        STOP_FREQ_TOPIC = "OPEN-AIR/yak/Frequency/beg/Beg_freq_start_stop/scpi_inputs/stop_freq/value"
        START_STOP_TRIGGER_TOPIC = "OPEN-AIR/yak/Frequency/beg/Beg_freq_start_stop/scpi_details/generic_model/trigger"
        
        freq_mhz = marker_data.get('FREQ_MHZ', None)
        if freq_mhz is None:
            if Local_Debug_Enable:
                debug_log(
                    message="❌🔴 Error: Marker data is missing the 'FREQ_MHZ' key.",
                    file=current_file,
                    version=current_version,
                    function=f"{current_function}",
                    console_print_func=console_log
                )
            console_log("❌ Failed to tune: Marker data is incomplete.")
            return

        try:
            freq_mhz = float(freq_mhz)
            center_freq_hz = freq_mhz * HZ_TO_MHZ
        except (ValueError, TypeError) as e:
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 Error converting frequency to float: {e}",
                    file=current_file,
                    version=current_version,
                    function=f"{current_function}",
                    console_print_func=console_log
                )
            console_log("❌ Failed to tune: Invalid frequency value.")
            return

        # Calculate start and stop frequencies
        # FIX: Convert to integer for HZ value
        start_freq_hz = int(center_freq_hz - buffer)
        stop_freq_hz = int(center_freq_hz + buffer)

        if Local_Debug_Enable:
            debug_log(
                message=f"🔍 Calculated range: Start={start_freq_hz} Hz, Stop={stop_freq_hz} Hz.",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
        
        # Publish start frequency
        mqtt_controller.publish_message(topic=START_FREQ_TOPIC, subtopic="", value=start_freq_hz)
        console_log(f"✅ Set START_FREQ to {start_freq_hz} Hz.")
        
        # Publish stop frequency
        mqtt_controller.publish_message(topic=STOP_FREQ_TOPIC, subtopic="", value=stop_freq_hz)
        console_log(f"✅ Set STOP_FREQ to {stop_freq_hz} Hz.")
        
        # Trigger SCPI command
        mqtt_controller.publish_message(topic=START_STOP_TRIGGER_TOPIC, subtopic="", value=True)
        if Local_Debug_Enable:
            debug_log(
                message="🛠️🔵 Trigger set to True. Awaiting instrument response.",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
        
        # Reset the trigger
        mqtt_controller.publish_message(topic=START_STOP_TRIGGER_TOPIC, subtopic="", value=False)
        if Local_Debug_Enable:
            debug_log(
                message="🛠️🔵 Trigger reset to False. Command sequence complete.",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
        
        console_log("✅ Tuning command sequence complete.")

    except Exception as e:
        if Local_Debug_Enable:
            debug_log(
                message=f"❌🔴 Critical error during marker tuning with buffer: {e}",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
        console_log(f"❌ An error occurred while tuning to the marker with a buffer: {e}")

#####################################
### File: OPEN-AIR/workers/active/worker_active_peak_publisher.py
#####################################
# workers/worker_active_peak_publisher.py
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# A worker module that listens for marker frequency and amplitude outputs from the
# YAK repository and republishes the data to a new, deeply hierarchical topic
# structure based on the frequency (GHz down to 1s of kHz).
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251006.223430.3

import os
import inspect
import json
import threading
import re
import datetime
import math

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility

# --- Global Scope Variables (as per your instructions) ---
# NOTE: Version is updated to the current session time and revision 3
current_version = "20251006.223430.3"
# The hash calculation removes leading zeros, if any.
current_version_hash = (20251006 * 223430 * 3)
current_file = f"{os.path.basename(__file__)}"
Local_Debug_Enable = True

# --- Constants (No Magic Numbers) ---
# FIX: Using the single-level wildcard '+' to match the dynamic 'Marker_X' or 'Marker_X_freq' segment.
TOPIC_MARKER_PEAK_WILDCARD = "OPEN-AIR/yak/Markers/nab/NAB_all_marker_settings/scpi_outputs/+/value"
TOPIC_MARKER_FREQ_WILDCARD = "OPEN-AIR/yak/Markers/nab/NAB_all_marker_settings/scpi_outputs/+/value"
TOPIC_MEASUREMENTS_ROOT = "OPEN-AIR/measurements"
TOPIC_DELIMITER = "/"


class ActivePeakPublisher:
    """
    An event-driven worker that transforms flat marker data into a hierarchical
    topic structure based on frequency (GHz -> 100MHz -> 10MHz -> 1MHz -> 100kHz -> 10kHz -> 1kHz).
    """
    def __init__(self, mqtt_util: MqttControllerUtility):
        # Initializes the publisher and sets up subscriptions.
        current_function_name = inspect.currentframe().f_code.co_name

        if Local_Debug_Enable:
            debug_log(
                message=f"🛠️🟢 Initializing the Active Peak Publisher. Ready to pivot the data!",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

        self.mqtt_util = mqtt_util
        # Buffer to hold incomplete marker data (Peak or Freq only)
        # Key: Marker_ID (e.g., 'Marker_1'), Value: {'peak': float, 'freq_hz': float}
        self.marker_data_buffer = {}

        self._setup_subscriptions()
        console_log("✅ Active Peak Publisher is online and listening for marker data.")

    def _setup_subscriptions(self):
        # Subscribes to the wildcards for all marker peak and frequency values.
        self.mqtt_util.add_subscriber(TOPIC_MARKER_PEAK_WILDCARD, self._on_marker_message)
        self.mqtt_util.add_subscriber(TOPIC_MARKER_FREQ_WILDCARD, self._on_marker_message)
        
        if Local_Debug_Enable:
            debug_log(
                message=f"🔍 Subscribed to both peak and frequency wildcards.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}._setup_subscriptions",
                console_print_func=console_log
            )

    def _on_marker_message(self, topic, payload):
        # Primary callback to receive data, buffer it, and check for completeness.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Determine if it's a frequency or peak message
        # We look for the literal string 'freq' now, as the filter no longer guarantees a specific segment position.
        is_frequency = "freq" in topic
        
        # The Marker ID is the second-to-last part of the topic.
        # Example: .../Marker_1/value -> ['value', 'Marker_1', ...] -> Marker_1
        marker_id = topic.split(TOPIC_DELIMITER)[-2].replace('_freq', '') 
        
        # Extract the value safely
        try:
            # 1. Decode the entire JSON payload to a Python dictionary
            payload_dict = json.loads(payload)
            # 2. Extract the string value (e.g., "-6.219589233E+01")
            value_str = payload_dict.get("value")
            
            # 3. Attempt to convert the string value to a float
            numeric_value = float(value_str) 
            
        except (json.JSONDecodeError, ValueError, TypeError):
            # This block now captures errors from:
            # a) Invalid JSON structure (JSONDecodeError)
            # b) Missing 'value' key (TypeError/AttributeError from get("value") )
            # c) Unparsable number string (ValueError)
            if Local_Debug_Enable:
                debug_log(
                    message=f"🛠️🟡 Silent Skip: Unparsable payload '{payload}'.",
                    file=current_file,
                    version=current_version,
                    function=f"{__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
            return

        # Initialize marker entry if it doesn't exist
        if marker_id not in self.marker_data_buffer:
            self.marker_data_buffer[marker_id] = {'peak': None, 'freq_hz': None}

        # Update the buffer
        if is_frequency:
            self.marker_data_buffer[marker_id]['freq_hz'] = numeric_value
            data_type = "Frequency"
        else:
            self.marker_data_buffer[marker_id]['peak'] = numeric_value
            data_type = "Peak"

        if Local_Debug_Enable:
            debug_log(
                message=f"🛠️🔵 Buffered {data_type} for {marker_id}: {numeric_value}. Checking for pair...",
                file=current_file,
                version=current_version,
                function=f"{__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

        # Check if both peak and frequency are now available
        buffer_entry = self.marker_data_buffer[marker_id]
        if buffer_entry['peak'] is not None and buffer_entry['freq_hz'] is not None:
            # Full data set for this marker is ready for publishing
            self._republish_to_hierarchical_topic(
                marker_id=marker_id,
                freq_hz=buffer_entry['freq_hz'],
                peak_dbm=buffer_entry['peak']
            )
            # Clear the entry from the buffer
            del self.marker_data_buffer[marker_id]

    def _republish_to_hierarchical_topic(self, marker_id, freq_hz, peak_dbm):
        # Converts frequency in Hz to the required hierarchical topic structure and publishes.
        current_function_name = inspect.currentframe().f_code.co_name

        try:
            # Convert Hz to MHz for easier parsing (e.g., 612,345,000 Hz -> 612.345 MHz)
            freq_mhz = freq_hz / 1_000_000.0
            
            # --- Hierarchical Parsing ---
            
            # 1. Gigahertz (A)
            ghz = int(freq_mhz // 1000)
            freq_mhz_remainder = freq_mhz % 1000
            
            # 2. Hundreds of MHz (B)
            mhz_hundreds = int(freq_mhz_remainder // 100)
            mhz_remainder = freq_mhz_remainder % 100

            # 3. Tens of MHz (C)
            mhz_tens = int(mhz_remainder // 10)
            mhz_remainder = mhz_remainder % 10

            # 4. Ones of MHz (D)
            mhz_ones = int(mhz_remainder // 1)
            
            # 5. Kilohertz (E, F, G) - Convert remaining fraction to kHz
            khz_total = round((freq_mhz - int(freq_mhz)) * 1000.0, 0)
            
            khz_hundreds = int(khz_total // 100)
            khz_remainder = khz_total % 100
            
            khz_tens = int(khz_remainder // 10)
            khz_ones = int(khz_remainder % 10)
            
            # Final Frequency Breakdowns for the Topic Path: A/B/C/D/E/F/G
            # A: GHz
            # B: 100s of MHz
            # C: 10s of MHz
            # D: 1s of MHz
            # E: 100s of kHz
            # F: 10s of kHz
            # G: 1s of kHz
            
            topic_parts = [
                ghz,
                mhz_hundreds,
                mhz_tens,
                mhz_ones,
                khz_hundreds,
                khz_tens,
                khz_ones
            ]
            
            # Join the parts to form the topic path
            topic_path = TOPIC_DELIMITER.join(map(str, topic_parts))
            full_topic = f"{TOPIC_MEASUREMENTS_ROOT}/{topic_path}"
            
            
            # Final Payload for the leaf node (G)
            final_payload = {
                "Marker": marker_id,
                "Peak_dBm": round(peak_dbm, 2),
                "Source_Freq_MHz": round(freq_mhz, 6),
                "Timestamp": datetime.datetime.now().isoformat()
            }
            
            # Publish to the newly constructed hierarchical topic
            self.mqtt_util.publish_message(
                topic=full_topic,
                subtopic="",
                value=json.dumps(final_payload),
                retain=True
            )

            if Local_Debug_Enable:
                debug_log(
                    message=f"🐐💾 Reposted {marker_id} data to hierarchical topic.",
                    file=current_file,
                    version=current_version,
                    function=f"{__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
            console_log(f"✅ Reposted {marker_id} ({round(freq_mhz, 3)} MHz) to {full_topic}")

        except Exception as e:
            console_log(f"❌ Error during hierarchical republishing for {marker_id}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 Arrr, the code be capsized in republishing! The error be: {e}",
                    file=current_file,
                    version=current_version,
                    function=f"{__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

#####################################
### File: OPEN-AIR/workers/utils/connection_status_logic.py
#####################################
# workers/connection_status_logic.py
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# This file contains the core logic for updating the graphical user interface (GUI)
# elements based on the instrument's connection status and the current running state.
# It acts as a centralized function to enable or disable buttons and other widgets
# across various tabs, ensuring the UI accurately reflects the application's status.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250813.163700.1

import tkinter as tk
import inspect
import os

from display.debug_logic import debug_log
from display.console_logic import console_log

# --- Version Information ---
current_version = "20250813.163700.1"
current_version_hash = (20250813 * 163700 * 1)
Local_Debug_Enable = True


def update_connection_status_logic(app_instance, is_connected, is_running, console_print_func):
    """
    Updates the state (enabled/disabled) of various GUI elements across different tabs
    based on the instrument's connection status and the current running state.
    This function acts as a central dispatcher for UI state changes.
    """
    current_function = inspect.currentframe().f_code.co_name
    if Local_Debug_Enable:
        debug_log(f"Updating connection status. Connected: {is_connected}, Running: {is_running}. Version: {current_version}",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)

    # --- Instrument Tab ---
    if hasattr(app_instance, 'instrument_parent_tab') and hasattr(app_instance.instrument_parent_tab, 'instrument_settings_tab'):
        instrument_tab = app_instance.instrument_parent_tab.instrument_settings_tab
        if hasattr(instrument_tab, '_update_ui_state'):
            instrument_tab._update_ui_state()

    # --- Orchestrator GUI ---
    # CHANGED: Reference the new orchestrator_gui attribute
    if hasattr(app_instance, 'orchestrator_gui'):
        app_instance.orchestrator_gui._update_button_states()
        if Local_Debug_Enable:
            debug_log("Orchestrator GUI buttons updated.",
                        file=f"{os.path.basename(__file__)} - {current_version}",
                        version=current_version,
                        function=current_function)
    else:
        if Local_Debug_Enable:
            debug_log("Orchestrator GUI instance not found during status update.",
                        file=f"{os.path.basename(__file__)} - {current_version}",
                        version=current_version,
                        function=current_function)

    # --- Presets Tab ---
    if hasattr(app_instance, 'presets_parent_tab') and hasattr(app_instance.presets_parent_tab, 'device_presets_tab'):
        device_presets_tab = app_instance.presets_parent_tab.device_presets_tab
        if hasattr(device_presets_tab, 'handle_connection_status_change_event'):
            device_presets_tab.handle_connection_status_change_event()
            if Local_Debug_Enable:
                debug_log("Device Presets Tab notified of connection change.",
                            file=f"{os.path.basename(__file__)} - {current_version}",
                            version=current_version,
                            function=current_function)

    if Local_Debug_Enable:
        debug_log("Finished updating all UI elements based on connection status. UI is now responsive!",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)

#####################################
### File: OPEN-AIR/workers/utils/worker_project_paths.py
#####################################
# workers/worker_project_paths.py
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# A utility module for defining all application file paths relative to the project root,
# ensuring consistent file access across all sub-modules.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251013.212800.2

import os
import inspect
import pathlib
import sys


# --- Global Scope Variables (as per your instructions) ---
current_version = "20251013.212800.2"
# The hash calculation drops the leading zero from the hour (e.g., 083015 becomes 83015).
# The current time is 21:36:17
current_version_hash = (20251013 * 212800 * 2)
current_file = f"{os.path.basename(__file__)}"
Local_Debug_Enable = True

# --- Global Path Anchor ---
# In main.py, GLOBAL_PROJECT_ROOT is defined as the parent of the script being executed.
# Since this file is within the 'workers' directory, we must ascend one level up to the project root.
try:
    if getattr(sys, 'frozen', False) and hasattr(sys, '_MEIPASS'):
        # Running as a bundled executable
        GLOBAL_PROJECT_ROOT = pathlib.Path(sys.executable).parent
    else:
        # Running from source
        GLOBAL_PROJECT_ROOT = pathlib.Path(__file__).resolve().parent.parent.parent
except Exception as e:
    # Use a simple print or standard fallback in case of a critical error, but do NOT use debug_log here.
    print(f"❌ Critical Error establishing GLOBAL_PROJECT_ROOT in {current_file}: {e}")
    GLOBAL_PROJECT_ROOT = pathlib.Path(".")


# --- Core Project Paths (Relative to GLOBAL_PROJECT_ROOT) ---

# FIX: Correctly constructs path relative to the project root.
MARKERS_JSON_PATH = GLOBAL_PROJECT_ROOT / "DATA" / "MARKERS.json"
MARKERS_CSV_PATH = GLOBAL_PROJECT_ROOT / "DATA" / "MARKERS.csv"
YAKETY_YAK_REPO_PATH = GLOBAL_PROJECT_ROOT / "DATA" / "YAKETYYAK.json"
PRESET_REPO_PATH = GLOBAL_PROJECT_ROOT / "DATA" / "PRESET.csv"

def get_absolute_path(relative_path: str):
    """
    Utility function to return an absolute path for a string relative to the project root.
    """
    # [A brief, one-sentence description of the function's purpose.]
    current_function_name = inspect.currentframe().f_code.co_name
    
    # DELETED: debug_log(f"🛠️🟢 Resolving path for: {relative_path}", ...)
              
    try:
        absolute_path = GLOBAL_PROJECT_ROOT / relative_path
        # DELETED: console_log(f"✅ Resolved Path: {absolute_path}")
        return absolute_path

    except Exception as e:
        # DELETED: console_log and debug_log calls for error handling
        print(f"❌ Error in {current_function_name}: {e}")
        return pathlib.Path(relative_path) # Return a relative path as a fallback

#####################################
### File: OPEN-AIR/workers/utils/worker_recon_data_node_builder.py
#####################################
# workers/recon_data_publisher.py
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# A script to generate and publish MQTT topics from a CSV file,
# simulating a detailed frequency scan for the 'Recon' module.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250901.195300.3

import os
import inspect
import datetime
import csv
import json
import time
import re

# --- Module Imports ---
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from display.logger import debug_log, console_log, log_visa_command
import workers.utils.worker_project_paths

# --- Global Scope Variables ---
CURRENT_DATE = datetime.datetime.now().strftime("%Y%m%d")
CURRENT_TIME = datetime.datetime.now().strftime("%H%M%S")
# Note: For hashing, any leading zero in the hour is dropped (e.g., 083015 becomes 83015).
CURRENT_TIME_HASH = int(datetime.datetime.now().strftime("%H%M%S"))
REVISION_NUMBER = 3
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
current_file = f"{os.path.basename(__file__)}"
Local_Debug_Enable = True

# --- Constants ---
MQTT_ROOT_TOPIC = "OPEN-AIR/recon"
CSV_FILE_PATH = workers.worker_project_paths.GLOBAL_PROJECT_ROOT / "DATA" / "ThisIsMyScan_RBW10K_HOLD3_Offset0_20250729_091431.csv"


def recon_data_publisher(mqtt_util_instance, console_log_func):
    """
    Reads frequency and amplitude data from a CSV file and publishes it to
    MQTT topics with a predefined hierarchical structure.
    """
    current_function_name = inspect.currentframe().f_code.co_name
    if Local_Debug_Enable:
        debug_log(
            message=f"🛠️🟢 Entering '{current_function_name}' to begin publishing data from CSV.",
            file=current_file,
            version=current_version,
            function=current_function_name,
            console_print_func=console_log_func
        )

    try:
        if not mqtt_util_instance:
            console_log_func("❌ MQTT utility instance is not available. Cannot publish topics.")
            return
            
        if not os.path.exists(CSV_FILE_PATH):
            console_log_func(f"❌ Error: CSV file not found at '{CSV_FILE_PATH}'.")
            return

        with open(CSV_FILE_PATH, mode='r') as csv_file:
            csv_reader = csv.reader(csv_file)
            
            # Skip the header row if it exists
            header_row = next(csv_reader, None)
            if header_row and not re.match(r'^\d', header_row[0]):
                 console_log_func("ℹ️ Skipping CSV header row.")
            else:
                # If there's no header, reset the reader to the start of the file
                csv_file.seek(0)
            
            i = 0
            for row in csv_reader:
                try:
                    freq_mhz = float(row[0])
                    value_dbm = float(row[1])
                    
                    # Calculate frequency components directly from MHz
                    ghz = int(freq_mhz // 1000)
                    mhz_remainder = freq_mhz % 1000
                    
                    # Breakdown MHz into hundreds, tens, and ones
                    mhz_hundreds = int(mhz_remainder // 100)
                    mhz_tens = int((mhz_remainder % 100) // 10)
                    mhz_ones = int(mhz_remainder % 10)
                    
                    # Breakdown kHz into hundreds, tens, and ones
                    khz_total = int(round((mhz_remainder - int(mhz_remainder)) * 1000, 0))
                    khz_hundreds = int(khz_total // 100)
                    khz_tens = int((khz_total % 100) // 10)
                    khz_ones = int(khz_total % 10)
                    
                    # Construct the topic in an ordered sequence
                    topic_path = f"GHz/{ghz}/Mhz/{mhz_hundreds}/{mhz_tens}/{mhz_ones}/khz/{khz_hundreds}/{khz_tens}/{khz_ones}"
                    full_topic = f"{MQTT_ROOT_TOPIC}/{topic_path}"

                    # Generate the JSON payload
                    payload = {
                        "Value": value_dbm,
                        "time": datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                        "Device": 0
                    }

                    # Publish the message with the retain flag set to True
                    mqtt_util_instance.publish_message(
                        topic=full_topic,
                        subtopic="",
                        value=json.dumps(payload),
                        retain=True
                    )
                    
                    i += 1

                    # Display progress every 1000 messages
                    if i % 1000 == 0:
                        console_log_func(f"🔵 Progress: {i} topics published from CSV.")
                
                except (ValueError, IndexError) as e:
                    console_log_func(f"❌ Error processing row: {row}. Skipping. Error: {e}")
                    continue

        console_log_func(f"✅ Celebration of success! Published {i} topics from '{CSV_FILE_PATH}'.")

    except Exception as e:
        console_log_func(f"❌ Error in {current_function_name}: {e}")
        if Local_Debug_Enable:
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=current_function_name,
                console_print_func=console_log_func
            )

# Example Usage
if __name__ == "__main__":
    # In a real application, MqttControllerUtility would be passed from a parent
    # For this example, we'll create a mock utility that just prints to console
    class MockMqttUtility:
        def publish_message(self, topic, subtopic, value, retain=False):
            full_topic = f"{topic}/{subtopic}" if subtopic else topic
            console_log(f"Published (Retain={retain}) Topic: {full_topic}\nPayload: {value}\n")

    mock_mqtt_util = MockMqttUtility()
    recon_data_publisher(mock_mqtt_util, console_log)

#####################################
### File: OPEN-AIR/workers/utils/worker_visa_pre_flight_check.py
#####################################
# workers/worker_visa_pre_flight_check.py
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# A standalone utility script to scan all available VISA resources (USB, TCP/IP, Serial, etc.)
# and list them for diagnostic purposes.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251013.202759.4 (Added full dependency status report for USB/TCPIP components)

import os
import inspect
import datetime
import pyvisa
import sys

# --- Check Optional Dependencies for PyVISA-py ---
# PyVISA-py relies on these optional packages for full functionality.
try:
    import usb.core
    USB_SUPPORT = True
except ImportError:
    USB_SUPPORT = False
    
try:
    import psutil
    NETWORK_ALL_INTERFACES_SUPPORT = True
except ImportError:
    NETWORK_ALL_INTERFACES_SUPPORT = False

try:
    import zeroconf
    NETWORK_HISLIP_SUPPORT = True
except ImportError:
    NETWORK_HISLIP_SUPPORT = False


# --- Global Scope Variables (as per Protocol 4.4) ---
# W: 20251013, X: 202759, Y: 4
current_version = "20251013.202759.4"
# The hash calculation drops the leading zero from the hour (20 -> 20)
current_version_hash = (20251013 * 202759 * 4)
current_file = f"{os.path.basename(__file__)}"
Local_Debug_Enable = True

# --- Mock Logging Functions (for standalone operation) ---
def console_log(message):
    """Prints a user-facing message."""
    print(f"[PRE-FLIGHT] {message}")

def debug_log(message, file, version, function, console_print_func):
    """Prints a detailed debug log entry (mocked for simplicity)."""
    if "--debug" in sys.argv:
        print(f"DEBUG: {message} | {file} | {version} Function: {function}")

def list_visa_resources():
    # Lists all available VISA resources using PyVISA.
    current_function_name = inspect.currentframe().f_code.co_name
    if Local_Debug_Enable:
        debug_log(
            message="🖥️🟢 Entering list_visa_resources. Initiating full system resource scan.",
            file=current_file,
            version=current_version,
            function=current_function_name,
            console_print_func=console_log
        )

    # Determine which backend to try. We prioritize the pure-Python backend (@py).
    backend_to_use = '@py'
    
    try:
        # Initialize the Resource Manager, explicitly using the pure-Python backend.
        rm = pyvisa.ResourceManager(backend_to_use) 
        
        # Safely determine the loaded backend description
        try:
            # This path is generally only available for vendor backends (like NI-VISA)
            library_path = rm.library.path
            backend_info = f"{library_path}"
        except AttributeError:
            # If .library is not available, assume the pure-Python backend is loaded.
            backend_info = "PyVISA-py (pure Python backend)"

        console_log("Scanning all available VISA resources (USB, TCPIP, GPIB, ASRL/Serial)...")
        console_log(f"Using VISA Backend: {backend_info}")
        
        console_log("-" * 40)
        
        # --- Dependency Status Report ---
        console_log("Dependency Status Report:")
        
        # 1. USB Dependency Check
        if USB_SUPPORT:
            console_log("✅ USB Dependency (pyusb) is installed.")
        else:
            console_log("❌ USB Dependency (pyusb) is MISSING. USB device discovery may fail.")
            console_log("   Action: Run 'pip install pyusb' and ensure 'libusb' is installed on your OS.")
            
        # 2. TCP/IP Interface Discovery Check
        if NETWORK_ALL_INTERFACES_SUPPORT:
            console_log("✅ Network Dependency (psutil) is installed (enables all interface scanning).")
        else:
            console_log("🟡 Network Dependency (psutil) is MISSING. Discovery limited to default interface.")
            console_log("   Action: Run 'pip install psutil'.")

        # 3. HiSLIP (mDNS/ZeroConf) Dependency Check
        if NETWORK_HISLIP_SUPPORT:
            console_log("✅ HiSLIP Dependency (zeroconf) is installed.")
        else:
            console_log("🟡 HiSLIP Dependency (zeroconf) is MISSING. HiSLIP resource discovery is disabled.")
            console_log("   Action: Run 'pip install zeroconf'.")
            
        console_log("-" * 40)
        
        # list_resources() performs the actual scan.
        resources = rm.list_resources()

        if resources:
            console_log(f"✅ Found {len(resources)} VISA Resource(s):")
            for i, resource in enumerate(resources, 1):
                # Attempt to determine resource type from the resource string
                resource_type = resource.split("::")[0]
                console_log(f"  {i}. {resource} ({resource_type})")
        else:
            console_log("🟡 No VISA resources found on the system.")
            console_log("Note: If devices are connected, check device power and physical connection.")
        
        console_log("-" * 40)
        console_log("✅ Scan complete.")
        return resources

    except pyvisa.errors.LibraryError as e:
        console_log(f"❌ Error: PyVISA backend library failed to load with '{backend_to_use}'.")
        console_log("  Ensure 'pyvisa-py' is installed and its dependencies (like 'pyusb') are met.")
        console_log(f"  Details: {e}")
    except Exception as e:
        console_log(f"❌ UNEXPECTED ERROR during VISA scan: {type(e).__name__}: {e}")
        if Local_Debug_Enable:
            debug_log(
                message=f"🖥️🔴 VISA scan failed: {e}",
                file=current_file,
                version=current_version,
                function=current_function_name,
                console_print_func=console_log
            )
    return []

if __name__ == "__main__":
    # Execute the scan function when the script is run directly.
    list_visa_resources()

#####################################
### File: OPEN-AIR/workers/exporters/utils_csv_writer.py
#####################################
# workers/utils_csv_writer.py
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# This module provides utility functions for writing spectrum scan data to CSV files.
# It encapsulates the logic for handling file paths, directory creation, and data formatting
# for CSV output, ensuring consistent data storage for analysis and historical tracking.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
# Version 20250810.134500.1 (FIXED: Added app_instance_ref parameter and wrapped console calls with after() to prevent GIL errors.)

current_version = "20250810.134500.1" # this variable should always be defined below the header to make the debugging better
current_version_hash = 20250810 * 134500 * 1 # Example hash, adjust as needed
Local_Debug_Enable = True

import csv
import os
import inspect # Import inspect module

# Updated imports for new logging functions
from display.logger import debug_log, console_log

def write_scan_data_to_csv(file_path, header, data, app_instance_ref, append_mode=False, console_print_func=None):
    """
    Writes scan data to a CSV file. This function is designed to write raw frequency
    and amplitude data collected from the spectrum analyzer. It handles creating
    the necessary directory structure if it doesn't exist and conditionally writes
    the header.

    Inputs:
        file_path (str): The full path to the CSV file where the data will be written.
        header (list or None): A list of strings representing the CSV header row.
                               If None, no header will be written.
        data (list): A list of lists or tuples, where each inner list/tuple represents
                     a row of data (e.g., [frequency_MHz, level_dBm]).
        app_instance_ref (object): A reference to the main application instance.
        append_mode (bool): If True, data will be appended to the file if it exists.
                            If False, the file will be overwritten.
        console_print_func (function, optional): Function to use for console output.
                                                  Defaults to console_log if None.
    Raises:
        IOError: If there is an issue writing to the file.
    """
    console_print_func = console_print_func if console_print_func else console_log # Use console_log as default
    current_function = inspect.currentframe().f_code.co_name
    if Local_Debug_Enable:
        debug_log(f"Attempting to write scan data to CSV: {file_path}, append_mode={append_mode}. Let's save this data!",
                    file=__file__,
                    version=current_version,
                    function=current_function)

    # Ensure the directory exists
    output_dir = os.path.dirname(file_path)
    if output_dir and not os.path.exists(output_dir):
        try:
            os.makedirs(output_dir)
            if Local_Debug_Enable:
                debug_log(f"Created directory: {output_dir}. Path cleared!",
                            file=__file__,
                            version=current_version,
                            function=current_function)
        except OSError as e:
            error_msg = f"❌ Error creating directory '{output_dir}': {e}. This is a disaster!"
            # WRAPPED WITH after() to prevent cross-thread access
            app_instance_ref.after(0, lambda: console_print_func(error_msg))
            if Local_Debug_Enable:
                debug_log(error_msg,
                            file=__file__,
                            version=current_version,
                            function=current_function)
            raise IOError(f"Failed to create directory {output_dir}") from e

    try:
        # Determine the mode and if header needs to be written
        file_exists = os.path.exists(file_path)
        
        # If not in append_mode, or if in append_mode but file doesn't exist, open in write mode.
        # Otherwise, open in append mode.
        mode = 'a' if append_mode and file_exists else 'w'
        
        # Flag to indicate if header needs to be written
        # Write header ONLY if header is not None and we are creating a new file or overwriting
        write_header = (header is not None) and (mode == 'w')

        with open(file_path, mode, newline='') as csv_file:
            csv_writer = csv.writer(csv_file)
            
            if write_header:
                csv_writer.writerow(header)
                if Local_Debug_Enable:
                    debug_log(f"Wrote header to CSV file: {file_path}. Header added!",
                                file=__file__,
                                version=current_version,
                                function=current_function)
            
            # Write data rows
            for freq_MHz, level_dBm in data:
                csv_writer.writerow([f"{freq_MHz:.3f}", f"{level_dBm:.3f}"])
        # WRAPPED WITH after() to prevent cross-thread access
        app_instance_ref.after(0, lambda: console_print_func(f"✅ Scan data written to CSV: {file_path}. Data saved!"))
        if Local_Debug_Enable:
            debug_log(f"Scan data written to CSV: {file_path}. Mission accomplished!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
    except IOError as e:
        error_msg = f"❌ I/O Error writing to CSV file {file_path}: {e}. This is a disaster!"
        # WRAPPED WITH after() to prevent cross-thread access
        app_instance_ref.after(0, lambda: console_print_func(error_msg))
        if Local_Debug_Enable:
            debug_log(error_msg,
                        file=__file__,
                        version=current_version,
                        function=current_function)
        raise # Re-raise to allow higher-level error handling
    except Exception as e:
        error_msg = f"❌ An unexpected error occurred while writing to CSV file {file_path}: {e}. What a mess!"
        # WRAPPED WITH after() to prevent cross-thread access
        app_instance_ref.after(0, lambda: console_print_func(error_msg))
        if Local_Debug_Enable:
            debug_log(error_msg,
                        file=__file__,
                        version=current_version,
                        function=current_function)
        raise # Re-raise to allow higher-level error handling

#####################################
### File: OPEN-AIR/workers/exporters/worker_file_csv_export.py
#####################################
# workers/worker_file_csv_export.py
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# A utility module to handle the logic for exporting data to a CSV file.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.120616.1

import csv
import inspect
import os

from display.logger import debug_log, console_log, log_visa_command

# --- Global Scope Variables ---
CURRENT_DATE = 20250824
CURRENT_TIME = 120616
CURRENT_TIME_HASH = 120616
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
current_file = f"{os.path.basename(__file__)}"
Local_Debug_Enable = True


class CsvExportUtility:
    """
    A utility class to handle CSV file export logic.
    """
    def __init__(self, print_to_gui_func):
        self._print_to_gui_console = print_to_gui_func

    def export_data_to_csv(self, data, file_path):
        """
        Exports a list of dictionaries to a CSV file.
        
        Args:
            data (list of dict): The data to export. Each dictionary represents a row.
            file_path (str): The path to the output CSV file.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        if Local_Debug_Enable:
            debug_log(
                message=f"🛠️🟢 Entering '{current_function_name}' to save data to CSV at '{file_path}'.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self._print_to_gui_console
            )
        
        try:
            if not data:
                console_log("❌ No data to export.")
                return

            # Grab the headers from the first dictionary's keys
            headers = data[0].keys()
            
            with open(file_path, 'w', newline='', encoding='utf-8') as csvfile:
                writer = csv.DictWriter(csvfile, fieldnames=headers)
                writer.writeheader()
                writer.writerows(data)
                
            console_log(f"✅ Data successfully exported to {file_path}")
            
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=self._print_to_gui_console
                )

#####################################
### File: OPEN-AIR/workers/builder/dynamic_gui_MQTT_subscriber.py
#####################################
# display/builder/dynamic_gui_MQTT_subscriber.py
#
# A mixin for DynamicGuiBuilder that handles MQTT subscription and message processing.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk, scrolledtext
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from display.styling.style import THEMES, DEFAULT_THEME


# --- Global Scope Variables ---
current_version = "20251127.000000.1"
current_version_hash = (20251127 * 0 * 1)
current_file = f"{os.path.basename(__file__)}"

# --- Constants ---
TOPIC_DELIMITER = "/"

Local_Debug_Enable = True


class MqttSubscriberMixin:
    """
    A mixin for the DynamicGuiBuilder to handle MQTT subscription and message processing.
    """
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        # This instance variable will be set in the DynamicGuiBuilder's __init__
        self.mqtt_util = None

    def _on_receive_command_message(self, topic, payload):
        # The main callback function that processes incoming MQTT messages.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Entering _on_receive_command_message() for topic: '{topic}' with payload: '{payload}'.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            if topic.startswith(self.base_topic):
                relative_topic = topic[len(self.base_topic):].strip(TOPIC_DELIMITER)
                
                if not relative_topic:
                    # Case 1: The full configuration JSON is received on the base topic.
                    try:
                        full_config = json.loads(payload)
                        if isinstance(full_config, dict):
                            self.config_data = full_config
                            # Note: _rebuild_gui is NOT called here by design, as local JSON is authoritative.
                            debug_log(
                                message=f"🖥️🔵 Full config received for base topic '{self.base_topic}'. Config data updated, but GUI not auto-rebuilt (local JSON is authoritative).",
                                file=current_file,
                                version=current_version,
                                function=f"{self.__class__.__name__}.{current_function_name}",
                                console_print_func=console_log
                            )
                            return
                    except (json.JSONDecodeError, TypeError):
                        pass

                # Case 2: An incremental update is received on a subtopic.
                path_parts = relative_topic.split(TOPIC_DELIMITER)
                self._update_nested_dict(path_parts, payload)
                
                # Only update the widget if the GUI has already been built.
                if self.gui_built:
                    self.after(0, self._update_widget_value, relative_topic, payload)

            debug_log(
                message=f"🖥️🔵 Exiting _on_receive_command_message() for topic: '{topic}'.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized in _on_receive_command_message! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


def log_to_gui(builder_instance, message):
    """
    Appends a message to the GUI log text widget if it exists.
    """
    current_function_name = inspect.currentframe().f_code.co_name
    
    debug_log(
        message=f"🔍🔵 Entering '{current_function_name}'. Inspecting log entry of length {len(message)}. Preparing to write to GUI.",
        file=current_file,
        version=current_version,
        function=current_function_name,
        console_print_func=console_log
    )
    
    try:
        if hasattr(builder_instance, 'log_text'):
            builder_instance.log_text.configure(state='normal')
            builder_instance.log_text.insert(tk.END, message + "\n\n")
            builder_instance.log_text.configure(state='disabled')
            builder_instance.log_text.see(tk.END)
            
        console_log("✅ Celebration of success! The log message did save to the GUI!")
        debug_log(
            message=f"🔍🔵 Exiting '{current_function_name}'. Log message written to GUI.",
            file=current_file,
            version=current_version,
            function=current_function_name,
            console_print_func=console_log
        )
            
    except Exception as e:
        console_log(f"❌ Error in {current_function_name}: {e}")
        debug_log(
            message=f"❌🔴 Arrr, the code be capsized! The logging to GUI has failed! The error be: {e}",
            file=current_file,
            version=current_version,
            function=current_function_name,
            console_print_func=console_log
        )

#####################################
### File: OPEN-AIR/workers/builder/dynamic_gui_builder.py
#####################################
# workers/builder/dynamic_gui_builder.py
#
# This dynamic GUI builder component (dynamic_gui_builder.py) orchestrates building widgets based on a JSON data structure received via MQTT.
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 44 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#


import os
import sys
import inspect
import datetime
import tkinter as tk
from tkinter import ttk, scrolledtext
import json
import paho.mqtt.client as mqtt
import pathlib # CRITICAL FIX: Missing import

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from display.styling.style import THEMES, DEFAULT_THEME
from .dynamic_gui_MQTT_subscriber import MqttSubscriberMixin
from .dynamic_gui_config_loader import get_json_filepath_from_base_topic # NEW IMPORT
from .dynamic_gui_mousewheel_mixin import MousewheelScrollMixin # NEW IMPORT

# --- Widget Creator Mixin Imports ---
from .dynamic_gui_create_label import LabelCreatorMixin
from .dynamic_gui_create_label_from_config import LabelFromConfigCreatorMixin
from .dynamic_gui_create_value_box import ValueBoxCreatorMixin
from .dynamic_gui_create_gui_slider_value import SliderValueCreatorMixin
from .dynamic_gui_create_gui_button_toggle import GuiButtonToggleCreatorMixin
from .dynamic_gui_create_gui_button_toggler import GuiButtonTogglerCreatorMixin
from .dynamic_gui_create_gui_dropdown_option import GuiDropdownOptionCreatorMixin
from .dynamic_gui_create_gui_actuator import GuiActuatorCreatorMixin
from .dynamic_gui_create_gui_checkbox import GuiCheckboxCreatorMixin
from .dynamic_gui_create_gui_listbox import GuiListboxCreatorMixin


# --- Global Scope Variables ---
current_file = f"{os.path.basename(__file__)}"

# --- Constants ---
TOPIC_DELIMITER = "/"
DEFAULT_PAD_X = 5
DEFAULT_PAD_Y = 2
DEFAULT_FRAME_PAD = 5
BUTTON_PADDING_MULTIPLIER = 5
BUTTON_BORDER_MULTIPLIER = 2
Local_Debug_Enable = True # This flag is checked by the updated debug_log and console_log functions
TITLE_FONT = ('Helvetica', 12, 'bold')
SECTION_FONT = ('Helvetica', 11, 'bold')


# The wrapper functions debug_log and console_log_switch are removed
# as the core debug_log and console_log now directly handle Local_Debug_Enable.

class DynamicGuiBuilder(
    ttk.Frame,
    MqttSubscriberMixin,
    MousewheelScrollMixin, # NEW MIXIN
    LabelCreatorMixin,
    LabelFromConfigCreatorMixin,
    ValueBoxCreatorMixin,
    SliderValueCreatorMixin,
    GuiButtonToggleCreatorMixin,
    GuiButtonTogglerCreatorMixin,
    GuiDropdownOptionCreatorMixin,
    GuiActuatorCreatorMixin,
    GuiCheckboxCreatorMixin,
    GuiListboxCreatorMixin
):
    """
    Dynamically builds GUI widgets based on a JSON data structure received via MQTT.
    """
    def __init__(self, parent, mqtt_util, config, *args, **kwargs):
        # Initializes the GUI builder, sets up the layout, and subscribes to the MQTT topic.
        current_function_name = inspect.currentframe().f_code.co_name
        self.current_class_name = self.__class__.__name__

        if Local_Debug_Enable:
            debug_log(
                message=f"🖥️🟢 Eureka! The grand experiment begins! Initializing the {self.current_class_name} for topic '{config.get('base_topic')}'.",
                file=current_file,
                version=current_version,
                function=f"{self.current_class_name}.{current_function_name}",
                console_print_func=console_log
            )
        try:
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            self.mqtt_util = mqtt_util
            self.config = config
            self.base_topic = config.get("base_topic")
            self.topic_widgets = {}

            self.config_data = {}
            self.gui_built = False # Flag to track if GUI has been built.
            self.log_text = None
            
            self.widget_factory = {
                "_sliderValue": self._create_slider_value,
                "_GuiButtonToggle": self._create_gui_button_toggle,
                "_buttonToggle": self._create_gui_button_toggle,
                "_GuiDropDownOption": self._create_gui_dropdown_option,
                "_DropDownOption": self._create_gui_dropdown_option,
                "_GuiButtonToggler": self._create_gui_button_toggler,
                "_Value": self._create_value_box,
                "_Label": self._create_label_from_config,
                "_GuiActuator": self._create_gui_actuator,
                "_GuiCheckbox": self._create_gui_checkbox,
                "_GuiListbox": self._create_gui_listbox
            }

            self._apply_styles(theme_name=DEFAULT_THEME)
            colors = THEMES.get(DEFAULT_THEME, THEMES["dark"])

            self.main_content_frame = ttk.Frame(self)
            self.main_content_frame.pack(fill=tk.BOTH, expand=True)

            self.canvas = tk.Canvas(self.main_content_frame, borderwidth=0, highlightthickness=0, background=colors["bg"])
            self.scroll_frame = ttk.Frame(self.canvas)
            self.canvas.create_window((0, 0), window=self.scroll_frame, anchor="nw")

            scrollbar = ttk.Scrollbar(self.main_content_frame, orient=tk.VERTICAL, command=self.canvas.yview)
            self.canvas.configure(yscrollcommand=scrollbar.set)
            self.scroll_frame.bind("<Configure>", lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all")))

            self.config_frame = ttk.Frame(self.scroll_frame)
            self.config_frame.pack(fill=tk.X, expand=True, padx=DEFAULT_FRAME_PAD, pady=DEFAULT_FRAME_PAD)

            self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
            scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

            # --- Bind Mousewheel Scrolling ---
            self.scroll_frame.bind("<Enter>", self._bind_mousewheel)
            self.scroll_frame.bind("<Leave>", self._unbind_mousewheel)

            # Attempt to load initial configuration from a JSON file
            json_filepath = get_json_filepath_from_base_topic(
                base_topic=self.base_topic,
                class_name=self.current_class_name,
                calling_file=current_file,
                calling_version=current_version,
                console_print_func=console_log
            )
            if json_filepath and json_filepath.is_file():
                try:
                    with open(json_filepath, 'r') as f:
                        self.config_data = json.load(f)
                    debug_log(
                        message=f"🖥️🔵 Successfully loaded initial configuration from {json_filepath}.",
                        file=current_file,
                        version=current_version,
                        function=f"{self.current_class_name}.{current_function_name}",
                        console_print_func=console_log
                    )
                    # Perform initial GUI build from the loaded JSON data
                    self._rebuild_gui()
                    self.gui_built = True # Mark GUI as built after initial load
                except Exception as e:
                    console_log(f"❌ Error loading initial config from {json_filepath}: {e}")
                    if Local_Debug_Enable:
                        debug_log(
                            message=f"🖥️🔴 Failed to load initial config from {json_filepath}. Error: {e}",
                            file=current_file,
                            version=current_version,
                            function=f"{self.current_class_name}.{current_function_name}",
                            console_print_func=console_log
                        )
            else:
                if Local_Debug_Enable:
                    debug_log(
                        message=f"⚠️ Warning: No initial JSON config file found for base_topic: {self.base_topic}. GUI will build upon first MQTT message.",
                        file=current_file,
                        version=current_version,
                        function=f"{self.current_class_name}.{current_function_name}",
                        console_print_func=console_log
                    )

            self.bind("<Map>", self._on_map_event)

            if self.base_topic:
                self.mqtt_util.add_subscriber(topic_filter=f"{self.base_topic}/#", callback_func=self._on_receive_command_message)

            console_log("✅ Celebration of success! The Dynamic GUI builder did initialize successfully!")
            if Local_Debug_Enable:
                debug_log(
                    message=f"🖥️🟢 Exiting {self.current_class_name}.__init__().",
                    file=current_file,
                    version=current_version,
                    function=f"{self.current_class_name}.{current_function_name}",
                    console_print_func=console_log
                )

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"🖥️🔴 The monster is throwing a tantrum! GUI rebuild failed! The error be: {e}",
                    file=current_file,
                    version=current_version,
                    function=f"{self.current_class_name}.{current_function_name}",
                    console_print_func=console_log
                )

    def _on_map_event(self, event=None):
        """Builds the GUI if it hasn't been built yet."""
        current_function_name = inspect.currentframe().f_code.co_name
        if not self.gui_built:
            if Local_Debug_Enable:
                debug_log(
                    message=f"🖥️🔵 First time mapping event for {self.base_topic}. Building GUI.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.current_class_name}.{current_function_name}",
                    console_print_func=console_log
                )
            self._rebuild_gui()
            self.gui_built = True
        else:
            if Local_Debug_Enable:
                debug_log(
                    message=f"🖥️🔵 GUI for {self.base_topic} already built. Skipping rebuild on map event.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.current_class_name}.{current_function_name}",
                    console_print_func=console_log
                )



    def _transmit_command(self, relative_topic, payload, retain=False):
        """
        A helper function to publish a command to the MQTT broker.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        if Local_Debug_Enable:
            debug_log(
                message=f"MQTT TX: Publishing '{payload}' to '{relative_topic}' (retain={retain}).",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
        self.mqtt_util.publish_message(topic=relative_topic, subtopic="", value=payload, retain=retain)


    def _update_nested_dict(self, path_parts, value):
        # Recursively traverses the dictionary structure and sets the value at the final key.
        current_level = self.config_data
        for part in path_parts[:-1]:
            current_level = current_level.setdefault(part, {})

        final_value = value
        if isinstance(value, str):
            try:
                data = json.loads(value)
                if isinstance(data, dict) and 'value' in data:
                    final_value = data['value']
            except (json.JSONDecodeError, TypeError):
                pass

        if isinstance(final_value, str):
            try:
                final_value = json.loads(final_value)
            except (json.JSONDecodeError, TypeError):
                pass

        if isinstance(final_value, str):
            if final_value.lower() == 'true':
                final_value = True
            elif final_value.lower() == 'false':
                final_value = False

        last_key = path_parts[-1]
        parent_dict = current_level.get(path_parts[-2]) if len(path_parts) > 1 else self.config_data

        if isinstance(parent_dict, dict) and parent_dict.get('type') == '_GuiButtonToggle':
            is_on = final_value
            if 'options' in parent_dict:
                for option_key, option_config in parent_dict['options'].items():
                    if option_key.upper() == 'ON':
                        option_config['selected'] = is_on
                    elif option_key.upper() == 'OFF':
                        option_config['selected'] = not is_on
        elif isinstance(parent_dict, dict) and parent_dict.get('type') == '_GuiCheckbox':
            parent_dict['value'] = final_value
        else:
            current_level[last_key] = final_value

    def _rebuild_gui(self):
        # Clears the main frame and rebuilds all widgets from the current config_data.
        current_function_name = inspect.currentframe().f_code.co_name
        if Local_Debug_Enable:
            debug_log(
                message=f"🖥️🔵 It's alive! Rebuilding the GUI with the latest configuration data.",
                file=current_file,
                version=current_version,
                function=f"{self.current_class_name}.{current_function_name}",
                console_print_func=console_log
            )
        try:
            for widget in self.config_frame.winfo_children():
                widget.destroy()
            self.topic_widgets.clear()
            self._create_dynamic_widgets(parent_frame=self.config_frame, data=self.config_data)

            rebuild_button = ttk.Button(self.config_frame, text="Rebuild GUI")
            rebuild_button.pack(pady=10)
            rebuild_button.configure(command=self._rebuild_gui)

            console_log("✅ Celebration of success! The GUI did rebuild itself from the aggregated data!")
            if Local_Debug_Enable:
                debug_log(
                    message=f"🖥️🔵 Exiting _rebuild_gui(). GUI rebuild completed.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.current_class_name}.{current_function_name}",
                    console_print_func=console_log
                )
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"🖥️🔴 The monster is throwing a tantrum! GUI rebuild failed! The error be: {e}",
                    file=current_file,
                    version=current_version,
                    function=f"{self.current_class_name}.{current_function_name}",
                    console_print_func=console_log
                )

    def _apply_styles(self, theme_name):
        # Applies the specified theme to the GUI elements using ttk.Style.
        current_function_name = inspect.currentframe().f_code.co_name
        if Local_Debug_Enable:
            debug_log(
                message=f"Entering {current_function_name} with arguments: {theme_name}",
                file=current_file,
                version=current_version,
                function=f"{self.current_class_name}.{current_function_name}",
                console_print_func=console_log
            )
        try:
            colors = THEMES.get(theme_name, THEMES["dark"])
            style = ttk.Style(self)
            style.theme_use("clam")

            # Get button-specific colors from the new, centralized dictionary
            # FIX: We are no longer using button_style, but rather the specific
            # dictionaries defined in style.py
            actuator_colors = colors["button_style_actuator"]
            toggle_colors = colors["button_style_toggle"]
            toggler_colors = colors["button_style_toggler"]

            style.configure('TFrame', background=colors["bg"])
            style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
            style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])

            # --- Corrected Button Styling for all three types ---
            # Define a custom style for the actuator buttons
            style.configure('Custom.TButton',
                            background=actuator_colors["background"],
                            foreground=actuator_colors["foreground"],
                            padding=colors["padding"] * BUTTON_PADDING_MULTIPLIER,
                            relief=colors["relief"],
                            borderwidth=0,
                            justify=tk.CENTER)

            style.map('Custom.TButton',
                      background=[('pressed', actuator_colors["Button_Pressed_Bg"]),
                                  ('active', actuator_colors["Button_Hover_Bg"])],
                      foreground=[('pressed', toggle_colors["Button_Selected_Fg"])])

            # Configure a separate style for the selected/toggled-on state
            style.configure('Custom.Selected.TButton',
                            background=toggle_colors["Button_Selected_Bg"],
                            foreground=toggle_colors["Button_Selected_Fg"],
                            padding=colors["padding"] * BUTTON_PADDING_MULTIPLIER,
                            relief=tk.SUNKEN,
                            borderwidth=0,
                            justify=tk.CENTER)
            
            style.map('Custom.Selected.TButton',
                      background=[('pressed', toggle_colors["Button_Pressed_Bg"]),
                                  ('active', toggle_colors["Button_Hover_Bg"])],
                      foreground=[('pressed', toggle_colors["Button_Selected_Fg"])])
            # --- End Corrected Button Styling ---

            style.configure('Debug.TLabel', background=colors["bg"], foreground=colors["fg_alt"])

            textbox_style = colors["textbox_style"]
            style.configure('Custom.TEntry',
                                      font=(textbox_style["Textbox_Font"], textbox_style["Textbox_Font_size"]),
                                 foreground=textbox_style["Textbox_Font_colour"],
                                 background=textbox_style["Textbox_BG_colour"],
                                 fieldbackground=textbox_style["Textbox_BG_colour"],
                                 bordercolor=textbox_style["Textbox_border_colour"])
            console_log("✅ Celebration of success! The styles did apply themselves beautifully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"🖥️🔴 By Jove, the style potion has curdled! The error be: {e}",
                    file=current_file,
                    version=current_version,
                    function=f"{self.current_class_name}.{current_function_name}",
                    console_print_func=console_log
                )

    def _create_dynamic_widgets(self, parent_frame, data, path_prefix=""):
        # Recursively creates widgets, tracking the topic path.
        current_function_name = inspect.currentframe().f_code.co_name
        if Local_Debug_Enable:
            debug_log(
                message=f"🖥️🔵 Entering _create_dynamic_widgets() for path_prefix: '{path_prefix}'.",
                file=current_file,
                version=current_version,
                function=f"{self.current_class_name}.{current_function_name}",
                console_print_func=console_log
            )
        try:
            if not isinstance(data, dict):
                if Local_Debug_Enable:
                    debug_log(
                        message=f"⚠️ Skipping _create_dynamic_widgets as data is not a dict for path_prefix: '{path_prefix}'.",
                        file=current_file,
                        version=current_version,
                        function=f"{self.__class__.__name__}.{current_function_name}",
                        console_print_func=console_log
                    )
                return

            for key, value in data.items():
                if isinstance(value, str):
                    try:
                        value = json.loads(value)
                    except json.JSONDecodeError:
                        pass

                safe_key = key.replace(TOPIC_DELIMITER, '_')
                current_path = f"{path_prefix}{TOPIC_DELIMITER}{safe_key}" if path_prefix else safe_key

                if isinstance(value, dict):
                    widget_type = value.get("type")
                    label_text = value.get("label", key.replace('_', ' ').title())

                    if widget_type == "OcaBlock":
                        nested_frame = ttk.Frame(parent_frame)
                        nested_frame.pack(fill=tk.X, expand=True, padx=DEFAULT_FRAME_PAD, pady=(DEFAULT_FRAME_PAD, DEFAULT_FRAME_PAD * 2))
                        label_widget = ttk.Label(nested_frame, text=label_text, font=TITLE_FONT)
                        label_widget.pack(anchor='w', padx=DEFAULT_PAD_X, pady=2)
                        separator = ttk.Separator(nested_frame, orient='horizontal')
                        separator.pack(fill='x', pady=2)
                        self._create_dynamic_widgets(nested_frame, value.get("fields", {}), path_prefix=current_path)
                        continue

                    creation_func = self.widget_factory.get(widget_type)
                    if creation_func:
                        if 'value' in value:
                            creation_func(parent_frame=parent_frame, label=label_text, config=value, path=f"{current_path}{TOPIC_DELIMITER}value")
                        else:
                            creation_func(parent_frame=parent_frame, label=label_text, config=value, path=current_path)
                        continue

                    nested_frame = ttk.Frame(parent_frame)
                    nested_frame.pack(fill=tk.X, expand=True, padx=DEFAULT_FRAME_PAD, pady=(DEFAULT_FRAME_PAD, DEFAULT_FRAME_PAD * 2))
                    label_widget = ttk.Label(nested_frame, text=label_text, font=TITLE_FONT)
                    label_widget.pack(anchor='w', padx=DEFAULT_PAD_X, pady=2)
                    separator = ttk.Separator(nested_frame, orient='horizontal')
                    separator.pack(fill='x', pady=2)
                    self._create_dynamic_widgets(nested_frame, value, path_prefix=current_path)
                else:
                    self._create_label(parent_frame=parent_frame, label=key.replace('_', ' ').title(), value=value, path=current_path)
            if Local_Debug_Enable:
                debug_log(
                    message=f"🖥️🔵 Exiting _create_dynamic_widgets() for path_prefix: '{path_prefix}'.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.current_class_name}.{current_function_name}",
                    console_print_func=console_log
                )
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")

    def _update_widget_value(self, relative_topic, payload):
        current_function_name = inspect.currentframe().f_code.co_name
        # Finds the correct widget and updates its state from an MQTT message.
        try:
            widget_info = self.topic_widgets.get(relative_topic)
            if not widget_info:
                if '/options/' in relative_topic:
                    parts = relative_topic.split('/options/')
                    base_path = parts[0]
                    widget_info_at_base = self.topic_widgets.get(f"{base_path}")

                    if widget_info_at_base and isinstance(widget_info_at_base, tuple):
                        # FIX: Differentiate between Listbox and Combobox (Dropdown)
                        # Check if it's a Listbox by checking the widget type
                        if isinstance(widget_info_at_base[0], tk.Listbox):
                            listbox, rebuild_method, _ = widget_info_at_base
                            # Traverse the config to get the updated config for this listbox
                            listbox_config = self.config_data
                            for part in base_path.split('/'):
                                if 'fields' in listbox_config:
                                    listbox_config = listbox_config['fields']
                                listbox_config = listbox_config.get(part, {})
                            # Call the rebuild method with the correct widget and config
                            if "options" in listbox_config:
                                rebuild_method(lb=listbox, cfg=listbox_config)
                            return
                        
                        # Check if it's a Combobox (Dropdown)
                        elif len(widget_info_at_base) == 3 and isinstance(widget_info_at_base[1], ttk.Combobox):
                            str_var, dropdown, rebuild_method = widget_info_at_base
                            dropdown_config = self.config_data
                            for part in base_path.split('/'):
                                if 'fields' in dropdown_config:
                                    dropdown_config = dropdown_config['fields']
                                dropdown_config = dropdown_config.get(part, {})
                            
                            if "options" in dropdown_config:
                                rebuild_method(dropdown=dropdown, config=dropdown_config)
                                parent_topic_path = '/'.join(base_path.split('/'))
                                parent_config_data = self.config_data
                                for part in parent_topic_path.split('/'):
                                    parent_config_data = parent_config_data.get(part, {})
                                if 'value' in parent_config_data:
                                    dropdown.set(parent_config_data['value'])
                            return
                return

            payload_value = payload
            if isinstance(payload, str):
                try:
                    data = json.loads(payload)
                    if isinstance(data, dict) and 'value' in data:
                        payload_value = data['value']
                except (json.JSONDecodeError, TypeError):
                    pass

            if isinstance(payload_value, str):
                try:
                    payload_value = json.loads(payload_value)
                except (json.JSONDecodeError, TypeError):
                    pass

            if isinstance(payload_value, str):
                if payload_value.lower() == 'true':
                    payload_value = True
                elif payload_value.lower() == 'false':
                    payload_value = False

            if isinstance(widget_info, ttk.Entry):
                widget_info.delete(0, tk.END)
                widget_info.insert(0, payload_value)
            elif isinstance(widget_info, tuple):
                if isinstance(widget_info[0], tk.BooleanVar) and isinstance(widget_info[1], ttk.Button):
                    bool_var, update_func = widget_info
                    new_state = bool(payload_value)
                    if bool_var.get() != new_state:
                        bool_var.set(new_state)
                        update_func()
                elif isinstance(widget_info[0], tk.BooleanVar) and isinstance(widget_info[1], ttk.Checkbutton):
                    bool_var, checkbutton = widget_info
                    new_state = bool(payload_value)
                    bool_var.set(new_state)
                elif isinstance(widget_info[0], tk.StringVar) and isinstance(widget_info[1], ttk.Scale):
                    str_var, slider = widget_info
                    str_var.set(f"{float(payload_value):.2f}")
                    slider.set(float(payload_value))
                elif isinstance(widget_info[0], tk.StringVar) and isinstance(widget_info[1], ttk.Combobox) and len(widget_info) == 3:
                    str_var, dropdown, rebuild_method = widget_info
                    str_var.set(str(payload_value))
                elif isinstance(widget_info[0], tk.Listbox) and len(widget_info) == 3:
                    listbox, rebuild_method, options_map = widget_info
                    
                    selected_key = next((key for key, opt in options_map.items() if str(opt.get('value', key)) == str(payload_value)), None)
                    if selected_key:
                        selected_label = options_map[selected_key].get('label_active', selected_key)
                        all_items = listbox.get(0, tk.END)
                        if selected_label in all_items:
                            idx = all_items.index(selected_label)
                            listbox.selection_clear(0, tk.END)
                            listbox.select_set(idx)
                            listbox.see(idx)
                elif isinstance(widget_info[0], tk.StringVar):
                    str_var, update_func = widget_info
                    str_var.set(str(payload_value))
                    update_func()
            elif isinstance(widget_info, ttk.Label):
                widget_info.config(text=f"{widget_info['text'].split(':')[0]}: {payload_value}")

        except Exception as e:
            console_log(f"❌ Error updating widget for topic '{relative_topic}': {e}")


    def _on_receive_command_message(self, topic, payload):
        current_function_name = inspect.currentframe().f_code.co_name
        # The main callback function that processes incoming MQTT messages.
        try:
            
            if topic.startswith(self.base_topic):
                relative_topic = topic[len(self.base_topic):].strip(TOPIC_DELIMITER)

                if not relative_topic:
                    try:
                        full_config = json.loads(payload)
                        if isinstance(full_config, dict):
                            # Update config_data, but don't automatically rebuild GUI
                            # GUI structure is now primarily driven by local JSON files.
                            self.config_data = full_config
                            if Local_Debug_Enable:
                                debug_log(
                                    message=f"🖥️🔵 Received full config via MQTT for {self.base_topic}. Updated config_data but did not auto-rebuild GUI (local JSON is authoritative).",
                                    file=current_file,
                                    version=current_version,
                                    function=f"{self.current_class_name}.{current_function_name}",
                                    console_print_func=console_log
                                )
                            return
                    except (json.JSONDecodeError, TypeError):
                        pass

                path_parts = relative_topic.split(TOPIC_DELIMITER)
                self._update_nested_dict(path_parts, payload)

                if self.gui_built:
                    self.after(0, self._update_widget_value, relative_topic, payload)

        except Exception as e:
            console_log(f"❌ Error in _on_receive_command_message: {e}")

#####################################
### File: OPEN-AIR/workers/builder/dynamic_gui_config_loader.py
#####################################
# workers/builder/dynamic_gui_config_loader.py
#
# This file (dynamic_gui_config_loader.py) provides utility functions to derive JSON configuration file paths from base topics, searching specific 'datasets' subdirectories.
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 44 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#


import inspect
import pathlib
import os # For os.path.basename and os.getcwd

# Assuming sys.path is already set up by main.py
from display.logger import debug_log, console_log, log_visa_command

# --- Global Scope Variables ---
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")

DATASET_ROOT_DIR = project_root / "datasets" # Using project_root to define DATASET_ROOT_DIR

def get_json_filepath_from_base_topic(
    base_topic: str,
    class_name: str, # Pass the class name from the caller for logging
    calling_file: str, # Pass the calling file for logging
    calling_version: str, # Pass the calling version for logging
    console_print_func # Pass the console_log from the caller for logging
) -> pathlib.Path | None:
    """
    Derives the JSON configuration file path from the base_topic.
    Searches in 'datasets/YAK', 'datasets/configuration', and 'datasets/Orchestration'.
    """
    current_function_name = inspect.currentframe().f_code.co_name
    
    # Determine the relevant subdirectory and base filename part
    core_topic_name = ""
    target_subdir = ""
    filename_prefix = ""

    if base_topic.lower().startswith("open-air/yak/"):
        core_topic_name = base_topic[len("open-air/"):].lower().replace('/', '_')
        target_subdir = "YAK"
        filename_prefix = "dataset_"
    elif base_topic.lower().startswith("open-air/configuration/"):
        core_topic_name = base_topic[len("open-air/configuration/"):].lower().replace('/', '_')
        target_subdir = "configuration"
        filename_prefix = "dataset_configuration_"
    elif base_topic.lower().startswith("open-air/dataset/orchestration"): # New Orchestration topic
        core_topic_name = base_topic[len("open-air/dataset/orchestration"):].lower().replace('/', '_').strip('_')
        target_subdir = "Orchestration"
        filename_prefix = "dataset_configuration_"
        if not core_topic_name: # If topic is just "open-air/dataset/orchestration"
            core_topic_name = "orchestration"
    else:
        # Handle topics that don't fit the OPEN-AIR/repository or OPEN-AIR/configuration pattern
        
        # Special handling for "application"
        if base_topic.lower() == "application":
            app_config_filename = "dataset_configuration_application.json"
            app_config_filepath = DATASET_ROOT_DIR / "configuration" / app_config_filename
            if app_config_filepath.is_file():
                debug_log(
                    message=f"🔍🔵 Found JSON config for 'application' at: {app_config_filepath}",
                    file=calling_file,
                    version=calling_version,
                    function=f"{class_name}.{current_function_name}",
                    console_print_func=console_print_func
                )
                return app_config_filepath

        # Special handling for "application_filepaths"
        if base_topic.lower() == "application_filepaths":
            app_filepaths_config_filename = "dataset_configuration_application_filepaths.json"
            app_filepaths_config_filepath = DATASET_ROOT_DIR / "configuration" / app_filepaths_config_filename
            if app_filepaths_config_filepath.is_file():
                debug_log(
                    message=f"🔍🔵 Found JSON config for 'application_filepaths' at: {app_filepaths_config_filepath}",
                    file=calling_file,
                    version=calling_version,
                    function=f"{class_name}.{current_function_name}",
                    console_print_func=console_print_func
                )
                debug_log(
                    message=f"🔍🔵 Exiting get_json_filepath_from_base_topic() with path: {app_filepaths_config_filepath}",
                    file=calling_file,
                    version=calling_version,
                    function=f"{class_name}.{current_function_name}",
                    console_print_func=console_print_func
                )
                return app_filepaths_config_filepath

        # Handle "Orchestration" (previously "Start-Stop-Pause")
        # This block is for base_topic == "Orchestration" explicitly
        if base_topic.lower() == "orchestration":
            orchestration_filename = "dataset_configuration_orchestration.json"
            orchestration_filepath = DATASET_ROOT_DIR / "Orchestration" / orchestration_filename
            if orchestration_filepath.is_file():
                debug_log(
                    message=f"🔍🔵 Found JSON config for 'Orchestration' at: {orchestration_filepath}",
                    file=calling_file,
                    version=calling_version,
                    function=f"{class_name}.{current_function_name}",
                    console_print_func=console_print_func
                )
                debug_log(
                    message=f"🔍🔵 Exiting get_json_filepath_from_base_topic() with path: {orchestration_filepath}",
                    file=calling_file,
                    version=calling_version,
                    function=f"{class_name}.{current_function_name}",
                    console_print_func=console_print_func
                )
                return orchestration_filepath
        
        # Fallback for other cases (e.g., if topic structure is simpler or unknown prefix)
        simple_topic_parts = base_topic.lower().replace('/', '_')
        
        repo_filename = f"dataset_YAK_{simple_topic_parts}.json"
        repo_filepath = DATASET_ROOT_DIR / "YAK" / repo_filename
        if repo_filepath.is_file():
            debug_log(
                message=f"🔍🔵 Found JSON config (fallback repo) at: {repo_filepath}",
                file=calling_file,
                version=calling_version,
                function=f"{class_name}.{current_function_name}",
                console_print_func=console_print_func
            )
            debug_log(
                message=f"🔍🔵 Exiting get_json_filepath_from_base_topic() with path: {repo_filepath}",
                file=calling_file,
                version=calling_version,
                function=f"{class_name}.{current_function_name}",
                console_print_func=console_print_func
            )
            return repo_filepath
        
        config_filename = f"dataset_configuration_{simple_topic_parts}.json"
        config_filepath = DATASET_ROOT_DIR / "configuration" / config_filename
        if config_filepath.is_file():
            debug_log(
                message=f"🔍🔵 Found JSON config (fallback config) at: {config_filepath}",
                file=calling_file,
                version=calling_version,
                function=f"{class_name}.{current_function_name}",
                console_print_func=console_print_func
            )
            debug_log(
                message=f"🔍🔵 Exiting get_json_filepath_from_base_topic() with path: {config_filepath}",
                file=calling_file,
                version=calling_version,
                function=f"{class_name}.{current_function_name}",
                console_print_func=console_print_func
            )
            return config_filepath

        debug_log(
            message=f"⚠️ Warning: No JSON config file found for base_topic: {base_topic}",
            file=calling_file,
            version=calling_version,
            function=f"{class_name}.{current_function_name}",
            console_print_func=console_print_func
        )
        debug_log(
            message=f"🔍🔵 Exiting get_json_filepath_from_base_topic() with path: None (No file found)",
            file=calling_file,
            version=calling_version,
            function=f"{class_name}.{current_function_name}",
            console_print_func=console_print_func
        )
        return None
        
    # If a specific prefix was matched (OPEN-AIR/yak or OPEN-AIR/configuration or OPEN-AIR/dataset/orchestration)
    if core_topic_name:
        final_filename = f"{filename_prefix}{core_topic_name}.json"
        final_filepath = DATASET_ROOT_DIR / target_subdir / final_filename
        if final_filepath.is_file():
            debug_log(
                message=f"🔍🔵 Found JSON config (prefixed match) at: {final_filepath}",
                file=calling_file,
                version=calling_version,
                function=f"{class_name}.{current_function_name}",
                console_print_func=console_print_func
            )
            debug_log(
                message=f"🔍🔵 Exiting get_json_filepath_from_base_topic() with path: {final_filepath}",
                file=calling_file,
                version=calling_version,
                function=f"{class_name}.{current_function_name}",
                console_print_func=console_print_func
            )
            return final_filepath

    debug_log(
        message=f"⚠️ Warning: No JSON config file found for base_topic: {base_topic}",
        file=calling_file,
        version=calling_version,
        function=f"{class_name}.{current_function_name}",
        console_print_func=console_print_func
    )
    debug_log(
        message=f"🔍🔵 Exiting get_json_filepath_from_base_topic() with path: None (No file found)",
        file=calling_file,
        version=calling_version,
        function=f"{class_name}.{current_function_name}",
        console_print_func=console_print_func
    )
    return None


#####################################
### File: OPEN-AIR/workers/builder/dynamic_gui_create_gui_actuator.py
#####################################
# workers/builder/dynamic_gui_create_gui_actuator.py
#
# This file (dynamic_gui_create_gui_actuator.py) provides the GuiActuatorCreatorMixin class for creating simple actuator buttons in the GUI.
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 44 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#


import os
import tkinter as tk
from tkinter import ttk
import inspect
import json

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command


Local_Debug_Enable = True

# The wrapper functions debug_log and console_log_switch are removed
# as the core debug_log and console_log now directly handle Local_Debug_Enable.


# --- Global Scope Variables ---
current_file = f"{os.path.basename(__file__)}"

# --- Constants ---
DEFAULT_PAD_X = 5
DEFAULT_PAD_Y = 2
TOPIC_DELIMITER = "/"


class GuiActuatorCreatorMixin:
    """
    A mixin class that provides the functionality for creating a simple
    actuator button widget that triggers an action via MQTT.
    """
    def _create_gui_actuator(self, parent_frame, label, config, path):
        # Creates a button that acts as a simple actuator.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # A trigger path is used to differentiate the trigger from other state values.
        trigger_path = path + "/trigger"
        
        if Local_Debug_Enable:
            debug_log(
                message=f"🛠️🟢 Entering {current_function_name} to conjure an actuator button for '{label}'.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

        try:
            # Create a frame to hold the label and button
            sub_frame = ttk.Frame(parent_frame)
            sub_frame.pack(side=tk.LEFT, padx=DEFAULT_PAD_X, pady=DEFAULT_PAD_Y)

            button_text = config.get('label', label)

            button = ttk.Button(
                sub_frame,
                text=button_text,
                style='Custom.TButton' 
            )
            button.pack(side=tk.LEFT, padx=DEFAULT_PAD_X)

            def on_press(event):
                # FIXED: The actuator now correctly publishes to the "actions" topic.
                action_path = trigger_path.replace("repository", "actions")

                if Local_Debug_Enable:
                    debug_log(
                        message=f"GUI ACTION: Publishing actuator command to '{action_path}' with value 'true'",
                        file=current_file,
                        version=current_version,
                        function=f"{self.__class__.__name__}.{current_function_name}",
                        console_print_func=console_log
                    )
                self._transmit_command(relative_topic=action_path, payload=True, retain=False)

            def on_release(event):
                # FIXED: The actuator now correctly publishes to the "actions" topic.
                action_path = trigger_path.replace("repository", "actions")

                if Local_Debug_Enable:
                    debug_log(
                        message=f"GUI ACTION: Publishing actuator command release to '{action_path}' with value 'false'",
                        file=current_file,
                        version=current_version,
                        function=f"{self.__class__.__name__}.{current_function_name}",
                        console_print_func=console_log
                    )
                self._transmit_command(relative_topic=action_path, payload=False, retain=False)

            button.bind("<ButtonPress-1>", on_press)
            button.bind("<ButtonRelease-1>", on_release)

            if path:
                self.topic_widgets[path] = button

            console_log(f"✅ Celebration of success! The actuator button '{label}' did appear.")
            if Local_Debug_Enable:
                debug_log(
                    message=f"🛠️🟢 Exiting '{current_function_name}'. Actuator button '{label}' created.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
            return sub_frame

        except Exception as e:
            console_log(f"❌ Error in {current_function_name} for '{label}': {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"🛠️🔴 Arrr, the code be capsized! The actuator button creation has failed! The error be: {e}",
                    file=current_file,
                    version=current_version,
                    function=current_function_name,
                    console_print_func=console_log
                )
            return None

#####################################
### File: OPEN-AIR/workers/builder/dynamic_gui_create_gui_button_toggle.py
#####################################
# workers/builder/dynamic_gui_create_gui_button_toggle.py
#
# This file (dynamic_gui_create_gui_button_toggle.py) provides the GuiButtonToggleCreatorMixin class for creating toggle button widgets in the GUI.
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 44 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#


import os
import tkinter as tk
from tkinter import ttk
from display.logger import debug_log, console_log, log_visa_command
import inspect
import json


Local_Debug_Enable = True

# The wrapper functions debug_log and console_log_switch are removed
# as the core debug_log and console_log now directly handle Local_Debug_Enable.


# --- Global Scope Variables ---
current_file = f"{os.path.basename(__file__)}"

TOPIC_DELIMITER = "/"

class GuiButtonToggleCreatorMixin:
    def _create_gui_button_toggle(self, parent_frame, label, config, path):
        # Creates a single button that toggles between two states (e.g., ON/OFF).
        current_function_name = inspect.currentframe().f_code.co_name

        if Local_Debug_Enable:
            debug_log(
                message=f"🛠️🟢 Entering '{current_function_name}' to conjure a button widget for '{label}' on path '{path}'.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

        try:
            options_map = config.get('options', {})
            on_config = options_map.get('ON', {})
            off_config = options_map.get('OFF', {})
            on_text = on_config.get('label_active', 'ON')
            off_text = off_config.get('label_inactive', 'OFF')

            is_on = options_map.get('ON', {}).get('selected', False)
            
            state_var = tk.BooleanVar(value=is_on)
            
            button = ttk.Button(parent_frame, text=on_text if is_on else off_text)
            button.pack(side=tk.LEFT, padx=5, pady=2)

            def update_button_state():
                # Updates the button's appearance based on its current state.
                current_state = state_var.get()
                if current_state:  # Correct logic: The button is ON, so use the 'Selected' style.
                    button.config(text=on_text, style='Custom.Selected.TButton')
                else: # The button is OFF, so use the default 'TButton' style.
                    button.config(text=off_text, style='Custom.TButton')

            def toggle_state_and_publish():
                # Flips the state, updates the button, and publishes the new state.
                new_state = not state_var.get()
                state_var.set(new_state)
                update_button_state()
                
                # Deselect the previous option (or publish the new "off" state)
                off_path = f"{path}{TOPIC_DELIMITER}options{TOPIC_DELIMITER}OFF{TOPIC_DELIMITER}selected"
                self._transmit_command(relative_topic=off_path, payload=str(not new_state).lower())
                
                # Select the new option (or publish the new "on" state)
                on_path = f"{path}{TOPIC_DELIMITER}options{TOPIC_DELIMITER}ON{TOPIC_DELIMITER}selected"
                self._transmit_command(relative_topic=on_path, payload=str(new_state).lower())
                
                if Local_Debug_Enable:
                    debug_log(
                        message=f"GUI ACTION: Publishing state change for '{label}' with new state '{new_state}'.",
                        file=current_file,
                        version=current_version,
                        function=f"{self.__class__.__name__}.{current_function_name}",
                        console_print_func=console_log
                    )

            button.config(command=toggle_state_and_publish)
            update_button_state() # Set initial text and style
            
            self.topic_widgets[path] = (state_var, update_button_state)

            console_log("✅ Celebration of success! the " + label + " did toggle its function with robust, new logic!")
            if Local_Debug_Enable:
                debug_log(
                    message=f"🛠️🟢 Exiting '{current_function_name}'. Toggle button '{label}' created.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
            return button

        except Exception as e:
            console_log(f"❌ Error in {current_function_name} for '{label}': {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"🛠️🔴 Arrr, the code be capsized! The toggle button creation has failed! The error be: {e}",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
            return None

#####################################
### File: OPEN-AIR/workers/builder/dynamic_gui_create_gui_button_toggler.py
#####################################
# workers/builder/dynamic_gui_create_gui_button_toggler.py
#
# This file (dynamic_gui_create_gui_button_toggler.py) provides the GuiButtonTogglerCreatorMixin class for creating groups of radio-style buttons in the GUI.
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 44 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#


import os
import tkinter as tk
from tkinter import ttk
import inspect
import time # CRITICAL: Import time for necessary delay

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command


Local_Debug_Enable = True

# The wrapper functions debug_log and console_log_switch are removed
# as the core debug_log and console_log now directly handle Local_Debug_Enable.


# --- Global Scope Variables ---
current_file = f"{os.path.basename(__file__)}"
# --- Constants ---
DEFAULT_PAD_X = 5
DEFAULT_PAD_Y = 2

class GuiButtonTogglerCreatorMixin:
    """
    A mixin class that provides the functionality for creating a
    group of buttons that behave like radio buttons.
    """
    def _create_gui_button_toggler(self, parent_frame, label, config, path):
        # Creates a set of custom buttons that behave like radio buttons ("bucket of buttons").
        current_function_name = inspect.currentframe().f_code.co_name

        if Local_Debug_Enable:
            debug_log(
                message=f"🛠️🟢 Entering '{current_function_name}' to create a button toggler for '{label}'.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

        try:
            group_frame = ttk.Frame(parent_frame)
            group_frame.pack(fill=tk.X, expand=True, padx=DEFAULT_PAD_X, pady=DEFAULT_PAD_Y)

            label_widget = ttk.Label(group_frame, text=label)
            label_widget.pack(anchor='w', padx=DEFAULT_PAD_X, pady=2)

            button_container = ttk.Frame(group_frame)
            button_container.pack(fill=tk.BOTH, expand=True, padx=2, pady=2)

            options_data = config.get('options', {})
            buttons = {}

            selected_key = next((key for key, opt in options_data.items() if str(opt.get('selected', 'no')).lower() in ['yes', 'true']), None)
            selected_var = tk.StringVar(value=selected_key)

            def update_button_styles():
                current_selection = selected_var.get()
                for key, button_widget in buttons.items():
                    option_data = options_data.get(key, {})
                    
                    # Determine the text and style for the button based on its state
                    if key == current_selection:
                        # Correct logic: The selected button uses the 'Selected' style.
                        button_text = option_data.get('label_active', option_data.get('label', ''))
                        button_widget.config(style='Custom.Selected.TButton')
                    else:
                        # All other buttons use the default 'TButton' style.
                        button_text = option_data.get('label_inactive', option_data.get('label', ''))
                        button_widget.config(style='Custom.TButton')

                    # Add value and units on separate lines if they exist
                    value = option_data.get('value')
                    units = option_data.get('units')
                    if value is not None:
                        button_text += f"\n{value}"
                    if units is not None:
                        button_text += f"\n{units}"
                    
                    button_widget.config(text=button_text)

            def create_command(key):
                def command():
                    current_selection = selected_var.get()
                    
                    # 1. Force Deselect (if any selected)
                    if current_selection:
                        # CRITICAL: Publish the DESELECT to the old key
                        deselect_path = f"{path}/options/{current_selection}/selected"
                        self._transmit_command(relative_topic=deselect_path, payload='false')
                        
                        # CRITICAL: Add a minimal, synchronous delay to prevent race condition.
                        # This pause allows the application's MQTT client to send the first message 
                        # before the second one is sent on the same thread.
                        time.sleep(0.01)

                    # 2. Force Select the new button
                    selected_path = f"{path}/options/{key}/selected"
                    self._transmit_command(relative_topic=selected_path, payload='true')

                    # 3. Update the local UI state after messages are published
                    selected_var.set(key)
                    update_button_styles()
                    
                return command

            max_cols = 5
            row_num = 0
            col_num = 0

            for option_key, option_data in options_data.items():
                button = ttk.Button(
                    button_container,
                    command=create_command(option_key)
                )
                button.grid(row=row_num, column=col_num, padx=2, pady=2, sticky="ew")
                button_container.grid_columnconfigure(col_num, weight=1)
                buttons[option_key] = button

                col_num += 1
                if col_num >= max_cols:
                    col_num = 0
                    row_num += 1

            update_button_styles()

            if path:
                self.topic_widgets[path] = (selected_var, update_button_styles)

            console_log("✅ Celebration of success! The button toggler did appear.")
            if Local_Debug_Enable:
                debug_log(
                    message=f"🛠️🟢 Exiting '{current_function_name}'. Button toggler '{label}' created.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
            return group_frame

        except Exception as e:
            console_log(f"❌ Error in {current_function_name} for '{label}': {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"🛠️🔴 Arrr, the code be capsized! The button toggler creation has failed! The error be: {e}",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
            return None


#####################################
### File: OPEN-AIR/workers/builder/dynamic_gui_create_gui_checkbox.py
#####################################
# workers/builder/dynamic_gui_create_gui_checkbox.py
#
# This file (dynamic_gui_create_gui_checkbox.py) provides the GuiCheckboxCreatorMixin class for creating checkbox widgets in the GUI.
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 44 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#


import os
import tkinter as tk
from tkinter import ttk
import inspect
import json

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command


Local_Debug_Enable = True

# The wrapper functions debug_log and console_log_switch are removed
# as the core debug_log and console_log now directly handle Local_Debug_Enable.


# --- Global Scope Variables ---
current_file = f"{os.path.basename(__file__)}"

# --- Constants ---
DEFAULT_PAD_X = 5
DEFAULT_PAD_Y = 2

class GuiCheckboxCreatorMixin:
    """
    A mixin class that provides the functionality for creating a
    checkbox widget.
    """
    def _create_gui_checkbox(self, parent_frame, label, config, path):
        # Creates a checkbox widget.
        current_function_name = inspect.currentframe().f_code.co_name

        debug_log(
            message=f"🛠️🟢 Entering '{current_function_name}' to create a checkbox for '{label}'.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # We use a BooleanVar to track the state of the checkbox.
            initial_value = bool(config.get('value', False))
            state_var = tk.BooleanVar(value=initial_value)

            def get_label_text():
                current_state = state_var.get()
                # Use label_active/label_inactive if they exist, otherwise fall back to the main label.
                if current_state:
                    return config.get('label_active', config.get('label', ''))
                else:
                    return config.get('label_inactive', config.get('label', ''))
            
            def update_label():
                # Manually update the checkbox text
                checkbox.config(text=get_label_text())

            def toggle_and_publish():
                # Flips the state and publishes the change via MQTT.
                new_state = state_var.get()
                # Pass raw boolean instead of JSON string
                payload = new_state
                debug_log(
                    message=f"GUI ACTION: Publishing state change for '{label}' to path '{path}' with value '{new_state}'.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
                self._transmit_command(relative_topic=path, payload=payload)
                # Update the label after the state change
                update_label()

            # Create the checkbox button with an initial label.
            checkbox = ttk.Checkbutton(
                parent_frame,
                text=get_label_text(),
                variable=state_var,
                command=toggle_and_publish
            )
            checkbox.pack(side=tk.LEFT, padx=DEFAULT_PAD_X, pady=DEFAULT_PAD_Y)
            
            # Store the widget and its state variable for external updates.
            if path:
                self.topic_widgets[path] = (state_var, checkbox)

            console_log(f"✅ Celebration of success! The checkbox '{label}' did appear.")
            debug_log(
                message=f"🛠️🟢 Exiting '{current_function_name}'. Checkbox '{label}' created.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            return checkbox

        except Exception as e:
            console_log(f"❌ Error in {current_function_name} for '{label}': {e}")
            debug_log(
                message=f"🛠️🔴 Arrr, the code be capsized! The checkbox creation has failed! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            return None

#####################################
### File: OPEN-AIR/workers/builder/dynamic_gui_create_gui_dropdown_option.py
#####################################
# workers/builder/dynamic_gui_create_gui_dropdown_option.py
#
# This file (dynamic_gui_create_gui_dropdown_option.py) provides the GuiDropdownOptionCreatorMixin class for creating dropdown (Combobox) widgets in the GUI.
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 44 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#


import os
import tkinter as tk
from tkinter import ttk
import inspect
from decimal import Decimal

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command


Local_Debug_Enable = True





# --- Global Scope Variables ---
current_file = f"{os.path.basename(__file__)}"

# --- Constants ---
DEFAULT_PAD_X = 5
DEFAULT_PAD_Y = 2

class GuiDropdownOptionCreatorMixin:
    """
    A mixin class that provides the functionality for creating a
    dropdown (Combobox) widget.
    """
    def _create_gui_dropdown_option(self, parent_frame, label, config, path):
        # Creates a dropdown menu for multiple choice options.
        current_function_name = inspect.currentframe().f_code.co_name

        if Local_Debug_Enable:
            debug_log(
                message=f"🛠️🟢 Entering '{current_function_name}' to create a dropdown for '{label}'.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

        try:
            sub_frame = ttk.Frame(parent_frame)
            sub_frame.pack(side=tk.LEFT, padx=DEFAULT_PAD_X, pady=DEFAULT_PAD_Y)

            # Label
            label_widget = ttk.Label(sub_frame, text=f"{label}:")
            label_widget.pack(side=tk.LEFT, padx=(DEFAULT_PAD_X, 0))

            options_map = config.get('options', {})

            # Filter out inactive options for initial display
            active_options = {k: v for k, v in options_map.items() if str(v.get('active', 'false')).lower() in ['true', 'yes']}

            # Try to convert values to Decimal for numerical sorting, fall back to string sorting.
            try:
                sorted_options = sorted(active_options.items(), key=lambda item: Decimal(item[1].get('value')))
            except:
                sorted_options = sorted(active_options.items(), key=lambda item: item[1].get('value', item[0]))

            # Populate the dropdown with labels and map them to values
            option_labels = [opt.get('label_active', key) for key, opt in sorted_options]
            option_values = [opt.get('value', key) for key, opt in sorted_options]

            # Find the initially selected key
            initial_selected_key = next((key for key, opt in options_map.items() if str(opt.get('selected', 'no')).lower() in ['yes', 'true']), None)
            
            initial_value_for_var = options_map.get(initial_selected_key, {}).get('value', initial_selected_key)
            selected_value_var = tk.StringVar(value=initial_value_for_var)
            displayed_text_var = tk.StringVar(value=options_map.get(initial_selected_key, {}).get('label_active', initial_selected_key))

            self._last_selected_option = initial_selected_key
            
            def update_displayed_text(value):
                # Helper to update the dropdown's displayed text based on its value.
                try:
                    selected_key = next((key for key, opt in options_map.items() if str(opt.get('value', key)) == str(value)), None)
                    displayed_text = options_map.get(selected_key, {}).get('label_active', selected_key)
                    displayed_text_var.set(displayed_text)
                except StopIteration:
                    displayed_text_var.set("") # Set to blank if value not found.

            def on_select(event):
                try:
                    selected_label = displayed_text_var.get()
                    selected_key = next((key for key, opt in options_map.items() if opt.get('label_active', key) == selected_label), None)
                    selected_value = options_map.get(selected_key, {}).get('value', selected_key)

                    if selected_key and selected_key != self._last_selected_option:
                        # Deselect the previous option
                        if self._last_selected_option:
                            old_path = f"{path}/options/{self._last_selected_option}/selected"
                            self._transmit_command(relative_topic=old_path, payload='false')

                        # Select the new option
                        new_path = f"{path}/options/{selected_key}/selected"
                        self._transmit_command(relative_topic=new_path, payload='true')
                        
                        self._last_selected_option = selected_key
                        selected_value_var.set(selected_value) # Update the value var

                    if Local_Debug_Enable:
                        debug_log(
                            message=f"GUI ACTION: Publishing to '{new_path}' with value 'true'",
                            file=current_file,
                            version=current_version,
                            function=f"{self.__class__.__name__}.{current_function_name}",
                            console_print_func=console_log
                        )

                except ValueError:
                    console_log("❌ Invalid selection in dropdown.")

            # Set the listbox foreground color to black.
            parent_frame.option_add('*TCombobox*Listbox.foreground', 'black')

            # Create a style for the combobox with a black foreground
            style = ttk.Style()
            style_name = f'BlackText.TCombobox'
            style.configure(style_name, foreground='black')

            selected_value_var.trace_add("write", lambda name, index, mode: update_displayed_text(selected_value_var.get()))
            # Create a Combobox that uses the displayed_text_var for its text.
            dropdown = ttk.Combobox(sub_frame, textvariable=displayed_text_var, values=option_labels, state="readonly", style=style_name)
            
            dropdown.bind("<<ComboboxSelected>>", on_select)
            dropdown.pack(side=tk.LEFT, padx=DEFAULT_PAD_X)

            if path:
                # Store the widget info in a way that includes the current selection for tracking
                # FIX: Storing the rebuild_options method in the tuple
                self.topic_widgets[path] = (selected_value_var, dropdown, self.rebuild_options)

            console_log("✅ Celebration of success! The dropdown menu did appear.")
            if Local_Debug_Enable:
                debug_log(
                    message=f"🛠️🟢 Exiting '{current_function_name}'. Dropdown '{label}' created.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
            return sub_frame

        except Exception as e:
            console_log(f"❌ Error in {current_function_name} for '{label}': {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"🛠️🔴 Arrr, the code be capsized! The dropdown creation has failed! The error be: {e}",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
            return None

    def rebuild_options(self, dropdown, config):
        """
        NEW: Rebuilds the option list for a dropdown based on a new configuration.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        if Local_Debug_Enable:
            debug_log(
                message=f"🛠️🟢 Entering '{current_function_name}' to rebuild options for dropdown.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
        options_map = config.get('options', {})

        # Filter out options that are not active
        active_options = {k: v for k, v in options_map.items() if str(v.get('active', 'false')).lower() in ['true', 'yes']}

        try:
            sorted_options = sorted(active_options.items(), key=lambda item: Decimal(item[1].get('value')))
        except:
            sorted_options = sorted(active_options.items(), key=lambda item: item[1].get('value', item[0]))

        option_labels = [opt.get('label_active', key) for key, opt in sorted_options]
        dropdown['values'] = option_labels

        # Find the currently selected option to retain it if possible
        current_selection = dropdown.get()
        if current_selection not in option_labels and option_labels:
            dropdown.set(option_labels[0])
            self._last_selected_option = next((key for key, opt in active_options.items() if opt.get('label_active', key) == option_labels[0]), None)
        if Local_Debug_Enable:
            debug_log(
                message=f"🛠️🟢 Exiting '{current_function_name}'. Options rebuilt for dropdown.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

#####################################
### File: OPEN-AIR/workers/builder/dynamic_gui_create_gui_listbox.py
#####################################
# workers/builder/dynamic_gui_create_gui_listbox.py
#
# This file (dynamic_gui_create_gui_listbox.py) provides the GuiListboxCreatorMixin class for dynamically creating Listbox widgets in the GUI.
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 44 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#


import os
import tkinter as tk
from tkinter import ttk
import inspect
from decimal import Decimal

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command


Local_Debug_Enable = True





# --- Global Scope Variables ---
current_file = f"{os.path.basename(__file__)}"

# --- Constants ---
DEFAULT_PAD_X = 5
DEFAULT_PAD_Y = 2


class GuiListboxCreatorMixin:
    """
    A mixin class that provides the functionality for creating a
    Listbox widget.
    """
    def _create_gui_listbox(self, parent_frame, label, config, path):
        # Creates a listbox menu for multiple choice options.
        current_function_name = inspect.currentframe().f_code.co_name

        if Local_Debug_Enable:
            debug_log(
                message=f"🛠️🟢 Entering '{current_function_name}' to create a listbox for '{label}'.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

        try:
            sub_frame = ttk.Frame(parent_frame)
            sub_frame.pack(side=tk.LEFT, fill=tk.Y, padx=DEFAULT_PAD_X, pady=DEFAULT_PAD_Y)

            label_widget = ttk.Label(sub_frame, text=label)
            label_widget.pack(anchor='w', padx=DEFAULT_PAD_X, pady=2)

            listbox_frame = ttk.Frame(sub_frame)
            listbox_frame.pack(fill=tk.BOTH, expand=True)

            scrollbar = ttk.Scrollbar(listbox_frame, orient=tk.VERTICAL)
            listbox = tk.Listbox(listbox_frame, yscrollcommand=scrollbar.set, exportselection=False, selectmode=tk.SINGLE)
            
            scrollbar.config(command=listbox.yview)
            scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            options_map = config.get('options', {})

            def rebuild_options_for_listbox(lb, cfg):
                # Rebuilds the option list for the listbox based on a new configuration.
                lb.delete(0, tk.END)
                options_map_local = cfg.get('options', {})
                
                active_options = {k: v for k, v in options_map_local.items() if str(v.get('active', 'false')).lower() in ['true', 'yes']}
                
                try:
                    sorted_options = sorted(active_options.items(), key=lambda item: Decimal(item[1].get('value')))
                except:
                    sorted_options = sorted(active_options.items(), key=lambda item: item[1].get('value', item[0]))

                for key, opt in sorted_options:
                    lb.insert(tk.END, opt.get('label_active', key))

                initial_selected_key = next((key for key, opt in options_map_local.items() if str(opt.get('selected', 'no')).lower() in ['yes', 'true']), None)
                if initial_selected_key:
                    initial_label = options_map_local[initial_selected_key].get('label_active', initial_selected_key)
                    if initial_label in lb.get(0, tk.END):
                        idx = lb.get(0, tk.END).index(initial_label)
                        lb.select_set(idx)
                        lb.see(idx)

            rebuild_options_for_listbox(listbox, config)
            self._last_selected_option_listbox = next((key for key, opt in options_map.items() if str(opt.get('selected', 'no')).lower() in ['yes', 'true']), None)

            def on_select(event):
                widget = event.widget
                selection_indices = widget.curselection()
                if not selection_indices:
                    return

                selected_index = selection_indices[0]
                selected_label = widget.get(selected_index)
                
                try:
                    selected_key = next((key for key, opt in options_map.items() if opt.get('label_active', key) == selected_label), None)
                    
                    if selected_key and selected_key != self._last_selected_option_listbox:
                        # Deselect the previous option
                        if self._last_selected_option_listbox:
                            old_path = f"{path}/options/{self._last_selected_option_listbox}/selected"
                            self._transmit_command(relative_topic=old_path, payload='false')

                        # Select the new option
                        new_path = f"{path}/options/{selected_key}/selected"
                        self._transmit_command(relative_topic=new_path, payload='true')
                        
                        self._last_selected_option_listbox = selected_key

                    if Local_Debug_Enable:
                        debug_log(
                            message=f"GUI ACTION: Publishing selection for '{selected_key}' to path '{path}'.",
                            file=current_file,
                            version=current_version,
                            function=f"{self.__class__.__name__}.{current_function_name}",
                            console_print_func=console_log
                        )
                except (ValueError, StopIteration):
                    console_log("❌ Invalid selection in listbox.")

            listbox.bind("<<ListboxSelect>>", on_select)

            if path:
                self.topic_widgets[path] = (listbox, rebuild_options_for_listbox, options_map)

            console_log("✅ Celebration of success! The listbox menu did appear.")
            if Local_Debug_Enable:
                debug_log(
                    message=f"🛠️🟢 Exiting '{current_function_name}'. Listbox '{label}' created.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
            return sub_frame

        except Exception as e:
            console_log(f"❌ Error in {current_function_name} for '{label}': {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"🛠️🔴 Arrr, the code be capsized! The listbox creation has failed! The error be: {e}",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
            return None

#####################################
### File: OPEN-AIR/workers/builder/dynamic_gui_create_gui_slider_value.py
#####################################
# workers/builder/dynamic_gui_create_gui_slider_value.py
#
# This file (dynamic_gui_create_gui_slider_value.py) provides the SliderValueCreatorMixin class for creating slider widgets with text entry in the GUI.
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 44 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#


import os
import tkinter as tk
from tkinter import ttk
import inspect

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command


Local_Debug_Enable = True





# --- Global Scope Variables ---
current_file = f"{os.path.basename(__file__)}"

# --- Constants ---
DEFAULT_PAD_X = 5
DEFAULT_PAD_Y = 2

class SliderValueCreatorMixin:
    """
    A mixin class that provides the functionality for creating a
    slider widget combined with a text entry box.
    """
    def _create_slider_value(self, parent_frame, label, config, path):
        # Creates a slider and an entry box for a numerical value.
        current_function_name = inspect.currentframe().f_code.co_name

        if Local_Debug_Enable:
            debug_log(
                message=f"🛠️🟢 Entering '{current_function_name}' to create a slider and value box for '{label}'.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

        try:
            sub_frame = ttk.Frame(parent_frame)
            sub_frame.pack(fill=tk.X, expand=True, padx=DEFAULT_PAD_X, pady=DEFAULT_PAD_Y)

            # --- Layout Refactor: Start ---
            # Line 1: Label
            label_widget = ttk.Label(sub_frame, text=f"{label}:")
            label_widget.pack(side=tk.TOP, fill=tk.X, padx=(DEFAULT_PAD_X, DEFAULT_PAD_X), pady=(0, DEFAULT_PAD_Y))

            # Line 2: Slider
            min_val = float(config.get('min', '0'))
            max_val = float(config.get('max', '100'))
            
            # 🛠️ New fix: Create a custom style for a thicker slider
            style = ttk.Style(sub_frame)
            style_name = 'Thicker.Horizontal.TScale'
            style.configure(style_name, sliderlength=40)
            slider = ttk.Scale(sub_frame, from_=min_val, to=max_val, orient=tk.HORIZONTAL, style=style_name)
            
            slider.pack(side=tk.TOP, fill=tk.X, expand=True, padx=DEFAULT_PAD_X, pady=(0, DEFAULT_PAD_Y))

            # Line 3: Textbox and Units
            value_unit_frame = ttk.Frame(sub_frame)
            value_unit_frame.pack(side=tk.TOP, fill=tk.X, expand=True)

            units_label = ttk.Label(value_unit_frame, text=config.get('units', ''))
            units_label.pack(side=tk.RIGHT, padx=(DEFAULT_PAD_X, DEFAULT_PAD_X))

            entry_value = tk.StringVar(value=config.get('value', '0'))
            entry = ttk.Entry(value_unit_frame, width=7, style="Custom.TEntry", textvariable=entry_value, justify=tk.RIGHT)
            entry.pack(side=tk.RIGHT, padx=(DEFAULT_PAD_X, 0))
            
            try:
                initial_val = float(entry_value.get())
                slider.set(initial_val)
            except (ValueError, tk.TclError):
                slider.set(min_val)
            # --- Layout Refactor: End ---

            def on_slider_move(val):
                entry_value.set(f"{float(val):.2f}")

            def on_slider_release(event):
                new_val = float(slider.get())
                if Local_Debug_Enable:
                    debug_log(
                        message=f"GUI ACTION: Publishing to '{path}' with value '{new_val}'",
                        file=current_file,
                        version=current_version,
                        function=f"{self.__class__.__name__}.{current_function_name}",
                        console_print_func=console_log
                    )
                self._transmit_command(relative_topic=path, payload=new_val)

            def on_entry_change(event):
                try:
                    new_val = float(entry.get())
                    if min_val <= new_val <= max_val:
                        slider.set(new_val)
                        if Local_Debug_Enable:
                            debug_log(
                                message=f"GUI ACTION: Publishing to '{path}' with value '{new_val}'",
                                file=current_file,
                                version=current_version,
                                function=f"{self.__class__.__name__}.{current_function_name}",
                                console_print_func=console_log
                            )
                        self._transmit_command(relative_topic=path, payload=new_val)
                except ValueError:
                    console_log("Invalid input, please enter a number.")

            slider.config(command=on_slider_move)
            slider.bind("<ButtonRelease-1>", on_slider_release)
            entry.bind("<FocusOut>", on_entry_change)
            entry.bind("<Return>", on_entry_change)

            if path:
                self.topic_widgets[path] = (entry_value, slider)

            console_log("✅ Celebration of success! The slider value box did appear.")
            if Local_Debug_Enable:
                debug_log(
                    message=f"🛠️🟢 Exiting '{current_function_name}'. Slider '{label}' created.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
            return sub_frame

        except Exception as e:
            console_log(f"❌ Error in {current_function_name} for '{label}': {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"🛠️🔴 Arrr, the code be capsized! The slider value box creation has failed! The error be: {e}",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
            return None

#####################################
### File: OPEN-AIR/workers/builder/dynamic_gui_create_label.py
#####################################
# display/builder/dynamic_gui_create_label.py
#
# A mixin class for the DynamicGuiBuilder that handles the creation of a label widget.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os

import tkinter as tk

from tkinter import ttk

import inspect



# --- Module Imports ---

from display.logger import debug_log, console_log, log_visa_command





Local_Debug_Enable = True
current_version = "20251127.000000.1"
current_version_hash = (20251127 * 0 * 1)
current_file = f"{os.path.basename(__file__)}"

# --- Constants ---
# These are local to this module but should match the main builder's constants.
DEFAULT_PAD_X = 5
DEFAULT_PAD_Y = 2

class LabelCreatorMixin:
    """
    A mixin class that provides the functionality for creating a label widget.
    """
    def _create_label(self, parent_frame, label, value, units=None, path=None):
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🛠️🟢 Entering '{current_function_name}' to create a label: '{label}' with value '{value}'.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            sub_frame = ttk.Frame(parent_frame)
            sub_frame.pack(padx=DEFAULT_PAD_X, pady=DEFAULT_PAD_Y, anchor='w')

            label_text = f"{label}: {value}"
            if units:
                label_text += f" {units}"

            label_widget = ttk.Label(sub_frame, text=label_text)
            label_widget.pack(side=tk.LEFT, padx=(DEFAULT_PAD_X, DEFAULT_PAD_X))

            # Store the widget using its full topic path as the key for live updates.
            if path:
                self.topic_widgets[path] = label_widget
            
            debug_log(
                message=f"🛠️🟢 Exiting '{current_function_name}'. Label '{label}' created.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            return label_widget, sub_frame

        except Exception as e:
            console_log(f"❌ Error in {current_function_name} for '{label}': {e}")
            debug_log(
                message=f"🛠️🔴 Arrr, the code be capsized! Label creation has failed! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            return None, None

#####################################
### File: OPEN-AIR/workers/builder/dynamic_gui_create_label_from_config.py
#####################################
# display/builder/dynamic_gui_create_label_from_config.py
#
# A mixin class for the DynamicGuiBuilder that handles creating a label from a config dictionary.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command

# --- Global Scope Variables ---
current_version = "20251127.000000.1"
current_version_hash = (20251127 * 0 * 1)
current_file = f"{os.path.basename(__file__)}"

Local_Debug_Enable = True


class LabelFromConfigCreatorMixin:
    """
    A mixin class that provides a wrapper for creating a label widget
    from a configuration dictionary.
    """
    def _create_label_from_config(self, parent_frame, label, config, path):
        # A wrapper for _create_label to match the factory function signature.
        # It calls the _create_label method (provided by LabelCreatorMixin).
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🛠️🟢 Entering '{current_function_name}' to create label from config for '{label}'.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            result = self._create_label(
                parent_frame=parent_frame,
                label=label,
                value=config.get("value"),
                units=config.get("units"),
                path=path
            )
            debug_log(
                message=f"🛠️🟢 Exiting '{current_function_name}'. Label from config '{label}' created.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            return result
        except Exception as e:
            console_log(f"❌ Error in {current_function_name} for '{label}': {e}")
            debug_log(
                message=f"🛠️🔴 Arrr, the code be capsized! Label from config creation has failed! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            return None

#####################################
### File: OPEN-AIR/workers/builder/dynamic_gui_create_value_box.py
#####################################
# workers/builder/dynamic_gui_create_value_box.py
#
# This file (dynamic_gui_create_value_box.py) provides the ValueBoxCreatorMixin class for creating editable text box widgets in the GUI.
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 44 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#


import os
import tkinter as tk
from tkinter import ttk
import inspect

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command

# --- Global Scope Variables ---
current_file = f"{os.path.basename(__file__)}"

# --- Constants ---
DEFAULT_PAD_X = 5
DEFAULT_PAD_Y = 2

class ValueBoxCreatorMixin:
    """
    A mixin class that provides the functionality for creating an
    editable text box widget.
    """
    def _create_value_box(self, parent_frame, label, config, path):
        # Creates an editable text box (_Value).
        current_function_name = inspect.currentframe().f_code.co_name

        debug_log(
            message=f"🛠️🟢 Entering '{current_function_name}' to conjure an entry box for '{label}'.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            sub_frame = ttk.Frame(parent_frame)
            sub_frame.pack(side=tk.LEFT, padx=DEFAULT_PAD_X, pady=DEFAULT_PAD_Y)

            label_widget = ttk.Label(sub_frame, text=f"{label}:")
            label_widget.pack(side=tk.LEFT, padx=(DEFAULT_PAD_X, DEFAULT_PAD_X))

            entry_value = tk.StringVar(value=config.get('value', ''))
            entry = ttk.Entry(sub_frame, textvariable=entry_value, style="Custom.TEntry")
            entry.pack(side=tk.LEFT, padx=DEFAULT_PAD_X)

            if config.get('units'):
                units_label = ttk.Label(sub_frame, text=config['units'])
                units_label.pack(side=tk.LEFT, padx=(0, DEFAULT_PAD_X))

            def on_entry_change(event):
                new_val = entry_value.get()
                debug_log(
                    message=f"GUI ACTION: Publishing to '{path}' with value '{new_val}'",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
                # CORRECTED: This now correctly uses the central transmit method.
                self._transmit_command(relative_topic=path, payload=new_val)

            entry.bind("<FocusOut>", on_entry_change)
            entry.bind("<Return>", on_entry_change)

            # Store the widget using its full topic path as the key.
            if path:
                self.topic_widgets[path] = entry

            console_log(f"✅ Celebration of success! The value box did appear.")
            debug_log(
                message=f"🛠️🟢 Exiting '{current_function_name}'. Value box '{label}' created.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            return sub_frame

        except Exception as e:
            console_log(f"❌ Error in {current_function_name} for '{label}': {e}")
            debug_log(
                message=f"🛠️🔴 Arrr, the code be capsized! The value box creation has failed! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            return None

#####################################
### File: OPEN-AIR/workers/builder/dynamic_gui_mousewheel_mixin.py
#####################################
# workers/builder/dynamic_gui_mousewheel_mixin.py
#
# This file (dynamic_gui_mousewheel_mixin.py) provides the MousewheelScrollMixin class, adding mousewheel scrolling functionality to Tkinter Canvas widgets.
# A complete and comprehensive pre-amble that describes the file and the functions within.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 44 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#


import sys
import inspect
import datetime
import pathlib
import os

from display.logger import debug_log, console_log, log_visa_command


# --- Global Scope Variables ---
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class MousewheelScrollMixin:
    """
    Mixin to add mousewheel scrolling functionality to a Tkinter Canvas.
    Assumes the presence of `self.canvas` and logging utilities.
    """
    def _on_mousewheel(self, event):
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Mousewheel event detected: {event.num}. Scrolling canvas.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        # Platform-specific mouse wheel scrolling
        if sys.platform == "linux":
            if event.num == 4: # Scroll up
                self.canvas.yview_scroll(-1, "units")
            elif event.num == 5: # Scroll down
                self.canvas.yview_scroll(1, "units")
        else: # Windows and macOS
            self.canvas.yview_scroll(int(-1 * (event.delta / 120)), "units")

    def _bind_mousewheel(self, event):
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Binding mousewheel scrolling for canvas.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        # Bind mousewheel scrolling when the mouse enters the scrollable area
        self.canvas.bind_all("<MouseWheel>", self._on_mousewheel)
        self.canvas.bind_all("<Button-4>", self._on_mousewheel) # Linux scroll up
        self.canvas.bind_all("<Button-5>", self._on_mousewheel) # Linux scroll down

    def _unbind_mousewheel(self, event):
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Unbinding mousewheel scrolling for canvas.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        # Unbind mousewheel scrolling when the mouse leaves the scrollable area
        self.canvas.unbind_all("<MouseWheel>")
        self.canvas.unbind_all("<Button-4>")
        self.canvas.unbind_all("<Button-5>")


#####################################
### File: OPEN-AIR/workers/ui/utils_display_monitor.py
#####################################
# workers/ui/utils_display_monitor.py
#
# This file (utils_display_monitor.py) provides utility functions to interact with and update the plots in the Scan Monitor display tab.
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 44 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#


import inspect
import os
import traceback 
import numpy as np
from matplotlib.offsetbox import AnchoredText 

from display.logger import debug_log, console_log, log_visa_command




def _find_and_plot_peaks(ax, data, start_freq_MHz, end_freq_MHz):
    # [A brief, one-sentence description of the function's purpose.]
    # Finds and plots local peaks on a Matplotlib axis.
    debug_log(f"Entering _find_and_plot_peaks with {len(data) if data else 0} data points.",
                file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

    try:
        if not data:
            console_log("✅ No data to search for peaks.")
            return

        x_data = np.array(data)[:, 0]
        y_data = np.array(data)[:, 1]
        
        total_span = end_freq_MHz - start_freq_MHz
        segment_width = total_span / 150
        peaks = []
        i = 0
        while i < len(x_data):
            segment_end_freq = x_data[i] + segment_width
            segment_indices = np.where((x_data >= x_data[i]) & (x_data <= segment_end_freq))
            if not segment_indices[0].any():
                i += 1
                continue
            
            segment_y_data = y_data[segment_indices]
            segment_x_data = x_data[segment_indices]
            peak_y = np.max(segment_y_data)
            peak_x = segment_x_data[np.argmax(segment_y_data)]
            peaks.append((peak_x, peak_y))

            next_i_candidate = np.where(x_data >= peak_x + segment_width)[0]
            i = next_i_candidate[0] if len(next_i_candidate) > 0 else len(x_data)
        
        sorted_peaks = sorted(peaks, key=lambda p: p[1], reverse=True)[:10]
        for peak_x, peak_y in sorted_peaks:
            ax.axvline(x=peak_x, color='orange', linestyle='--', linewidth=1, zorder=4)
        
        console_log(f"✅ Found and plotted {len(sorted_peaks)} peaks.")
    except Exception as e:
        console_log(f"❌ Error in _find_and_plot_peaks: {e}")
        debug_log(f"Arrr, the code be capsized in peak finding! The error be: {e}\n{traceback.format_exc()}",
                    file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

def _setup_zoom_events(ax, canvas, original_xlim):
    # [A brief, one-sentence description of the function's purpose.]
    # Sets up event handlers for horizontal zooming on the plot.
    debug_log(f"Entering _setup_zoom_events.", file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)
    
    try:
        drag_start_x = None
        ax.original_xlim = original_xlim

        def on_press(event):
            nonlocal drag_start_x
            if event.button == 1 and event.inaxes == ax:
                drag_start_x = event.xdata

        def on_release(event):
            nonlocal drag_start_x
            if event.button == 1 and event.inaxes == ax and drag_start_x is not None:
                drag_end_x = event.xdata
                if drag_end_x is not None and drag_start_x != drag_end_x:
                    ax.set_xlim(min(drag_start_x, drag_end_x), max(drag_start_x, drag_end_x))
                    canvas.draw_idle()
                drag_start_x = None

        def on_double_click(event):
            if event.button == 1 and event.inaxes == ax:
                reset_zoom(ax=ax, canvas=canvas)

        canvas.mpl_connect('button_press_event', on_press)
        canvas.mpl_connect('button_release_event', on_release)
        canvas.mpl_connect('button_press_event', on_double_click)
        console_log("✅ Zoom events are now live!")
    except Exception as e:
        console_log(f"❌ Error in _setup_zoom_events: {e}")
        debug_log(f"Great Scott! The zoom mechanism has backfired! Error: {e}\n{traceback.format_exc()}",
                    file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

def reset_zoom(ax, canvas):
    # [A brief, one-sentence description of the function's purpose.]
    # Resets the plot to its original, full x-axis view.
    debug_log(f"Entering reset_zoom.", file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)
    try:
        if hasattr(ax, 'original_xlim'):
            ax.set_xlim(ax.original_xlim)
            canvas.draw_idle()
        console_log("✅ Celebration of success! Zoom reset.")
    except Exception as e:
        console_log(f"❌ Error in reset_zoom: {e}")
        debug_log(f"It's madness! The zoom refused to reset! Error: {e}\n{traceback.format_exc()}",
                    file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

def update_top_plot(scan_monitor_tab_instance, data, start_freq_MHz, end_freq_MHz, plot_title):
    # [A brief, one-sentence description of the function's purpose.]
    # Updates the top plot in the Scan Monitor tab with new data.
    debug_log(f"Entering update_top_plot with plot_title: {plot_title}", file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)
        
    try:
        plot_info = scan_monitor_tab_instance.plots["top"]
        ax = plot_info['ax']
        canvas = plot_info['canvas']
        ax.clear()
        
        data_tuples = None
        # FIX: The incoming data DataFrame now has frequencies in MHz.
        # We no longer need to divide by 1,000,000 here.
        if data is not None and not data.empty:
            data_tuples = list(zip(data['Frequency_Hz'], data['Power_dBm']))

        if data_tuples:
            frequencies, amplitudes = zip(*data_tuples)
            ax.plot(frequencies, amplitudes, color='yellow', linewidth=1)
        
        ax.set_title(plot_title, color='white')
        ax.set_xlim(start_freq_MHz, end_freq_MHz)
        ax.set_ylim(-120, 0)
        ax.set_yticks(np.arange(-120, 1, 20))
        ax.grid(True, linestyle='--', color='gray', alpha=0.5)

        annot = ax.annotate("", xy=(0,0), xytext=(20,20), textcoords="offset points",
                            bbox=dict(boxstyle="round", fc="white", ec="black", lw=1),
                            arrowprops=dict(arrowstyle="wedge,tail_width=0.5", fc="white", ec="black"))
        annot.set_visible(False)

        def update_annot(event):
            if data_tuples and event.xdata and event.ydata:
                x_data = np.array(data_tuples)[:, 0]
                y_data = np.array(data_tuples)[:, 1]
                idx = np.abs(x_data - event.xdata).argmin()
                annot.xy = (x_data[idx], y_data[idx])
                annot.set_text(f"Freq: {x_data[idx]:.3f} MHz\nAmp: {y_data[idx]:.2f} dBm")
                annot.set_visible(True)
                canvas.draw_idle()
            else:
                annot.set_visible(False)
                canvas.draw_idle()

        canvas.mpl_connect("motion_notify_event", update_annot)
        
        _find_and_plot_peaks(ax=ax, data=data_tuples, start_freq_MHz=start_freq_MHz, end_freq_MHz=end_freq_MHz)
        _setup_zoom_events(ax=ax, canvas=canvas, original_xlim=(start_freq_MHz, end_freq_MHz))

        canvas.draw()
        console_log("✅ Celebration of success! Top plot updated.")
    except Exception as e:
        console_log(f"❌ Error in update_top_plot: {e}")
        debug_log(f"Arrr, the top plot be capsized! The error be: {e}\n{traceback.format_exc()}",
                    file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

def update_middle_plot(scan_monitor_tab_instance, data, start_freq_MHz, end_freq_MHz, plot_title):
    # [A brief, one-sentence description of the function's purpose.]
    # Updates the middle plot in the Scan Monitor tab with new data.
    debug_log(f"Entering update_middle_plot with plot_title: {plot_title}", file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

    try:
        plot_info = scan_monitor_tab_instance.plots["middle"]
        ax = plot_info['ax']
        canvas = plot_info['canvas']
        ax.clear()

        data_tuples = None
        # FIX: The incoming data DataFrame now has frequencies in MHz.
        # We no longer need to divide by 1,000,000 here.
        if data is not None and not data.empty:
            data_tuples = list(zip(data['Frequency_Hz'], data['Power_dBm']))

        if data_tuples:
            frequencies, amplitudes = zip(*data_tuples)
            ax.plot(frequencies, amplitudes, color='green', linewidth=1)
        
        ax.set_title(plot_title, color='white')
        ax.set_xlim(start_freq_MHz, end_freq_MHz)
        ax.set_ylim(-120, 0)
        ax.set_yticks(np.arange(-120, 1, 20))
        ax.grid(True, linestyle='--', color='gray', alpha=0.5)

        annot = ax.annotate("", xy=(0,0), xytext=(20,20), textcoords="offset points",
                            bbox=dict(boxstyle="round", fc="white", ec="black", lw=1),
                            arrowprops=dict(arrowstyle="wedge,tail_width=0.5", fc="white", ec="black"))
        annot.set_visible(False)

        def update_annot(event):
            if data_tuples and event.xdata and event.ydata:
                x_data = np.array(data_tuples)[:, 0]
                y_data = np.array(data_tuples)[:, 1]
                idx = np.abs(x_data - event.xdata).argmin()
                annot.xy = (x_data[idx], y_data[idx])
                annot.set_text(f"Freq: {x_data[idx]:.3f} MHz\nAmp: {y_data[idx]:.2f} dBm")
                annot.set_visible(True)
                canvas.draw_idle()
            else:
                annot.set_visible(False)
                canvas.draw_idle()

        canvas.mpl_connect("motion_notify_event", update_annot)

        _find_and_plot_peaks(ax=ax, data=data_tuples, start_freq_MHz=start_freq_MHz, end_freq_MHz=end_freq_MHz)
        _setup_zoom_events(ax=ax, canvas=canvas, original_xlim=(start_freq_MHz, end_freq_MHz))
        
        canvas.draw()
        console_log("✅ Celebration of success! Middle plot updated.")
    except Exception as e:
        console_log(f"❌ Error in update_middle_plot: {e}")
        debug_log(f"It's alive! Oh wait, no, the middle plot is dead. Error: {e}\n{traceback.format_exc()}",
                    file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

def update_bottom_plot(scan_monitor_tab_instance, data, start_freq_MHz, end_freq_MHz, plot_title):
    # [A brief, one-sentence description of the function's purpose.]
    # Updates the bottom plot in the Scan Monitor tab with new data.
    debug_log(f"Entering update_bottom_plot with plot_title: {plot_title}", file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)
    
    try:
        plot_info = scan_monitor_tab_instance.plots["bottom"]
        ax = plot_info['ax']
        canvas = plot_info['canvas']
        
        ax.clear()

        data_tuples = None
        # FIX: The incoming data DataFrame now has frequencies in MHz.
        # We no longer need to divide by 1,000,000 here.
        if data is not None and not data.empty:
            data_tuples = list(zip(data['Frequency_Hz'], data['Power_dBm']))

        if data_tuples:
            frequencies, amplitudes = zip(*data_tuples)
            ax.plot(frequencies, amplitudes, color='cyan', linewidth=1)
        
        ax.set_title(plot_title, color='white')
        ax.set_xlim(start_freq_MHz, end_freq_MHz)
        ax.set_ylim(-120, 0)
        ax.set_yticks(np.arange(-120, 1, 20))
        ax.grid(True, linestyle='--', color='gray', alpha=0.5)

        annot = ax.annotate("", xy=(0,0), xytext=(20,20), textcoords="offset points",
                            bbox=dict(boxstyle="round", fc="white", ec="black", lw=1),
                            arrowprops=dict(arrowstyle="wedge,tail_width=0.5", fc="white", ec="black"))
        annot.set_visible(False)

        def update_annot(event):
            if data_tuples and event.xdata and event.ydata:
                x_data = np.array(data_tuples)[:, 0]
                y_data = np.array(data_tuples)[:, 1]
                idx = np.abs(x_data - event.xdata).argmin()
                annot.xy = (x_data[idx], y_data[idx])
                annot.set_text(f"Freq: {x_data[idx]:.3f} MHz\nAmp: {y_data[idx]:.2f} dBm")
                annot.set_visible(True)
                canvas.draw_idle()
            else:
                annot.set_visible(False)
                canvas.draw_idle()

        canvas.mpl_connect("motion_notify_event", update_annot)
        
        _find_and_plot_peaks(ax=ax, data=data_tuples, start_freq_MHz=start_freq_MHz, end_freq_MHz=end_freq_MHz)
        _setup_zoom_events(ax=ax, canvas=canvas, original_xlim=(start_freq_MHz, end_freq_MHz))
        
        canvas.draw()
        console_log("✅ Celebration of success! Bottom plot updated.")
    except Exception as e:
        console_log(f"❌ Error in update_bottom_plot: {e}")
        debug_log(f"Shiver me timbers, the bottom plot has been scuttled! Error: {e}\n{traceback.format_exc()}",
                    file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

def clear_monitor_plots(scan_monitor_tab_instance):
    # [A brief, one-sentence description of the function's purpose.]
    # Clears all three plots in the Scan Monitor tab.
    debug_log(f"Entering clear_monitor_plots.", file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)
                
    try:
        if not scan_monitor_tab_instance:
            console_log("❌ Scan Monitor tab instance could not be found. Cannot clear plots.")
            return

        for plot_name in ["top", "middle", "bottom"]:
            plot_info = scan_monitor_tab_instance.plots.get(plot_name, {})
            ax = plot_info.get('ax')
            canvas = plot_info.get('canvas')
            if ax and canvas:
                ax.clear()
                ax.set_facecolor('#1e1e1e')
                ax.set_title(f"Plot {plot_name.capitalize()} Placeholder", color='white')
                ax.set_ylim(-120, 0)
                ax.set_yticks(np.arange(-120, 1, 20))
                ax.grid(True, linestyle='--', color='gray', alpha=0.5)
                canvas.draw()
        
        console_log("✅ Celebration of success! All monitor plots cleared.")
    except Exception as e:
        console_log(f"❌ Error in clear_monitor_plots: {e}")
        debug_log(f"My creation! It refuses to be cleared! Error: {e}\n{traceback.format_exc()}",
                    file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

#####################################
### File: OPEN-AIR/workers/ui/utils_scan_view.py
#####################################
# workers/ui/utils_scan_view.py
#
# This file (utils_scan_view.py) provides utility functions to interact with and update the single plot in the Scan View display tab.
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 44 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#


import inspect
import os
import traceback 
import numpy as np
from matplotlib.offsetbox import AnchoredText 

from display.logger import debug_log, console_log, log_visa_command


def _find_and_plot_peaks(ax, data, start_freq_MHz, end_freq_MHz):
    # [A brief, one-sentence description of the function's purpose.]
    # Finds and plots local peaks on a Matplotlib axis.
    debug_log(f"Entering _find_and_plot_peaks with {len(data) if data else 0} data points.",
                file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

    try:
        if not data:
            console_log("✅ No data to search for peaks.")
            return

        x_data = np.array(data)[:, 0]
        y_data = np.array(data)[:, 1]
        
        total_span = end_freq_MHz - start_freq_MHz
        segment_width = total_span / 150
        peaks = []
        i = 0
        while i < len(x_data):
            segment_end_freq = x_data[i] + segment_width
            segment_indices = np.where((x_data >= x_data[i]) & (x_data <= segment_end_freq))
            if not segment_indices[0].any():
                i += 1
                continue
            
            segment_y_data = y_data[segment_indices]
            segment_x_data = x_data[segment_indices]
            peak_y = np.max(segment_y_data)
            peak_x = segment_x_data[np.argmax(segment_y_data)]
            peaks.append((peak_x, peak_y))

            next_i_candidate = np.where(x_data >= peak_x + segment_width)[0]
            i = next_i_candidate[0] if len(next_i_candidate) > 0 else len(x_data)
        
        sorted_peaks = sorted(peaks, key=lambda p: p[1], reverse=True)[:10]
        for peak_x, peak_y in sorted_peaks:
            ax.axvline(x=peak_x, color='orange', linestyle='--', linewidth=1, zorder=4)
        
        console_log(f"✅ Found and plotted {len(sorted_peaks)} peaks.")
    except Exception as e:
        console_log(f"❌ Error in _find_and_plot_peaks: {e}")
        debug_log(f"Arrr, the code be capsized in peak finding! The error be: {e}\n{traceback.format_exc()}",
                    file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

def _setup_zoom_events(ax, canvas, original_xlim):
    # [A brief, one-sentence description of the function's purpose.]
    # Sets up event handlers for horizontal zooming on the plot.
    debug_log(f"Entering _setup_zoom_events.", file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)
    
    try:
        drag_start_x = None
        ax.original_xlim = original_xlim

        def on_press(event):
            nonlocal drag_start_x
            if event.button == 1 and event.inaxes == ax:
                drag_start_x = event.xdata

        def on_release(event):
            nonlocal drag_start_x
            if event.button == 1 and event.inaxes == ax and drag_start_x is not None:
                drag_end_x = event.xdata
                if drag_end_x is not None and drag_start_x != drag_end_x:
                    ax.set_xlim(min(drag_start_x, drag_end_x), max(drag_start_x, drag_end_x))
                    canvas.draw_idle()
                drag_start_x = None

        def on_double_click(event):
            if event.button == 1 and event.inaxes == ax:
                reset_zoom(ax=ax, canvas=canvas)

        canvas.mpl_connect('button_press_event', on_press)
        canvas.mpl_connect('button_release_event', on_release)
        canvas.mpl_connect('button_press_event', on_double_click)
        console_log("✅ Zoom events are now live!")
    except Exception as e:
        console_log(f"❌ Error in _setup_zoom_events: {e}")
        debug_log(f"Great Scott! The zoom mechanism has backfired! Error: {e}\n{traceback.format_exc()}",
                    file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

def reset_zoom(ax, canvas):
    # [A brief, one-sentence description of the function's purpose.]
    # Resets the plot to its original, full x-axis view.
    debug_log(f"Entering reset_zoom.", file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)
    try:
        if hasattr(ax, 'original_xlim'):
            ax.set_xlim(ax.original_xlim)
            canvas.draw_idle()
        console_log("✅ Celebration of success! Zoom reset.")
    except Exception as e:
        console_log(f"❌ Error in reset_zoom: {e}")
        debug_log(f"It's madness! The zoom refused to reset! Error: {e}\n{traceback.format_exc()}",
                    file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

def update_single_plot(scan_view_tab_instance, data, start_freq_MHz, end_freq_MHz, plot_title, line_color='yellow'):
    # [A brief, one-sentence description of the function's purpose.]
    # Updates the single plot in the Scan View tab with new data.
    debug_log(f"Entering update_plot with plot_title: {plot_title}", file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)
        
    try:
        plot_info = scan_view_tab_instance.plot
        ax = plot_info['ax']
        canvas = plot_info['canvas']
        ax.clear()
        
        data_tuples = None
        if data is not None and not data.empty:
            # FIX: Remove the redundant conversion, as data is already in MHz
            data_tuples = list(zip(data['Frequency_Hz'], data['Power_dBm']))

        if data_tuples:
            frequencies, amplitudes = zip(*data_tuples)
            # FIXED: Used the new line_color parameter
            ax.plot(frequencies, amplitudes, color=line_color, linewidth=1)
        
        ax.set_title(plot_title, color='white')
        ax.set_xlim(start_freq_MHz, end_freq_MHz)
        ax.set_ylim(-120, 0)
        ax.set_yticks(np.arange(-120, 1, 20))
        ax.grid(True, linestyle='--', color='gray', alpha=0.5)

        annot = ax.annotate("", xy=(0,0), xytext=(20,20), textcoords="offset points",
                            bbox=dict(boxstyle="round", fc="white", ec="black", lw=1),
                            arrowprops=dict(arrowstyle="wedge,tail_width=0.5", fc="white", ec="black"))
        annot.set_visible(False)

        def update_annot(event):
            if data_tuples and event.xdata and event.ydata:
                x_data = np.array(data_tuples)[:, 0]
                y_data = np.array(data_tuples)[:, 1]
                idx = np.abs(x_data - event.xdata).argmin()
                annot.xy = (x_data[idx], y_data[idx])
                annot.set_text(f"Freq: {x_data[idx]:.3f} MHz\nAmp: {y_data[idx]:.2f} dBm")
                annot.set_visible(True)
                canvas.draw_idle()
            else:
                annot.set_visible(False)
                canvas.draw_idle()

        canvas.mpl_connect("motion_notify_event", update_annot)
        
        _find_and_plot_peaks(ax=ax, data=data_tuples, start_freq_MHz=start_freq_MHz, end_freq_MHz=end_freq_MHz)
        _setup_zoom_events(ax=ax, canvas=canvas, original_xlim=(start_freq_MHz, end_freq_MHz))

        canvas.draw()
        console_log("✅ Celebration of success! Plot updated.")
    except Exception as e:
        console_log(f"❌ Error in update_plot: {e}")
        debug_log(f"Arrr, the plot be capsized! The error be: {e}\n{traceback.format_exc()}",
                    file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

#####################################
### File: OPEN-AIR/workers/presets/worker_preset_from_device.py
#####################################
# workers/worker_preset_from_device.py
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# A worker module to handle the logic for querying, parsing, and presenting
# presets stored on the connected instrument via MQTT.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251013.221814.3

import os
import inspect
import datetime
import json
import re
import threading
import time

# --- Module Imports ---
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from display.logger import debug_log, console_log, log_visa_command

# --- Global Scope Variables (as per your instructions) ---
current_date = datetime.datetime.now().strftime("%Y%m%d")
current_time = datetime.datetime.now().strftime("%H%M%S")
# UPDATED VERSION: 20251013.221814.3
current_version = f"{current_date}.{current_time}.3" 
current_version_hash = (int(current_date) * int(current_time) * 3)
current_file = f"{os.path.basename(__file__)}"
Local_Debug_Enable = True

# --- MQTT Topic Constants (No Magic Numbers) ---
ROOT_TOPIC = "OPEN-AIR/yak/Memory"
NAB_TRIGGER_TOPIC = f"{ROOT_TOPIC}/Nab/Nab_Preset_Catalog/scpi_details/N9342CN/trigger"
NAB_OUTPUT_TOPIC = f"{ROOT_TOPIC}/Nab/Nab_Preset_Catalog/scpi_outputs/preset_catalog_list/value"
SET_FILENAME_TOPIC = f"{ROOT_TOPIC}/Set/Set_Store_Preset/scpi_inputs/preset_fileName/value"
SET_TRIGGER_TOPIC = f"{ROOT_TOPIC}/Set/Set_Store_Preset/scpi_details/N9342CN/trigger"

# --- NEW: MQTT Topic for publishing presets ---
PRESET_REPOSITORY_TOPIC = "OPEN-AIR/repository/presets"

class PresetFromDeviceWorker:
    """
    A worker class that manages preset operations on the device via MQTT.
    """
    def __init__(self, mqtt_util: MqttControllerUtility):
        """
        Initializes the worker and subscribes to the necessary topic.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        self.mqtt_util = mqtt_util
        self.last_preset_list = None
        self.preset_list_event = threading.Event()

        if Local_Debug_Enable:
            debug_log(
                message=f"🛠️🟢 Initializing preset worker and subscribing to root topic.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
        
        # Subscribe to the master topic and all its sub-levels
        self.mqtt_util.add_subscriber(topic_filter=f"{ROOT_TOPIC}/#", callback_func=self._on_mqtt_message)
    

    def _on_mqtt_message(self, topic, payload):
        """
        A private callback to capture the preset list when it arrives from the device.
        """
        if topic == NAB_OUTPUT_TOPIC:
            self.last_preset_list = payload
            self.preset_list_event.set()
            console_log("✅ A new preset catalog has been received! Time to parse the data.")
            
            valid_presets = self.parse_presets_from_device(self.last_preset_list)
            if valid_presets:
                # Call the new function to publish the presets
                self.publish_presets_to_repository(valid_presets)
        
    def get_presets_from_device(self):
        """
        Triggers the device to query its presets. This function is non-blocking.
        The result is handled by the _on_mqtt_message callback.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        if Local_Debug_Enable:
            debug_log(
                message=f"🛠️🟢 Triggering device to send preset catalog.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

        try:
            # Set the trigger to true
            self.preset_list_event.clear()
            self.mqtt_util.publish_message(topic=NAB_TRIGGER_TOPIC, subtopic="", value=True, retain=False)
            
            # Set the trigger to false immediately afterwards, before waiting
            self.mqtt_util.publish_message(topic=NAB_TRIGGER_TOPIC, subtopic="", value=False, retain=False)

            console_log("✅ TRIGGER sent. Awaiting preset catalog response...")
            return True

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            self.mqtt_util.publish_message(topic=NAB_TRIGGER_TOPIC, subtopic="", value=False, retain=False)
            return False

    def parse_presets_from_device(self, raw_preset_string: str) -> list:
        """
        Parses a raw, comma-separated string of preset data and returns a list
        of valid filenames ending in '.STA'.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        if Local_Debug_Enable:
            debug_log(
                message=f"🛠️🟢 Parsing raw preset string for valid '.STA' files.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
        
        if not raw_preset_string:
            return []
            
        # The first three values are not filenames, so we skip them.
        parts = raw_preset_string.strip().split(',')
        if len(parts) <= 3:
            console_log("❌ Invalid preset string format. Too few parts.")
            return []

        # We start at index 3 and increment by 4 to get each filename
        valid_presets = []
        for i in range(3, len(parts), 4):
            filename = parts[i].strip()
            if filename.upper().endswith(".STA"):
                valid_presets.append(filename)
                
        console_log(f"✅ Found {len(valid_presets)} valid presets.")
        return valid_presets

    def publish_presets_to_repository(self, preset_list: list):
        """
        Takes a list of preset filenames and publishes the full preset data 
        dictionary as a single JSON payload to one topic per preset.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        if Local_Debug_Enable:
            debug_log(
                message=f"🛠️🟢 Publishing {len(preset_list)} presets as monolithic JSON blobs to repository.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
        
        num_published = 0
        for i, filename in enumerate(preset_list):
            if i >= 25:
                break
                
            preset_key = f"PRESET_{100 + i:03d}"
            
            # Create a dictionary for the current preset's data
            preset_data = {
                "Active": True,
                "FileName": filename,
                "NickName": filename,
                "Start": "",
                "Stop": "",
                "Center": "",
                "Span": "",
                "RBW": "",
                "VBW": "",
                "RefLevel": "",
                "Attenuation": "",
                "MaxHold": "",
                "HighSens": "",
                "PreAmp": "",
                "Trace1Mode": "",
                "Trace2Mode": "",
                "Trace3Mode": "",
                "Trace4Mode": "",
            }
            
            # Publish the entire dictionary as a single JSON blob
            self.mqtt_util.publish_message(
                topic=f"{PRESET_REPOSITORY_TOPIC}/{preset_key}",
                subtopic="",
                value=json.dumps(preset_data), # Publish the whole dict as a string
                retain=True
            )
            
            num_published = i + 1

        console_log(f"✅ Successfully published {num_published} presets as monolithic nodes to the repository.")


    def present_presets_from_device(self, preset_filename: str):
        """
        Sets the specified preset filename and triggers the device to store it.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        if Local_Debug_Enable:
            debug_log(
                message=f"🛠️🟢 Pushing preset filename '{preset_filename}' to device and triggering save.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

        try:
            # 1. Push the filename value via MQTT
            self.mqtt_util.publish_message(topic=SET_FILENAME_TOPIC, subtopic="", value=preset_filename, retain=False)
            
            # 2. Trigger the action to set the preset to 'true'
            self.mqtt_util.publish_message(topic=SET_TRIGGER_TOPIC, subtopic="", value=True, retain=False)

            # 3. Trigger the action to set the preset to 'false' afterwards
            self.mqtt_util.publish_message(topic=SET_TRIGGER_TOPIC, subtopic="", value=False, retain=False)
            
            console_log("✅ Preset filename sent and save triggered.")
            return True

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            return False

if __name__ == "__main__":
    # This block is for demonstrating the worker's functionality
    # outside of the main application.

    class MockMqttUtil:
        def __init__(self):
            self.subscribers = {}
        def add_subscriber(self, topic_filter, callback_func):
            self.subscribers[topic_filter] = callback_func
        def publish_message(self, topic, subtopic, value, retain=False):
            full_topic = f"{topic}/{subtopic}" if subtopic else topic
            print(f"Mock publish: {full_topic} -> {value}")
            if full_topic == NAB_OUTPUT_TOPIC:
                self.subscribers[full_topic](full_topic, value)

    # Mock the MQTT utility and instantiate the worker
    mock_mqtt_util = MockMqttUtil()
    worker = PresetFromDeviceWorker(mqtt_util=mock_mqtt_util)
    
    # Example 1: Get presets from device
    print("\n--- Testing Get_presets_from_device ---")
    mock_response_string = "0,0,0,Preset1.STA,0,0,0,0,Preset2.STA,0,0,0,0,Preset3.STA,0,0,0,0,InvalidFile.txt,0,0,0"
    
    presets_list_str = worker.get_presets_from_device()
    
    if presets_list_str:
        # Manually trigger the message
        worker._on_mqtt_message(NAB_OUTPUT_TOPIC, mock_response_string)
        
        # Example 2: Parse the presets
        print("\n--- Testing Parse_presets_from_device ---")
        valid_presets = worker.parse_presets_from_device(presets_list_str)
        print(f"Valid Presets: {valid_presets}")
        
        # Example 3: Present a single preset to device
        if valid_presets:
            print("\n--- Testing Present_presents_from_device ---")
            worker.present_presets_from_device(valid_presets[0])

#####################################
### File: OPEN-AIR/workers/presets/worker_preset_pusher.py
#####################################
# workers/worker_preset_pusher.py
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# A worker module to process a selected preset and push the corresponding
# SCPI commands via MQTT to configure the instrument.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250919.231000.1

import os
import inspect
import json
import time

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility

# --- Global Scope Variables ---
current_version = "20250919.231000.1"
current_version_hash = (20250919 * 231000 * 1)
current_file = f"{os.path.basename(__file__)}"
Local_Debug_Enable = True

HZ_TO_MHZ = 1_000_000

# --- MQTT Topic Constants (No Magic Numbers) ---
# Frequency
FREQ_START_INPUT = "OPEN-AIR/yak/Frequency/rig/Rig_freq_start_stop/scpi_inputs/start_freq/value"
FREQ_STOP_INPUT = "OPEN-AIR/yak/Frequency/rig/Rig_freq_start_stop/scpi_inputs/stop_freq/value"
FREQ_TRIGGER = "OPEN-AIR/yak/Frequency/rig/Rig_freq_start_stop/scpi_details/generic_model/trigger"

# Bandwidth
RBW_INPUT = "OPEN-AIR/yak/Bandwidth/set/Set_RBW/scpi_inputs/hz_value/value"
RBW_TRIGGER = "OPEN-AIR/yak/Bandwidth/set/Set_RBW/scpi_details/generic_model/trigger"
VBW_INPUT = "OPEN-AIR/yak/Bandwidth/set/Set_VBW/scpi_inputs/hz_value/value"
VBW_TRIGGER = "OPEN-AIR/yak/Bandwidth/set/Set_VBW/scpi_details/generic_model/trigger"

# Amplitude
AMP_TRIGGER = "OPEN-AIR/yak/Amplitude/rig/rig_Ref_Level_dBm/scpi_details/generic_model/trigger"
AMP_REF_LEVEL = "OPEN-AIR/yak/Amplitude/rig/rig_Ref_Level_dBm/scpi_inputs/Ref_Level_dBm/value"
AMP_ATTENUATION = "OPEN-AIR/yak/Amplitude/rig/rig_Ref_Level_dBm/scpi_inputs/Attenuation_dB/value"
AMP_PREAMP = "OPEN-AIR/yak/Amplitude/rig/rig_Ref_Level_dBm/scpi_inputs/Preamp_On/value"

# Trace Modes
TRACE_TRIGGER = "OPEN-AIR/yak/Trace/rig/rig_All_trace_modes/scpi_details/generic_model/trigger"
TRACE_MODE_1_INPUT = "OPEN-AIR/yak/Trace/rig/rig_All_trace_modes/scpi_inputs/mode1/value"
TRACE_MODE_2_INPUT = "OPEN-AIR/yak/Trace/rig/rig_All_trace_modes/scpi_inputs/mode2/value"
TRACE_MODE_3_INPUT = "OPEN-AIR/yak/Trace/rig/rig_All_trace_modes/scpi_inputs/mode3/value"
TRACE_MODE_4_INPUT = "OPEN-AIR/yak/Trace/rig/rig_All_trace_modes/scpi_inputs/mode4/value"


class PresetPusherWorker:
    """
    A worker class that takes a selected preset and pushes the settings to the instrument.
    """
    def __init__(self, mqtt_controller: MqttControllerUtility):
        """
        Initializes the worker with a shared MQTT controller instance.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        self.mqtt_controller = mqtt_controller
        if Local_Debug_Enable:
            debug_log(
                message=f"🛠️🟢 The preset pusher has been summoned!",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def Tune_to_preset(self, preset_values):
        """
        Executes a sequence of commands to configure the instrument based on a preset.

        Args:
            preset_values (list): A list of values for the selected preset.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        if Local_Debug_Enable:
            debug_log(
                message=f"🛠️🟢 Attuning the instrument to the selected preset. Ready the coils!",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
        
        # Mapping the input list to readable variables
        keys = [
            "Preset_number", "Active", "FileName", "NickName", "Start", "Stop", "Center", "Span", "RBW", "VBW",
            "RefLevel", "Attenuation", "MaxHold", "HighSens", "PreAmp",
            "Trace1Mode", "Trace2Mode", "Trace3Mode", "Trace4Mode"
        ]
        preset_dict = dict(zip(keys, preset_values))

        # --- Mandatory: Set Start and Stop Frequencies ---
        try:

            start_freq_mhz = float(preset_dict.get('Start'))
            stop_freq_mhz = float(preset_dict.get('Stop'))

            # Apply the conversion from MHz to Hz
            self.mqtt_controller.publish_message(topic=FREQ_START_INPUT, subtopic="", value=start_freq_mhz * HZ_TO_MHZ)
            self.mqtt_controller.publish_message(topic=FREQ_STOP_INPUT, subtopic="", value=stop_freq_mhz * HZ_TO_MHZ)

            self.mqtt_controller.publish_message(topic=FREQ_TRIGGER, subtopic="", value=True)
            self.mqtt_controller.publish_message(topic=FREQ_TRIGGER, subtopic="", value=False)
            console_log("✅ Start/Stop frequencies set.")
        except Exception as e:
            console_log(f"❌ Error setting Start/Stop frequencies: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"🛠️🔴 The frequency setter is on the fritz! The error be: {e}",
                    file=current_file, version=current_version, function=current_function_name, console_print_func=console_log
                )

        # --- Conditional: Set RBW ---
        if preset_dict.get('RBW') is not None and preset_dict.get('RBW').lower() != 'null':
            self.mqtt_controller.publish_message(topic=RBW_INPUT, subtopic="", value=preset_dict.get('RBW'))
            self.mqtt_controller.publish_message(topic=RBW_TRIGGER, subtopic="", value=True)
            self.mqtt_controller.publish_message(topic=RBW_TRIGGER, subtopic="", value=False)
            console_log("✅ Resolution Bandwidth (RBW) set.")

        # --- Conditional: Set VBW ---
        if preset_dict.get('VBW') is not None and preset_dict.get('VBW').lower() != 'null':
            self.mqtt_controller.publish_message(topic=VBW_INPUT, subtopic="", value=preset_dict.get('VBW'))
            self.mqtt_controller.publish_message(topic=VBW_TRIGGER, subtopic="", value=True)
            self.mqtt_controller.publish_message(topic=VBW_TRIGGER, subtopic="", value=False)
            console_log("✅ Video Bandwidth (VBW) set.")

        # --- Conditional: Set Amplitude Rig ---
        ref_level = preset_dict.get('RefLevel')
        attenuation = preset_dict.get('Attenuation')
        preamp = preset_dict.get('PreAmp')
        if all(val is not None and val.lower() != 'null' for val in [ref_level, attenuation, preamp]):
            self.mqtt_controller.publish_message(topic=AMP_REF_LEVEL, subtopic="", value=ref_level)
            self.mqtt_controller.publish_message(topic=AMP_ATTENUATION, subtopic="", value=attenuation)
            self.mqtt_controller.publish_message(topic=AMP_PREAMP, subtopic="", value=preamp)
            self.mqtt_controller.publish_message(topic=AMP_TRIGGER, subtopic="", value=True)
            self.mqtt_controller.publish_message(topic=AMP_TRIGGER, subtopic="", value=False)
            console_log("✅ Amplitude settings (RefLevel, Attenuation, Preamp) set.")
        
        # --- Conditional: Set Trace Modes ---
        trace_modes = [preset_dict.get(f'Trace{i}Mode') for i in range(1, 5)]
        if all(val is not None and val.lower() != 'null' for val in trace_modes):
            self.mqtt_controller.publish_message(topic=TRACE_MODE_1_INPUT, subtopic="", value=trace_modes[0])
            self.mqtt_controller.publish_message(topic=TRACE_MODE_2_INPUT, subtopic="", value=trace_modes[1])
            self.mqtt_controller.publish_message(topic=TRACE_MODE_3_INPUT, subtopic="", value=trace_modes[2])
            self.mqtt_controller.publish_message(topic=TRACE_MODE_4_INPUT, subtopic="", value=trace_modes[3])
            self.mqtt_controller.publish_message(topic=TRACE_TRIGGER, subtopic="", value=True)
            self.mqtt_controller.publish_message(topic=TRACE_TRIGGER, subtopic="", value=False)
            console_log("✅ Trace modes set.")
        
        if Local_Debug_Enable:
            debug_log(
                message=f"🛠️✅ The tuning sequence is complete! All command triggers have been sent.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    # Mock classes for standalone testing
    class MockMqttUtility:
        def publish_message(self, topic: str, subtopic: str, value, retain=False):
            full_topic = f"{topic}/{subtopic}" if subtopic else topic
            print(f"Mock publish: {full_topic} -> {value}")

    mock_mqtt_util = MockMqttUtility()
    worker = PresetPusherWorker(mqtt_controller=mock_mqtt_util)
    
    # Example preset data (from your log)
    example_preset_values = [
        'PRESET_003', 'true', '34MON.STA', '34MON', '590', '650', '620', '60',
        '30000', 'null', 'null', '-50', 'null', 'null', 'Write',
        'MAXhold', 'MINhold', 'null', ''
    ]

    print("\n--- Testing Tune_to_preset with example data ---")
    worker.Tune_to_preset(preset_values=example_preset_values)

#####################################
### File: OPEN-AIR/workers/markers/worker_marker_logic.py
#####################################
# workers/utils_marker_logic.py
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# A utility module to contain core business logic functions related to marker data
# processing and calculation, ensuring separation of concerns (DOP 6.2).
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251005.230247.1

import os
import inspect

# --- Graceful Dependency Importing ---
try:
    import numpy as np
    NUMPY_AVAILABLE = True
except ImportError:
    np = None
    NUMPY_AVAILABLE = False
    
# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command

# --- Global Scope Variables (as per Section 4.4) ---
current_version = "20251005.230247.1"
# The hash calculation drops the leading zero from the hour (23 -> 23)
current_version_hash = (20251005 * 230247 * 1)
current_file = f"{os.path.basename(__file__)}"
Local_Debug_Enable = True


def calculate_frequency_range(marker_data_list):
    # Calculates the minimum and maximum frequencies from a list of marker dictionaries.
    current_function_name = inspect.currentframe().f_code.co_name
    
    # [A brief, one-sentence description of the function's purpose.]
    if Local_Debug_Enable:
        debug_log(
            message=f"🛠️🟢 Entering {current_function_name} to divine the full spectral range from {len(marker_data_list)} markers.",
            file=current_file,
            version=current_version,
            function=current_function_name,
            console_print_func=console_log
        )

    if not marker_data_list:
        if Local_Debug_Enable:
            debug_log(
                message="🛠️🟡 The marker list is an empty void! Returning null range.",
                file=current_file,
                version=current_version,
                function=current_function_name,
                console_print_func=console_log
            )
        return None, None

    if not NUMPY_AVAILABLE:
        console_log("❌ Error: NumPy is required but not available. Cannot perform calculation.")
        return None, None
        
    try:
        freqs = []
        for marker in marker_data_list:
            try:
                # The canonical header for frequency is 'FREQ_MHZ'
                freqs.append(float(marker.get('FREQ_MHZ', 0)))
            except (ValueError, TypeError):
                continue
        
        if freqs:
            min_freq = np.min(freqs)
            max_freq = np.max(freqs)

            console_log(f"✅ Calculated range: {min_freq} MHz to {max_freq} MHz.")
            return min_freq, max_freq
        
        console_log("🟡 No valid frequencies found in marker data.")
        return None, None

    except Exception as e:
        console_log(f"❌ Error in {current_function_name}: {e}")
        if Local_Debug_Enable:
            debug_log(
                message=f"🛠️🔴 Arrr, the code be capsized! Calculation failed: {e}",
                file=current_file,
                version=current_version,
                function=current_function_name,
                console_print_func=console_log
            )
        return None, None

#####################################
### File: OPEN-AIR/workers/markers/worker_marker_peak_re_publisher.py
#####################################
# workers/markers/worker_marker_peak_re_publisher.py
#
# This worker listens to the immediate output of the NAB marker command (Marker_1/value, etc.)
# and republishes the received peak value to the final markers repository location.
# It is instantiated with the starting device ID of the current batch to correctly map outputs.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251213.120000.44

import os
import inspect
import json
import threading
import re
import time 

# --- Module Imports ---
from display.logger import debug_log, console_log
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility

# --- Global Scope Variables ---
Current_Date = 20251213
Current_Time = 120000
Current_iteration = 44

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)
current_file = f"{os.path.basename(__file__)}"


# --- MQTT Topic Constants ---
TOPIC_MARKERS_ROOT = "OPEN-AIR/measurements"
TOPIC_MARKER_NAB_OUTPUT_WILDCARD = "OPEN-AIR/yak/Markers/nab/NAB_all_marker_settings/scpi_outputs/Marker_*/value"
NUMBER_OF_MARKERS = 6


class MarkerPeakPublisher:
    """
    Handles subscriptions to the immediate NAB marker output and republishes the values 
    to the correct final Device-ID/Peak topics based on a provided starting device ID.
    """
    def __init__(self, mqtt_util: MqttControllerUtility, starting_device_id: str):
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message=f"🛠️🟢 Initializing Peak Publisher for batch starting with {starting_device_id}. STARTING MAP GENERATION.",
            file=current_file, version=current_version, function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        self.mqtt_util = mqtt_util
        self.starting_device_id = starting_device_id
        
        self.marker_to_device_map = self._generate_device_map(starting_device_id)
        debug_log(
            message=f"🛠️🔍 Generated Map: {self.marker_to_device_map}",
            file=current_file, version=current_version, function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        # Register Subscription
        self._setup_subscriptions()

        console_log(f"✅ Peak Publisher for {starting_device_id} is active and ready to catch peak values.")

    def _generate_device_map(self, start_id: str) -> dict:
        """
        Calculates the next 5 device IDs and maps Marker_1..Marker_6 to them.
        Assumes ID format is 'Device-###'.
        """
        device_map = {}
        # Extract the number from the starting device ID (e.g., 025 from Device-025)
        match = re.search(r'Device-(\d+)', start_id)
        if not match:
            console_log(f"❌ Error: Invalid starting Device ID format: {start_id}")
            return {}

        start_num = int(match.group(1))
        
        for i in range(NUMBER_OF_MARKERS):
            current_num = start_num + i
            # Format the number back to three digits (e.g., 025)
            device_id = f"Device-{current_num:03d}"
            marker_key = f"Marker_{i + 1}"
            device_map[marker_key] = device_id
        
        return device_map
    
    def _setup_subscriptions(self):
        """
        Subscribes to the specific NAB Marker outputs.
        """
        # We subscribe to the wildcard and rely on the callback to handle the topic match.
        self.mqtt_util.add_subscriber(TOPIC_MARKER_NAB_OUTPUT_WILDCARD, self._on_nab_output_and_republish_peak)

    def _on_nab_output_and_republish_peak(self, topic, payload):
        """
        Listens to the NAB query results (Marker_X/value), logs the result, 
        and republishes the peak value to the final Device-ID/Peak topic.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message=f"🐐🟢 PUBLISHER HANDLER FIRED for topic: {topic}",
            file=current_file, version=current_version, function=current_function_name,
            console_print_func=console_log
        )
        
        try:
            # 1. Extract Marker ID and Peak Value
            marker_id = topic.split('/')[-2] # e.g., "Marker_1"
            device_id = self.marker_to_device_map.get(marker_id)
            final_peak_topic = f"{TOPIC_MARKERS_ROOT}/{device_id}/Peak"
            
            # Safely extract peak value
            try:
                # Value is stored as a JSON string by YakRxManager
                peak_value = json.loads(payload).get("value")
            except (json.JSONDecodeError, AttributeError):
                peak_value = payload # Fallback to raw payload
            
            # 2. Validation and Publishing
            try:
                # Attempt to convert to float. This will fail if the value is 'nan' or 'ERROR'.
                float_peak_value = float(peak_value)

                # Republishing - Publish to the final repo path
                if device_id:
                    self.mqtt_util.publish_message(final_peak_topic, "", float_peak_value, retain=True)
                    
                    debug_log(
                        message=f"🐐💾 REPUBLISH SUCCESS: {device_id} ({marker_id}) peak: {float_peak_value} dBm. Final Topic: {final_peak_topic}",
                        file=current_file, version=current_version, function=current_function_name,
                        console_print_func=console_log
                    )
                else:
                    debug_log(
                        message=f"🐐🟡 REPUBLISH WARNING: Peak received for {marker_id} but no Device-ID found in batch map.",
                        file=current_file, version=current_version, function=current_function_name,
                        console_print_func=console_log
                    )
            
            except ValueError:
                # This block handles "nan" or non-numeric strings, which is your requested error spot.
                error_message = "ERROR: Peak Value Invalid"
                self.mqtt_util.publish_message(final_peak_topic, "", error_message, retain=True)
                
                debug_log(
                    message=f"🐐🔴 REPUBLISH ERROR: Peak Value '{peak_value}' for {device_id} failed conversion. Published Error Status.",
                    file=current_file, version=current_version, function=current_function_name,
                    console_print_func=console_log
                )


        except Exception as e:
            # General failure protection
            # Find the first device ID in the map for error context
            first_device_id = next(iter(self.marker_to_device_map.values()), "UNKNOWN_DEVICE")
            final_peak_topic = f"{TOPIC_MARKERS_ROOT}/{first_device_id}/Peak"
            self.mqtt_util.publish_message(final_peak_topic, "", "CRITICAL_ERROR", retain=True)
            
            console_log(f"❌ Critical Error in Peak Publisher for {first_device_id}: {e}")
            debug_log(
                message=f"🐐🔴 CRITICAL FAILURE in Publisher Flow. Error: {e}",
                file=current_file, version=current_version, function=current_function_name,
                console_print_func=console_log
            )

#####################################
### File: OPEN-AIR/workers/publishers/worker_YAK_publisher.py
#####################################
# OPEN-AIR/workers/publishers/worker_YAK_publisher.py
#
# A script to read and publish JSON datasets from the local directory to an MQTT broker.
# This version includes enhanced logging and versioning to aid in debugging and tracking.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
# Version 20251013.221941.5
# UPDATED: The main function now exclusively publishes files that start with the prefix 'YAK_'.
# FIXED: The recursive publishing logic is updated to handle list of dictionary objects by publishing the inner content as a single JSON blob to prevent excessive nesting.

import os
import json
import sys
import inspect
import pathlib
import time
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from display.styling.style import THEMES, DEFAULT_THEME

Local_Debug_Enable = True # This flag is checked by the updated debug_log and console_log functions

# --- Global Scope Variables ---
CURRENT_DATE = 20251013
CURRENT_TIME = 221941
REVISION_NUMBER = 5
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME * REVISION_NUMBER)
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")

def publish_recursive(mqtt_util, base_topic, data):
    """
    Recursively publishes nested dictionary and list data to the MQTT broker.
    It constructs the topic using meaningful names from the JSON data.
    """
    current_function_name = inspect.currentframe().f_code.co_name
    
    if isinstance(data, dict):
        for key, value in data.items():
            clean_key = key.replace(' ', '_').replace('/', '_')
            new_topic = f"{base_topic}/{clean_key}"

            # --- NEW: Check for JSON string value (for monolithic publishing) ---
            if isinstance(value, str):
                try:
                    # Attempt to load the value as a dictionary (e.g., preset blob)
                    json_value = json.loads(value)
                    if isinstance(json_value, dict):
                        # If it is a dictionary (like the monolithic preset data), 
                        # publish the entire content as a flat JSON string and STOP recursion.
                        mqtt_util.publish_message(topic=new_topic, subtopic="", value=value, retain=True)
                        console_log(f"Published monolithic topic: '{new_topic}'")
                        continue
                except (json.JSONDecodeError, TypeError):
                    # Not a JSON string or not a dict, proceed with normal recursion
                    pass
            # --- END NEW CHECK ---


            # If the value is a dictionary and contains metadata, publish the metadata
            if isinstance(value, dict) and any(k in value for k in ["type", "AES70", "description"]):
                for sub_key, sub_value in value.items():
                    # Only publish the metadata, not the nested children yet
                    if sub_key not in ["fields"]:
                        publish_recursive(mqtt_util, f"{new_topic}/{sub_key}", sub_value)
                # Now, check for nested fields and recurse
                if "fields" in value:
                    publish_recursive(mqtt_util, f"{new_topic}/fields", value["fields"])
                
            # Check for a descriptive name within the current dictionary
            elif isinstance(value, dict) and "name" in value:
                clean_name = value['name'].replace(' ', '_').replace('/', '_')
                publish_recursive(mqtt_util, f"{base_topic}/{clean_key}/{clean_name}", value)
            elif isinstance(value, dict) and "model" in value:
                clean_model = value['model'].replace(' ', '_').replace('/', '_')
                publish_recursive(mqtt_util, f"{base_topic}/{clean_key}/{clean_model}", value)
            elif isinstance(value, dict) and "range" in value:
                clean_range = value['range'].replace(' ', '_').replace('/', '_')
                publish_recursive(mqtt_util, f"{base_topic}/{clean_key}/{clean_range}", value)
            else:
                publish_recursive(mqtt_util, new_topic, value)
    
    elif isinstance(data, list):
        for item in data:
            if isinstance(item, dict):
                # We expect the structure to be [{"KEY": {DATA}}]
                item_key = next(iter(item.keys()))
                item_value = item[item_key]

                new_topic = f"{base_topic}/{item_key}"
                
                # Publish the inner content as a JSON string to keep it monolithic and stop recursion here
                mqtt_util.publish_message(topic=new_topic, subtopic="", value=json.dumps(item_value), retain=True)
                console_log(f"Published monolithic topic: '{new_topic}'")
            else:
                # If the list contains simple values, continue recursion
                new_topic = f"{base_topic}"
                publish_recursive(mqtt_util, new_topic, item)
                
    else:
        cleaned_topic = base_topic.replace("#", "").replace("+", "")
        mqtt_util.publish_message(topic=cleaned_topic, subtopic="", value=json.dumps(data), retain=True)
        console_log(f"Published topic: '{cleaned_topic}' with value: '{json.dumps(data)}'")

def main(mqtt_util: MqttControllerUtility):
    """
    Publishes the contents of JSON files from the 'datasets/YAK'
    directory to the MQTT broker, flattening the JSON structure into detailed topics.
    
    Args:
        mqtt_util: An instance of MqttControllerUtility passed from the main application.
    """
    current_function_name = inspect.currentframe().f_code.co_name

    debug_log(
        message="🖥️🟢 Entering 'main' to publish JSON YAK files.",
        file=current_file,
        version=current_version,
        function=f"YAK_publisher.{current_function_name}",
        console_print_func=console_log
    )
    
    try:
        data_directory = os.path.join(project_root, 'datasets', 'YAK')
        
        json_files = [f for f in os.listdir(data_directory) if f.endswith('.json')]
            
        if not json_files:
            console_log("No JSON files found in the 'datasets/YAK' directory.")
            return

        console_log(f"Found {len(json_files)} JSON file(s) to publish. Publishing recursively...")

        for file_name in json_files:
            file_path = os.path.join(data_directory, file_name)
            
            base_name = os.path.splitext(os.path.basename(file_name))[0]
            if base_name.startswith("dataset_YAK_yak_"):
                base_name = base_name.replace("dataset_YAK_yak_", "", 1)
            elif base_name.startswith("dataset_YAK_"):
                base_name = base_name.replace("dataset_YAK_", "", 1)
            elif base_name.startswith("YAK_"):
                base_name = base_name.replace("YAK_", "", 1)
            
            base_name_clean = base_name.replace(' ', '_')
            
            topic_levels = base_name_clean.split('_')
            
            file_topic_path = "/".join(topic_levels)
            
            root_topic = f"OPEN-AIR/yak/{file_topic_path}"
            
            try:
                debug_log(
                    message=f"🔍🔵 Processing file: '{file_name}'",
                    file=current_file,
                    version=current_version,
                    function=f"YAK_publisher.{current_function_name}",
                    console_print_func=console_log
                )
                with open(file_path, 'r') as f:
                    data = json.load(f)

                mqtt_util.purge_branch(root_topic)
                
                publish_recursive(mqtt_util, root_topic, data)
                console_log(f"✅ Finished processing file: '{file_name}'")

            except json.JSONDecodeError:
                console_log(f"Error: Could not decode JSON from file '{file_name}'. Skipping.")
            except Exception as e:
                console_log(f"An unexpected error occurred while processing '{file_name}': {e}")
            

    except Exception as e:
        console_log(f"❌ Error in {current_function_name}: {e}")
        debug_log(
            message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
            file=current_file,
            version=current_version,
            function=f"YAK_publisher.{current_function_name}",
            console_print_func=console_log
        )

if __name__ == "__main__":
    # This block would typically be called from a main application script
    # For standalone testing, you'd need to mock MqttControllerUtility
    console_log("This script is designed to be imported as a module. Exiting.")


#####################################
### File: OPEN-AIR/workers/publishers/worker_dataset_publisher.py
#####################################
# OPEN-AIR/datasets/worker_dataset_publisher.py
#
# A script to read and publish JSON datasets from the local directory to an MQTT broker.
# This version includes enhanced logging and versioning to aid in debugging and tracking.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
# Version 20250903.230800.4
# UPDATED: The main function now exclusively publishes files that start with the prefix 'dataset_'.

import os
import json
import sys
import inspect
import pathlib
import time
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from display.styling.style import THEMES, DEFAULT_THEME

Local_Debug_Enable = True # This flag is checked by the updated debug_log and console_log functions



# --- Global Scope Variables ---
CURRENT_DATE = 20250903
CURRENT_TIME = 230800
REVISION_NUMBER = 4
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME * REVISION_NUMBER)
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")

def publish_recursive(mqtt_util, base_topic, data):
    """
    Recursively publishes nested dictionary and list data to the MQTT broker.
    It constructs the topic using meaningful names from the JSON data.
    """
    current_function_name = inspect.currentframe().f_code.co_name
    
    if isinstance(data, dict):
        for key, value in data.items():
            clean_key = key.replace(' ', '_').replace('/', '_')
            new_topic = f"{base_topic}/{clean_key}"

            # If the value is a dictionary and contains metadata, publish the metadata
            if isinstance(value, dict) and any(k in value for k in ["type", "AES70", "description"]):
                for sub_key, sub_value in value.items():
                    # Only publish the metadata, not the nested children yet
                    if sub_key not in ["fields"]:
                        publish_recursive(mqtt_util, f"{new_topic}/{sub_key}", sub_value)
                # Now, check for nested fields and recurse
                if "fields" in value:
                    publish_recursive(mqtt_util, f"{new_topic}/fields", value["fields"])
                
            # Check for a descriptive name within the current dictionary
            elif isinstance(value, dict) and "name" in value:
                clean_name = value['name'].replace(' ', '_').replace('/', '_')
                publish_recursive(mqtt_util, f"{base_topic}/{clean_key}/{clean_name}", value)
            elif isinstance(value, dict) and "model" in value:
                clean_model = value['model'].replace(' ', '_').replace('/', '_')
                publish_recursive(mqtt_util, f"{base_topic}/{clean_key}/{clean_model}", value)
            elif isinstance(value, dict) and "range" in value:
                clean_range = value['range'].replace(' ', '_').replace('/', '_')
                publish_recursive(mqtt_util, f"{base_topic}/{clean_key}/{clean_range}", value)
            else:
                publish_recursive(mqtt_util, new_topic, value)
    
    elif isinstance(data, list):
        for item in data:
            if isinstance(item, dict):
                # --- START OF FIX: Only get the first key and its value for the topic.
                item_key = next(iter(item.keys()))
                item_value = item[item_key]

                new_topic = f"{base_topic}/{item_key}"
                publish_recursive(mqtt_util, new_topic, item_value)
                # --- END OF FIX ---
            else:
                new_topic = f"{base_topic}"
                publish_recursive(mqtt_util, new_topic, item)
                
    else:
        cleaned_topic = base_topic.replace("#", "").replace("+", "")
        mqtt_util.publish_message(topic=cleaned_topic, subtopic="", value=json.dumps(data), retain=True)
        console_log(f"Published topic: '{cleaned_topic}' with value: '{json.dumps(data)}'")

def main(mqtt_util: MqttControllerUtility):
    """
    Publishes the contents of JSON files from the 'datasets/configuration' directory
    to the MQTT broker, flattening the JSON structure into detailed topics.
    
    Args:
        mqtt_util: An instance of MqttControllerUtility passed from the main application.
    """
    current_function_name = inspect.currentframe().f_code.co_name

    debug_log(
        message="🖥️🟢 Entering 'main' to publish JSON datasets.",
        file=current_file,
        version=current_version,
        function=f"dataset_publisher.{current_function_name}",
        console_print_func=console_log
    )
    
    try:
        data_directory = os.path.join(project_root, 'datasets', 'configuration')
        
        # MODIFIED: Filter for files ending with '.json'
        json_files = [f for f in os.listdir(data_directory) if f.endswith('.json')]
            
        if not json_files:
            console_log("No JSON files starting with 'dataset_' found in the current directory.")
            return

        console_log(f"Found {len(json_files)} 'dataset_' JSON file(s) to publish. Publishing recursively...")

        for file_name in json_files:
            file_path = os.path.join(data_directory, file_name)
            
            base_name = os.path.splitext(os.path.basename(file_name))[0]
            if base_name.startswith("dataset_configuration_"):
                base_name = base_name.replace("dataset_configuration_", "", 1)
            
            base_name_clean = base_name.replace(' ', '_')
            
            topic_levels = base_name_clean.split('_')
            
            file_topic_path = "/".join(topic_levels)
            
            root_topic = f"OPEN-AIR/configuration/{file_topic_path}"
            
            try:
                debug_log(
                    message=f"🔍🔵 Processing file: '{file_name}'",
                    file=current_file,
                    version=current_version,
                    function=f"dataset_publisher.{current_function_name}",
                    console_print_func=console_log
                )
                with open(file_path, 'r') as f:
                    data = json.load(f)

                mqtt_util.purge_branch(root_topic)
                
                publish_recursive(mqtt_util, root_topic, data)
                console_log(f"✅ Finished processing file: '{file_name}'")

            except json.JSONDecodeError:
                console_log(f"Error: Could not decode JSON from file '{file_name}'. Skipping.")
            except Exception as e:
                console_log(f"An unexpected error occurred while processing '{file_name}': {e}")
            

    except Exception as e:
        console_log(f"❌ Error in {current_function_name}: {e}")
        debug_log(
            message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
            file=current_file,
            version=current_version,
            function=f"dataset_publisher.{current_function_name}",
            console_print_func=console_log
        )

if __name__ == "__main__":
    # This block would typically be called from a main application script
    # For standalone testing, you'd need to mock MqttControllerUtility
    console_log("This script is designed to be imported as a module. Exiting.")


#####################################
### File: OPEN-AIR/workers/publishers/worker_meta_publisher.py
#####################################
# OPEN-AIR/workers/publishers/worker_meta_publisher.py
#
# A script to read and publish JSON datasets from the local directory to an MQTT broker.
# This version includes enhanced logging and versioning to aid in debugging and tracking.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250919.214648.5
# UPDATED: The main function now exclusively publishes files that start with the prefix 'YAK_'.
# FIXED: Added a check to skip publishing a preset's sub-tree if its "Active" flag is false.

import os
import json
import sys
import inspect
import pathlib
import time
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from display.styling.style import THEMES, DEFAULT_THEME

Local_Debug_Enable = True # This flag is checked by the updated debug_log and console_log functions

# --- Global Scope Variables ---
current_version = "20251213.000000.2"
current_version_hash = (20251213 * 0 * 2) # Updated hash
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\\\", "/")

def publish_recursive(mqtt_util, base_topic, data):
    """
    Recursively publishes nested dictionary and list data to the MQTT broker.
    It constructs the topic using meaningful names from the JSON data.
    """
    current_function_name = inspect.currentframe().f_code.co_name
    
    if isinstance(data, dict):
        for key, value in data.items():
            clean_key = key.replace(' ', '_').replace('/', '_')
            new_topic = f"{base_topic}/{clean_key}"

            # NEW FIX: Check for the 'Active' flag and skip the rest of the tree if it's false.
            if isinstance(value, dict) and 'Active' in value and str(value.get('Active')).lower() == 'false':
                debug_log(
                    message=f"🛠️🟡 Skipping inactive branch for topic: {base_topic}/{clean_key}",
                    file=current_file,
                    version=current_version,
                    function=f"meta_publisher.{current_function_name}",
                    console_print_func=console_log
                )
                continue

            # If the value is a dictionary and contains metadata, publish the metadata
            if isinstance(value, dict) and any(k in value for k in ["type", "AES70", "description"]):
                for sub_key, sub_value in value.items():
                    # Only publish the metadata, not the nested children yet
                    if sub_key not in ["fields"]:
                        publish_recursive(mqtt_util, f"{new_topic}/{sub_key}", sub_value)
                # Now, check for nested fields and recurse
                if "fields" in value:
                    publish_recursive(mqtt_util, f"{new_topic}/fields", value["fields"])
                
            # Check for a descriptive name within the current dictionary
            elif isinstance(value, dict) and "name" in value:
                clean_name = value['name'].replace(' ', '_').replace('/', '_')
                publish_recursive(mqtt_util, f"{base_topic}/{clean_key}/{clean_name}", value)
            elif isinstance(value, dict) and "model" in value:
                clean_model = value['model'].replace(' ', '_').replace('/', '_')
                publish_recursive(mqtt_util, f"{base_topic}/{clean_key}/{clean_model}", value)
            elif isinstance(value, dict) and "range" in value:
                clean_range = value['range'].replace(' ', '_').replace('/', '_')
                publish_recursive(mqtt_util, f"{base_topic}/{clean_key}/{clean_range}", value)
            else:
                publish_recursive(mqtt_util, new_topic, value)
    
    elif isinstance(data, list):
        for index, item in enumerate(data):
            # Attempt to find a suitable key for list items, e.g., 'channel', 'id', 'name'
            item_identifier = None
            if isinstance(item, dict):
                if 'channel' in item:
                    item_identifier = f"channel_{item['channel']}"
                elif 'id' in item:
                    item_identifier = item['id'].replace(' ', '_').replace('/', '_')
                elif 'name' in item:
                    item_identifier = item['name'].replace(' ', '_').replace('/', '_')
                else:
                    item_identifier = f"item_{index}" # Fallback if no specific identifier

                new_topic = f"{base_topic}/{item_identifier}"
                publish_recursive(mqtt_util, new_topic, item)
            else:
                # If list item is not a dict, just publish it under the base_topic with an index
                new_topic = f"{base_topic}/item_{index}"
                publish_recursive(mqtt_util, new_topic, item)
                
    else:
        cleaned_topic = base_topic.replace("#", "").replace("+", "")
        mqtt_util.publish_message(topic=cleaned_topic, subtopic="", value=data, retain=True)
        console_log(f"Published topic: '{cleaned_topic}' with value: '{json.dumps(data)}'")

def main(mqtt_util: MqttControllerUtility):
    """
    Publishes the contents of JSON files that start with 'meta_' in the 'datasets/meta'
    directory to the MQTT broker, flattening the JSON structure into detailed topics.
    
    Args:
        mqtt_util: An instance of MqttControllerUtility passed from the main application.
    """
    current_function_name = inspect.currentframe().f_code.co_name

    debug_log(
        message="🖥️🟢 Entering 'main' to publish JSON meta files.",
        file=current_file,
        version=current_version,
        function=f"meta_publisher.{current_function_name}",
        console_print_func=console_log
    )
    
    try:
        data_directory = os.path.join(project_root, 'datasets', 'meta')
        
        json_files = [f for f in os.listdir(data_directory) if f.startswith('meta_') and f.endswith('.json')]
            
        if not json_files:
            console_log("No JSON files starting with 'meta_' found in the 'datasets/meta' directory.")
            return

        console_log(f"Found {len(json_files)} 'meta_' JSON file(s) to publish. Publishing recursively...")

        for file_name in json_files:
            file_path = os.path.join(data_directory, file_name)
            
            base_name = os.path.splitext(os.path.basename(file_name))[0]
            if base_name.startswith("meta_"):
                base_name = base_name.replace("meta_", "", 1)
            
            base_name_clean = base_name.replace(' ', '_')
            
            topic_levels = base_name_clean.split('_')
            
            file_topic_path = "/".join(topic_levels)
            
            root_topic = f"OPEN-AIR/meta/{file_topic_path}"
            
            try:
                debug_log(
                    message=f"🔍🔵 Processing file: '{file_name}'",
                    file=current_file,
                    version=current_version,
                    function=f"meta_publisher.{current_function_name}",
                    console_print_func=console_log
                )
                with open(file_path, 'r') as f:
                    data = json.load(f)

                mqtt_util.purge_branch(root_topic)
                
                publish_recursive(mqtt_util, root_topic, data)
                console_log(f"✅ Finished processing file: '{file_name}'")

            except json.JSONDecodeError:
                console_log(f"Error: Could not decode JSON from file '{file_name}'. Skipping.")
            except Exception as e:
                console_log(f"An unexpected error occurred while processing '{file_name}': {e}")
            

    except Exception as e:
        console_log(f"❌ Error in {current_function_name}: {e}")
        debug_log(
            message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
            file=current_file,
            version=current_version,
            function=f"meta_publisher.{current_function_name}",
            console_print_func=console_log
        )

if __name__ == "__main__":
    # This block would typically be called from a main application script
    # For standalone testing, you'd need to mock MqttControllerUtility
    console_log("This script is designed to be imported as a module. Exiting.")


#####################################
### File: OPEN-AIR/workers/Importer/worker_importer_appender.py
#####################################
# workers/Importer/worker_importer_appender.py
#
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213
Current_Time = 120000
Current_iteration = 44

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#

import inspect
from tkinter import filedialog
from display.logger import debug_log, console_log
from workers.importers.worker_marker_file_import_handling import (
    maker_file_load_markers_file,
    maker_file_load_ias_html,
    maker_file_load_wwb_shw,
    maker_file_load_sb_pdf,
)
from workers.importers.worker_marker_file_import_converter import (
    Marker_convert_wwb_zip_report_to_csv,
    Marker_convert_SB_v2_PDF_File_report_to_csv
)
from workers.Importer.worker_importer_saver import save_markers_file_internally

Local_Debug_Enable = True

def append_markers_file_action(importer_tab_instance):
    headers, new_data = maker_file_load_markers_file()
    if headers and new_data:
        importer_tab_instance.tree_headers = headers
        importer_tab_instance.tree_data.extend(new_data)
        importer_tab_instance._update_treeview()
        save_markers_file_internally(importer_tab_instance)

def append_ias_html_action(importer_tab_instance):
    headers, new_data = maker_file_load_ias_html()
    if headers and new_data:
        importer_tab_instance.tree_headers = headers
        importer_tab_instance.tree_data.extend(new_data)
        importer_tab_instance._update_treeview()
        save_markers_file_internally(importer_tab_instance)

def append_wwb_shw_action(importer_tab_instance):
    headers, new_data = maker_file_load_wwb_shw()
    if headers and new_data:
        importer_tab_instance.tree_headers = headers
        importer_tab_instance.tree_data.extend(new_data)
        importer_tab_instance._update_treeview()
        save_markers_file_internally(importer_tab_instance)

def append_wwb_zip_action(importer_tab_instance):
    current_function = inspect.currentframe().f_code.co_name
    file_path = filedialog.askopenfilename(
        defaultextension=".zip",
        filetypes=[("Shure Wireless Workbench files", "*.zip"), ("All files", "*.*")]
    )
    if not file_path:
        debug_log(
            message="🛠️🟡 'Append WWB.zip' action cancelled by user.",
            file=importer_tab_instance.current_file,
            version=importer_tab_instance.current_version,
            function=f"{current_function}",
            console_print_func=console_log
        )
        return
    headers, new_data = Marker_convert_wwb_zip_report_to_csv(file_path=file_path)
    if headers and new_data:
        importer_tab_instance.tree_headers = headers
        importer_tab_instance.tree_data.extend(new_data)
        importer_tab_instance._update_treeview()
        save_markers_file_internally(importer_tab_instance)

def append_sb_pdf_action(importer_tab_instance):
    headers, new_data = maker_file_load_sb_pdf()
    if headers and new_data:
        importer_tab_instance.tree_headers = headers
        importer_tab_instance.tree_data.extend(new_data)
        importer_tab_instance._update_treeview()
        save_markers_file_internally(importer_tab_instance)

def append_sb_v2_pdf_action(importer_tab_instance):
    current_function = inspect.currentframe().f_code.co_name
    file_path = filedialog.askopenfilename(
        defaultextension=".pdf",
        filetypes=[("Sound Base V2 PDF files", "*.pdf"), ("All files", "*.*")]
    )
    if not file_path:
        debug_log(
            message="🛠️🟡 'Append SB V2.pdf' action cancelled by user.",
            file=importer_tab_instance.current_file,
            version=importer_tab_instance.current_version,
            function=f"{current_function}",
            console_print_func=console_log
        )
        return
    headers, new_data = Marker_convert_SB_v2_PDF_File_report_to_csv(pdf_file_path=file_path)
    if headers and new_data:
        importer_tab_instance.tree_headers = headers
        importer_tab_instance.tree_data.extend(new_data)
        importer_tab_instance._update_treeview()
        save_markers_file_internally(importer_tab_instance)


#####################################
### File: OPEN-AIR/workers/Importer/worker_importer_editor.py
#####################################
# workers/Importer/worker_importer_editor.py
#
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213
Current_Time = 120000
Current_iteration = 44

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#

import inspect
import os
import re
import tkinter as tk
from tkinter import ttk
from display.logger import debug_log, console_log
from workers.Importer.worker_importer_saver import save_markers_file_internally

Local_Debug_Enable = True

def on_tree_double_click(importer_tab_instance, event):
    current_function = inspect.currentframe().f_code.co_name
    current_file = os.path.basename(__file__)
    debug_log(f"[{current_file} - {current_function}] Treeview double-clicked for editing.", file=current_file, version=current_version, function=current_function, console_print_func=console_log)
    if not importer_tab_instance.marker_tree.identify_region(event.x, event.y) == "cell":
        return
    column_id = importer_tab_instance.marker_tree.identify_column(event.x)
    item_id = importer_tab_instance.marker_tree.identify_row(event.y)
    if not item_id or not column_id:
        return
    col_index = int(column_id[1:]) - 1
    if col_index < 0 or col_index >= len(importer_tab_instance.tree_headers):
        debug_log(f"[{current_file} - {current_function}] Invalid column index {col_index} for editing.", file=current_file, version=current_version, function=current_function, console_print_func=console_log)
        return
    current_value = importer_tab_instance.marker_tree.item(item_id, 'values')[col_index]
    start_editing_cell(importer_tab_instance, item_id, col_index, initial_value=current_value)

def start_editing_cell(importer_tab_instance, item, col_index, initial_value=""):
    current_function = inspect.currentframe().f_code.co_name
    current_file = os.path.basename(__file__)
    for widget in importer_tab_instance.marker_tree.winfo_children():
        if isinstance(widget, ttk.Entry) and widget.winfo_name() == "cell_editor":
            widget.destroy()
    entry_editor = ttk.Entry(importer_tab_instance.marker_tree, style="Markers.TEntry", name="cell_editor")
    entry_editor.insert(0, initial_value)
    entry_editor.focus_force()
    x, y, width, height = importer_tab_instance.marker_tree.bbox(item, importer_tab_instance.marker_tree["columns"][col_index])
    entry_editor.place(x=x, y=y, width=width, height=height)
    entry_editor.current_item = item
    entry_editor.current_col_index = col_index
    def on_edit_complete_and_navigate(event, navigate_direction=None):
        new_value = entry_editor.get()
        entry_editor.destroy()
        current_values = list(importer_tab_instance.marker_tree.item(item, 'values'))
        current_values[col_index] = new_value
        importer_tab_instance.marker_tree.item(item, values=current_values)
        row_idx = importer_tab_instance.marker_tree.index(item)
        if row_idx < len(importer_tab_instance.tree_data) and isinstance(importer_tab_instance.tree_data[row_idx], dict):
            importer_tab_instance.tree_data[row_idx][importer_tab_instance.tree_headers[col_index]] = new_value
            console_log(f"Updated cell: Row {row_idx+1}, Column '{importer_tab_instance.tree_headers[col_index]}' to '{new_value}'")
            debug_log(f"[{current_file} - {current_function}] Updated tree_data[{row_idx}]['{importer_tab_instance.tree_headers[col_index]}'] to '{new_value}'.", file=current_file, version=current_version, function=current_function, console_print_func=console_log)
            save_markers_file_internally(importer_tab_instance)
        else:
            debug_log(f"[{current_file} - {current_function}] Error: Row index {row_idx} out of bounds or data not a dictionary for self.tree_data.", file=current_file, version=current_version, function=current_function, console_print_func=console_log)
        if navigate_direction:
            navigate_cells(importer_tab_instance, item, col_index, navigate_direction)
    entry_editor.bind("<Return>", lambda e: on_edit_complete_and_navigate(e, "down"))
    entry_editor.bind("<Tab>", lambda e: on_edit_complete_and_navigate(e, "right"))
    entry_editor.bind("<Shift-Tab>", lambda e: on_edit_complete_and_navigate(e, "left"))
    entry_editor.bind("<Control-Return>", lambda e: on_edit_complete_and_navigate(e, "ctrl_down"))
    entry_editor.bind("<FocusOut>", lambda e: on_edit_complete_and_navigate(e, None))
    entry_editor.bind("<Up>", lambda e: on_edit_complete_and_navigate(e, "up"))
    entry_editor.bind("<Down>", lambda e: on_edit_complete_and_navigate(e, "down"))
    entry_editor.bind("<Left>", lambda e: on_edit_complete_and_navigate(e, "left"))
    entry_editor.bind("<Right>", lambda e: on_edit_complete_and_navigate(e, "right"))

def navigate_cells(importer_tab_instance, current_item, current_col_index, direction):
    current_function = inspect.currentframe().f_code.co_name
    current_file = os.path.basename(__file__)
    debug_log(f"[{current_file} - {current_function}] Navigating cells.", file=current_file, version=current_version, function=current_function, console_print_func=console_log)
    items = importer_tab_instance.marker_tree.get_children()
    num_rows = len(items)
    num_cols = len(importer_tab_instance.tree_headers)
    current_row_idx = items.index(current_item) if current_item in items else -1
    next_item = None
    next_col_index = -1
    initial_value_for_next_cell = ""
    if current_row_idx == -1:
        debug_log(f"[{current_file} - {current_function}] Current item not found in tree for navigation.", file=current_file, version=current_version, function=current_function, console_print_func=console_log)
        return
    if direction == "down":
        next_row_idx = current_row_idx + 1
        next_col_index = current_col_index
        if next_row_idx < num_rows:
            next_item = items[next_row_idx]
    elif direction == "up":
        next_row_idx = current_row_idx - 1
        next_col_index = current_col_index
        if next_row_idx >= 0:
            next_item = items[next_row_idx]
    elif direction == "right":
        next_col_index = current_col_index + 1
        if next_col_index < num_cols:
            next_item = current_item
        else:
            next_row_idx = current_row_idx + 1
            if next_row_idx < num_rows:
                next_item = items[next_row_idx]
                next_col_index = 0
    elif direction == "left":
        next_col_index = current_col_index - 1
        if next_col_index >= 0:
            next_item = current_item
        else:
            next_row_idx = current_row_idx - 1
            if next_row_idx >= 0:
                next_item = items[next_row_idx]
                next_col_index = num_cols - 1
    elif direction == "ctrl_down":
        next_row_idx = current_row_idx + 1
        next_col_index = current_col_index
        if next_row_idx < num_rows:
            next_item = items[next_row_idx]
            prev_cell_value = importer_tab_instance.marker_tree.item(current_item, 'values')[current_col_index]
            initial_value_for_next_cell = increment_string_with_trailing_digits(prev_cell_value)
            new_values = list(importer_tab_instance.marker_tree.item(next_item, 'values'))
            new_values[next_col_index] = initial_value_for_next_cell
            importer_tab_instance.marker_tree.item(next_item, values=new_values)
            if next_row_idx < len(importer_tab_instance.tree_data) and isinstance(importer_tab_instance.tree_data[next_row_idx], dict):
                importer_tab_instance.tree_data[next_row_idx][importer_tab_instance.tree_headers[next_col_index]] = initial_value_for_next_cell
            else:
                debug_log(f"[{current_file} - {current_function}] Cannot Ctrl+Enter: No row below.", file=current_file, version=current_version, function=current_function, console_print_func=console_log)
                return
    if next_item is not None and next_col_index != -1:
        if direction != "ctrl_down":
            try:
                next_item_values = importer_tab_instance.marker_tree.item(next_item, 'values')
                if 0 <= next_col_index < len(next_item_values):
                    initial_value_for_next_cell = next_item_values[next_col_index]
                else:
                    debug_log(f"[{current_file} - {current_function}] Next column index {next_col_index} out of bounds for next item values. Setting empty.", file=current_file, version=current_version, function=current_function, console_print_func=console_log)
                    initial_value_for_next_cell = ""
            except Exception as e:
                debug_log(f"[{current_file} - {current_function}] Error getting initial value for next cell: {e}. Setting empty.", file=current_file, version=current_version, function=current_function, console_print_func=console_log)
                initial_value_for_next_cell = ""
        importer_tab_instance.marker_tree.focus(next_item)
        importer_tab_instance.marker_tree.selection_set(next_item)
        importer_tab_instance.after(10, lambda: start_editing_cell(importer_tab_instance, next_item, next_col_index, initial_value_for_next_cell))
    else:
        debug_log(f"[{current_file} - {current_function}] No cell to navigate to in direction: {direction}", file=current_file, version=current_version, function=current_function, console_print_func=console_log)

def increment_string_with_trailing_digits(text):
    match = re.search(r'(\d+)$', text)
    if match:
        num_str = match.group(1)
        num_int = int(num_str)
        incremented_num = num_int + 1
        new_num_str = str(incremented_num).zfill(len(num_str))
        return text[:-len(num_str)] + new_num_str
    return text

def on_tree_header_click(importer_tab_instance, event):
    current_function = inspect.currentframe().f_code.co_name
    current_file = os.path.basename(__file__)
    debug_log(f"[{current_file} - {current_function}] Treeview header clicked for sorting.", file=current_file, version=current_version, function=current_function, console_print_func=console_log)
    region = importer_tab_instance.marker_tree.identify_region(event.x, event.y)
    if region == "heading":
        column_id = importer_tab_instance.marker_tree.identify_column(event.x)
        col_index = int(column_id[1:]) - 1
        if col_index < 0 or col_index >= len(importer_tab_instance.tree_headers):
            debug_log(f"[{current_file} - {current_function}] Invalid column index {col_index} for sorting.", file=current_file, version=current_version, function=current_function, console_print_func=console_log)
            return
        column_name = importer_tab_instance.tree_headers[col_index]
        if importer_tab_instance.sort_column == column_name:
            importer_tab_instance.sort_direction = not importer_tab_instance.sort_direction
        else:
            importer_tab_instance.sort_column = column_name
            importer_tab_instance.sort_direction = True
        sort_treeview(importer_tab_instance, column_name, importer_tab_instance.sort_direction)

def sort_treeview(importer_tab_instance, column_name, ascending):
    current_function = inspect.currentframe().f_code.co_name
    current_file = os.path.basename(__file__)
    debug_log(f"[{current_file} - {current_function}] Sorting treeview by '{column_name}', ascending: {ascending}.", file=current_file, version=current_version, function=current_function, console_print_func=console_log)
    def get_sort_key(item):
        value = item.get(column_name, "")
        try:
            return float(value)
        except (ValueError, TypeError):
            return str(value)
    importer_tab_instance.tree_data.sort(key=get_sort_key, reverse=not ascending)
    populate_marker_tree(importer_tab_instance)
    console_log(f"Sorted by '{column_name}' {'Ascending' if ascending else 'Descending'}.")

def populate_marker_tree(importer_tab_instance):
    """Re-populates the treeview from the internal data model."""
    importer_tab_instance.marker_tree.delete(*importer_tab_instance.marker_tree.get_children())
    standardized_headers = importer_tab_instance.tree_headers if importer_tab_instance.tree_headers else ["ZONE", "GROUP", "DEVICE", "NAME", "FREQ_MHZ", "PEAK"]
    importer_tab_instance.marker_tree["columns"] = standardized_headers
    for col in standardized_headers:
        importer_tab_instance.marker_tree.heading(col, text=col, command=lambda c=col: sort_treeview(importer_tab_instance, c, importer_tab_instance.sort_column != c or not importer_tab_instance.sort_direction))
        importer_tab_instance.marker_tree.column(col, width=100)
    for row in importer_tab_instance.tree_data:
        values = [row.get(raw_header, '') for raw_header in standardized_headers]
        importer_tab_instance.marker_tree.insert("", "end", values=values)

def delete_selected_row(importer_tab_instance, event):
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"[{importer_tab_instance.current_file} - {current_function}] Delete key pressed.", file=importer_tab_instance.current_file, version=importer_tab_instance.current_version, function=current_function, console_print_func=console_log)
    selected_items = importer_tab_instance.marker_tree.selection()
    if not selected_items:
        console_log("🟡 No row selected to delete.")
        return
    for item in selected_items:
        index_in_tree = importer_tab_instance.marker_tree.index(item)
        if index_in_tree < len(importer_tab_instance.tree_data):
            importer_tab_instance.marker_tree.delete(item)
            del importer_tab_instance.tree_data[index_in_tree]
            console_log(f"✅ Deleted row {index_in_tree + 1}.")
        else:
            console_log(f"❌ Error: Row {index_in_tree + 1} not found in data.")
    save_markers_file_internally(importer_tab_instance)


#####################################
### File: OPEN-AIR/workers/Importer/worker_importer_loader.py
#####################################
# workers/Importer/worker_importer_loader.py
#
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213
Current_Time = 120000
Current_iteration = 44

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#

import inspect
from tkinter import filedialog
from display.logger import debug_log, console_log
from workers.importers.worker_marker_file_import_handling import (
    maker_file_load_markers_file,
    maker_file_load_ias_html,
    maker_file_load_wwb_shw,
    maker_file_load_sb_pdf,
)
from workers.importers.worker_marker_file_import_converter import (
    Marker_convert_wwb_zip_report_to_csv,
    Marker_convert_SB_v2_PDF_File_report_to_csv
)
from workers.Importer.worker_importer_saver import save_markers_file_internally

Local_Debug_Enable = True

def load_markers_file_action(importer_tab_instance):
    headers, data = maker_file_load_markers_file()
    if headers and data:
        importer_tab_instance.tree_headers = headers
        importer_tab_instance.tree_data = data
        importer_tab_instance._update_treeview()
        save_markers_file_internally(importer_tab_instance)

def load_ias_html_action(importer_tab_instance):
    headers, data = maker_file_load_ias_html()
    if headers and data:
        importer_tab_instance.tree_headers = headers
        importer_tab_instance.tree_data = data
        importer_tab_instance._update_treeview()
        save_markers_file_internally(importer_tab_instance)

def load_wwb_shw_action(importer_tab_instance):
    headers, data = maker_file_load_wwb_shw()
    if headers and data:
        importer_tab_instance.tree_headers = headers
        importer_tab_instance.tree_data = data
        importer_tab_instance._update_treeview()
        save_markers_file_internally(importer_tab_instance)

def load_wwb_zip_action(importer_tab_instance):
    current_function = inspect.currentframe().f_code.co_name
    file_path = filedialog.askopenfilename(
        defaultextension=".zip",
        filetypes=[("Shure Wireless Workbench files", "*.zip"), ("All files", "*.*")]
    )
    if not file_path:
        debug_log(
            message="🛠️🟡 'Load WWB.zip' action cancelled by user.",
            file=importer_tab_instance.current_file,
            version=importer_tab_instance.current_version,
            function=f"{current_function}",
            console_print_func=console_log
        )
        return
    headers, data = Marker_convert_wwb_zip_report_to_csv(file_path=file_path)
    if headers and data:
        importer_tab_instance.tree_headers = headers
        importer_tab_instance.tree_data = data
        importer_tab_instance._update_treeview()
        save_markers_file_internally(importer_tab_instance)

def load_sb_pdf_action(importer_tab_instance):
    headers, data = maker_file_load_sb_pdf()
    if headers and data:
        importer_tab_instance.tree_headers = headers
        importer_tab_instance.tree_data = data
        importer_tab_instance._update_treeview()
        save_markers_file_internally(importer_tab_instance)

def load_sb_v2_pdf_action(importer_tab_instance):
    current_function = inspect.currentframe().f_code.co_name
    file_path = filedialog.askopenfilename(
        defaultextension=".pdf",
        filetypes=[("Sound Base V2 PDF files", "*.pdf"), ("All files", "*.*")]
    )
    if not file_path:
        debug_log(
            message="🛠️🟡 'Load SB V2.pdf' action cancelled by user.",
            file=importer_tab_instance.current_file,
            version=importer_tab_instance.current_version,
            function=f"{current_function}",
            console_print_func=console_log
        )
        return
    headers, data = Marker_convert_SB_v2_PDF_File_report_to_csv(pdf_file_path=file_path)
    if headers and data:
        importer_tab_instance.tree_headers = headers
        importer_tab_instance.tree_data = data
        importer_tab_instance._update_treeview()
        save_markers_file_internally(importer_tab_instance)


#####################################
### File: OPEN-AIR/workers/Importer/worker_importer_saver.py
#####################################
# workers/Importer/worker_importer_saver.py
#
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213
Current_Time = 120000
Current_iteration = 44

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#

from display.logger import console_log
from workers.importers.worker_marker_file_import_handling import (
    maker_file_save_intermediate_file,
    maker_file_save_open_air_file
)
from workers.importers.worker_marker_csv_to_json_mqtt import csv_to_json_and_publish

def save_markers_file_internally(importer_tab_instance):
    maker_file_save_intermediate_file(importer_tab_instance.tree_headers, importer_tab_instance.tree_data)
    if importer_tab_instance.mqtt_util:
        publish_markers_to_mqtt(importer_tab_instance)

def publish_markers_to_mqtt(importer_tab_instance):
    csv_to_json_and_publish(mqtt_util=importer_tab_instance.mqtt_util)

def save_open_air_file_action(importer_tab_instance):
    maker_file_save_open_air_file(importer_tab_instance.tree_headers, importer_tab_instance.tree_data)
    if importer_tab_instance.mqtt_util:
        publish_markers_to_mqtt(importer_tab_instance)


#####################################
### File: OPEN-AIR/workers/importers/worker_marker_csv_to_json_mqtt.py
#####################################
# workers/worker_marker_csv_to_json_mqtt.py
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# This module reads a CSV file, converts it to a structured JSON format,
# saves the JSON, and publishes the entire structure to an MQTT topic.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251005.220127.2

import os
import inspect
import csv
import json
import pathlib
from collections import defaultdict

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from workers.utils.worker_project_paths import MARKERS_JSON_PATH, MARKERS_CSV_PATH # NEW: Import paths


# --- Global Scope Variables ---
current_version = "20251005.220127.2"
current_version_hash = (20251005 * 220127 * 2)
current_file = f"{os.path.basename(__file__)}"
Local_Debug_Enable = True

MQTT_BASE_TOPIC = "OPEN-AIR/repository/markers"


def _publish_recursive(mqtt_util, base_topic, data):
    """
    A simple recursive function to publish all parts of a nested dictionary.
    """
    if isinstance(data, dict):
        for key, value in data.items():
            new_topic = f"{base_topic}/{key}"
            _publish_recursive(mqtt_util, new_topic, value)
    else:
        # When we hit a final value, publish it.
        mqtt_util.publish_message(topic=base_topic, subtopic="", value=str(data), retain=True)


def csv_to_json_and_publish(mqtt_util: MqttControllerUtility):
    """
    Reads MARKERS.csv, calculates summary data (total, min/max freq, span), converts
    to a flat device-centric JSON structure, saves it, and publishes to MQTT.
    
    MODIFIED: Uses the new nested structure with an 'IDENTITY' blob.
    """
    current_function_name = inspect.currentframe().f_code.co_name
    if Local_Debug_Enable:
        debug_log(
            message=f"🛠️🟢 Initiating device-centric CSV to JSON conversion and MQTT publish. Applying new nested structure.",
            file=current_file,
            version=current_version,
            function=current_function_name,
            console_print_func=console_log
        )

    if not MARKERS_CSV_PATH.is_file():
        console_log(f"❌ {MARKERS_CSV_PATH} not found. Aborting operation.")
        return

    # --- Step 1: Read CSV and generate the flat JSON structure ---
    json_state = {}
    try:
        with open(MARKERS_CSV_PATH, mode='r', newline='', encoding='utf-8') as csvfile:
            # Read all data into a list to process it multiple times
            reader = list(csv.DictReader(csvfile))
            
            total_devices = len(reader)
            min_freq = float('inf')
            max_freq = float('-inf')

            # First pass: calculate min/max frequencies
            for row in reader:
                try:
                    # --- FIX: Check for 'FREQ', 'FREQ (MHZ)', and 'FREQ_MHZ' ---
                    # Now relies on the canonical 'FREQ_MHZ' key from file_handling worker
                    freq_str = row.get("FREQ_MHZ")
                    if freq_str:
                        freq = float(freq_str)
                        if freq < min_freq:
                            min_freq = freq
                        if freq > max_freq:
                            max_freq = freq
                except (ValueError, TypeError):
                    # Ignore rows with non-numeric frequencies for min/max calculation
                    continue
            
            # Handle case where no valid frequencies were found
            if min_freq == float('inf'): min_freq = 0
            if max_freq == float('-inf'): max_freq = 0

            # Calculate the span
            span_mhz = max_freq - min_freq

            # Add summary data to the root of the JSON state
            json_state["total_devices"] = total_devices
            json_state["min_frequency_mhz"] = round(min_freq, 6)
            json_state["max_frequency_mhz"] = round(max_freq, 6)
            json_state["span_mhz"] = round(span_mhz, 6)
            
            # Second pass: build the device dictionaries
            for i, row in enumerate(reader, 1):
                device_key = f"Device-{i:03d}"
                
                # --- NEW STRUCTURE IMPLEMENTATION ---
                json_state[device_key] = {
                    "IDENTITY": {
                        "Name": row.get("NAME", ""),
                        "Device": row.get("DEVICE", ""),
                        "Zone": row.get("ZONE", ""),
                        "Group": row.get("GROUP", ""),
                        "FREQ_MHZ": row.get("FREQ_MHZ") or "null",
                    },
                    "Peak": row.get("PEAK", "nan"),
                    # Removing the "active" and "selected" fields as requested
                }
                # --- END NEW STRUCTURE IMPLEMENTATION ---

        console_log("✅ Successfully read CSV and generated nested JSON structure with summary data.")
    except Exception as e:
        console_log(f"❌ Error processing CSV file: {e}")
        if Local_Debug_Enable:
            debug_log(
                message=f"❌🔴 The CSV-to-JSON contraption has malfunctioned! The error be: {e}",
                file=current_file,
                version=current_version,
                function=current_function_name,
                console_print_func=console_log
            )
        return

    # --- Step 2: Save the generated structure to MARKERS.json ---
    try:
        # Ensure the DATA directory exists
        MARKERS_JSON_PATH.parent.mkdir(parents=True, exist_ok=True)
        with open(MARKERS_JSON_PATH, 'w') as f:
            json.dump(json_state, f, indent=4)
        console_log(f"✅ Saved generated structure to {MARKERS_JSON_PATH}.")
    except Exception as e:
        console_log(f"❌ Error saving to {MARKERS_JSON_PATH}: {e}")
        if Local_Debug_Enable:
            debug_log(
                message=f"❌🔴 The enchanted scroll refuses to be written! The error be: {e}",
                file=current_file,
                version=current_version,
                function=current_function_name,
                console_print_func=console_log
            )
        return

    # --- Step 3: Publish the entire structure to MQTT ---
    try:
        # First, clear any old data under the base topic by publishing a null, retained message.
        # This will remove all the old topics (Device-001/Name, Device-001/active, etc.)
        mqtt_util.purge_branch(MQTT_BASE_TOPIC)
        console_log(f"Cleared old data under topic: {MQTT_BASE_TOPIC}/#")

        # Now, publish the new, complete structure recursively.
        _publish_recursive(mqtt_util, MQTT_BASE_TOPIC, json_state)
        
        console_log("✅ Successfully published the full marker set to MQTT.")
    except Exception as e:
        console_log(f"❌ Error publishing to MQTT: {e}")
        if Local_Debug_Enable:
            debug_log(
                message=f"❌🔴 The message pigeons have flown astray! The error be: {e}",
                file=current_file,
                version=current_version,
                function=current_function_name,
                console_print_func=console_log
            )

#####################################
### File: OPEN-AIR/workers/importers/worker_marker_file_import_converter.py
#####################################
# workers/worker_marker_report_converter.py
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# This file contains utility functions for converting various spectrum analyzer
# report formats (HTML, SHW, Soundbase PDF) into a standardized CSV format.
# This version specifically restores the logic from the previously provided
# 'old_report_converter_utils.py' and adapts it to the new logging system.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
# Version 20250815.200000.3 (FIXED: The headers for CSV conversions now include a "Peak" column with a placeholder value to prevent data loss.)
# MODIFIED: Added a new function Marker_convert_wwb_zip_report_to_csv to handle WWB zip files.

import csv
import subprocess
import sys
import xml.etree.ElementTree as ET
import os
import re
from bs4 import BeautifulSoup
import pdfplumber
import inspect
import numpy as np
import zipfile
import io
# Removed the unnecessary import: from tkinter import filedialog

current_file = os.path.basename(__file__) # Get current file name for debug_log
current_version = "20250815.200000.3"
current_version_hash = (20250815 * 200000 * 3)
Local_Debug_Enable = True

headers = ["ZONE", "GROUP", "DEVICE", "NAME", "FREQ_MHZ", "PEAK"] # NEW: Added Peak header

# Updated imports for new logging functions
from display.logger import debug_log, console_log, log_visa_command


def Marker_convert_IAShtml_report_to_csv(html_content):
    """
    Converts the HTML frequency coordination report into a list of dictionaries
    suitable for CSV output, handling multiple zones. This version is based on
    the IAS HTML to CSV.py prototype for accurate extraction.
    All frequencies are converted to MHz for consistency.

    Inputs:
        html_content (str): The full HTML content of the report.
        console_print_func (function, optional): A function to use for printing messages
                                                 to the console. If None, uses standard print.

    Returns:
        tuple: A tuple containing:
               - list: A list of strings representing the CSV headers.
               - list: A list of dictionaries, where each dictionary represents a row
                       in the CSV and keys are column headers.
    """
    
    current_function = inspect.currentframe().f_code.co_name
    current_file = os.path.basename(__file__) # Get current file name for debug_log

    if Local_Debug_Enable:
        debug_log("Starting HTML report conversion.", 
                file=current_file, version=current_version, function=current_function, console_print_func=console_log)

    soup = BeautifulSoup(html_content, 'html.parser')
    

    
    data_rows = []

    # Find the main content area within the HTML, based on the IAS prototype.
    main_content_container = None
    
    first_zone_p = soup.find('p', style=lambda value: value and 'font-size: large' in value and 'text-decoration: underline' in value)

    if first_zone_p:
        main_content_container = first_zone_p.find_parent('span')
        
        if Local_Debug_Enable:
            debug_log(f"Found main content container based on first zone paragraph.",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)
    
    if not main_content_container:
        main_table = soup.find('table', class_='MainTable')
        if main_table:
            main_table_trs = main_table.find_all('tr')
            if len(main_table_trs) > 1:
                second_tr_td = main_table_trs[1].find('td')
                if second_tr_td:
                    potential_span_wrapper = second_tr_td.find('span')
                    if potential_span_wrapper:
                        main_content_container = potential_span_wrapper
                    else:
                        main_content_container = second_tr_td
                    
                    if Local_Debug_Enable:
                        debug_log(f"Found main content container based on MainTable structure.",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)
    
    if not main_content_container:
        
        if Local_Debug_Enable:
            debug_log("Warning: Could not find the main content container. No data will be extracted.",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)
        return headers, data_rows

    current_zone_type = ""
    # Iterate through the children of the identified main content container
    for element in main_content_container.children:
        if element.name == 'p' and element.get('style') and \
           'font-size: large' in element.get('style') and \
           'text-decoration: underline' in element.get('style'):
            zone_text = element.get_text(strip=True)
            if zone_text.startswith("Zone:"):
                current_zone_type = zone_text.replace("Zone:", "").strip()
        
                if Local_Debug_Enable:
                    debug_log(f"Processing Zone: {current_zone_type}",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)
        
        elif element.name == 'table' and 'Assignment' in element.get('class', []):
            table = element
            
            device_name_tag = table.find('th')
            current_group_name = device_name_tag.get_text(strip=True) if device_name_tag else ""
        
            if Local_Debug_Enable:
                debug_log(f"Processing Group: {current_group_name}",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)

            rows_in_table = table.find_all('tr')[1:] # Skip the first row as it contains the <th> (device_name)
      
            if Local_Debug_Enable:
                debug_log(f"Found {len(rows_in_table)} rows in current table.",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)

            for row in rows_in_table:
                data_spans = row.find_all('span')
                
                if data_spans:
                    for data_span in data_spans:
                        cells = data_span.find_all('td')
                        if len(cells) >= 4:
                            band_type = cells[0].get_text(strip=True)
                            
                            channel_frequency_tag = cells[3].find('b')
                            channel_frequency_str = channel_frequency_tag.get_text(strip=True) if channel_frequency_tag else ""

                            channel_name = cells[1].get_text(strip=True)
                            if not channel_name:
                                channel_name = cells[2].get_text(strip=True)
                            
                            # Convert frequency string to MHz
                            freq_MHz = "N/A"
                            try:
                                freq_match = re.search(r'(\d+(\.\d+)?)\s*(kHz|MHz|GHz)', channel_frequency_str, re.IGNORECASE)
                                if freq_match:
                                    value = float(freq_match.group(1))
                                    unit = freq_match.group(3).lower()
                                    if unit == 'mhz':
                                        freq_MHz = value
                                    elif unit == 'ghz':
                                        freq_MHz = value * 1000 # GHz to MHz
                                    elif unit == 'khz':
                                        freq_MHz = value / 1000 # kHz to MHz
                                    if Local_Debug_Enable:
                                        debug_log(f"HTML Freq conversion: '{channel_frequency_str}' -> {freq_MHz} MHz",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)
                                else:
                                    # Fallback if regex doesn't match, assume MHz
                                    freq_MHz = float(channel_frequency_str) # Assume it's already in MHz
    
                                    if Local_Debug_Enable:
                                        debug_log(f"HTML Freq conversion (fallback): '{channel_frequency_str}' -> {freq_MHz} MHz",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)
                            except ValueError:
    
                                if Local_Debug_Enable:
                                    debug_log(f"HTML Freq conversion error: '{channel_frequency_str}'",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)
                                freq_MHz = "Invalid Frequency"

                            row_data = {
                                "ZONE": current_zone_type,
                                "GROUP": current_group_name,
                                "DEVICE": band_type,
                                "NAME": channel_name,
                                "FREQ_MHZ": freq_MHz, # Store in MHz
                                "PEAK": np.nan # NEW: Added Peak column
                            }
                            if band_type or channel_frequency_str or channel_name:
                                data_rows.append(row_data)
                           
                            if Local_Debug_Enable:
                                debug_log(f"Added HTML row: {row_data}",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)
                else:
                    # Process rows that have <td>s directly (e.g., blank rows or specific structures without inner spans)
                    cells = row.find_all('td')
                    if len(cells) >= 4: 
                        band_type = cells[0].get_text(strip=True)
                        channel_frequency_tag = cells[3].find('b')
                        channel_frequency_str = channel_frequency_tag.get_text(strip=True) if channel_frequency_tag else ""
                        
                        channel_name = cells[1].get_text(strip=True)
                     
                        if not channel_name:
                            channel_name = cells[2].get_text(strip=True)

                        # Convert frequency string to MHz
                        freq_MHz = "N/A"
                        try:
                            freq_match = re.search(r'(\d+(?:\.\d+)?)\s*(?:(k|m|g)?hz)?', channel_frequency_str, re.IGNORECASE)
                            if freq_match:
                                value = float(freq_match.group(1))
                                unit_group = freq_match.group(2) # FIX: Changed from group(3) to group(2) to match regex changes
                                if unit_group:
                                    unit = unit_group.lower()
                                    if unit == 'm': # MHz
                                        freq_MHz = value
                                    elif unit == 'g': # GHz
                                        freq_MHz = value * 1000
                                    elif unit == 'k': # kHz
                                        freq_MHz = value / 1000
                                else: # No unit specified, assume MHz
                                    freq_MHz = value
                                if Local_Debug_Enable:
                                    debug_log(f"HTML Freq conversion (direct td): '{channel_frequency_str}' -> {freq_MHz} MHz",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)
                            else:
                                # Fallback if regex doesn't match, assume MHz
                                freq_MHz = float(channel_frequency_str) # Assume it's already in MHz
    
                                if Local_Debug_Enable:
                                    debug_log(f"HTML Freq conversion (direct td, fallback): '{channel_frequency_str}' -> {freq_MHz} MHz",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)
                        except ValueError:
    
                            if Local_Debug_Enable:
                                debug_log(f"HTML Freq conversion error (direct td): '{channel_frequency_str}'",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)
                            freq_MHz = "Invalid Frequency"

                        row_data = {
                            "ZONE": current_zone_type,
                            "GROUP": current_group_name,
                        
                            "DEVICE": band_type,
                            "NAME": channel_name,
                            "FREQ_MHZ": freq_MHz, # Store in MHz
                            "PEAK": np.nan # NEW: Added Peak column
                        }
                        if band_type or channel_frequency_str or channel_name:
                            data_rows.append(row_data)
                            if Local_Debug_Enable:
                                debug_log(f"Added HTML row (direct td): {row_data}",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)
    
    if Local_Debug_Enable:
        debug_log(f"Finished HTML report conversion. Extracted {len(data_rows)} rows.",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)
    return headers, data_rows


def Marker_convert_WWB_SHW_File_report_to_csv(xml_file_path):
    """
    Parses an SHW (XML) file and extracts frequency data, converting it
    into a standardized CSV format. This version is based on the SHOW to CSV.py
    prototype for accurate extraction of ZONE and GROUP.
    All frequencies are converted to MHz for consistency.

    Inputs:
        xml_file_path (str): The full path to the SHW (XML) file.
        console_print_func (function, optional): A function to use for printing messages
                                                 to the console. If None, uses standard print.
    Outputs:
        tuple: A tuple containing:
               - headers (list): A list of strings representing the CSV header row.
               - csv_data (list): A list of dictionaries, where each dictionary
                                  represents a row of data with keys matching the headers.
    Raises:
        FileNotFoundError: If the specified XML file does not exist.
        xml.etree.ElementTree.ParseError: If the XML file is malformed.
        Exception: For other parsing or data extraction errors.
    """
    
    current_function = inspect.currentframe().f_code.co_name
    current_file = os.path.basename(__file__)

    if Local_Debug_Enable:
        debug_log(f"Starting SHW report conversion for '{os.path.basename(xml_file_path)}'.",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)

    
    csv_data = []

    try:
        with open(xml_file_path, 'r', encoding='utf-8') as f:
            tree = ET.parse(f)
        root = tree.getroot()
        
        if Local_Debug_Enable:
            debug_log("XML file parsed successfully.",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)

        # Iterate through 'freq_entry' elements
        for i, freq_entry in enumerate(root.findall('.//freq_entry')):
            if i % 100 == 0: # Print progress every 100 entries
                
                if Local_Debug_Enable:
                    debug_log(f"Processing SHW entry {i}...",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)

            # Reverting ZONE and GROUP extraction to match SHOW to CSV.py prototype
            zone_element = freq_entry.find('compat_key/zone')
            zone = zone_element.text if zone_element is not None else "N/A"

            group = freq_entry.get('tag', "N/A") # Extract GROUP from the 'tag' attribute of freq_entry
           
            # Extract DEVICE (manufacturer, model, band)
            manufacturer = freq_entry.find('manufacturer').text if freq_entry.find('manufacturer') is not None else "N/A"
            model = freq_entry.find('model').text if freq_entry.find('model') is not None else "N/A"
            band_element = freq_entry.find('compat_key/band') 
            band = band_element.text if band_element is not None else "N/A"
            device = f"{manufacturer} - {model} - {band}"

            # Extract NAME
            name_element = freq_entry.find('source_name')
            name = name_element.text if name_element is not None else "N/A"

            # Extract FREQ from value. User states SHW files contain markers in KHZ.
            freq_element = freq_entry.find('value')
            freq_MHz = "N/A"
            if freq_element is not None and freq_element.text is not None:
                freq_str = freq_element.text 
            
                if Local_Debug_Enable:
                    debug_log(f"DEBUG (SHW): Processing freq_str: '{freq_str}' for device '{name}'",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)

                try:
                    # Convert kHz to MHz as per user's clarification
                    freq_MHz = float(freq_str) / 1000.0 
                    if Local_Debug_Enable:
                        debug_log(f"SHW Freq conversion: '{freq_str}' kHz -> {freq_MHz} MHz",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)
                except ValueError:
    
                    if Local_Debug_Enable:
                        debug_log(f"SHW Freq conversion error: '{freq_str}'",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)
                    freq_MHz = "Invalid Frequency"

            csv_data.append({
                "ZONE": zone,
                "GROUP": group,
                "DEVICE": device,
                "NAME": name,
                "FREQ_MHZ": freq_MHz, # Store in MHz
                "PEAK": np.nan # NEW: Added Peak column
            })
    
        if Local_Debug_Enable:
            debug_log(f"Finished SHW report conversion. Extracted {len(csv_data)} rows.",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)
        return headers, csv_data

    except FileNotFoundError:
    
        if Local_Debug_Enable:
            debug_log(f"Error: The file '{xml_file_path}' was not found.",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)
        raise FileNotFoundError(f"The file '{xml_file_path}' was not found.")
    except ET.ParseError as e:
    
        if Local_Debug_Enable:
            debug_log(f"Error: Malformed XML (SHW) file '{xml_file_path}': {e}",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)
        raise ET.ParseError(f"Error parsing XML (SHW) file '{xml_file_path}': {e}")
    except Exception as e:
    
        if Local_Debug_Enable:
            debug_log(f"Error during SHW conversion data extraction: {e}",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)
        raise

def Marker_convert_wwb_zip_report_to_csv(file_path):
    """
    Parses a WWB.zip file, extracts relevant information, and returns a standardized
    list of dictionaries.

    Args:
        file_path (str): The full path to the WWB.zip archive.

    Returns:
        tuple: A tuple containing:
               - headers (list): A list of strings representing the CSV header row.
               - csv_data (list): A list of dictionaries, where each dictionary
                                  represents a row of data with keys matching the headers.
    """
    current_function = inspect.currentframe().f_code.co_name
    current_file = os.path.basename(__file__)

    if not file_path:
        if Local_Debug_Enable:
            debug_log(
                message="🛠️🟡 No file path provided for zip conversion.",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
        return [], []
        
    if Local_Debug_Enable:
        debug_log(
            message=f"🛠️🟢 Starting ZIP report conversion for: {os.path.basename(file_path)}",
            file=current_file,
            version=current_version,
            function=f"{current_function}",
            console_print_func=console_log
        )
    
    csv_data = []

    try:
        # Parse the zip filename to get ZONE and GROUP
        zip_filename_stem = os.path.splitext(os.path.basename(file_path))[0]
        # Example: 'Chase Rice 08-09-25_Main Stage Direct Support_wwb'
        zip_parts = re.split(r'_(?=\w+)', zip_filename_stem)
        
        # The ZONE is the first part, stripping the date part.
        zone = zip_parts[0] if len(zip_parts) > 0 else "N/A"
        
        # The main group is the second part, stripping the last two parts.
        group_match = re.search(r'([^_]+)_wwb$', zip_filename_stem)
        main_group = group_match.group(1).replace('_', ' ') if group_match else "N/A"
        
        console_log(f"Derived from ZIP filename: ZONE='{zone}', Main Group='{main_group}'")

        with zipfile.ZipFile(file_path, 'r') as zip_ref:
            csv_files = [name for name in zip_ref.namelist() if name.endswith('.csv')]
            
            if not csv_files:
                console_log("❌ Error: No .csv file found inside the .zip archive.")
                if Local_Debug_Enable:
                    debug_log(
                        message="❌🔴 No CSV file found within ZIP. Mission failed!",
                        file=current_file,
                        version=current_version,
                        function=f"{current_function}",
                        console_print_func=console_log
                    )
                return [], []
            
            if len(csv_files) > 1:
                console_log(f"🟡 Warning: Found multiple .csv files. Processing all of them.")
                if Local_Debug_Enable:
                    debug_log(
                        message=f"🛠️🟡 Found multiple CSV files. Processing all of them.",
                        file=current_file,
                        version=current_version,
                        function=f"{current_function}",
                        console_print_func=console_log
                    )

            for csv_file_name in csv_files:
                # Parse the CSV filename for device and group
                csv_filename_stem = os.path.splitext(os.path.basename(csv_file_name))[0]
                csv_filename_parts = csv_filename_stem.split('_')
                
                device = csv_filename_parts[0] if len(csv_filename_parts) > 0 else "N/A"
                csv_group = csv_filename_parts[1] if len(csv_filename_parts) > 1 else "N/A"

                with zip_ref.open(csv_file_name) as csv_in_zip:
                    csv_reader = csv.reader(io.TextIOWrapper(csv_in_zip, 'utf-8'))
                    
                    for row in csv_reader:
                        if not row:
                            continue
                        
                        try:
                            # Assume the first column is the frequency in MHz
                            freq_mhz = float(row[0])
                            
                            row_data = {
                                "ZONE": zone,
                                "GROUP": csv_group,
                                "DEVICE": device,
                                "NAME": "",  # The prompt says just the freq, so name can be empty or the freq itself.
                                "FREQ_MHZ": freq_mhz,
                                "PEAK": np.nan 
                            }
                            csv_data.append(row_data)
                            if Local_Debug_Enable:
                                debug_log(f"Added ZIP CSV row: {row_data}",
                                            file=current_file,
                                            version=current_version,
                                            function=f"{current_function}",
                                            console_print_func=console_log)
                        except (ValueError, IndexError):
                            # Skip rows that are not valid frequency data
                            if Local_Debug_Enable:
                                debug_log(f"Skipping non-frequency data row: {row}",
                                            file=current_file,
                                            version=current_version,
                                            function=f"{current_function}",
                                            console_print_func=console_log)
            
        console_log(f"✅ Extracted and converted {len(csv_files)} CSV files successfully!")
        return headers, csv_data

    except FileNotFoundError:
        if Local_Debug_Enable:
            debug_log(
                message=f"❌ Error: The file '{file_path}' was not found.",
                file=current_file,
                version=current_version,
                function=current_function,
                console_print_func=console_log
            )
        console_log(f"Error: The file '{file_path}' was not found.")
        return [], []
    except zipfile.BadZipFile:
        if Local_Debug_Enable:
            debug_log(
                message=f"❌ Error: The file '{file_path}' is not a valid zip archive.",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
        console_log(f"Error: The file '{file_path}' is not a valid zip archive.")
        return [], []
    except Exception as e:
        if Local_Debug_Enable:
            debug_log(
                message=f"❌ Error converting ZIP file: {e}",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
        console_log(f"Error: Failed to convert ZIP file. {e}")
        return [], []
    
def Marker_convert_SB_PDF_File_report_to_csv(pdf_file_path):
    """
    Parses a PDF file (Sound Base format) and extracts frequency data, converting it
    into a standardized CSV format. This function maps PDF fields to the MARKERS.CSV
    structure as follows:
    - PDF 'Group' -> CSV 'ZONE'
    - PDF 'Model' -> CSV 'GROUP'
    - PDF 'Name' -> CSV 'NAME'
    - PDF 'Frequency' -> CSV 'FREQ' (in MHz)
    - CSV 'DEVICE' is constructed from PDF 'Model', 'Band', and 'Preset'.

    Inputs:
        pdf_file_path (str): The full path to the PDF file.
        console_print_func (function, optional): A function to use for printing messages
                                                 to the console. If None, uses standard print.
    Outputs:
        tuple: A tuple containing:
               - headers (list): A list of strings representing the CSV header row.
               - csv_data (list): A list of dictionaries, where each dictionary
                                  represents a row of data with keys matching the headers.
    Raises:
        FileNotFoundError: If the specified PDF file does not exist.
        Exception: For other parsing or data extraction errors.
    """
    
    current_function = inspect.currentframe().f_code.co_name
    current_file = os.path.basename(__file__)

    if Local_Debug_Enable:
        debug_log(f"Starting PDF report conversion for '{os.path.basename(pdf_file_path)}'.",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)

    
    csv_data = []

    try:
        with pdfplumber.open(pdf_file_path) as pdf:
            last_known_group = "Uncategorized" # Default group if not found
            
            if Local_Debug_Enable:
                debug_log(f"Opened PDF with {len(pdf.pages)} pages.",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)

            for page_num, page in enumerate(pdf.pages):
        
                if Local_Debug_Enable:
                    debug_log(f"Processing Page {page_num + 1}...",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)
                # Extract text for group headers
                lines = page.extract_text().splitlines()
                lines = [line.strip() for line in lines if line.strip()]

                group_headers = [(i, line) for i, line in enumerate(lines)
                           if re.match(r".+\(\d+ frequencies\)", line)]

                tables = page.extract_tables()
                if Local_Debug_Enable:
                    debug_log(f"Found {len(tables)} tables on Page {page_num + 1}.",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)

                group_index = 0
                for table_num, table in enumerate(tables):
                    if group_index < len(group_headers):
                        last_known_group = group_headers[group_index][1]
                        group_index += 1

                    current_zone = last_known_group # PDF Group -> CSV ZONE
        
                    if Local_Debug_Enable:
                        debug_log(f"Processing Table {table_num + 1} for Zone: {current_zone}",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)

                    for row_num, row in enumerate(table):
                        if not row or all(cell is None or cell.strip() == "" for cell in row):
                            continue

                        if "Model" in row[0] and "Frequency" in row[-1]: # Skip header rows
                            if Local_Debug_Enable:
                                debug_log(f"Skipping header row: {row}",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)
                            continue

                        clean_row = [cell.replace("\n", " ").strip() if cell else "" for cell in row]
                        # Ensure row has at least 6 elements to unpack safely
                        while len(clean_row) < 6:
                            clean_row.append("")

                        model_pdf, band_pdf, name_pdf, preset_pdf, spacing_pdf, frequency_pdf_str = clean_row

                        if model_pdf.strip() == current_zone.strip(): # Skip rows that mistakenly repeat the group name
                            if Local_Debug_Enable:
                                debug_log(f"Skipping duplicate group name row: {row}",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)
                            continue

                        # Map PDF fields to CSV fields
                        zone_csv = current_zone
                        group_csv = model_pdf # PDF Model -> CSV GROUP

                        # Construct DEVICE from PDF Model, Band, Preset
                        device_csv = f"{model_pdf}"
                        if band_pdf:
                            device_csv += f" - {band_pdf}"
                        if preset_pdf:
                            device_csv += f" - {preset_pdf}"
                        
                        name_csv = name_pdf # PDF Name -> CSV NAME

                        freq_MHz_csv = "N/A"
        
                        try:
                            # The frequency is already in MHz, so no conversion needed
                            freq_MHz_csv = float(frequency_pdf_str)
                            if Local_Debug_Enable:
                                debug_log(f"PDF Freq conversion: '{frequency_pdf_str}' -> {freq_MHz_csv} MHz",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)
                        except ValueError:
        
                            if Local_Debug_Enable:
                                debug_log(f"PDF Freq conversion error: '{frequency_pdf_str}'",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)
                            freq_MHz_csv = "Invalid Frequency"

                        csv_data.append({
               
                            "ZONE": zone_csv,
                            "GROUP": group_csv,
                            "DEVICE": device_csv,
                            "NAME": name_csv,
                            "FREQ_MHZ": freq_MHz_csv,
                            "PEAK": np.nan # NEW: Added Peak column
                        })
                        if Local_Debug_Enable:
                            debug_log(f"Added PDF row: {csv_data[-1]}",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)
        
        if Local_Debug_Enable:
            debug_log(f"Finished PDF report conversion. Extracted {len(csv_data)} rows.",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)
        return headers, csv_data

    except FileNotFoundError:
        
        if Local_Debug_Enable:
            debug_log(f"Error: The file '{pdf_file_path}' was not found.",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)
        raise FileNotFoundError(f"The file '{pdf_file_path}' was not found.")
    except Exception as e:
        
        if Local_Debug_Enable:
            debug_log(f"Error during PDF conversion data extraction: {e}",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)
        raise

def Marker_convert_csv_unknow_report_to_csv(file_path):
    """
    Performs a 'best-effort' conversion of a CSV file with unknown headers
    to the standardized marker report format.
    
    Args:
        file_path (str): The path to the input CSV file.
    
    Returns:
        tuple: A tuple containing the standardized headers and a list of
               dictionaries with the matched data.
    """
    current_function = inspect.currentframe().f_code.co_name
    if Local_Debug_Enable:
        debug_log(
            message=f"🛠️🟢 Starting best-effort CSV conversion for: {file_path}",
            file=current_file,
            version=current_version,
            function=current_function,
            console_print_func=console_log
        )
    
    # Standardized headers and their common aliases
    standard_headers = ["ZONE", "GROUP", "DEVICE", "NAME", "FREQ_MHZ", "PEAK"]
    header_aliases = {
    
        "zone": ["zone", "area", "location"],
        "group": ["group", "channel_group"],
        "device": ["device", "dev_type", "model"],
        "name": ["name", "alias", "description"],
        "FREQ_MHZ": ["freq", "frequency", "frequency_mhz", "FREQ_MHZ"],
        "peak": ["peak", "peak_level", "max_level", "dbm"]
    }
    
    try:
        with open(file_path, 'r', newline='') as csvfile:
            reader = csv.reader(csvfile)
            input_headers = [h.strip().lower() for h in next(reader)]
            data = list(reader)
        
        header_map = {}
        for std_header in standard_headers:
            aliases = header_aliases.get(std_header.lower(), [std_header.lower()])
            for alias in aliases:
                if alias in input_headers:
                    header_map[std_header] = input_headers.index(alias)
                    break
       
        processed_data = []
        for row in data:
            new_row = {header: None for header in standard_headers}
            
            for std_header, index in header_map.items():
                if index < len(row):
                    value = row[index].strip()
                    if std_header.lower() == "FREQ_MHZ" and value:
                        try:
                            # Attempt to convert to MHz if needed
                            match = re.search(r'(\d+(?:\.\d+)?)\s*(?:(k|m|g)?hz)?', value, re.IGNORECASE)
                            if match:
                                val = float(match.group(1))
                                unit = match.group(2)
                                if unit and unit.lower() == 'k':
                                    val /= 1000
                                elif unit and unit.lower() == 'g':
                                    val *= 1000
                                new_row[std_header] = val
                  
                            else:
                                new_row[std_header] = float(value)
                        except ValueError:
                            new_row[std_header] = value
                    else:
                        new_row[std_header] = value
            processed_data.append(new_row)
            
        if Local_Debug_Enable:
            debug_log(
                message=f"✅ Finished best-effort conversion. Headers mapped: {header_map}",
                file=current_file,
                version=current_version,
                function=current_function,
                console_print_func=console_log
            )
        return standard_headers, processed_data
  
    except FileNotFoundError:
        if Local_Debug_Enable:
            debug_log(
                message=f"❌ Error: The file '{file_path}' was not found.",
                file=current_file,
                version=current_version,
                function=current_function,
                console_print_func=console_log
            )
        return [], []
    except Exception as e:
        if Local_Debug_Enable:
            debug_log(
                message=f"❌ Error during best-effort CSV conversion: {e}",
                file=current_file,
                version=current_version,
                function=current_function,
                console_print_func=console_log
            )
        return [], []
    


def Marker_convert_SB_v2_PDF_File_report_to_csv(pdf_file_path):
    """
    Parses a PDF file (Sound Base v2 format) and extracts frequency data, converting it
    into a standardized CSV format.

    Args:
        pdf_file_path (str): The full path to the PDF file.
        
    Returns:
        tuple: A tuple containing:
               - headers (list): A list of strings representing the CSV header row.
               - csv_data (list): A list of dictionaries, where each dictionary
                                  represents a row of data with keys matching the headers.
    """
    current_function = inspect.currentframe().f_code.co_name
    current_file = os.path.basename(__file__)
    
    if Local_Debug_Enable:
        debug_log(
            message=f"🛠️🟢 Starting PDF (Sound Base v2) report conversion for: {os.path.basename(pdf_file_path)}",
            file=current_file,
            version=current_version,
            function=f"{current_function}",
            console_print_func=console_log
        )
    
    csv_data = []

    try:
        with pdfplumber.open(pdf_file_path) as pdf:
            text = pdf.pages[0].extract_text()
            
            # Use regex to find the ZONE
            zone_match = re.search(r'ZONE: (.+)', text)
            zone = zone_match.group(1).strip() if zone_match else 'N/A'
            if Local_Debug_Enable:
                debug_log(f"🔍 Found ZONE: {zone}",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)
            
            # The pattern to find all groups
            group_pattern = re.compile(r'^\s*([A-Z\s&]+ IEM\'S|[A-Z\s&]+ MICS & BACKLINE)\s*$', re.MULTILINE)
            
            lines = text.split('\n')
            current_group = None
            
            for line in lines:
                line = line.strip()
                if not line:
                    continue
                
                # Check if the line is a new group header
                group_match = group_pattern.search(line)
                if group_match:
                    current_group = group_match.group(1).strip()
                    if Local_Debug_Enable:
                        debug_log(f"🔍 Found new GROUP: {current_group}",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)
                    continue
                
                # Regex to find all frequency-device pairs on the current line
                device_matches = re.findall(r'(\d+\.\d+)\s+([\w\s-]+?(?=\s*\d+\.\d+|$))', line)
                
                if device_matches:
                    for freq, device in device_matches:
                        device_clean = device.strip()
                        freq_clean = freq.strip()
                        
                        if current_group:
                            csv_data.append({
                                'ZONE': zone,
                                'GROUP': current_group,
                                'DEVICE': device_clean,
                                'NAME': device_clean,
                                'FREQ_MHZ': freq_clean,
                                'PEAK': np.nan 
                            })
                            
            if Local_Debug_Enable:
                debug_log(f"✅ Finished conversion. Extracted {len(csv_data)} rows.",  file=current_file, version=current_version, function=current_function, console_print_func=console_log)
            return headers, csv_data

    except FileNotFoundError:
        if Local_Debug_Enable:
            debug_log(
                message=f"❌ Error: The file '{pdf_file_path}' was not found.",
                file=current_file,
                version=current_version,
                function=current_function,
                console_print_func=console_log
            )
        return [], []
    except Exception as e:
        if Local_Debug_Enable:
            debug_log(
                message=f"❌ Error during PDF conversion: {e}",
                file=current_file,
                version=current_version,
                function=current_function,
                console_print_func=console_log
            )
        return [], []

#####################################
### File: OPEN-AIR/workers/importers/worker_marker_file_import_handling.py
#####################################
# workers/worker_marker_file_handling.py
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# This worker module handles all file I/O and data processing logic for marker files,
# separating it from the GUI's presentation layer.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251009.213617.2

import os
import csv
import xml.etree.ElementTree as ET
import sys
import inspect
import threading
import json 
import datetime 
import re 
import pathlib
import pandas as pd
import numpy as np
from tkinter import filedialog, messagebox

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from workers.importers.worker_marker_file_import_converter import (
    Marker_convert_IAShtml_report_to_csv,
    Marker_convert_SB_PDF_File_report_to_csv,
    Marker_convert_WWB_SHW_File_report_to_csv,
    Marker_convert_csv_unknow_report_to_csv
)
from workers.utils.worker_project_paths import GLOBAL_PROJECT_ROOT # NEW: Import GLOBAL_PROJECT_ROOT


# --- Global Scope Variables ---
current_version = "20251009.213617.2"
current_version_hash = (20251009 * 213617 * 2)
current_file_path = pathlib.Path(__file__).resolve()
# FIX: The project root is one level up from the 'workers' folder.
project_root = current_file_path.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")
Local_Debug_Enable = True

# --- Constants ---
DEFAULT_PAD_X = 5
DEFAULT_PAD_Y = 2
# NEW CONSTANT: Define the canonical headers
CANONICAL_HEADERS = ["ZONE", "GROUP", "DEVICE", "NAME", "FREQ_MHZ", "PEAK"]

def maker_file_check_for_markers_file():
    # Checks for the MARKERS.csv file in the DATA directory and loads it if it exists.
    current_function = inspect.currentframe().f_code.co_name
    
    # ANCHOR FIX: Use the stable GLOBAL_PROJECT_ROOT now available.
    target_path = GLOBAL_PROJECT_ROOT / 'DATA' / 'MARKERS.csv'
    
    if Local_Debug_Enable:
        debug_log(
            message=f"🛠️🕵️‍♂️ Checking for existing markers file at: {target_path}",
            file=current_file,
            version=current_version,
            function=f"{current_function}",
            console_print_func=console_log
        )
    
    if target_path.is_file():
        if Local_Debug_Enable:
            debug_log(
                message=f"✅ Found an existing MARKERS.csv file. Attempting to load.",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
        try:
            with open(target_path, 'r', newline='') as csvfile:
                reader = csv.DictReader(csvfile)
                headers = reader.fieldnames if reader.fieldnames else CANONICAL_HEADERS
                data = list(reader)
            
            if Local_Debug_Enable:
                debug_log(
                    message="✅ Successfully loaded MARKERS.csv on startup.",
                    file=current_file,
                    version=current_version,
                    function=f"{current_function}",
                    console_print_func=console_log
                )
            return headers, data
        except Exception as e:
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌ Error loading existing MARKERS.csv on startup: {e}",
                    file=current_file,
                    version=current_version,
                    function=f"{current_function}",
                    console_print_func=console_log
                )
            console_log(f"Error: Failed to load existing MARKERS.csv. {e}")
    else:
        if Local_Debug_Enable:
            debug_log(
                message="🛠️🟡 No existing MARKERS.csv found. Starting with a blank table.",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
    return CANONICAL_HEADERS, []

def maker_file_load_markers_file():
    # Opens a file dialog, loads a generic CSV file, and returns its headers and data.
    current_function = inspect.currentframe().f_code.co_name
    file_path = filedialog.askopenfilename(
        defaultextension=".csv",
        filetypes=[("CSV files", "*.csv"), ("All files", "*.*")]
    )
    if not file_path:
        if Local_Debug_Enable:
            debug_log(
                message="🛠️🟡 'Load CSV Marker Set' action cancelled by user.",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
        return [], []

    if Local_Debug_Enable:
        debug_log(
            message=f"🛠️🟢 'Load CSV Marker Set' button clicked. Opening file: {file_path}",
            file=current_file,
            version=current_version,
            function=f"{current_function}",
            console_print_func=console_log
        )
    console_log(f"Action: Load CSV Marker Set from {os.path.basename(file_path)}.")
    
    try:
        # Pass the desired headers to the converter for consistency
        headers, data = Marker_convert_csv_unknow_report_to_csv(file_path)

        if not data:
            console_log("❌ Failed to process CSV file or no data found.")
            return [], []

        # Convert list of lists to list of dictionaries
        dict_data = []
        if headers:
            for row in data:
                dict_data.append(dict(zip(headers, row)))

        if Local_Debug_Enable:
            debug_log(
                message=f"🔍🔵 Received Headers: {headers}",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
        if Local_Debug_Enable:
            debug_log(
                message=f"🔍🔵 Received first {min(len(dict_data), 5)} data points: {dict_data[:5]}",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
        
        if Local_Debug_Enable:
            debug_log(
                message="✅ CSV file loaded successfully.",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
        # Ensure we return canonical headers so the GUI knows what columns to show.
        return CANONICAL_HEADERS, dict_data
    except Exception as e:
        if Local_Debug_Enable:
            debug_log(
                message=f"❌ Error loading CSV file: {e}",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
        console_log(f"Error: Failed to process CSV file. {e}")
        return [], []

def maker_file_load_ias_html():
    # Opens a file dialog, loads an IAS HTML file, converts it, and returns the data.
    current_function = inspect.currentframe().f_code.co_name
    file_path = filedialog.askopenfilename(
        defaultextension=".html",
        filetypes=[("HTML files", "*.html;*.htm"), ("All files", "*.*")]
    )
    if not file_path:
        if Local_Debug_Enable:
            debug_log(
                message="🛠️🟡 'Load IAS HTML' action cancelled by user.",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
        return [], []
        
    if Local_Debug_Enable:
        debug_log(
            message=f"🛠️🟢 'Load IAS HTML' button clicked. Opening file: {file_path}",
            file=current_file,
            version=current_version,
            function=f"{current_function}",
            console_print_func=console_log
        )
    console_log(f"Action: Load IAS HTML from {os.path.basename(file_path)}.")

    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            html_content = f.read()

        headers, data = Marker_convert_IAShtml_report_to_csv(html_content)

        dict_data = []
        if headers:
            for row in data:
                dict_data.append(dict(zip(headers, row)))

        if Local_Debug_Enable:
            debug_log(
                message=f"🔍🔵 Received Headers: {headers}",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
        if Local_Debug_Enable:
            debug_log(
                message=f"🔍🔵 Received first {min(len(dict_data), 5)} data points: {dict_data[:5]}",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )

        if Local_Debug_Enable:
            debug_log(
                message="✅ HTML report converted successfully.",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
        return CANONICAL_HEADERS, dict_data
    except Exception as e:
        if Local_Debug_Enable:
            debug_log(
                message=f"❌ Error converting HTML report: {e}",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
        console_log(f"Error: Failed to convert HTML file. {e}")
        return [], []

def maker_file_load_wwb_shw():
    # Opens a file dialog, loads a WWB .shw file, converts it, and returns the data.
    current_function = inspect.currentframe().f_code.co_name
    file_path = filedialog.askopenfilename(
        defaultextension=".shw",
        filetypes=[("Shure Wireless Workbench files", "*.shw"), ("All files", "*.*")]
    )
    if not file_path:
        if Local_Debug_Enable:
            debug_log(
                message="🛠️🟡 'Load WWB.shw' action cancelled by user.",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
        return [], []
        
    if Local_Debug_Enable:
        debug_log(
            message=f"🛠️🟢 'Load WWB.shw' button clicked. Opening file: {file_path}",
            file=current_file,
            version=current_version,
            function=f"{current_function}",
            console_print_func=console_log
        )
    console_log(f"Action: Load WWB.shw from {os.path.basename(file_path)}.")
    
    try:
        headers, data = Marker_convert_WWB_SHW_File_report_to_csv(file_path)

        dict_data = []
        if headers:
            for row in data:
                dict_data.append(dict(zip(headers, row)))

        if Local_Debug_Enable:
            debug_log(
                message=f"🔍🔵 Received Headers: {headers}",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
        if Local_Debug_Enable:
            debug_log(
                message=f"🔍🔵 Received first {min(len(dict_data), 5)} data points: {dict_data[:5]}",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
        
        if Local_Debug_Enable:
            debug_log(
                message="✅ SHW file converted successfully.",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
        return CANONICAL_HEADERS, dict_data
    except Exception as e:
        if Local_Debug_Enable:
            debug_log(
                message=f"❌ Error converting SHW file: {e}",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
        console_log(f"Error: Failed to convert SHW file. {e}")
        return [], []

def maker_file_load_sb_pdf():
    # Opens a file dialog, loads a Soundbase PDF file, converts it, and returns the data.
    current_function = inspect.currentframe().f_code.co_name
    file_path = filedialog.askopenfilename(
        defaultextension=".pdf",
        filetypes=[("PDF files", "*.pdf"), ("All files", "*.*")]
    )
    if not file_path:
        if Local_Debug_Enable:
            debug_log(
                message="🛠️🟡 'Load SB PDF' action cancelled by user.",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
        return [], []
        
    if Local_Debug_Enable:
        debug_log(
            message=f"🛠️🟢 'Load SB PDF' button clicked. Opening file: {file_path}",
            file=current_file,
            version=current_version,
            function=f"{current_function}",
            console_print_func=console_log
        )
    console_log(f"Action: Load SB PDF from {os.path.basename(file_path)}.")

    try:
        headers, data = Marker_convert_SB_PDF_File_report_to_csv(file_path)

        dict_data = []
        if headers:
            for row in data:
                dict_data.append(dict(zip(headers, row)))

        if Local_Debug_Enable:
            debug_log(
                message=f"🔍🔵 Received Headers: {headers}",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
        if Local_Debug_Enable:
            debug_log(
                message=f"🔍🔵 Received first {min(len(dict_data), 5)} data points: {dict_data[:5]}",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )

        if Local_Debug_Enable:
            debug_log(
                message="✅ PDF report converted successfully.",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
        return CANONICAL_HEADERS, dict_data
    except Exception as e:
        if Local_Debug_Enable:
            debug_log(
                message=f"❌ Error converting PDF report: {e}",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
        console_log(f"Error: Failed to convert PDF file. {e}")
        return [], []
    
def maker_file_save_intermediate_file(tree_headers, tree_data):
    # Saves the current tree data to a file named 'MARKERS.csv' in the DATA directory at the project root level.
    current_function = inspect.currentframe().f_code.co_name
    # ANCHOR FIX: Use the stable GLOBAL_PROJECT_ROOT now available.
    target_path = GLOBAL_PROJECT_ROOT / 'DATA' / 'MARKERS.csv'
    
    if Local_Debug_Enable:
        debug_log(
            message=f"💾🟢 Saving data to intermediate file: {target_path}. Headers: {tree_headers}, first row: {tree_data[0] if tree_data else 'N/A'}",
            file=current_file,
            version=current_version,
            function=f"{current_function}",
            console_print_func=console_log
        )
    
    try:
        with open(target_path, 'w', newline='') as csvfile:
            # Use DictWriter to ensure only rows that match the headers are written
            writer = csv.DictWriter(csvfile, fieldnames=CANONICAL_HEADERS) 
            
            # Use CANONICAL_HEADERS to ensure consistent output file
            writer.writeheader()
            writer.writerows(tree_data)
            
        console_log(f"Intermediate file saved as {target_path}")
    except Exception as e:
        console_log(f"Error: Failed to save intermediate MARKERS.csv file. {e}")
        
def maker_file_save_open_air_file(tree_headers, tree_data):
    # Saves the current tree data to a file named 'OpenAir.csv' in the DATA directory.
    current_function = inspect.currentframe().f_code.co_name
    
    if not tree_headers or not tree_data:
        if Local_Debug_Enable:
            debug_log(
                message="🛠️🟡 'Save Open Air' action aborted: no data in treeview.",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
        console_log("Action: Save Markers as Open Air.csv. No data to save.")
        return

    file_path = filedialog.asksaveasfilename(
        defaultextension=".csv",
        initialfile="OpenAir.csv",
        filetypes=[("CSV files", "*.csv"), ("All files", "*.*")]
    )
    if not file_path:
        if Local_Debug_Enable:
            debug_log(
                message="🛠️🟡 'Save Open Air' action cancelled by user.",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
        return

    if Local_Debug_Enable:
        debug_log(
            message=f"🛠️🟢 'Save Open Air' button clicked. Saving to: {file_path}",
            file=current_file,
            version=current_version,
            function=f"{current_function}",
            console_print_func=console_log
        )
    console_log(f"Action: Saving Markers as Open Air.csv to {os.path.basename(file_path)}.")
    
    try:
        with open(file_path, 'w', newline='') as csvfile:
            writer = csv.DictWriter(csvfile, fieldnames=tree_headers)
            writer.writeheader()
            writer.writerows(tree_data)
        
        console_log(f"File saved successfully to {file_path}")
        if Local_Debug_Enable:
            debug_log(
                message="✅ File saved successfully.",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
    except Exception as e:
        if Local_Debug_Enable:
            debug_log(
                message=f"❌ Error saving Open Air CSV file: {e}",
                file=current_file,
                version=current_version,
                function=f"{current_function}",
                console_print_func=console_log
            )
        console_log(f"Error: Failed to save file. {e}")

#####################################
### File: OPEN-AIR/SUB APP - CSV to json APP/csvtojson.py
#####################################
import tkinter as tk
from tkinter import filedialog, messagebox, ttk
import pandas as pd
import json
import os
import sys
import io
import re

Local_Debug_Enable = True

class CSVToJSONApp(tk.Tk):
    """
    A Tkinter application to convert a CSV file to a nested JSON structure
    with dynamic grouping capabilities and a JSON preview feature.
    """
    def __init__(self):
        super().__init__()
        self.title("CSV to JSON Converter")
        self.geometry("1200x800")
        
        self.csv_filepath = ""
        self.headers = []
        self.header_widgets = {}

        self.setup_frames()
        self.create_widgets()

    def setup_frames(self):
        """Creates the main frames for organizing the UI."""
        self.top_frame = tk.Frame(self, padx=10, pady=10)
        self.top_frame.pack(fill=tk.X)

        self.main_content_frame = tk.Frame(self, padx=10, pady=10)
        self.main_content_frame.pack(fill=tk.BOTH, expand=True)

        self.header_config_frame = tk.LabelFrame(self.main_content_frame, text="Header Configuration", padx=10, pady=10)
        self.header_config_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        self.output_frame = tk.LabelFrame(self.main_content_frame, text="JSON Output", padx=10, pady=10)
        self.output_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        self.headers_canvas = tk.Canvas(self.header_config_frame)
        self.headers_canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        self.headers_scrollbar = ttk.Scrollbar(self.header_config_frame, orient=tk.VERTICAL, command=self.headers_canvas.yview)
        self.headers_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        self.headers_canvas.configure(yscrollcommand=self.headers_scrollbar.set)
        self.headers_frame = tk.Frame(self.headers_canvas)
        self.headers_canvas.create_window((0, 0), window=self.headers_frame, anchor="nw")
        
        self.headers_frame.bind("<Configure>", lambda event: self.headers_canvas.configure(scrollregion=self.headers_canvas.bbox("all")))

        # Notebook for Treeview and Raw JSON view
        self.output_notebook = ttk.Notebook(self.output_frame)
        self.output_notebook.pack(fill=tk.BOTH, expand=True)

        # Treeview tab
        tree_frame = ttk.Frame(self.output_notebook)
        self.output_notebook.add(tree_frame, text='Structured View')
        self.treeview = ttk.Treeview(tree_frame, columns=('Value'), show='tree headings')
        self.treeview.heading('#0', text='Key')
        self.treeview.heading('Value', text='Value')
        self.treeview.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        self.treeview_scrollbar = ttk.Scrollbar(tree_frame, orient=tk.VERTICAL, command=self.treeview.yview)
        self.treeview.configure(yscrollcommand=self.treeview_scrollbar.set)
        self.treeview_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        # Raw JSON tab
        raw_frame = ttk.Frame(self.output_notebook)
        self.output_notebook.add(raw_frame, text='Raw JSON')
        self.raw_json_text = tk.Text(raw_frame, wrap=tk.WORD, font=("Consolas", 10))
        self.raw_json_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        self.raw_json_scrollbar = ttk.Scrollbar(raw_frame, orient=tk.VERTICAL, command=self.raw_json_text.yview)
        self.raw_json_text.configure(yscrollcommand=self.raw_json_scrollbar.set)
        self.raw_json_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

    def create_widgets(self):
        """Creates and places all the widgets in the application window."""
        tk.Label(self.top_frame, text="Input CSV File:").grid(row=0, column=0, sticky="W", padx=5, pady=2)
        self.csv_path_entry = tk.Entry(self.top_frame, width=50)
        self.csv_path_entry.grid(row=0, column=1, padx=5, pady=2)
        self.csv_browse_button = tk.Button(self.top_frame, text="Browse...", command=self.load_csv_file)
        self.csv_browse_button.grid(row=0, column=2, padx=5, pady=2)

        tk.Label(self.top_frame, text="Output JSON File:").grid(row=1, column=0, sticky="W", padx=5, pady=2)
        self.json_path_entry = tk.Entry(self.top_frame, width=50)
        self.json_path_entry.grid(row=1, column=1, padx=5, pady=2)
        self.json_browse_button = tk.Button(self.top_frame, text="Browse...", command=self.save_json_file)
        self.json_browse_button.grid(row=1, column=2, padx=5, pady=2)
        
        tk.Label(self.top_frame, text="Root JSON Key Name:").grid(row=2, column=0, sticky="W", padx=5, pady=2)
        self.root_name_entry = tk.Entry(self.top_frame, width=20)
        self.root_name_entry.insert(0, "root")
        self.root_name_entry.grid(row=2, column=1, sticky="W", padx=5, pady=2)

        self.load_button = tk.Button(self.top_frame, text="Load Headers", command=self.load_headers)
        self.load_button.grid(row=3, column=0, pady=10)
        self.preview_button = tk.Button(self.top_frame, text="Preview JSON", command=self.preview_json)
        self.preview_button.grid(row=3, column=1, pady=10)
        self.convert_button = tk.Button(self.top_frame, text="Convert to JSON", command=self.convert_to_json)
        self.convert_button.grid(row=3, column=2, pady=10)

        self.headers_canvas.update_idletasks()
        self.headers_canvas.config(scrollregion=self.headers_canvas.bbox("all"))

    def load_csv_file(self):
        """Opens a file dialog to select the input CSV file."""
        filepath = filedialog.askopenfilename(defaultextension=".csv", filetypes=[("CSV files", "*.csv")])
        if filepath:
            self.csv_path_entry.delete(0, tk.END)
            self.csv_path_entry.insert(0, filepath)
            self.csv_filepath = filepath
            filename = os.path.basename(filepath)
            default_json_name = os.path.splitext(filename)[0] + ".json"
            self.json_path_entry.delete(0, tk.END)
            self.json_path_entry.insert(0, default_json_name)

    def save_json_file(self):
        """Opens a file dialog to specify the output JSON file path."""
        filepath = filedialog.asksaveasfilename(defaultextension=".json", filetypes=[("JSON files", "*.json")])
        if filepath:
            self.json_path_entry.delete(0, tk.END)
            self.json_path_entry.insert(0, filepath)
    
    def load_headers(self):
        """
        Reads headers from the selected CSV and creates UI controls for each,
        including grouping options.
        """
        for widget in self.headers_frame.winfo_children():
            widget.destroy()

        self.headers.clear()
        self.header_widgets.clear()
        
        if not self.csv_filepath or not os.path.exists(self.csv_filepath):
            messagebox.showerror("Error", "Please select a valid CSV file.")
            return

        try:
            df = pd.read_csv(self.csv_filepath, nrows=1, keep_default_na=False)
            self.headers = list(df.columns)
            
            # Create a row of controls for each header
            tk.Label(self.headers_frame, text="JSON Key Name", font=("Arial", 10, "bold")).grid(row=0, column=0, padx=5, pady=2)
            tk.Label(self.headers_frame, text="Role", font=("Arial", 10, "bold")).grid(row=0, column=1, padx=5, pady=2)
            tk.Label(self.headers_frame, text="Nested Under", font=("Arial", 10, "bold")).grid(row=0, column=2, padx=5, pady=2)
            tk.Label(self.headers_frame, text="Part Name (e.g., 'contents')", font=("Arial", 10, "bold")).grid(row=0, column=3, padx=5, pady=2)

            for i, header in enumerate(self.headers):
                row_num = i + 1
                
                header_entry = tk.Entry(self.headers_frame, width=20)
                header_entry.insert(0, header)
                header_entry.grid(row=row_num, column=0, sticky="W", padx=5, pady=2)
                
                role_var = tk.StringVar()
                # ADDING THE NEW ROLE
                role_dropdown = ttk.Combobox(self.headers_frame, textvariable=role_var, state="readonly",
                                             values=["Hierarchical Key", "Sub Key", "Simple Value", "Value as Key", "Key Name and Value", "Skip"])
                role_dropdown.grid(row=row_num, column=1, padx=5, pady=2)
                
                nested_under_var = tk.StringVar()
                nested_under_dropdown = ttk.Combobox(self.headers_frame, textvariable=nested_under_var, state="readonly", values=["root"])
                nested_under_dropdown.grid(row=row_num, column=2, padx=5, pady=2)
                
                part_name_entry = tk.Entry(self.headers_frame, width=25)
                part_name_entry.grid(row=row_num, column=3, padx=5, pady=2)
                
                self.header_widgets[header] = {
                    "header_entry": header_entry,
                    "role_var": role_var,
                    "nested_under_var": nested_under_var,
                    "nested_under_dropdown": nested_under_dropdown,
                    "part_name_entry": part_name_entry
                }

                def toggle_widgets(event):
                    role = role_dropdown.get()
                    if role in ["Hierarchical Key", "Key Name and Value"]:
                        part_name_entry['state'] = 'normal'
                    else:
                        part_name_entry.delete(0, tk.END)
                        part_name_entry['state'] = 'disabled'
                    
                    self.update_nested_under_dropdowns()
                    self.preview_json()

                role_dropdown.bind("<<ComboboxSelected>>", toggle_widgets)
            
            self.after(100, self.preview_json)

            self.headers_canvas.update_idletasks()
            self.headers_canvas.config(scrollregion=self.headers_canvas.bbox("all"))

        except Exception as e:
            messagebox.showerror("Error", f"Failed to read CSV headers: {e}")

    def update_nested_under_dropdowns(self):
        """Updates the options in the Nested Under dropdowns based on current roles."""
        parents = ["root"]
        for header, widgets in self.header_widgets.items():
            role = widgets['role_var'].get()
            # ADDING THE NEW ROLE TO THE PARENTS
            if role in ["Hierarchical Key", "Value as Key", "Key Name and Value"]:
                parents.append(header)
        
        for header, widgets in self.header_widgets.items():
            widgets['nested_under_dropdown']['values'] = parents
            if widgets['nested_under_var'].get() not in parents:
                widgets['nested_under_var'].set("root")

    def generate_json_from_config(self):
        """
        Helper function to generate JSON data from the current UI configuration.
        """

        try:
            df = pd.read_csv(self.csv_filepath, keep_default_na=False)

            sort_by_columns = []
            header_map = {}
            for original_header, widgets in self.header_widgets.items():
                role = widgets["role_var"].get()
                json_key_name = widgets["header_entry"].get()
                nested_under = widgets["nested_under_var"].get()

                config = {
                    "original_header": original_header,
                    "json_key": json_key_name if role not in ["Value as Key"] else None,
                    "role": role,
                    "nested_under": nested_under
                }
                if role in ["Hierarchical Key", "Key Name and Value"]:
                    config["part_name"] = widgets["part_name_entry"].get() or "parts"
                    sort_by_columns.append(original_header)
                elif role == "Value as Key":
                    config["json_key"] = json_key_name
                    sort_by_columns.append(original_header)
                
                header_map[original_header] = config

            df.sort_values(by=sort_by_columns, inplace=True, kind='stable')
            
            
            
            root_name = self.root_name_entry.get()
            final_json = {root_name: []}
            
            final_json[root_name] = self.build_json_hierarchy(df, header_map, "root")
            
            if final_json[root_name] == []:
                messagebox.showerror("Error", "The root 'Hierarchical Key' or 'Value as Key' must be selected to form the root of the JSON structure.")
                return {}
            
            
            return final_json
        
        except Exception as e:
            messagebox.showerror("Error", f"An error occurred during generation: {e}")
            
            return {}

    def preview_json(self):
        """Generates and displays a preview of the JSON output."""
        if not self.csv_filepath or not os.path.exists(self.csv_filepath):
            
            self.update_output_with_json({})
            return

        json_data = self.generate_json_from_config()
        # Only proceed if generation was successful and returned a non-empty dictionary
        if json_data:
            self.update_output_with_json(json_data)
            
    def convert_to_json(self):
        """Converts the CSV to JSON and saves the file."""
        json_filepath = self.json_path_entry.get()
        if not json_filepath:
            messagebox.showerror("Error", "Please specify an output JSON file name.")
            return

        json_data = self.generate_json_from_config()
        if not json_data:
            return

        try:
            with open(json_filepath, 'w') as f:
                json.dump(json_data, f, indent=4)
            
            self.update_output_with_json(json_data)
            messagebox.showinfo("Success", f"Successfully converted and saved to {json_filepath}")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to save JSON file: {e}")

    def update_output_with_json(self, data):
        """
        Clears and populates the Treeview and Raw JSON viewer with JSON data.
        """
        # Update Treeview
        for item in self.treeview.get_children():
            self.treeview.delete(item)

        def insert_items(parent, dictionary):
            if isinstance(dictionary, dict):
                for key, value in dictionary.items():
                    if isinstance(value, (dict, list)):
                        node = self.treeview.insert(parent, 'end', text=key, open=True)
                        insert_items(node, value)
                    else:
                        self.treeview.insert(parent, 'end', text=key, values=(value,))
            elif isinstance(dictionary, list):
                for i, item in enumerate(dictionary):
                    if isinstance(item, (dict, list)):
                        node = self.treeview.insert(parent, 'end', text=f"[{i}]", open=True)
                        insert_items(node, item)
                    else:
                        self.treeview.insert(parent, 'end', text=f"[{i}]", values=(item,))

        insert_items('', data)

        # Update Raw JSON viewer
        self.raw_json_text.delete(1.0, tk.END)
        try:
            formatted_json = json.dumps(data, indent=4)
            self.raw_json_text.insert(tk.END, formatted_json)
        except Exception as e:
            self.raw_json_text.insert(tk.END, f"Error formatting JSON: {e}")
        


    def build_json_hierarchy(self, df, header_map, parent_key):
        """
        Recursively builds the JSON structure from the grouped DataFrame.
        This version now correctly handles multiple grouping keys per level.
        """
        output_list = []
        
        
        # Get all headers nested under the current parent_key
        current_level_configs = sorted(
            [h for h in header_map.values() if h['nested_under'] == parent_key and h['role'] != "Skip"],
            key=lambda x: self.headers.index(x['original_header'])
        )

        # Find the first grouping key for this level
        first_grouping_key_config = next((h for h in current_level_configs if h['role'] in ["Hierarchical Key", "Value as Key", "Key Name and Value"] ), None)
        
        # Base case: No more grouping keys at this level
        if first_grouping_key_config is None:
        
            output_list = []
            if not df.empty:
                simple_configs = [h for h in current_level_configs if h['role'] in ["Simple Value", "Sub Key"]]
                
                for _, row in df.iterrows():
                    node = {}
                    for header_config in simple_configs:
                        original_header = header_config['original_header']
                        json_key = header_config['json_key']
                        value = row[original_header]
                        
                        if pd.notna(value) and value != '':
                            if isinstance(value, bool):
                                value = str(value).lower()
                            node[json_key] = value
                    if node:
                        output_list.append(node)
            return output_list

        first_grouping_key = first_grouping_key_config['original_header']
        grouped_df = df.groupby(first_grouping_key, sort=False)
        
        for key_value, group in grouped_df:
            node = {}
            
            # Build the current node based on the first grouping key
            if first_grouping_key_config['role'] == "Value as Key":
                children = self.build_json_hierarchy(group, header_map, first_grouping_key)
                merged_children = {}
                if children and isinstance(children, list):
                    for child_dict in children:
                        merged_children.update(child_dict)
                elif children and isinstance(children, dict):
                    merged_children.update(children)
                
                node[key_value] = merged_children
                
            elif first_grouping_key_config['role'] == "Hierarchical Key":
                if isinstance(key_value, bool):
                    key_value = str(key_value).lower()
                
                node[first_grouping_key_config['json_key']] = key_value
                node[first_grouping_key_config['part_name']] = self.build_json_hierarchy(group, header_map, first_grouping_key)
                
            # NEW LOGIC FOR "KEY NAME AND VALUE"
            elif first_grouping_key_config['role'] == "Key Name and Value":
                part_name = first_grouping_key_config['part_name']
                # Create a key with the header's JSON Key Name
                # The value is a dictionary with the part_name holding the CSV value
                node[first_grouping_key_config['json_key']] = {
                    part_name: key_value,
                    "parts": self.build_json_hierarchy(group, header_map, first_grouping_key)
                }

            output_list.append(node)
        
        return output_list

if __name__ == "__main__":
    app = CSVToJSONApp()
    app.mainloop()

#####################################
### File: OPEN-AIR/display/gui_display.py
#####################################
# display/gui_display.py
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# A script that dynamically builds the application's Tkinter GUI based on the
# predefined directory structure. It acts as the "orchestrator," recursively
# traversing a folder hierarchy to construct the user interface, now with
# support for "tear-off" tabs that can become their own windows.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1 # REVISION NUMBER INCREASED
# FIXED: Added logic in _build_from_directory to ensure tab frames expand to fill the Notebook,
#        resolving the issue where child frames (like the Matplotlib plot) were not visible.
# FIXED: Added logic to suppress the implicit dependency on PIL/ImageTk during dynamic module loading,
#        resolving the persistent environmental error on application startup.

# 📚 Python's standard library modules are our trusty sidekicks!
import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import importlib.util
import sys
import pathlib

#// --- REQUIRED IMPORTS FOR PLOTTING INTEGRATION (FIX) ---
#// --- REQUIRED IMPORTS FOR PLOTTING INTEGRATION (FIX) ---
#import numpy as np #// Needed for numerical base
#import seaborn as sns# // Preload seaborn context and dependencies
#import matplotlib.pyplot as plt #// Preload Matplotlib context
#from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk
#// --------------------------------------------------------

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from display.styling.style import THEMES, DEFAULT_THEME


Local_Debug_Enable = True

# The wrapper functions debug_log and console_log_switch are removed
# as the core debug_log and console_log now directly handle Local_Debug_Enable.

# --- Global Scope Variables (as per Protocol 4.4) ---
current_version = "20251127.000000.1"
# The hash calculation drops the leading zero from the hour (23 -> 23)
current_version_hash = (20251127 * 0 * 1)
current_file = f"{os.path.basename(__file__)}"

# --- Constants (Pulled from old global state) ---
CURRENT_DATE = 20251127
CURRENT_TIME = 0
CURRENT_TIME_HASH = 0
REVISION_NUMBER = 1

class Application(tk.Tk):
    """
    The main application class that orchestrates the GUI build process.
    """
    def __init__(self, mqtt_util_instance: MqttControllerUtility):
        print("--- DEBUG: Entering Application.__init__() ---")
        current_function_name = inspect.currentframe().f_code.co_name
        
        if Local_Debug_Enable:
            debug_log(
                message="🖥️ 🟢 The grand orchestrator is waking up! Let's get this GUI built!",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
        
        self._notebooks = {}
        self._frames_by_path = {}
        self._detached_windows = {}
        self.last_selected_tab_name = None
        self.mqtt_util = mqtt_util_instance

        try:
            # --- CRITICAL FIX: Explicitly disable PIL/ImageTk handling ---
            # This prevents the dynamic loader from failing on systems where the PIL binary link is broken/missing.
            try:
                # This should prevent Tkinter from attempting to load the problematic shared library during startup.
                del sys.modules['PIL.ImageTk']
            except (KeyError, AttributeError):
                pass
            
            super().__init__()
            self.title("OPEN-AIR 2")
            self.geometry("1600x1200")
            # self.lift() # Bring window to front
            # self.attributes('-topmost', True) # Keep window on top
            # self.after_idle(self.attributes, '-topmost', False) # Release topmost after idle
            self.attributes('-topmost', False) # Release topmost after idle
            if Local_Debug_Enable:
                debug_log(
                    message="🔍🔵 Tkinter main window created with title 'OPEN-AIR 2' and geometry '1600x1200'. (Topmost disabled for debug)",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

            self.theme_colors = self._apply_styles(theme_name="DEFAULT_THEME")
            if Local_Debug_Enable:
                debug_log(
                    message=f"🔍🔵 Applied theme: {DEFAULT_THEME}.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

            self._build_from_directory(path=pathlib.Path(__file__).parent, parent_widget=self)
            if Local_Debug_Enable:
                debug_log(
                    message="🔍🔵 Finished building GUI from directory structure.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

    def _apply_styles(self, theme_name: str):
        """Applies the specified theme to the entire application using ttk.Style."""
        current_function_name = inspect.currentframe().f_code.co_name
        if Local_Debug_Enable:
            debug_log(
                message=f"🔍🔵 Applying styles for theme: {theme_name}.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        style.configure('.',
                        background=colors["bg"],
                        foreground=colors["fg"],
                        font=('Helvetica', 10),
                        padding=colors["padding"],
                        borderwidth=colors["border_width"])

        style.configure('TFrame', background=colors["bg"])

        style.configure('TNotebook',
                        background=colors["primary"],
                        borderwidth=0)
        
        style.map('TNotebook.Tab',
                  background=[('selected', colors["accent"]), ('!selected', colors["secondary"])],
                  foreground=[('selected', colors["text"]), ('!selected', colors["fg"])])

        tab_padding = [colors["padding"] * 10, colors["padding"] * 5]
        style.configure('TNotebook.Tab',
                        padding=tab_padding,
                        font=('Helvetica', 11, 'bold'),
                        borderwidth=0)

        self.configure(background=colors["bg"])
        if Local_Debug_Enable:
            debug_log(
                message=f"🔍🔵 Styles applied. Root window background set to {colors['bg']}.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
        if Local_Debug_Enable:
            debug_log(
                message=f"🔍🔵 Exiting _apply_styles. Theme: {theme_name} applied.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
        return colors


    def _build_from_directory(self, path: pathlib.Path, parent_widget):
        """Recursively builds the GUI based on folder structure."""
        current_function_name = inspect.currentframe().f_code.co_name
        if Local_Debug_Enable:
            debug_log(
                message=f"🔍🔵 Entering _build_from_directory for path: '{path}'. Parent widget: {parent_widget}.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
        
        try:
            sub_dirs = sorted([d for d in path.iterdir() if d.is_dir()])
            if Local_Debug_Enable:
                debug_log(
                    message=f"🔍🔵 Found sub_dirs in '{path}': {[d.name for d in sub_dirs]}.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
  
            layout_dirs = [d for d in sub_dirs if d.name.split('_')[0] in ['left', 'right', 'top', 'bottom']]
            
            if layout_dirs:
                if Local_Debug_Enable:
                    debug_log(
                        message=f"🔍🔵 Found layout_dirs in '{path}': {[d.name for d in layout_dirs]}. Applying layout logic.",
                        file=current_file,
                        version=current_version,
                        function=f"{self.__class__.__name__}.{current_function_name}",
                        console_print_func=console_log
                    )
                is_horizontal = any(d.name.startswith('left_') or d.name.startswith('right_') for d in layout_dirs)
                is_vertical = any(d.name.startswith('top_') or d.name.startswith('bottom_') for d in layout_dirs)

                if is_horizontal and is_vertical:
                    console_log(f"❌ Layout Error: Cannot mix horizontal and vertical layouts in '{path}'.")
                    if Local_Debug_Enable:
                        debug_log(
                            message=f"❌🔴 Layout Error: Mixed horizontal and vertical layouts detected in '{path}'.",
                            file=current_file,
                            version=current_version,
                            function=f"{self.__class__.__name__}.{current_function_name}",
                            console_print_func=console_log
                        )
                    return

                sort_order = ['left', 'top', 'right', 'bottom']
                sorted_layout_dirs = sorted(layout_dirs, key=lambda d: sort_order.index(d.name.split('_')[0]))
                
                if is_horizontal:
                    paned_window = ttk.PanedWindow(parent_widget, orient=tk.HORIZONTAL)
                    paned_window.pack(fill=tk.BOTH, expand=True)
                    
                    def on_sash_drag(event):
                        sash_pos = paned_window.sashpos(0)
                        debug_log(f"Sash dragged. New position: {sash_pos}", file=current_file, version=current_version, function="_build_from_directory.<locals>.on_sash_drag", console_print_func=console_log)
                        self.update_idletasks()

                    paned_window.bind("<B1-Motion>", on_sash_drag)

                    percentages = []
                    for sub_dir in sorted_layout_dirs:
                        if sub_dir.name.split('_')[0] not in ['left', 'right']: continue
                        try:
                            percentage = int(sub_dir.name.split('_')[1])
                            percentages.append(percentage)
                            new_frame = ttk.Frame(paned_window, borderwidth=self.theme_colors["border_width"], relief=self.theme_colors["relief"])
                            paned_window.add(new_frame, weight=percentage)
                            if Local_Debug_Enable:
                                debug_log(
                                    message=f"🔍🔵 Created horizontal pane for '{sub_dir.name}' with weight {percentage}.",
                                    file=current_file,
                                    version=current_version,
                                    function=f"{self.__class__.__name__}.{current_function_name}",
                                    console_print_func=console_log
                                )
                            self._build_from_directory(path=sub_dir, parent_widget=new_frame)
                        except (IndexError, ValueError) as e:
                            console_log(f"⚠️ Warning: Could not parse percentage from folder name '{sub_dir.name}'. Error: {e}")
                            if Local_Debug_Enable:
                                debug_log(
                                    message=f"⚠️ Warning: Layout parsing failed for '{sub_dir.name}'. Error: {e}",
                                    file=current_file,
                                    version=current_version,
                                    function=f"{self.__class__.__name__}.{current_function_name}",
                                    console_print_func=console_log
                                )
                    
                    def configure_sash(event):
                        total_percentage = sum(percentages)
                        if len(percentages) > 1 and total_percentage > 0:
                            sash_pos = int(event.width * (percentages[0] / total_percentage))
                            paned_window.sash_place(0, sash_pos, 0)
                            paned_window.unbind("<Configure>")

                    paned_window.bind("<Configure>", configure_sash)
                
                elif is_vertical:
                    paned_window = ttk.PanedWindow(parent_widget, orient=tk.VERTICAL)
                    paned_window.pack(fill=tk.BOTH, expand=True)

                    def on_sash_drag(event):
                        sash_pos = paned_window.sashpos(0)
                        debug_log(f"Sash dragged. New position: {sash_pos}", file=current_file, version=current_version, function="_build_from_directory.<locals>.on_sash_drag", console_print_func=console_log)
                        self.update_idletasks()

                    paned_window.bind("<B1-Motion>", on_sash_drag)

                    percentages = []
                    for sub_dir in sorted_layout_dirs:
                        if sub_dir.name.split('_')[0] not in ['top', 'bottom']: continue
                        try:
                            percentage = int(sub_dir.name.split('_')[1])
                            percentages.append(percentage)
                            new_frame = ttk.Frame(paned_window, borderwidth=self.theme_colors["border_width"], relief=self.theme_colors["relief"])
                            paned_window.add(new_frame, weight=percentage)
                            if Local_Debug_Enable:
                                debug_log(
                                    message=f"🔍🔵 Created vertical pane for '{sub_dir.name}' with weight {percentage}.",
                                    file=current_file,
                                    version=current_version,
                                    function=f"{self.__class__.__name__}.{current_function_name}",
                                    console_print_func=console_log
                                )
                            self._build_from_directory(path=sub_dir, parent_widget=new_frame)
                        except (IndexError, ValueError) as e:
                            console_log(f"⚠️ Warning: Could not parse percentage from folder name '{sub_dir.name}'. Error: {e}")
                            if Local_Debug_Enable:
                                debug_log(
                                    message=f"⚠️ Warning: Layout parsing failed for '{sub_dir.name}'. Error: {e}",
                                    file=current_file,
                                    version=current_version,
                                    function=f"{self.__class__.__name__}.{current_function_name}",
                                    console_print_func=console_log
                                )

                    def configure_sash(event):
                        total_percentage = sum(percentages)
                        if len(percentages) > 1 and total_percentage > 0:
                            sash_pos = int(event.height * (percentages[0] / total_percentage))
                            paned_window.sash_place(0, 0, sash_pos)
                            paned_window.unbind("<Configure>")
                    
                    paned_window.bind("<Configure>", configure_sash)
                return

            # Check for directories that start with a digit, which are now our tab indicators.
            # This identifies directories like "1_Connection", "2_monitors", etc.
            potential_tab_dirs = [d for d in sub_dirs if d.name and d.name[0].isdigit()]
            is_tab_container = bool(potential_tab_dirs)
 
            if is_tab_container:
                if Local_Debug_Enable:
                    debug_log(
                        message=f"🔍🔵 Found tab container directories in '{path}'. Creating ttk.Notebook.",
                        file=current_file,
                        version=current_version,
                        function=f"{self.__class__.__name__}.{current_function_name}",
                        console_print_func=console_log
                    )
                notebook = ttk.Notebook(parent_widget)
                notebook.pack(fill=tk.BOTH, expand=True)
                if Local_Debug_Enable:
                    debug_log(
                        message="🔍🔵 ttk.Notebook packed (fill=BOTH, expand=True).",
                        file=current_file,
                        version=current_version,
                        function=f"{self.__class__.__name__}.{current_function_name}",
                        console_print_func=console_log
                    )
                
                notebook.bind('<Control-Button-1>', self._tear_off_tab)
                notebook.bind('<<NotebookTabChanged>>', self._on_tab_change)
                
                # Filter for actual tab directories (starting with a digit) and sort them numerically.
                tab_dirs = sorted([d for d in sub_dirs if d.name and d.name[0].isdigit()], 
                                  key=lambda d: int(d.name.split('_')[0]))
                for tab_dir in tab_dirs:
                    tab_frame = ttk.Frame(notebook)
                    
                    # FIX ADDED HERE: Ensure the tab_frame expands to fill the space allocated by the notebook.
                    # This prevents child frames (like the plot) from collapsing.
                    tab_frame.grid_rowconfigure(0, weight=1)
                    tab_frame.grid_columnconfigure(0, weight=1)
                    tab_frame.grid(row=0, column=0, sticky="nsew") # Place the frame in the notebook area
                    if Local_Debug_Enable:
                        debug_log(
                            message=f"🔍🔵 Created tab frame for '{tab_dir.name}'. Grid configured and placed.",
                            file=current_file,
                            version=current_version,
                            function=f"{self.__class__.__name__}.{current_function_name}",
                            console_print_func=console_log
                        )
                    
                    self._frames_by_path[tab_dir] = tab_frame
                    
                    parts = tab_dir.name.split('_')
                    start_index = next((i for i, part in enumerate(parts) if part.isdigit()), -1)
                    display_name = " ".join(parts[start_index + 1:]).title() if start_index != -1 else tab_dir.name
                    notebook.add(tab_frame, text=display_name)
                    if Local_Debug_Enable:
                        debug_log(
                            message=f"🔍🔵 Added tab '{display_name}' to notebook.",
                            file=current_file,
                            version=current_version,
                            function=f"{self.__class__.__name__}.{current_function_name}",
                            console_print_func=console_log
                        )
                    
                    # The recursive call will place the contents (like ScanViewGUIFrame) inside the tab_frame
                    self._build_from_directory(path=tab_dir, parent_widget=tab_frame)

            if "2_monitors" in str(path):
                if Local_Debug_Enable:
                    debug_log(
                        message=f"🔍🔵 Special handling for 'tab_2_monitors' in path: '{path}'.",
                        file=current_file,
                        version=current_version,
                        function=f"{self.__class__.__name__}.{current_function_name}",
                        console_print_func=console_log
                    )
                py_files = sorted([f for f in path.iterdir() if f.is_file() and f.name.startswith("gui_") and f.suffix == '.py'])
                parent_widget.grid_rowconfigure(0, weight=1)
                parent_widget.grid_rowconfigure(1, weight=1)
                parent_widget.grid_rowconfigure(2, weight=1)
                parent_widget.grid_columnconfigure(0, weight=1)
                
                for i, py_file in enumerate(py_files):
                    module_name = py_file.stem
                    if Local_Debug_Enable:
                        debug_log(
                            message=f"🔍🔵 Dynamically importing module '{module_name}' for monitor frame.",
                            file=current_file,
                            version=current_version,
                            function=f"{self.__class__.__name__}.{current_function_name}",
                            console_print_func=console_log
                        )
                    spec = importlib.util.spec_from_file_location(module_name, py_file)
                    module = importlib.util.module_from_spec(spec)
                    sys.modules[module_name] = module
                    spec.loader.exec_module(module)

                    for name, obj in inspect.getmembers(module):
                        if inspect.isclass(obj) and issubclass(obj, (ttk.Frame, tk.Frame)) and obj.__module__ == module.__name__:
                            try:
                                config = {"theme_colors": self.theme_colors}
                                frame_instance = obj(parent_widget, mqtt_util=self.mqtt_util, config=config)
                                frame_instance.grid(row=i, column=0, sticky="nsew")
                                if Local_Debug_Enable:
                                    debug_log(
                                        message=f"🔍🔵 Instantiated and gridded '{name}' from '{py_file.name}'.",
                                        file=current_file,
                                        version=current_version,
                                        function=f"{self.__class__.__name__}.{current_function_name}",
                                        console_print_func=console_log
                                    )
                            except Exception as e:
                                console_log(f"❌ Failed to instantiate '{name}' from '{py_file.name}': {e}")
                                if Local_Debug_Enable:
                                    debug_log(
                                        message=f"❌🔴 Error instantiating '{name}' from '{py_file.name}': {e}",
                                        file=current_file,
                                        version=current_version,
                                        function=f"{self.__class__.__name__}.{current_function_name}",
                                        console_print_func=console_log
                                    )
                        
                return
            else:
                if Local_Debug_Enable:
                    debug_log(
                        message=f"🔍🔵 Applying general build logic for path: '{path}'.",
                        file=current_file,
                        version=current_version,
                        function=f"{self.__class__.__name__}.{current_function_name}",
                        console_print_func=console_log
                    )
                for sub_dir in sub_dirs:
                    if sub_dir.name.startswith("child_"):
                        if Local_Debug_Enable:
                            debug_log(
                                message=f"🔍🔵 Building child container for subdirectory: '{sub_dir.name}'.",
                                file=current_file,
                                version=current_version,
                                function=f"{self.__class__.__name__}.{current_function_name}",
                                console_print_func=console_log
                            )
                        self._build_child_container(path=sub_dir, parent_widget=parent_widget)

                py_files = sorted([f for f in path.iterdir() if f.is_file() and f.name.startswith("gui_") and f.suffix == '.py'])
                for py_file in py_files:
                    if Local_Debug_Enable:
                        debug_log(
                            message=f"🔍🔵 Building child container for Python file: '{py_file.name}'.",
                            file=current_file,
                            version=current_version,
                            function=f"{self.__class__.__name__}.{current_function_name}",
                            console_print_func=console_log
                        )
                    self._build_child_container(path=py_file, parent_widget=parent_widget)
            if Local_Debug_Enable:
                debug_log(
                    message=f"🔍🔵 Exiting _build_from_directory for path: '{path}'.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

        except Exception as e:
            console_log(f"❌ Error in {current_function_name} for path {path}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )


            
    def _build_child_container(self, path: pathlib.Path, parent_widget):
        """Dynamically imports and instantiates a GUI component from a Python file."""
        current_function_name = inspect.currentframe().f_code.co_name
        
        try:
            if path.is_dir():
                gui_file = next(f for f in path.iterdir() if f.is_file() and f.name.startswith("gui_") and f.suffix == '.py')
            else:
                gui_file = path

            module_name = gui_file.stem
            
            if Local_Debug_Enable:
                debug_log(
                    message=f"🔍🔵 Preparing to dynamically import module: '{module_name}' from path: '{gui_file}'.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
           
            spec = importlib.util.spec_from_file_location(module_name, gui_file)
            module = importlib.util.module_from_spec(spec)
            sys.modules[module_name] = module
            spec.loader.exec_module(module)

            # --- START FIXED, ROBUST INSTANTIATION LOGIC ---
            for name, obj in inspect.getmembers(module):
                if inspect.isclass(obj) and issubclass(obj, (ttk.Frame, tk.Frame)) and obj.__module__ == module.__name__:
                    if Local_Debug_Enable:
                        debug_log(
                            message=f"🔍🔵 Found a valid GUI class: '{name}'. Attempting safe instantiation.",
                            file=current_file,
                            version=current_version,
                            function=f"{self.__class__.__name__}.{current_function_name}",
                            console_print_func=console_log
                        )

                    frame_instance = None
                    try:
                        # Determine which arguments the constructor accepts
                        sig = inspect.signature(obj.__init__)
                        init_params = sig.parameters.keys()

                        # Prepare arguments to pass, based on availability in self and config needs
                        kwargs_to_pass = {}
                        if 'mqtt_util' in init_params and hasattr(self, 'mqtt_util'):
                            kwargs_to_pass['mqtt_util'] = self.mqtt_util
                        
                        config = {"theme_colors": self.theme_colors}
                        if name == "DynamicGuiBuilder" and hasattr(module, "MQTT_TOPIC_FILTER"):
                            config.update({
                                "base_topic": module.MQTT_TOPIC_FILTER,
                                "log_to_gui_console": console_log,
                                "log_to_gui_treeview": None
                            })
                        if 'config' in init_params:
                            kwargs_to_pass['config'] = config

                        # Attempt instantiation with dynamically determined arguments
                        # 'parent' is typically the first positional argument
                        frame_instance = obj(parent_widget, **kwargs_to_pass)

                        # If instantiation was successful
                        if frame_instance:
                            frame_instance.pack(fill=tk.BOTH, expand=True)
                            if Local_Debug_Enable:
                                debug_log(
                                    message=f"🔍🔵 Successfully instantiated and packed '{name}'.",
                                    file=current_file,
                                    version=current_version,
                                    function=f"{self.__class__.__name__}.{current_function_name}",
                                    console_print_func=console_log
                                )
                            return
                        else:
                            raise RuntimeError(f"Instantiation failed for class '{name}'.")

                    except Exception as e:
                        console_log(f"❌ Failed to instantiate '{name}' from '{gui_file.name}': {e}")
                        if Local_Debug_Enable:
                            debug_log(
                                message=f"❌🔴 Silent Crash Avoided: Instantiation of '{name}' failed. The error be: {e}",
                                file=current_file,
                                version=current_version,
                                function=f"{self.__class__.__name__}.{current_function_name}",
                                console_print_func=console_log
                            )
                        # Display an error message frame instead of leaving a blank spot
                        error_frame = ttk.Frame(parent_widget)
                        error_frame.pack(fill=tk.BOTH, expand=True)
                        ttk.Label(error_frame, text=f"ERROR LOADING: {gui_file.name}", foreground="red").pack(pady=10)
                        if Local_Debug_Enable:
                            debug_log(
                                message=f"🔍🔵 Displayed error frame for '{gui_file.name}'.",
                                file=current_file,
                                version=current_version,
                                function=f"{self.__class__.__name__}.{current_function_name}",
                                console_print_func=console_log
                            )
                        return

            # If we iterate all members and find no class
            raise AttributeError(f"Module '{module_name}' needs a class that inherits from 'ttk.Frame' or 'tk.Frame'.")
            # --- END FIXED, ROBUST INSTANTIATION LOGIC ---

        except Exception as e:
            console_log(f"❌ Error importing or executing module at {path}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 Fatal error during dynamic load: {e}",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
        if Local_Debug_Enable:
            debug_log(
                message=f"🔍🔵 Exiting _build_child_container for path: '{path}'.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _tear_off_tab(self, event):
        """Tears a tab off of its Notebook and places it into a new Toplevel window."""
        current_function_name = inspect.currentframe().f_code.co_name
        if Local_Debug_Enable:
            debug_log(
                message=f"🔍🔵 Attempting to tear off tab from event: {event}.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
        
        try:
            notebook = event.widget
            tab_id = notebook.identify(event.x, event.y)
            if not tab_id:
                if Local_Debug_Enable:
                    debug_log(
                        message="⚠️ No tab identified at click location.",
                        file=current_file,
                        version=current_version,
                        function=f"{self.__class__.__name__}.{current_function_name}",
                        console_print_func=console_log
                    )
                return 
            frame_id = notebook.tab(tab_id, "id")
            tab_title = notebook.tab(tab_id, "text")
            
            if frame_id in self._detached_windows:
                console_log(f"⚠️ Tab '{tab_title}' is already in a detached window.")
                if Local_Debug_Enable:
                    debug_log(
                        message=f"⚠️ Tab '{tab_title}' is already detached.",
                        file=current_file,
                        version=current_version,
                        function=f"{self.__class__.__name__}.{current_function_name}",
                        console_print_func=console_log
                    )
                return

            new_window = tk.Toplevel(self)
            new_window.title(tab_title)
            if Local_Debug_Enable:
                debug_log(
                    message=f"🔍🔵 Created new Toplevel window for detached tab '{tab_title}'.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
            
            notebook.forget(tab_id)
            frame_id.pack(in_=new_window, fill=tk.BOTH, expand=True)
            if Local_Debug_Enable:
                debug_log(
                    message=f"🔍🔵 Hid original tab and packed frame into new window.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
            
            self._detached_windows[frame_id] = {
                "window": new_window,
                "notebook": notebook,
                "tab_title": tab_title
            }
            
            new_window.protocol("WM_DELETE_WINDOW", lambda: self._re_attach_tab(frame_id))

            console_log(f"✅ Celebration of success! Tab '{tab_title}' has been detached and is now a new window.")
            if Local_Debug_Enable:
                debug_log(
                    message=f"✅ Tab '{tab_title}' successfully detached.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
            if Local_Debug_Enable:
                debug_log(
                    message=f"🔍🔵 Exiting _tear_off_tab().",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

    def _re_attach_tab(self, frame):
        """Re-attaches a detached frame back to its original Notebook."""
        current_function_name = inspect.currentframe().f_code.co_name
        if Local_Debug_Enable:
            debug_log(
                message=f"🔍🔵 Attempting to re-attach tab for frame: {frame}.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
  
        try:
            if frame not in self._detached_windows:
                debug_log(
                    message=f"⚠️ Frame {frame} not found in detached windows.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
                return
            state = self._detached_windows[frame]
            notebook = state["notebook"]
            tab_title = state["tab_title"]
            window = state["window"]
            
            frame.pack_forget()
            notebook.add(frame, text=tab_title)
            debug_log(
                message=f"🔍🔵 Re-packed frame into notebook and re-added tab '{tab_title}'.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
        
            del self._detached_windows[frame]
            window.destroy()
            debug_log(
                message=f"🔍🔵 Destroyed detached window for '{tab_title}'.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            
            console_log(f"✅ Celebration of success! Tab '{tab_title}' has been re-attached.")
            debug_log(
                message=f"✅ Tab '{tab_title}' successfully re-attached.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            debug_log(
                message=f"🔍🔵 Exiting _re_attach_tab().",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            
    def _on_tab_change(self, event):
        """Logs a debug message when a tab is selected or deselected."""
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🔍🔵 Entering '{current_function_name}' to log a tab change.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            notebook = event.widget
            newly_selected_tab_id = notebook.select()
            newly_selected_tab_name = notebook.tab(newly_selected_tab_id, "text")

            if self.last_selected_tab_name:
                debug_log(
                    message=f"📘🔴 Tab '{self.last_selected_tab_name}' deselected!",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

            debug_log(
                message=f"📘🟢 Tab '{newly_selected_tab_name}' selected!",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            
            self.last_selected_tab_name = newly_selected_tab_name
            
            console_log("✅ Celebration of success!")
            debug_log(
                message="✅ Tab change logged successfully.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            debug_log(
                message=f"🔍🔵 Exiting _on_tab_change().",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

#####################################
### File: OPEN-AIR/display/logger.py
#####################################
# display/logger.py
#
# This module provides a centralized logging utility for the entire application,
# including console output, file writing, and conditional logging.
# It includes functionality for relative timestamps and error file logging.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251213.000000.1 (Migrated from worker_active_logging.py)

import os
import inspect
import datetime
import pathlib
import json # Used for JSON logging if a payload is passed
import sys

# project_root should be defined globally, or passed. For now, assume it's available.
# In a real scenario, this would likely be passed from a central configuration.
# For consistency with other modules, we will define it here relative to this file.
current_file_path = pathlib.Path(__file__).resolve()
# Define GLOBAL_PROJECT_ROOT directly here to break circular dependency
GLOBAL_PROJECT_ROOT = current_file_path.parent.parent # Assuming 'display' is directly under project root


# Record the application start time for relative timestamps
APP_START_TIME = datetime.datetime.now()


# --- Global Scope Variables (as per Section 4.4) ---
current_version = "20251213.000000.1" # Version for this specific logging module
current_version_hash = (20251213 * 0 * 1)
current_file = f"{os.path.basename(__file__)}"
Local_Debug_Enable = True


# --- Configuration Placeholders (To be set by the main application's config manager) ---
# NOTE: These are temporary global placeholders that a Configuration Manager will eventually set.
global_settings = {
    "general_debug_enabled": True, # The main toggle for debug messages
    "debug_to_terminal": True,     # Output debug to the terminal/IDE console
    "debug_to_file": True,         # Output debug to the debug log file
    "log_truncation_enabled": True, # Truncate large numeric payloads
    "include_console_messages_to_debug_file": True, # Include console_log output in debug file
    "log_visa_commands_enabled": True, # Log all SCPI commands sent/received
    "include_visa_messages_to_debug_file": True, # Include VISA logs in the main debug file
    "debug_to_gui_console": True,  # Output debug to the in-app console
    "include_timestamp_in_debug": True, # NEW: Include MM.SS timestamp in debug output
}
# Log file paths (relative to the project root for safety)
FILE_LOG_DIR = GLOBAL_PROJECT_ROOT / "DATA" / "debug" # Using locally defined GLOBAL_PROJECT_ROOT

VISA_LOG_FILENAME = "visa_commands.log"
DEBUG_FILE_PATH = None  # This will be dynamically set/updated
ERRORS_LOG_FILENAME = "ERRORS.log" # NEW CONSTANT FOR ERROR LOGGING

# Global variable to store the current log filename
current_debug_log_filename = None

# --- Constants (No Magic Numbers) ---
MAX_LOG_LENGTH = 150 
TRUNCATION_SUFFIX = " ... [Truncated]"
ERROR_MARKER_CRITICAL = "🔴"
ERROR_MARKER_USER = "❌"

# --- Global Redirectors (To be set by the GUI Application) ---
# These functions will be overwritten by the GUI's text redirectors.
GUI_CONSOLE_PRINT_FUNC = print 
GUI_LOG_TO_DEBUG_CONSOLE_FUNC = lambda x: print(f"GUI_DEBUG: {x}") 
GUI_CLEAR_CONSOLE_FUNC = lambda: None
# =========================================================================

def _log_to_error_file(message: str):
    # Logs the message to the dedicated ERRORS.log file if it contains a failure marker.
    if ERROR_MARKER_USER in message or ERROR_MARKER_CRITICAL in message:
        _log_to_file(message, ERRORS_LOG_FILENAME)


def get_log_filename():
    # Returns a unique filename based on the current date and minute.
    global current_debug_log_filename
    
    current_minute = datetime.datetime.now().strftime("%Y%m%d_%H%M")
    if current_debug_log_filename is None or not current_debug_log_filename.startswith(f"debug_log_{current_minute}"):
        current_debug_log_filename = f"debug_log_{current_minute}.log"
        
    return current_debug_log_filename

def _safe_print(message: str):
    # Prints to the console/GUI target, avoiding recursion issues if print is hooked.
    timestamp_prefix = ""
    if global_settings.get("include_timestamp_in_debug"):
        elapsed_seconds = (datetime.datetime.now() - APP_START_TIME).total_seconds()
        minutes = int(elapsed_seconds // 60)
        seconds = int(elapsed_seconds % 60)
        milliseconds = int((elapsed_seconds - int(elapsed_seconds)) * 1000)
        timestamp_prefix = f"{minutes:02d}.{seconds:02d}.{milliseconds:03d} "

    if 'GUI_CONSOLE_PRINT_FUNC' in globals() and callable(GUI_CONSOLE_PRINT_FUNC):
        GUI_CONSOLE_PRINT_FUNC(f"{timestamp_prefix}{message}")
    else:
        # FALLBACK FIX: Use print() without arguments to avoid file=sys.stderr crash
        print(f"{timestamp_prefix}{message}")
        
def _log_to_file(message: str, log_filename: str):
    # Helper to safely write a message to a file.
    log_path = FILE_LOG_DIR / log_filename
    
    # --- NEW FIX: Ensure the log directory exists before trying to open the file. ---
    try:
        if not FILE_LOG_DIR.exists():
            FILE_LOG_DIR.mkdir(parents=True, exist_ok=True)
            _safe_print(f"✅ Created missing log directory: {FILE_LOG_DIR}")
    except Exception as e:
        # FALLBACK FIX: Use simple print.
        print(f"❌ Critical Error: Failed to create log directory '{FILE_LOG_DIR}': {e}")
        return # Abort logging if directory creation fails
    # --- END NEW FIX ---
    
    try:
        with open(log_path, "a", encoding="utf-8") as log_file:
            log_file.write(message + "\n")
            
    except Exception as e:
        # FALLBACK FIX: Use simple print.
        print(f"❌ Error writing to log file '{log_path}': {e}")

def _truncate_message(message: str) -> str:
    # Truncates long messages as per spec, specifically targeting numeric-heavy payloads.
    if not global_settings["log_truncation_enabled"]:
        return message

    # Simplified check for a long string that looks like a data dump
    if len(message) > MAX_LOG_LENGTH and all(c.isdigit() or c in '.-+e' for c in message.replace(' ', '').replace(',', '').replace(';', '')):
        return message[:MAX_LOG_LENGTH] + TRUNCATION_SUFFIX
    elif len(message) > MAX_LOG_LENGTH and message.count('/') > 5:
        # Also truncate long MQTT topic paths
        return message[:MAX_LOG_LENGTH] + TRUNCATION_SUFFIX
        
    return message


# =========================================================================
# PUBLIC LOGGING API (Called by other modules)
# =========================================================================

def console_log(message: str, local_debug_enabled: bool = None):
    # Logs a user-facing message to the console and conditionally to the debug file.
    if local_debug_enabled is None:
        frame = inspect.currentframe().f_back
        if frame:
            frame = frame.f_back # Go up one more frame to get the caller of console_log
        local_debug_enabled = frame.f_globals.get('Local_Debug_Enable', False) if frame else False

    if local_debug_enabled:
        # 1. Log to console output
        if global_settings["debug_to_terminal"]:
            _safe_print(message)
            
        # 2. Log to main debug file
        if global_settings["debug_to_file"] and global_settings["include_console_messages_to_debug_file"]:
            _log_to_file(f"🖥️ {message}", get_log_filename())

    # 3. Log to errors file if it contains the marker (always, regardless of debug flag)
    _log_to_error_file(message)

def debug_log(message: str, file: str, version: str, function: str, console_print_func):
    # Logs a detailed debug message to the specified outputs.
    if not global_settings["general_debug_enabled"]:
        return
        
    # Get the calling frame
    frame = inspect.currentframe().f_back
    
    # Check if Local_Debug_Enable is defined and True in the calling frame
    local_debug_enabled = frame.f_globals.get('Local_Debug_Enable', False)

    if local_debug_enabled:        # Truncate the message before prepending metadata
        truncated_message = _truncate_message(message)
        
        # The full log entry format: [EMOJI] [MESSAGE] | [FILE] | [VERSION] Function: [FUNCTION]
        timestamp_prefix = ""
        if global_settings.get("include_timestamp_in_debug"):
            elapsed_seconds = (datetime.datetime.now() - APP_START_TIME).total_seconds()
            minutes = int(elapsed_seconds // 60)
            seconds = int(elapsed_seconds % 60)
            milliseconds = int((elapsed_seconds - int(elapsed_seconds)) * 1000)
            timestamp_prefix = f"{minutes:02d}.{seconds:02d}.{milliseconds:03d} "
        
        log_entry = f"{timestamp_prefix}{truncated_message} | {file} | {version} Function: {function}"

        # 1. Log to console output
        if global_settings["debug_to_terminal"]:
            console_print_func(log_entry)

        # 2. Log to main debug file
        if global_settings["debug_to_file"]:
            _log_to_file(log_entry, get_log_filename())
            
        # 3. Log to errors file if it contains the marker
        _log_to_error_file(message)


# PUBLIC API: Implemented as per the user's explicit request.
def log_visa_command(command: str, direction: str):
    # Logs SCPI commands sent to and responses received from the instrument.
    if not global_settings["log_visa_commands_enabled"]:
        return
        
    direction_emoji = "➡️" if direction == "SENT" else "⬅️"
    
    # Truncate command, primarily for large query responses
    truncated_command = _truncate_message(command)
    
    # The log entry format for the visa file is simple
    log_entry = f"🐐 {direction_emoji} {direction}: {truncated_command}"

    # 1. Log to VISA-specific file
    _log_to_file(log_entry, VISA_LOG_FILENAME)

    # 2. Conditionally log to main debug file
    if global_settings["include_visa_messages_to_debug_file"]:
        _log_to_file(f"🐐 {log_entry}", get_log_filename())
        
    # 3. Log to errors file if it contains the marker
    _log_to_error_file(log_entry)


#####################################
### File: OPEN-AIR/display/right_50/bottom_90/3_debug/gui_tab_3_debug.py
#####################################
# display/right_50/bottom_90/tab_3_debug/gui_tab_3_debug.py
#
# A DEBUG tab component inheriting from the formal BaseGUIFrame.
# It provides logging controls and an MQTT table view for inspection.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1
# MODIFIED: Inherits from the centralized BaseGUIFrame and uses clean attribute referencing.

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from display.styling.style import THEMES, DEFAULT_THEME
# FIXED: Import the formalized BaseGUIFrame
from display.right_50.bottom_90.prototype.base_gui_component_rebuilt import BaseGUIFrame


# --- Global Scope Variables (Protocol 4.4) ---
current_version = "20251127.000000.1"
current_version_hash = (20251127 * 0 * 1)
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parents[4] 
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class DebugTabGUIFrame(BaseGUIFrame):
    """
    A debug frame with logging and MQTT monitoring functionality.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        if 'config' in kwargs:
            kwargs.pop('config')
        super().__init__(parent, mqtt_util, *args, **kwargs)

        debug_log(
            message="🖥️🟢 Initializing the dedicated Debug Tab GUI. Time for deep inspection!",
            file=current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        # Overwrite inherited MQTT topic variable for local use
        self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
        
        self._create_widgets()
        
        # Now subscribe to messages after the widgets exist.
        parent_folder = str(pathlib.Path(self.current_file).parent)
        subscription_topic = f"{parent_folder.replace('\\', '/')}/#"
        self.mqtt_util.add_subscriber(topic_filter=subscription_topic, callback_func=self._on_mqtt_message)
        self.mqtt_util.add_subscriber(topic_filter="Open-Air/Recon/#", callback_func=self._on_mqtt_message)


        console_log("✅ Debug Tab GUI initialized successfully!")

    def _create_widgets(self):
        """Creates all the UI widgets for the comprehensive conductor tab."""
        
        # --- Log Buttons Frame ---
        log_button_frame = ttk.Frame(self)
        log_button_frame.pack(side=tk.TOP, fill=tk.X, padx=10, pady=5)
        
        # Button 1: Log
        ttk.Button(log_button_frame, text="Log", command=self.log_button_press).pack(side=tk.LEFT, padx=5)
        
        # Button 2: Debug
        ttk.Button(log_button_frame, text="Debug", command=self.debug_button_press).pack(side=tk.LEFT, padx=5)

        # Button 3: Publish Version
        ttk.Button(log_button_frame, text="Publish Version", command=self._publish_version_message).pack(side=tk.LEFT, padx=5)

        # Custom MQTT Publish Entry
        self.custom_topic_entry = ttk.Entry(log_button_frame, style="Custom.TEntry")
        self.custom_topic_entry.insert(0, f"Custom Message")
        self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
        
        ttk.Button(log_button_frame, text="Publish Custom", command=self._publish_custom_message).pack(side=tk.LEFT, padx=5)
        
        ttk.Label(log_button_frame, textvariable=self.mqtt_topic_var).pack(side=tk.LEFT, padx=5)

        # --- MQTT Message Log Table ---
        self.subscriptions_table_frame = ttk.Frame(self)
        self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings", style="Custom.Treeview")
        self.subscriptions_table.heading("Topic", text="Topic")
        self.subscriptions_table.heading("Message Content", text="Message Content")
        self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
        self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
        table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # --- Status Bar at the bottom ---
        status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
        status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
        
        file_parts = self.current_file.rsplit('/', 1)
        file_folder = file_parts[0] if len(file_parts) > 1 else ""
        file_name = file_parts[-1]

        status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
        ttk.Label(status_bar, text=status_text, anchor='w').pack(side=tk.LEFT, fill=tk.X, expand=True)

    def log_button_press(self):
        # Sends a standard log message.
        current_function_name = inspect.currentframe().f_code.co_name
        console_log(f"Log button pressed in {self.current_file}. Initiating standard log entry.")
        debug_log(
            message=f"🖥️🟢 Executing 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

    def debug_button_press(self):
        # Sends a debug log message.
        current_function_name = inspect.currentframe().f_code.co_name
        console_log(f"Debug button pressed in {self.current_file}.")
        debug_log(
            message=f"🔍🔵 The debug button was clicked! Time for a deeper inspection!",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        topic = self.current_file
        message = self.current_version
        self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
        console_log("✅ Version message published successfully!")
        debug_log(
            message=f"🖥️🟢 Published version '{message}' to topic '{topic}/version'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )


    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        try:
            # Safely parse the value from the payload dictionary
            message_content = json.loads(payload).get("value", payload)
            
            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
            
        except Exception as e:
            debug_log(
                message=f"❌🔴 Error processing MQTT message in Debug Tab: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        topic = self.current_file
        subtopic = "textbox"
        message = self.custom_topic_entry.get()
        self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
        console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        debug_log(
            message=f"🖥️🟢 Published custom message: '{message}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

#####################################
### File: OPEN-AIR/display/right_50/bottom_90/1_scan/gui_scan.py
#####################################
# display/right_50/bottom_90/tab_1_scan/gui_tab_1_scan.py
#
# This file defines the GUI frame for the scan view, featuring a Matplotlib/Seaborn plot.
#
# Author: Anthony Peter Kuzub
#
# Version 20251127.000000.1

import tkinter as tk
from tkinter import ttk
import numpy as np
import seaborn as sns
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk

from display.logger import debug_log, console_log, log_visa_command
import pathlib
import os

current_version = "UNKNOWN_VERSION.000000.0"
current_version_hash = 0
current_file_path = pathlib.Path(__file__).resolve()
project_root = pathlib.Path("/home/anthony/Documents/OPEN-AIR").resolve()
current_file = str(current_file_path.relative_to(project_root)).replace("\\\\", "/")

class ScanViewGUIFrame(ttk.Frame):
    
    def __init__(self, parent, mqtt_util=None, config=None):
        super().__init__(parent)
        
        # The parent will use .pack() or .grid() on this frame.
        # This frame will use .grid() for its own children.
        
        # Configure grid for expansion: Row 0 is canvas (weight 1), Row 1 is toolbar (weight 0)
        self.grid_rowconfigure(0, weight=1) 
        self.grid_rowconfigure(1, weight=0)
        self.grid_columnconfigure(0, weight=1)
        
        # Use theme from parent if available, otherwise fallback
        self.theme_colors = config.get("theme_colors", {
            "bg": "#2b2b2b", "fg": "#dcdcdc", "fg_alt": "#888888", "accent": "#f4902c"
        })

        self._create_plot_widgets()
        console_log("✅ Scan View Plot Frame Initialized.")

    def _create_plot_widgets(self):
        # --- 0. Set Seaborn Style ---
        sns.set_theme(style="darkgrid", palette="deep") 
        
        # --- 1. Create Matplotlib Figure and Axes ---
        self.fig = Figure(figsize=(8, 6), dpi=100, facecolor=self.theme_colors["bg"])
        self.ax = self.fig.add_subplot(111, facecolor=self.theme_colors["bg"])
        
        # --- Placeholder Plot: A Simple Sine Wave using Seaborn ---
        t = np.arange(0.0, 2.0, 0.01)
        s = 1 + np.sin(2 * np.pi * t)
        
        # Use Seaborn's lineplot, passing the Matplotlib axes object (ax)
        sns.lineplot(x=t, y=s, ax=self.ax, color=self.theme_colors["accent"], linewidth=2) 
        
        # --- Configure Axes ---
        self.ax.set_title("Live Scan View", color=self.theme_colors["fg"])
        self.ax.set_xlabel("Frequency (MHz)", color=self.theme_colors["fg"])
        self.ax.set_ylabel("Amplitude (dBm)", color=self.theme_colors["fg"])
        self.ax.tick_params(axis='x', colors=self.theme_colors["fg"])
        self.ax.tick_params(axis='y', colors=self.theme_colors["fg"])
        self.ax.grid(True, linestyle='--', color=self.theme_colors["fg_alt"], alpha=0.5)

        # --- 2. Create Tkinter canvas and grid it ---
        self.canvas = FigureCanvasTkAgg(self.fig, master=self)
        self.canvas_widget = self.canvas.get_tk_widget()
        self.canvas_widget.grid(row=0, column=0, sticky="nsew")

        # --- 3. Add Toolbar Frame (Master for Toolbar) ---
        self.toolbar_frame = ttk.Frame(self)
        self.toolbar_frame.grid(row=1, column=0, sticky="ew")
        
        self.toolbar = NavigationToolbar2Tk(self.canvas, self.toolbar_frame)
        self.toolbar.update()
        self.toolbar.pack(side="top", fill="x")

        self.canvas.draw()
        console_log("✅ Plot successfully rendered in Scan View.")

#####################################
### File: OPEN-AIR/display/right_50/bottom_90/2_monitors/gui_monitor_bottom.py
#####################################
# gui_monitor_1_top_blank_graph.py 
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version is simplified to only display a blank Matplotlib plot.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251026.220340.3 (Blank Graph)
# MODIFIED: Removed all plot-specific colors, titles, and axis styling to create a blank graph.

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json

# --- Matplotlib imports for plotting functionality ---
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from display.styling.style import THEMES, DEFAULT_THEME

# --- Global Scope Variables ---
CURRENT_DATE = 20250823
CURRENT_TIME = 1500
REVISION_NUMBER = 21

current_version = "20251026.220340.3" # Updated version number
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME * REVISION_NUMBER)
current_function_name = ""


class MonitorTopGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames now focused on displaying a Matplotlib plot.
    """
    PLOT_ID = "top" 
    
    def __init__(self, parent, mqtt_util=None, config=None, *args, **kwargs):
        """
        Initializes the GUI frame with a blank plot.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)

            self._apply_styles(theme_name=DEFAULT_THEME)

            # --- Single Plot Frame ---
            plot_frame = ttk.Frame(self)
            plot_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            plot_frame.grid_columnconfigure(0, weight=1)
            plot_frame.grid_rowconfigure(0, weight=1)

            # This section creates the matplotlib figure and canvas.
            # RETAINED: Figure creation, but removed all color styling for a blank look.
            self.theme_colors = config.get("theme_colors", {
                "bg": "#2b2b2b", "fg": "#dcdcdc", "fg_alt": "#888888", "accent": "#f4902c"
            })
            figure = Figure(figsize=(8, 6), dpi=100, facecolor=self.theme_colors["bg"])
            ax = figure.add_subplot(111, facecolor=self.theme_colors["bg"])
            ax.set_title("Bottom Monitor", color=self.theme_colors["fg"])
            ax.set_xlabel("Frequency (MHz)", color=self.theme_colors["fg"])
            ax.set_ylabel("Amplitude (dBm)", color=self.theme_colors["fg"])
            ax.tick_params(axis='x', colors=self.theme_colors["fg"])
            ax.tick_params(axis='y', colors=self.theme_colors["fg"])
            ax.grid(True, linestyle='--', color=self.theme_colors["fg_alt"], alpha=0.5)
            
            canvas = FigureCanvasTkAgg(figure, master=plot_frame)
            canvas_widget = canvas.get_tk_widget()
            canvas_widget.pack(fill=tk.BOTH, expand=True)
            
            self.plot = {'figure': figure, 'ax': ax, 'canvas': canvas, 'widget': canvas_widget}

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        # General widget styling
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])

        # Table (Treeview) styling
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

        # Entry (textbox) styling
        style.configure('Custom.TEntry',
                        fieldbackground=colors["entry_bg"],
                        foreground=colors["entry_fg"],
                        bordercolor=colors["table_border"])
        

if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test with Blank Plot")
    
    app_frame = MonitorTopGUIFrame(parent=root)
    
    root.mainloop()

#####################################
### File: OPEN-AIR/display/right_50/bottom_90/2_monitors/gui_monitor_middle.py
#####################################
# gui_monitor_1_top_blank_graph.py 
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version is simplified to only display a blank Matplotlib plot.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251026.220340.3 (Blank Graph)
# MODIFIED: Removed all plot-specific colors, titles, and axis styling to create a blank graph.

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json

# --- Matplotlib imports for plotting functionality ---
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from display.styling.style import THEMES, DEFAULT_THEME

# --- Global Scope Variables ---
CURRENT_DATE = 20250823
CURRENT_TIME = 1500
REVISION_NUMBER = 21

current_version = "20251026.220340.3" # Updated version number
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME * REVISION_NUMBER)
current_function_name = ""


class MonitorTopGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames now focused on displaying a Matplotlib plot.
    """
    PLOT_ID = "top" 
    
    def __init__(self, parent, mqtt_util=None, config=None, *args, **kwargs):
        """
        Initializes the GUI frame with a blank plot.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)

            self._apply_styles(theme_name=DEFAULT_THEME)

            # --- Single Plot Frame ---
            plot_frame = ttk.Frame(self)
            plot_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            plot_frame.grid_columnconfigure(0, weight=1)
            plot_frame.grid_rowconfigure(0, weight=1)

            # This section creates the matplotlib figure and canvas.
            # RETAINED: Figure creation, but removed all color styling for a blank look.
            self.theme_colors = config.get("theme_colors", {
                "bg": "#2b2b2b", "fg": "#dcdcdc", "fg_alt": "#888888", "accent": "#f4902c"
            })
            figure = Figure(figsize=(8, 6), dpi=100, facecolor=self.theme_colors["bg"])
            ax = figure.add_subplot(111, facecolor=self.theme_colors["bg"])
            ax.set_title("Middle Monitor", color=self.theme_colors["fg"])
            ax.set_xlabel("Frequency (MHz)", color=self.theme_colors["fg"])
            ax.set_ylabel("Amplitude (dBm)", color=self.theme_colors["fg"])
            ax.tick_params(axis='x', colors=self.theme_colors["fg"])
            ax.tick_params(axis='y', colors=self.theme_colors["fg"])
            ax.grid(True, linestyle='--', color=self.theme_colors["fg_alt"], alpha=0.5)
            
            canvas = FigureCanvasTkAgg(figure, master=plot_frame)
            canvas_widget = canvas.get_tk_widget()
            canvas_widget.pack(fill=tk.BOTH, expand=True)
            
            self.plot = {'figure': figure, 'ax': ax, 'canvas': canvas, 'widget': canvas_widget}

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        # General widget styling
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])

        # Table (Treeview) styling
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

        # Entry (textbox) styling
        style.configure('Custom.TEntry',
                        fieldbackground=colors["entry_bg"],
                        foreground=colors["entry_fg"],
                        bordercolor=colors["table_border"])
        

if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test with Blank Plot")
    
    app_frame = MonitorTopGUIFrame(parent=root)
    
    root.mainloop()

#####################################
### File: OPEN-AIR/display/right_50/bottom_90/2_monitors/gui_monitor_top.py
#####################################
# gui_monitor_1_top_blank_graph.py 
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version is simplified to only display a blank Matplotlib plot.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1 (Blank Graph)
# MODIFIED: Removed all plot-specific colors, titles, and axis styling to create a blank graph.

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json

# --- Matplotlib imports for plotting functionality ---
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2Tk

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from display.styling.style import THEMES, DEFAULT_THEME

# --- Global Scope Variables ---
CURRENT_DATE = 20251127
CURRENT_TIME = 0
REVISION_NUMBER = 1

current_version = "20251127.000000.1" # Updated version number
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME * REVISION_NUMBER)
current_function_name = ""


class MonitorTopGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames now focused on displaying a Matplotlib plot.
    """
    PLOT_ID = "top" 
    
    def __init__(self, parent, mqtt_util=None, config=None, *args, **kwargs):
        """
        Initializes the GUI frame with a blank plot.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)

            self._apply_styles(theme_name=DEFAULT_THEME)

            # --- Single Plot Frame ---
            plot_frame = ttk.Frame(self)
            plot_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
            plot_frame.grid_columnconfigure(0, weight=1)
            plot_frame.grid_rowconfigure(0, weight=1)

            # This section creates the matplotlib figure and canvas.
            # RETAINED: Figure creation, but removed all color styling for a blank look.
            self.theme_colors = config.get("theme_colors", {
                "bg": "#2b2b2b", "fg": "#dcdcdc", "fg_alt": "#888888", "accent": "#f4902c"
            })
            figure = Figure(figsize=(8, 6), dpi=100, facecolor=self.theme_colors["bg"])
            ax = figure.add_subplot(111, facecolor=self.theme_colors["bg"])
            ax.set_title("Top Monitor", color=self.theme_colors["fg"])
            ax.set_xlabel("Frequency (MHz)", color=self.theme_colors["fg"])
            ax.set_ylabel("Amplitude (dBm)", color=self.theme_colors["fg"])
            ax.tick_params(axis='x', colors=self.theme_colors["fg"])
            ax.tick_params(axis='y', colors=self.theme_colors["fg"])
            ax.grid(True, linestyle='--', color=self.theme_colors["fg_alt"], alpha=0.5)
            
            canvas = FigureCanvasTkAgg(figure, master=plot_frame)
            canvas_widget = canvas.get_tk_widget()
            canvas_widget.pack(fill=tk.BOTH, expand=True)
            
            self.plot = {'figure': figure, 'ax': ax, 'canvas': canvas, 'widget': canvas_widget}

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        # General widget styling
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])

        # Table (Treeview) styling
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

        # Entry (textbox) styling
        style.configure('Custom.TEntry',
                        fieldbackground=colors["entry_bg"],
                        foreground=colors["entry_fg"],
                        bordercolor=colors["table_border"])
        

if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test with Blank Plot")
    
    app_frame = MonitorTopGUIFrame(parent=root)
    
    root.mainloop()

#####################################
### File: OPEN-AIR/display/right_50/bottom_90/prototype/base_gui_component_rebuilt.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version corrects the styling of tables and entry widgets for a more cohesive look.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from display.styling.style import THEMES, DEFAULT_THEME

# --- Global Scope Variables ---
CURRENT_DATE = 20251127
CURRENT_TIME = 0
CURRENT_TIME_HASH = 0
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class is now designed as a self-contained "island" that manages its own MQTT state.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # We apply the style at the top of the __init__ to affect all child widgets.
            self._apply_styles(theme_name=DEFAULT_THEME)

            # Create a label for the frame
            frame_label = ttk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = ttk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame, style="Custom.TEntry")
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = ttk.Button(
                mqtt_frame,
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)

            # We now register our callback with the central utility instead of overwriting the client's callback.
            parent_folder = str(pathlib.Path(self.current_file).parent)
            subscription_topic = f"{parent_folder.replace('\\', '/')}/#"
            self.mqtt_util.add_subscriber(topic_filter=subscription_topic, callback_func=self._on_mqtt_message)


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings", style="Custom.Treeview")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            # New frame for log buttons, placed at the bottom below the table.
            log_button_frame = ttk.Frame(self)
            log_button_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=5)

            # Button 1: Log
            self.log_button = ttk.Button(
                log_button_frame, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = ttk.Button(
                log_button_frame, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        # General widget styling
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])

        # Table (Treeview) styling
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

        # Entry (textbox) styling
        style.configure('Custom.TEntry',
                        fieldbackground=colors["entry_bg"],
                        foreground=colors["entry_fg"],
                        bordercolor=colors["table_border"])
        
    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            message_content = json.loads(payload)["value"]
            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()

#####################################
### File: OPEN-AIR/display/right_50/bottom_90/6_prototype/gui_prototype.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version corrects the styling of tables and entry widgets for a more cohesive look.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from display.styling.style import THEMES, DEFAULT_THEME

# --- Global Scope Variables ---
CURRENT_DATE = 20251127
CURRENT_TIME = 0
CURRENT_TIME_HASH = 0
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class is now designed as a self-contained "island" that manages its own MQTT state.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            if 'config' in kwargs:
                kwargs.pop('config')
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # We apply the style at the top of the __init__ to affect all child widgets.
            self._apply_styles(theme_name=DEFAULT_THEME)

            # Create a label for the frame
            frame_label = ttk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = ttk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame, style="Custom.TEntry")
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = ttk.Button(
                mqtt_frame,
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)

            # We now register our callback with the central utility instead of overwriting the client's callback.
            parent_folder = str(pathlib.Path(self.current_file).parent)
            subscription_topic = f"{parent_folder.replace('\\', '/')}/#"
            self.mqtt_util.add_subscriber(topic_filter=subscription_topic, callback_func=self._on_mqtt_message)


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings", style="Custom.Treeview")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            # New frame for log buttons, placed at the bottom below the table.
            log_button_frame = ttk.Frame(self)
            log_button_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=5)

            # Button 1: Log
            self.log_button = ttk.Button(
                log_button_frame, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = ttk.Button(
                log_button_frame, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        # General widget styling
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])

        # Table (Treeview) styling
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

        # Entry (textbox) styling
        style.configure('Custom.TEntry',
                        fieldbackground=colors["entry_bg"],
                        foreground=colors["entry_fg"],
                        bordercolor=colors["table_border"])
        
    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            message_content = json.loads(payload)["value"]
            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()

#####################################
### File: OPEN-AIR/display/right_50/bottom_90/8_configuration/gui_tab_5_configuration.py
#####################################
# This is a specialized GUI component designed for the Configuration tab.
# It acts as a test harness for features related to configuration management within the main
# section. This refactored version is a standalone test harness with mock functionality.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk, scrolledtext # Added scrolledtext
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from display.styling.style import THEMES, DEFAULT_THEME

# --- Global Scope Variables ---
CURRENT_DATE = 20251127
CURRENT_TIME = 0
CURRENT_TIME_HASH = 0
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
current_file = f"tabs/Experiments/tab_experiments_child_initial_configuration.py"


class InitialConfigurationTab(ttk.Frame):
    def __init__(self, master=None, *args, **kwargs):
        """
        Initializes the InitialConfigurationTab, a Tkinter Frame for viewing and
        editing the application's configuration.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"📕🟢 Initializing InitialConfigurationTab...",
                  file=current_file, version=current_version, function=current_function, console_print_func=console_log)

        super().__init__(master, **kwargs)
        
        self._create_widgets()
        self._populate_config_table()
        
        debug_log(message=f"📕✅ InitialConfigurationTab initialized.",
                  file=current_file, version=current_version, function=current_function, console_print_func=console_log)

    def _create_widgets(self):
        """
        Creates and lays out the widgets for the configuration tab, including a
        text area for displaying the config and buttons for saving and reloading.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"📕🟢 Creating widgets for InitialConfigurationTab.",
                  file=current_file, version=current_version, function=current_function, console_print_func=console_log)

        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(1, weight=1)

        control_frame = ttk.Frame(self)
        control_frame.grid(row=0, column=0, padx=10, pady=5, sticky="ew")
        control_frame.grid_columnconfigure(0, weight=1)
        control_frame.grid_columnconfigure(1, weight=1)
        
        save_button = ttk.Button(control_frame, text="Save Config", command=self._save_program_configure_action, style='Green.TButton')
        save_button.grid(row=0, column=0, padx=5, pady=5, sticky="ew")

        reload_button = ttk.Button(control_frame, text="Reload Config", command=self._reload_config_action, style='Orange.TButton')
        reload_button.grid(row=0, column=1, padx=5, pady=5, sticky="ew")

        self.config_text_widget = scrolledtext.ScrolledText(self, wrap="word", height=25, bg="#2b2b2b", fg="#cccccc", insertbackground="white", font=("Courier", 10))
        self.config_text_widget.grid(row=1, column=0, padx=10, pady=5, sticky="nsew")
        
        debug_log(message=f"📕✅ Widgets created.",
                  file=current_file, version=current_version, function=current_function, console_print_func=console_log)
    
    def _populate_config_table(self):
        """
        Reads a mock config file and populates the text widget with its content.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"📕🟢 Populating config table from a mock file.",
                  file=current_file, version=current_version, function=current_function, console_print_func=console_log)

        try:
            mock_config_content = """[GENERAL]
theme = dark
log_level = DEBUG

[INSTRUMENT]
visa_resource = ASRL1::INSTR
ref_level_dBm = -20
power_attenuation_dB = 10
preamp_on = False
high_sensitivity_on = False

[MARKERS]
marker1_freq_MHz = 111.0
marker2_freq_MHz = 222.0
marker3_freq_MHz = 333.0
"""
            self.config_text_widget.config(state=tk.NORMAL)
            self.config_text_widget.delete('1.0', tk.END)
            self.config_text_widget.insert(tk.END, mock_config_content)
            self.config_text_widget.config(state=tk.DISABLED)
            
            debug_log(message=f"📕✅ Config table populated successfully.",
                      file=current_file, version=current_version, function=current_function, console_print_func=console_log)

        except Exception as e:
            console_log(message=f"❌ Error populating config table: {e}")
            debug_log(message=f"📕🔴 Failed to populate config table. Error: {e}",
                      file=current_file, version=current_version, function=current_function, console_print_func=console_log)
    
    def _save_program_configure_action(self):
        """
        Handles the action of saving the edited config back to a mock file.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"📕🟢 Attempting to save mock config file...",
                  file=current_file, version=current_version, function=current_function, console_print_func=console_log)

        try:
            current_content = self.config_text_widget.get('1.0', tk.END)
            # In a real app, this would write to a file. Here, we just log the action.
            console_log("✅ Configuration saved successfully! (Mock Action)")
            debug_log(message=f"📕✅ Mock configuration saved. Arrr, the treasure be safely stowed! ⚓️",
                      file=current_file, version=current_version, function=current_function, console_print_func=console_log)

        except Exception as e:
            console_log(message=f"❌ Error saving configuration: {e}")
            debug_log(message=f"📕🔴 Failed to save configuration. Error: {e}",
                      file=current_file, version=current_version, function=current_function, console_print_func=console_log)

    def _reload_config_action(self):
        """
        Handles the action of reloading a mock config from disk.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"📕🟢 Reloading config from mock disk...",
                  file=current_file, version=current_version, function=current_function, console_print_func=console_log)
        
        self._populate_config_table()
        
        console_log("✅ Configuration reloaded from mock disk.")
        debug_log(message=f"📕✅ Reloaded mock config. The map be fresh! 🗺️",
                  file=current_file, version=current_version, function=current_function, console_print_func=console_log)

if __name__ == "__main__":
    root = tk.Tk()
    root.title("Initial Configuration Tab Test")
    
    app_frame = InitialConfigurationTab(master=root)
    
    root.mainloop()

#####################################
### File: OPEN-AIR/display/right_50/bottom_90/4_conductor/gui_mqtt_conductor.py
#####################################
# display/base_gui_component.py
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# This component allows for real-time control and monitoring of MQTT messages,
# offering a centralized "conductor" view of the system's communication.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import json
from collections import defaultdict

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from display.styling.style import THEMES, DEFAULT_THEME

# --- Global Scope Variables ---
CURRENT_DATE = 20251127
CURRENT_TIME = 0
CURRENT_TIME_HASH = 0
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
current_file = f"display/right_40/bottom_90/tab_4_conductor/{os.path.basename(__file__)}"

# --- Constant Variables (No Magic Numbers) ---
SERVER_STATUS_FRAME_TEXT = "Server Status"
PUBLISH_FRAME_TEXT = "Publish Message"
SUBSCRIPTIONS_FRAME_TEXT = "Live Subscriptions"
CLIENTS_FRAME_TEXT = "Connected Clients"
TOPIC_LABEL_TEXT = "Topic:"
SUBTOPIC_LABEL_TEXT = "Subtopic:"
VALUE_LABEL_TEXT = "Value:"
PUBLISH_BUTTON_TEXT = "Publish"
CLEAR_BUTTON_TEXT = "Clear Log"
COLUMNS = ("Topic", "Message")
SERVER_STATUS_TEXT = "Status:"
SERVER_ADDRESS_TEXT = "Broker Address:"
SERVER_VERSION_TEXT = "Version:"
SERVER_UPTIME_TEXT = "Uptime:"
SERVER_MESSAGE_COUNT_TEXT = "Messages:"
CLIENT_COUNT_TEXT = "Clients:"
FILTER_LABEL_TEXT = "Filter Topics:"
STATUS_RUNNING_TEXT = "Running"
STATUS_STOPPED_TEXT = "Stopped"


class MqttConductorFrame(ttk.Frame):
    """
    A comprehensive GUI frame for controlling and monitoring a local MQTT broker.
    It provides a centralized view of broker status, topic activity, and connected clients.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        """
        Initializes the GUI, setting up layout and widgets.
        This version integrates with the main application's MqttControllerUtility.

        Args:
            parent: The parent widget for this frame.
            mqtt_util: A shared instance of MqttControllerUtility.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message=f"🐐🟢 Initializing the '{self.__class__.__name__}' GUI frame. This one's a masterpiece of form over function!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            if 'config' in kwargs:
                kwargs.pop('config')
            super().__init__(parent, *args, **kwargs)
            self.mqtt_util = mqtt_util
            
            self._apply_styles(theme_name=DEFAULT_THEME)
            
            self.topics_in_table = defaultdict(lambda: None)
            self.clients_in_table = set()
            self.purge_confirmation = False

            # FIX: Create widgets first before subscribing to prevent AttributeError.
            self._create_widgets()
            
            # Now subscribe to messages after the widgets exist.
            self.mqtt_util.log_to_table = self.log_to_table
            self.mqtt_util.print_to_gui_func = self.log_to_gui
            self.mqtt_util.add_subscriber(topic_filter="#", callback_func=self._on_message)
            self.mqtt_util.add_subscriber(topic_filter="$SYS/#", callback_func=self._on_sys_message)

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """Applies the specified theme to the GUI elements."""
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])
        style.configure('Custom.Treeview',
                         background=colors["table_bg"],
                         foreground=colors["table_fg"],
                         fieldbackground=colors["table_bg"],
                         bordercolor=colors["table_border"],
                         borderwidth=colors["border_width"])
        style.configure('Custom.Treeview.Heading',
                         background=colors["table_heading_bg"],
                         foreground=colors["fg"],
                         relief=colors["relief"],
                         borderwidth=colors["border_width"])
        style.configure('Custom.TEntry',
                         fieldbackground=colors["entry_bg"],
                         foreground=colors["entry_fg"],
                         bordercolor=colors["table_border"])
        style.configure('TButton', background=colors["accent"], foreground=colors["text"], padding=5)

    def _create_widgets(self):
        """Creates all the UI widgets for the comprehensive conductor tab."""
        top_frame = ttk.Frame(master=self)
        top_frame.pack(side=tk.TOP, pady=10, padx=10, fill=tk.X, expand=False)
        center_frame = ttk.Frame(master=self)
        center_frame.pack(pady=10, padx=10, fill=tk.BOTH, expand=True)
        bottom_frame = ttk.Frame(master=self)
        bottom_frame.pack(side=tk.BOTTOM, pady=10, padx=10, fill=tk.X, expand=False)

        server_status_frame = ttk.LabelFrame(master=top_frame, text=SERVER_STATUS_FRAME_TEXT)
        server_status_frame.pack(side=tk.LEFT, fill=tk.BOTH, padx=5, expand=True)
        self.server_status_label = ttk.Label(master=server_status_frame, text=f"{SERVER_STATUS_TEXT} {STATUS_STOPPED_TEXT}")
        self.server_address_label = ttk.Label(master=server_status_frame, text=f"{SERVER_ADDRESS_TEXT} localhost")
        self.server_version_label = ttk.Label(master=server_status_frame, text=f"{SERVER_VERSION_TEXT} N/A")
        self.server_uptime_label = ttk.Label(master=server_status_frame, text=f"{SERVER_UPTIME_TEXT} N/A")
        self.server_message_count_label = ttk.Label(master=server_status_frame, text=f"{SERVER_MESSAGE_COUNT_TEXT} N/A")
        self.server_client_count_label = ttk.Label(master=server_status_frame, text=f"{CLIENT_COUNT_TEXT} N/A")
        self.server_status_label.pack(anchor=tk.W, padx=5, pady=2)
        self.server_address_label.pack(anchor=tk.W, padx=5, pady=2)
        self.server_version_label.pack(anchor=tk.W, padx=5, pady=2)
        self.server_uptime_label.pack(anchor=tk.W, padx=5, pady=2)
        self.server_message_count_label.pack(anchor=tk.W, padx=5, pady=2)
        self.server_client_count_label.pack(anchor=tk.W, padx=5, pady=2)
        
        server_controls_frame = ttk.Frame(master=top_frame)
        server_controls_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=5, pady=5)
        # --- Bind buttons to the actual utility functions ---
        self.start_btn = ttk.Button(master=server_controls_frame, text="Start Broker", command=lambda: console_log("Mock: Start Broker"))
        self.stop_btn = ttk.Button(master=server_controls_frame, text="Stop Broker", command=lambda: console_log("Mock: Stop Broker"))
        self.check_status_btn = ttk.Button(master=server_controls_frame, text="Check Status", command=self._check_status_request)
        self.start_btn.pack(pady=2, padx=5, fill=tk.X)
        self.stop_btn.pack(pady=2, padx=5, fill=tk.X)
        self.check_status_btn.pack(pady=2, padx=5, fill=tk.X)
        
        # --- NEW: Clear Retained Messages Button ---
        self.clear_retained_btn = ttk.Button(master=server_controls_frame, text="Clear Retained Messages", command=self._clear_retained_messages)
        self.clear_retained_btn.pack(pady=2, padx=5, fill=tk.X)

        publish_frame = ttk.LabelFrame(master=top_frame, text=PUBLISH_FRAME_TEXT)
        publish_frame.pack(side=tk.LEFT, fill=tk.BOTH, padx=5, expand=True)
        tk.Label(master=publish_frame, text=TOPIC_LABEL_TEXT).grid(row=0, column=0, padx=5, pady=5, sticky="e")
        self.topic_entry = ttk.Entry(master=publish_frame, style="Custom.TEntry")
        self.topic_entry.grid(row=0, column=1, columnspan=2, padx=5, pady=5, sticky="ew")
        self.topic_entry.insert(0, f"conductor/test_message")

        tk.Label(master=publish_frame, text=VALUE_LABEL_TEXT).grid(row=1, column=0, padx=5, pady=5, sticky="e")
        self.value_entry = ttk.Entry(master=publish_frame, style="Custom.TEntry")
        self.value_entry.grid(row=1, column=1, columnspan=2, padx=5, pady=5, sticky="ew")
        self.value_entry.insert(0, "Test Payload")

        # --- Bind the publish button to the new _publish_custom_message method ---
        publish_btn = ttk.Button(master=publish_frame, text=PUBLISH_BUTTON_TEXT, command=self._publish_custom_message)
        publish_btn.grid(row=0, column=3, rowspan=2, padx=5, sticky="ew")

        subscriptions_frame = ttk.LabelFrame(master=center_frame, text=SUBSCRIPTIONS_FRAME_TEXT)
        subscriptions_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        self.subscriptions_table = ttk.Treeview(master=subscriptions_frame, columns=COLUMNS, show="headings", style="Custom.Treeview")
        self.subscriptions_table.heading("Topic", text="Topic")
        self.subscriptions_table.heading("Message", text="Message Content")
        self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        table_scrollbar = ttk.Scrollbar(master=subscriptions_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
        self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
        table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        bottom_btn_frame = ttk.Frame(master=bottom_frame)
        bottom_btn_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=5, pady=5)
        self.log_btn = ttk.Button(master=bottom_btn_frame, text="Log", command=lambda: console_log("A sample log message from the Conductor."))
        self.debug_btn = ttk.Button(master=bottom_btn_frame, text="Debug", command=lambda: debug_log(message="A sample debug message.", file=current_file, version=current_version, function="_create_widgets", console_print_func=console_log))
        self.purge_mqtt_btn = ttk.Button(master=bottom_btn_frame, text="Purge OPEN-AIR MQTT", command=self._on_purge_button_clicked)
        self.clear_btn = ttk.Button(master=bottom_btn_frame, text=CLEAR_BUTTON_TEXT, command=self._clear_log)
        self.log_btn.pack(side=tk.LEFT, padx=5, pady=5)
        self.debug_btn.pack(side=tk.LEFT, padx=5, pady=5)
        self.purge_mqtt_btn.pack(side=tk.LEFT, padx=5, pady=5)
        self.clear_btn.pack(side=tk.RIGHT, padx=5, pady=5)
    
    def _on_purge_button_clicked(self):
        if not self.purge_confirmation:
            self.purge_confirmation = True
            self.purge_mqtt_btn.config(text="Are you sure? Purge OPEN-AIR.")
            self.after(5000, self._reset_purge_button_state)
        else:
            console_log("🔥 Purging all 'OPEN-AIR' MQTT topics...")
            try:
                self.mqtt_util.purge_branch('OPEN-AIR')
                console_log("✅ Purge command sent successfully.")
            except Exception as e:
                console_log(f"❌ Failed to send purge command: {e}")
            finally:
                self._reset_purge_button_state()

    def _reset_purge_button_state(self):
        self.purge_confirmation = False
        if self.purge_mqtt_btn.winfo_exists():
            self.purge_mqtt_btn.config(text="Purge OPEN-AIR MQTT")

    def log_to_gui(self, message):
        """Allows the utility to log messages to the console."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🐐🔵 Entering '{current_function_name}' to print a message to the GUI console.",
            file=current_file,
            version=current_version,
            function=current_function_name,
            console_print_func=console_log
        )
        try:
            # The console_log function already exists globally.
            console_log(message)
            
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=current_function_name,
                console_print_func=console_log
            )
            
    def log_to_table(self, topic: str, message: str):
        """Allows the utility to log messages to the table."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
    #   debug_log(
    #        message=f"🐐🔵 Entering '{current_function_name}' to add a message to the table.",
    #        file=current_file,
    #        version=current_version,
    #        function=current_function_name,
    #        console_print_func=console_log
    #    )
        try:
            self.subscriptions_table.insert('', 'end', values=(topic, message))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=current_function_name,
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        """Publishes the message from the GUI's text boxes."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        #debug_log(
        #    message=f"🐐🟢 Entering '{current_function_name}' to publish a custom message.",
        #    file=current_file,
        #    version=current_version,
        #    function=current_function_name,
        #    console_print_func=console_log
        #)
        try:
            topic = self.topic_entry.get()
            value = self.value_entry.get()
            if not topic or not value:
                console_log("❌ Please enter a topic and a value.")
                return

            self.mqtt_util.publish_message(topic=topic, subtopic="", value=value)
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=current_function_name,
                console_print_func=console_log
            )

    def _clear_log(self):
        """Clears the contents of the subscriptions table."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🐐🟢 Entering '{current_function_name}' to clear the log.",
            file=current_file,
            version=current_version,
            function=current_function_name,
            console_print_func=console_log
        )
        try:
            self.subscriptions_table.delete(*self.subscriptions_table.get_children())

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=current_function_name,
                console_print_func=console_log
            )

    def _on_message(self, topic, payload):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
    #   debug_log(
    #        message=f"🐐🔵 Entering '{current_function_name}' to process a general MQTT message.",
    #        file=current_file,
    #        version=current_version,
    #        function=current_function_name,
    #        console_print_func=console_log
    #    )
        try:
            self.log_to_table(topic=topic, message=payload)

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=current_function_name,
                console_print_func=console_log
            )

    def _on_sys_message(self, topic, payload):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
       # debug_log(
       #     message=f"🔵 Entering '{current_function_name}' to process a system status message.",
       #     file=current_file,
       #     version=current_version,
       #     function=current_function_name,
       #     console_print_func=console_log
       # )
        try:
            if "$SYS/broker/version" in topic:
                self.server_version_label.config(text=f"{SERVER_VERSION_TEXT} {payload}")
            elif "$SYS/broker/uptime" in topic:
                self.server_uptime_label.config(text=f"{SERVER_UPTIME_TEXT} {payload}")
            elif "$SYS/broker/messages/sent" in topic:
                self.server_message_count_label.config(text=f"{SERVER_MESSAGE_COUNT_TEXT} {payload}")
            elif "$SYS/broker/clients/connected" in topic:
                self.server_client_count_label.config(text=f"{CLIENT_COUNT_TEXT} {payload}")
            
            self.server_status_label.config(text=f"{SERVER_STATUS_TEXT} {STATUS_RUNNING_TEXT}")
            
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=current_function_name,
                console_print_func=console_log
            )

    def _check_status_request(self):
        """
        Manually triggers a request for system information from the broker.
        """
        self.mqtt_util.publish_message(topic="$SYS/broker/version", subtopic="", value="", retain=False)
        self.mqtt_util.publish_message(topic="$SYS/broker/uptime", subtopic="", value="", retain=False)
        self.mqtt_util.publish_message(topic="$SYS/broker/messages/sent", subtopic="", value="", retain=False)
        self.mqtt_util.publish_message(topic="$SYS/broker/clients/connected", subtopic="", value="", retain=False)

    def _clear_retained_messages(self):
        """
        Shuts down the Mosquitto broker and clears its persistence file to remove all retained messages.
        This function needs to be implemented within the MQTT utility class.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🐐🟢 Initiating command to clear all retained MQTT messages.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        console_log("🟡 Clearing retained messages by stopping the broker and deleting the persistence file...")
        try:
            self.mqtt_util.clear_retained_messages()
            console_log("✅ Retained messages successfully cleared!")
        except Exception as e:
            console_log(f"❌ Failed to clear retained messages: {e}")
            debug_log(
                message=f"❌🔴 Avast! The clearing protocol has failed! Error: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

#####################################
### File: OPEN-AIR/display/right_50/top_10/gui_start_pause_stop.py
#####################################
MQTT_TOPIC_FILTER = "OPEN-AIR/dataset/Orchestration"










# display_gui_child_pusher.py

#
# A GUI frame that uses the DynamicGuiBuilder to create widgets for frequency settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect
import tkinter as tk
from tkinter import ttk

# --- Module Imports ---
from workers.builder.dynamic_gui_builder import DynamicGuiBuilder
from display.logger import debug_log, console_log, log_visa_command
import pathlib

# --- Global Scope Variables ---
current_version = "20251213.000000.1" # Updated version based on current date
current_version_hash = (20251213 * 0 * 1) # Updated hash
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\\\", "/")


class StartPauseStopGui(ttk.Frame):
    """
    A GUI component for Start/Pause/Stop functionality, instantiating DynamicGuiBuilder.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        """
        Initializes the Frequency frame and the dynamic GUI builder.
        """
        if 'config' in kwargs:
            kwargs.pop('config')
        super().__init__(parent, *args, **kwargs)

        # --- Dynamic GUI Builder ---
        current_function_name = "__init__"
        debug_log(
            message=f"🛠️🟢 Entering {current_function_name} to initialize the StartPauseStopGui.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            config = {
                "base_topic": MQTT_TOPIC_FILTER,
                "log_to_gui_console": console_log,
                "log_to_gui_treeview": None  # Assuming no treeview for this component
            }

            self.dynamic_gui = DynamicGuiBuilder(
                parent=self,
                mqtt_util=mqtt_util,
                config=config
            )
            console_log("✅ Celebration of success! The StartPauseStopGui did initialize its dynamic GUI builder.")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

#####################################
### File: OPEN-AIR/display/styling/style.py
#####################################
# display/styling/style.py
#
# Defines the color palettes for different UI themes, providing a centralized
# source for application-wide style configurations.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import copy
import tkinter as tk
from tkinter import ttk

# --- Global Scope Variables ---
current_version = "20251127.000000.1"
current_version_hash = (20251127 * 0 * 1)
current_file = f"{os.path.basename(__file__)}"

# The default theme to use. This can be changed here to easily switch the entire application's style.
DEFAULT_THEME = "dark"

# THEMES is a dictionary that holds all our color palettes.
THEMES = {
    # The "dark" theme, inspired by dark IDE color schemes.
    "dark": {
        "bg": "#2b2b2b",
        "fg": "#dcdcdc",
        "fg_alt": "#888888",
        "primary": "#3c3f41",
        "secondary": "#4e5254",
        "accent": "#f4902c",
        "hover_blue": "#4169E1",
        "text": "#ffffff",
        "border": "#555555",
        "relief": "solid",
        "border_width": 0,
        "padding": 1,
        "tab_content_padding": 1,
        # --- Styling Variables for Tables and Entries ---
        "table_bg": "#3c3f41",
        "table_fg": "#dcdcdc",
        "table_heading_bg": "#4e5254",
        "table_border": "#555555",
        "entry_bg": "#4e5254",
        "entry_fg": "#dcdcdc",
        # ----------------------------------------------------
        "textbox_style": {
            "Textbox_Font": "Segoe UI",
            "Textbox_Font_size": 13,
            "Textbox_Font_colour": "#ffffff",
            "Textbox_border_colour": "#555555",
            "Textbox_BG_colour": "#4e5254"
        },
        "button_base_style": {
            "borderwidth": 2,
            "relief": "raised",
            "padding": [10, 5],
            "font": ("Helvetica", 13, "bold"),
            "highlightcolor": "#ffffff",
            "highlightbackground": "#555555",
            "highlightthickness": 2,
        },
        "button_style_actuator": {
            "background": "#4e5254",
            "foreground": "#ffffff",
            "Button_Hover_Bg": "#4169E1",
            "Button_Pressed_Bg": "#f4902c",
            "Button_Disabled_Bg": "#888888",
            "Button_Disabled_Fg": "#dcdcdc",
        },
        "button_style_toggle": {
            "background": "#4e5254",
            "foreground": "#ffffff",
            "Button_Hover_Bg": "#4169E1",
            "Button_Pressed_Bg": "#f4902c",
            "Button_Selected_Bg": "#f4902c",
            "Button_Selected_Fg": "#ffffff",
            "Button_Disabled_Bg": "#888888",
            "Button_Disabled_Fg": "#dcdcdc",
        },
        "button_style_toggler": {
            "background": "#4e5254",
            "foreground": "#ffffff",
            "Button_Hover_Bg": "#4169E1",
            "Button_Pressed_Bg": "#f4902c",
            "Button_Selected_Bg": "#ae00ff",
            "Button_Selected_Fg": "#ffffff",
            "Button_Disabled_Bg": "#888888",
            "Button_Disabled_Fg": "#dcdcdc",
        },
        "tab_style": {
            "tab_base_style": {
                "background": "#3c3f41",
                "foreground": "#6d6d6d",
                "font": ("Helvetica", 13, "bold"),
                "padding": [10, 5],
                "borderwidth": 0,
                "relief": "flat",
                "highlightcolor": "#a5a5a5",
                "highlightbackground": "#555555",
                "highlightthickness": 0,
            },
            "tab_styles": [
                "Accent.TNotebook.Tab1",
                "Accent.TNotebook.Tab2",
                "Accent.TNotebook.Tab3",
                "Accent.TNotebook.Tab4",
                "Accent.TNotebook.Tab5",
                "Accent.TNotebook.Tab6",
                "Accent.TNotebook.Tab7",
                "Accent.TNotebook.Tab8",
                "Accent.TNotebook.Tab9",
                "Accent.TNotebook.Tab10",
            ]
        },
        "accent_colors": [
            "#996633",  # 1. Brown
            "#c75450",  # 2. Red
            "#d18616",  # 3. Orange
            "#dcdcaa",  # 4. Yellow
            "#6a9955",  # 5. Green
            "#007acc",  # 6. Blue
            "#6464a3",  # 7. Violet
            "#ce9178",  # 8. Tan
            "#b5cea8",  # 9. Gray-Green
            "#7d7d7d",  # 10. Gray
        ]
    },
    # The "light" theme, providing a high-contrast alternative.
    "light": {
        "bg": "#f0f0f0",
        "fg": "#000000",
        "fg_alt": "#555555",
        "primary": "#ffffff",
        "secondary": "#e0e0e0",
        "accent": "#0078d7",
        "hover_blue": "#4169E1",
        "text": "#000000",
        "border": "#ababab",
        "relief": "groove",
        "border_width": 0,
        "padding": 1,
        "tab_content_padding": 1,
        # --- Styling Variables for Tables and Entries ---
        "table_bg": "#ffffff",
        "table_fg": "#000000",
        "table_heading_bg": "#e0e0e0",
        "table_border": "#ababab",
        "entry_bg": "#ffffff",
        "entry_fg": "#000000",
        # ----------------------------------------------------
        "textbox_style": {
            "Textbox_Font": "Segoe UI",
            "Textbox_Font_size": 13,
            "Textbox_Font_colour": "#000000",
            "Textbox_border_colour": "#ababab",
            "Textbox_BG_colour": "#ffffff"
        },
        "button_base_style": {
            "borderwidth": 2,
            "relief": "raised",
            "padding": [10, 5],
            "background": "#e0e0e0",
            "foreground": "#000000",
            "font": ("Helvetica", 13, "bold"),
            "highlightcolor": "#000000",
            "highlightbackground": "#e0e0e0",
            "highlightthickness": 2,
        },
        "button_style": {
            "Button_Normal_Bg": "#e0e0e0",
            "Button_Normal_Fg": "#000000",
            "Button_Hover_Bg": "#4169E1",
            "Button_Pressed_Bg": "#0078d7",
            "Button_Selected_Bg": "#0078d7",
            "Button_Selected_Fg": "#ffffff",
            "Button_Disabled_Bg": "#ababab",
            "Button_Disabled_Fg": "#555555"
        },
        "button_style_actuator": {
            "background": "#e0e0e0",
            "foreground": "#000000",
            "pressed_bg": "#0078d7",
            "hover_bg": "#4169E1",
            "disabled_bg": "#ababab",
            "disabled_fg": "#555555",
        },
        "button_style_toggle": {
            "background": "#e0e0e0",
            "foreground": "#000000",
            "pressed_bg": "#0078d7",
            "hover_bg": "#4169E1",
            "selected_bg": "#0078d7",
            "selected_fg": "#ffffff",
            "disabled_bg": "#ababab",
            "disabled_fg": "#555555",
        },
        "button_style_toggler": {
            "background": "#e0e0e0",
            "foreground": "#000000",
            "pressed_bg": "#0078d7",
            "hover_bg": "#4169E1",
            "selected_bg": "#0078d7",
            "selected_fg": "#ffffff",
            "disabled_bg": "#ababab",
            "disabled_fg": "#555555",
        },
        "tab_style": {
            "tab_base_style": {
                "background": "#f0f0f0",
                "foreground": "#000000",
                "font": ("Helvetica", 13, "bold"),
                "padding": [10, 5],
                "borderwidth": 0,
                "relief": "flat",
                "highlightcolor": "#000000",
                "highlightbackground": "#e0e0e0",
                "highlightthickness": 0,
            },
            "tab_styles": [
                "Accent.TNotebook.Tab1",
                "Accent.TNotebook.Tab2",
                "Accent.TNotebook.Tab3",
                "Accent.TNotebook.Tab4",
                "Accent.TNotebook.Tab5",
                "Accent.TNotebook.Tab6",
                "Accent.TNotebook.Tab7",
                "Accent.TNotebook.Tab8",
                "Accent.TNotebook.Tab9",
                "Accent.TNotebook.Tab10",
            ]
        },
        "accent_colors": [
            "#A0522D",  # 1. Brown (Sienna)
            "#D22B2B",  # 2. Red (Firebrick)
            "#FF8C00",  # 3. Orange (DarkOrange)
            "#FFD700",  # 4. Yellow (Gold)
            "#228B22",  # 5. Green (ForestGreen)
            "#4169E1",  # 6. Blue (RoyalBlue)
            "#8A2BE2",  # 7. Violet (BlueViolet)
            "#D2691E",  # 8. Tan (Chocolate)
            "#556B2F",  # 9. Gray-Green (DarkOliveGreen)
            "#7d7d7d",  # 10. Gray
        ]
    }
}

#####################################
### File: OPEN-AIR/display/left_50/top_100/7_meta_Data/1_meta_data/gui_meta_data.py
#####################################
MQTT_TOPIC_FILTER = "OPEN-AIR/configuration/report"









# display/left_50/top_100/tab_1_instrument/sub_tab_2_settings/sub_tab_1_frequency/gui_frequency_1.py
#
# A GUI frame that uses the DynamicGuiBuilder to create widgets for frequency settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect
import tkinter as tk
from tkinter import ttk

# --- Module Imports ---
from workers.builder.dynamic_gui_builder import DynamicGuiBuilder
from display.logger import debug_log, console_log, log_visa_command
import pathlib

# --- Global Scope Variables ---
current_version = "20251127.000000.1"
current_version_hash = (20251127 * 0 * 1)
current_file = f"{os.path.basename(__file__)}"


class PresetPusherGui(ttk.Frame):
    """
    A container frame that instantiates the DynamicGuiBuilder for the Frequency configuration.
    """
    def __init__(self, parent, mqtt_util, config=None, *args, **kwargs):
        """
        Initializes the Frequency frame and the dynamic GUI builder.
        """
        if 'config' in kwargs:
            kwargs.pop('config')
        super().__init__(parent, *args, **kwargs)
        self.pack(fill=tk.BOTH, expand=True)

        # --- Dynamic GUI Builder ---
        current_function_name = "__init__"
        debug_log(
            message=f"🛠️🟢 Entering {current_function_name} to initialize the PresetPusherGui.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            config = {
                "base_topic": MQTT_TOPIC_FILTER,
                "log_to_gui_console": console_log,
                "log_to_gui_treeview": None  # Assuming no treeview for this component
            }

            self.dynamic_gui = DynamicGuiBuilder(
                parent=self,
                mqtt_util=mqtt_util,
                config=config
            )
            console_log("✅ Celebration of success! The PresetPusherGui did initialize its dynamic GUI builder.")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

#####################################
### File: OPEN-AIR/display/left_50/top_100/7_meta_Data/2_wireless_components/gui_wireless_components.py
#####################################
MQTT_TOPIC_FILTER = "OPEN-AIR/meta/components"

# display/left_50/top_100/7_meta_Data/2_wireless_components/gui_wireless_components.py
#
# This file (gui_wireless_components.py) provides the GUI component for displaying MQTT data in a table related to wireless components and exporting it.
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 44 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
from tkinter import filedialog

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from workers.exporters.worker_file_csv_export import CsvExportUtility
from workers.mqtt.worker_mqtt_data_flattening import MqttDataFlattenerUtility
from display.styling.style import THEMES, DEFAULT_THEME


Local_Debug_Enable = True





# --- Global Scope Variables ---
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("/", "/")

# --- No Magic Numbers (as per your instructions) ---


class InstrumentTranslatorGUI(ttk.Frame):
    """
    A GUI component for displaying MQTT data in a table and exporting it.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        """
        Initializes the GUI, sets up the layout, and subscribes to the MQTT topic.
        
        Args:
            parent (tk.Widget): The parent widget for this frame.
            mqtt_util (MqttControllerUtility): The MQTT utility instance for communication.
        """
        current_function_name = inspect.currentframe().f_code.co_name

        if Local_Debug_Enable:
            debug_log(
                message=f"🖥️🟢 Initializing the {self.__class__.__name__}.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

        try:
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash
            self.mqtt_util = mqtt_util
            self.csv_export_util = CsvExportUtility(print_to_gui_func=console_log)
            self.data_flattener = MqttDataFlattenerUtility(print_to_gui_func=console_log)
            self.current_class_name = self.__class__.__name__

            self._apply_styles(theme_name=DEFAULT_THEME)

            # --- MQTT Topic Entry Section ---
            topic_frame = ttk.LabelFrame(self, text="MQTT Topic Filter")
            topic_frame.pack(fill=tk.X, padx=10, pady=5)
            self.topic_entry = ttk.Entry(topic_frame, width=80)
            self.topic_entry.insert(0, MQTT_TOPIC_FILTER)
            self.topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            # --- MQTT Message Log Table ---
            self.table_frame = ttk.Frame(self)
            self.table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

            horizontal_scrollbar = ttk.Scrollbar(self.table_frame, orient=tk.HORIZONTAL)
            self.commands_table = ttk.Treeview(self.table_frame, xscrollcommand=horizontal_scrollbar.set, show="headings", style="Custom.Treeview")
            horizontal_scrollbar.config(command=self.commands_table.xview)
            
            vertical_scrollbar = ttk.Scrollbar(self.table_frame, orient=tk.VERTICAL, command=self.commands_table.yview)
            self.commands_table.config(yscrollcommand=vertical_scrollbar.set)

            horizontal_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)
            vertical_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            self.commands_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            self.mqtt_util.add_subscriber(topic_filter=f"{self.topic_entry.get()}/#", callback_func=self._on_commands_message)

            # --- File Controls Section ---
            file_frame = ttk.LabelFrame(self, text="File")
            file_frame.pack(fill=tk.X, padx=10, pady=5)
           
            # Button: Export to CSV
            self.export_button = ttk.Button(
                file_frame,
                text="Export to CSV",
                command=self._export_table_data
            )
            self.export_button.pack(side=tk.LEFT, padx=5, pady=5)


            # --- Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)

            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Instrument Translator GUI initialized successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                    file=self.current_file,
                    version=self.current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
    
    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")

        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])
        style.configure('TButton', background=colors["accent"], foreground=colors["text"], padding=colors["padding"] * 5, relief=colors["relief"], borderwidth=colors["border_width"] * 2)
        style.map('TButton', background=[('active', colors["secondary"])])
        
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

    def _on_commands_message(self, topic, payload):
        """
        Callback for when an MQTT message is received on the commands topic. 
        It processes the message, flattens the data, and updates or adds rows to the table.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        if Local_Debug_Enable:
            debug_log(
                message=f"🖥️🔵 Received MQTT message on topic '{topic}'. Processing message...",
                file=self.current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
        
        try:
            pivoted_rows = self.data_flattener.process_mqtt_message_and_pivot(
                topic=topic,
                payload=payload,
                topic_prefix=self.topic_entry.get()
            )

            if pivoted_rows:
                # Dynamically configure columns ONLY IF this is the first data payload.
                if not self.commands_table["columns"]:
                    new_headers = list(pivoted_rows[0].keys())
                    self.commands_table["columns"] = tuple(new_headers)
                    for col in new_headers:
                        self.commands_table.heading(col, text=col.replace("_", " ").title())
                        self.commands_table.column(col, width=150, stretch=True)

                # Iterate through each row of the new data to update or add
                for row in pivoted_rows:
                    parameter_path = row.get("Parameter")
                    
                    # Find if a row with this Parameter already exists
                    item_id_to_update = None
                    for item_id in self.commands_table.get_children():
                        row_values = self.commands_table.item(item_id, 'values')
                        if row_values and row_values[0] == parameter_path:
                            item_id_to_update = item_id
                            break
                    
                    if item_id_to_update:
                        # Update the existing row
                        new_values = [row.get(col, '') for col in self.commands_table["columns"]]
                        self.commands_table.item(item_id_to_update, values=new_values)
                        console_log(f"✅ Updated existing row for '{parameter_path}'.")
                    else:
                        # Insert a new row if it doesn't exist
                        new_values = [row.get(col, '') for col in self.commands_table["columns"]]
                        self.commands_table.insert('', tk.END, values=new_values)
                        console_log(f"✅ Added new row for '{parameter_path}'.")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 The data table construction has failed! A plague upon this error: {e}",
                    file=self.current_file,
                    version=self.current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

    def _export_table_data(self):
        """
        Opens a file dialog and exports the current data from the table to a CSV file.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        if Local_Debug_Enable:
            debug_log(
                message=f"🖥️🔵 Preparing to export table data to CSV.",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

        try:
            file_path = filedialog.asksaveasfilename(
                initialdir=os.getcwd(),
                title="Save Table Data as CSV",
                filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
                defaultextension=".csv"
            )
            
            if file_path:
                data = []
                headers = self.commands_table["columns"]
                for item_id in self.commands_table.get_children():
                    row_values = self.commands_table.item(item_id, 'values')
                    row_dict = dict(zip(headers, row_values))
                    data.append(row_dict)
                    
                self.csv_export_util.export_data_to_csv(data=data, file_path=file_path)
                console_log(f"✅ Data successfully exported to {file_path}!")
            else:
                console_log("🟡 CSV export canceled by user.")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                    file=self.current_file,
                    version=self.current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )


#####################################
### File: OPEN-AIR/display/left_50/top_100/7_meta_Data/3_Amplifiers and Antenna/gui_meta_devices_amplifier.py
#####################################
MQTT_TOPIC_FILTER = "OPEN-AIR/meta/components/amplifier"

# display/gui_marker_editor.py
#
# A GUI component for editing markers, designed to handle both full data sets
# and single-value updates intelligently via MQTT.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
from tkinter import filedialog

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from workers.exporters.worker_file_csv_export import CsvExportUtility
from workers.mqtt.worker_mqtt_data_flattening import MqttDataFlattenerUtility
from display.styling.style import THEMES, DEFAULT_THEME


Local_Debug_Enable = True





# --- Global Scope Variables ---
CURRENT_DATE = 20251127
CURRENT_TIME = 0
REVISION_NUMBER = 1
current_version = "20251127.000000.1"
current_version_hash = 20251127 * 0 * 1
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")

# --- No Magic Numbers (as per your instructions) ---


class InstrumentTranslatorGUI(ttk.Frame):
    """
    A GUI component for displaying MQTT data in a table and exporting it.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        """
        Initializes the GUI, sets up the layout, and subscribes to the MQTT topic.
        
        Args:
            parent (tk.Widget): The parent widget for this frame.
            mqtt_util (MqttControllerUtility): The MQTT utility instance for communication.
        """
        current_function_name = inspect.currentframe().f_code.co_name

        if Local_Debug_Enable:
            debug_log(
                message=f"🖥️🟢 Initializing the {self.__class__.__name__}.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

        try:
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash
            self.mqtt_util = mqtt_util
            self.csv_export_util = CsvExportUtility(print_to_gui_func=console_log)
            self.data_flattener = MqttDataFlattenerUtility(print_to_gui_func=console_log)
            self.current_class_name = self.__class__.__name__

            self._apply_styles(theme_name=DEFAULT_THEME)

            # --- MQTT Topic Entry Section ---
            topic_frame = ttk.LabelFrame(self, text="MQTT Topic Filter")
            topic_frame.pack(fill=tk.X, padx=10, pady=5)
            self.topic_entry = ttk.Entry(topic_frame, width=80)
            self.topic_entry.insert(0, MQTT_TOPIC_FILTER)
            self.topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            # --- MQTT Message Log Table ---
            self.table_frame = ttk.Frame(self)
            self.table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

            horizontal_scrollbar = ttk.Scrollbar(self.table_frame, orient=tk.HORIZONTAL)
            self.commands_table = ttk.Treeview(self.table_frame, xscrollcommand=horizontal_scrollbar.set, show="headings", style="Custom.Treeview")
            horizontal_scrollbar.config(command=self.commands_table.xview)
            
            vertical_scrollbar = ttk.Scrollbar(self.table_frame, orient=tk.VERTICAL, command=self.commands_table.yview)
            self.commands_table.config(yscrollcommand=vertical_scrollbar.set)

            horizontal_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)
            vertical_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            self.commands_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            self.mqtt_util.add_subscriber(topic_filter=f"{self.topic_entry.get()}/#", callback_func=self._on_commands_message)

            # --- File Controls Section ---
            file_frame = ttk.LabelFrame(self, text="File")
            file_frame.pack(fill=tk.X, padx=10, pady=5)
           
            # Button: Export to CSV
            self.export_button = ttk.Button(
                file_frame,
                text="Export to CSV",
                command=self._export_table_data
            )
            self.export_button.pack(side=tk.LEFT, padx=5, pady=5)


            # --- Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)

            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Instrument Translator GUI initialized successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                    file=self.current_file,
                    version=self.current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
    
    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")

        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])
        style.configure('TButton', background=colors["accent"], foreground=colors["text"], padding=colors["padding"] * 5, relief=colors["relief"], borderwidth=colors["border_width"] * 2)
        style.map('TButton', background=[('active', colors["secondary"])])
        
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

    def _on_commands_message(self, topic, payload):
        """
        Callback for when an MQTT message is received on the commands topic. 
        It processes the message, flattens the data, and updates or adds rows to the table.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        if Local_Debug_Enable:
            debug_log(
                message=f"🖥️🔵 Received MQTT message on topic '{topic}'. Processing message...",
                file=self.current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
        
        try:
            pivoted_rows = self.data_flattener.process_mqtt_message_and_pivot(
                topic=topic,
                payload=payload,
                topic_prefix=self.topic_entry.get()
            )

            if pivoted_rows:
                # Dynamically configure columns ONLY IF this is the first data payload.
                if not self.commands_table["columns"]:
                    new_headers = list(pivoted_rows[0].keys())
                    self.commands_table["columns"] = tuple(new_headers)
                    for col in new_headers:
                        self.commands_table.heading(col, text=col.replace("_", " ").title())
                        self.commands_table.column(col, width=150, stretch=True)

                # Iterate through each row of the new data to update or add
                for row in pivoted_rows:
                    parameter_path = row.get("Parameter")
                    
                    # Find if a row with this Parameter already exists
                    item_id_to_update = None
                    for item_id in self.commands_table.get_children():
                        row_values = self.commands_table.item(item_id, 'values')
                        if row_values and row_values[0] == parameter_path:
                            item_id_to_update = item_id
                            break
                    
                    if item_id_to_update:
                        # Update the existing row
                        new_values = [row.get(col, '') for col in self.commands_table["columns"]]
                        self.commands_table.item(item_id_to_update, values=new_values)
                        console_log(f"✅ Updated existing row for '{parameter_path}'.")
                    else:
                        # Insert a new row if it doesn't exist
                        new_values = [row.get(col, '') for col in self.commands_table["columns"]]
                        self.commands_table.insert('', tk.END, values=new_values)
                        console_log(f"✅ Added new row for '{parameter_path}'.")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 The data table construction has failed! A plague upon this error: {e}",
                    file=self.current_file,
                    version=self.current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

    def _export_table_data(self):
        """
        Opens a file dialog and exports the current data from the table to a CSV file.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        if Local_Debug_Enable:
            debug_log(
                message=f"🖥️🔵 Preparing to export table data to CSV.",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

        try:
            file_path = filedialog.asksaveasfilename(
                initialdir=os.getcwd(),
                title="Save Table Data as CSV",
                filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
                defaultextension=".csv"
            )
            
            if file_path:
                data = []
                headers = self.commands_table["columns"]
                for item_id in self.commands_table.get_children():
                    row_values = self.commands_table.item(item_id, 'values')
                    row_dict = dict(zip(headers, row_values))
                    data.append(row_dict)
                    
                self.csv_export_util.export_data_to_csv(data=data, file_path=file_path)
                console_log(f"✅ Data successfully exported to {file_path}!")
            else:
                console_log("🟡 CSV export canceled by user.")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                    file=self.current_file,
                    version=self.current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

#####################################
### File: OPEN-AIR/display/left_50/top_100/7_meta_Data/3_Amplifiers and Antenna/gui_meta_devices_antenna.py
#####################################
MQTT_TOPIC_FILTER = "OPEN-AIR/meta/components/antenna"

# display/left_50/top_100/7_meta_Data/3_Amplifiers and Antenna/gui_meta_devices_antenna.py
#
# This file (gui_meta_devices_antenna.py) provides the GUI component for displaying MQTT data related to antenna information in a table and exporting it.
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 44 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
from tkinter import filedialog

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from workers.exporters.worker_file_csv_export import CsvExportUtility
from workers.mqtt.worker_mqtt_data_flattening import MqttDataFlattenerUtility
from display.styling.style import THEMES, DEFAULT_THEME


Local_Debug_Enable = True





# --- Global Scope Variables ---
CURRENT_DATE = 20251127
CURRENT_TIME = 0
REVISION_NUMBER = 1
current_version = "20251127.000000.1"
current_version_hash = 20251127 * 0 * 1
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("/", "/")

# --- No Magic Numbers (as per your instructions) ---


class InstrumentTranslatorGUI(ttk.Frame):
    """
    A GUI component for displaying MQTT data in a table and exporting it.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        """
        Initializes the GUI, sets up the layout, and subscribes to the MQTT topic.
        
        Args:
            parent (tk.Widget): The parent widget for this frame.
            mqtt_util (MqttControllerUtility): The MQTT utility instance for communication.
        """
        current_function_name = inspect.currentframe().f_code.co_name

        if Local_Debug_Enable:
            debug_log(
                message=f"🖥️🟢 Initializing the {self.__class__.__name__}.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

        try:
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash
            self.mqtt_util = mqtt_util
            self.csv_export_util = CsvExportUtility(print_to_gui_func=console_log)
            self.data_flattener = MqttDataFlattenerUtility(print_to_gui_func=console_log)
            self.current_class_name = self.__class__.__name__

            self._apply_styles(theme_name=DEFAULT_THEME)

            # --- MQTT Topic Entry Section ---
            topic_frame = ttk.LabelFrame(self, text="MQTT Topic Filter")
            topic_frame.pack(fill=tk.X, padx=10, pady=5)
            self.topic_entry = ttk.Entry(topic_frame, width=80)
            self.topic_entry.insert(0, MQTT_TOPIC_FILTER)
            self.topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            # --- MQTT Message Log Table ---
            self.table_frame = ttk.Frame(self)
            self.table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

            horizontal_scrollbar = ttk.Scrollbar(self.table_frame, orient=tk.HORIZONTAL)
            self.commands_table = ttk.Treeview(self.table_frame, xscrollcommand=horizontal_scrollbar.set, show="headings", style="Custom.Treeview")
            horizontal_scrollbar.config(command=self.commands_table.xview)
            
            vertical_scrollbar = ttk.Scrollbar(self.table_frame, orient=tk.VERTICAL, command=self.commands_table.yview)
            self.commands_table.config(yscrollcommand=vertical_scrollbar.set)

            horizontal_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)
            vertical_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            self.commands_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            self.mqtt_util.add_subscriber(topic_filter=f"{self.topic_entry.get()}/#", callback_func=self._on_commands_message)

            # --- File Controls Section ---
            file_frame = ttk.LabelFrame(self, text="File")
            file_frame.pack(fill=tk.X, padx=10, pady=5)
           
            # Button: Export to CSV
            self.export_button = ttk.Button(
                file_frame,
                text="Export to CSV",
                command=self._export_table_data
            )
            self.export_button.pack(side=tk.LEFT, padx=5, pady=5)


            # --- Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)

            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                    file=self.current_file,
                    version=self.current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
    
    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")

        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])
        style.configure('TButton', background=colors["accent"], foreground=colors["text"], padding=colors["padding"] * 5, relief=colors["relief"], borderwidth=colors["border_width"] * 2)
        style.map('TButton', background=[('active', colors["secondary"])])
        
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

    def _on_commands_message(self, topic, payload):
        """
        Callback for when an MQTT message is received on the commands topic. 
        It processes the message, flattens the data, and updates or adds rows to the table.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        if Local_Debug_Enable:
            debug_log(
                message=f"🖥️🔵 Received MQTT message on topic '{topic}'. Processing message...",
                file=self.current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
        
        try:
            pivoted_rows = self.data_flattener.process_mqtt_message_and_pivot(
                topic=topic,
                payload=payload,
                topic_prefix=self.topic_entry.get()
            )

            if pivoted_rows:
                # Dynamically configure columns ONLY IF this is the first data payload.
                if not self.commands_table["columns"]:
                    new_headers = list(pivoted_rows[0].keys())
                    self.commands_table["columns"] = tuple(new_headers)
                    for col in new_headers:
                        self.commands_table.heading(col, text=col.replace("_", " ").title())
                        self.commands_table.column(col, width=150, stretch=True)

                # Iterate through each row of the new data to update or add
                for row in pivoted_rows:
                    parameter_path = row.get("Parameter")
                    
                    # Find if a row with this Parameter already exists
                    item_id_to_update = None
                    for item_id in self.commands_table.get_children():
                        row_values = self.commands_table.item(item_id, 'values')
                        if row_values and row_values[0] == parameter_path:
                            item_id_to_update = item_id
                            break
                    
                    if item_id_to_update:
                        # Update the existing row
                        new_values = [row.get(col, '') for col in self.commands_table["columns"]]
                        self.commands_table.item(item_id_to_update, values=new_values)
                        console_log(f"✅ Updated existing row for '{parameter_path}'.")
                    else:
                        # Insert a new row if it doesn't exist
                        new_values = [row.get(col, '') for col in self.commands_table["columns"]]
                        self.commands_table.insert('', tk.END, values=new_values)
                        console_log(f"✅ Added new row for '{parameter_path}'.")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 The data table construction has failed! A plague upon this error: {e}",
                    file=self.current_file,
                    version=self.current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

    def _export_table_data(self):
        """
        Opens a file dialog and exports the current data from the table to a CSV file.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        if Local_Debug_Enable:
            debug_log(
                message=f"🖥️🔵 Preparing to export table data to CSV.",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

        try:
            file_path = filedialog.asksaveasfilename(
                initialdir=os.getcwd(),
                title="Save Table Data as CSV",
                filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
                defaultextension=".csv"
            )
            
            if file_path:
                data = []
                headers = self.commands_table["columns"]
                for item_id in self.commands_table.get_children():
                    row_values = self.commands_table.item(item_id, 'values')
                    row_dict = dict(zip(headers, row_values))
                    data.append(row_dict)
                    
                self.csv_export_util.export_data_to_csv(data=data, file_path=file_path)
                console_log(f"✅ Data successfully exported to {file_path}!")
            else:
                console_log("🟡 CSV export canceled by user.")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                    file=self.current_file,
                    version=self.current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )


#####################################
### File: OPEN-AIR/display/left_50/top_100/3_Instrument/5_traces/gui_traces.py
#####################################
# display/left_50/top_100/tab_1_instrument/sub_tab_2_settings/sub_tab_5_traces/gui_traces.py
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# A GUI frame that uses the DynamicGuiBuilder to create widgets for the trace settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect
import tkinter as tk
from tkinter import ttk
import pathlib

# --- Module Imports ---
from workers.builder.dynamic_gui_builder import DynamicGuiBuilder
from display.logger import debug_log, console_log, log_visa_command

# --- Global Scope Variables ---
current_version = "20251127.000000.1"
current_version_hash = (20251127 * 0 * 1)
current_file = f"{os.path.basename(__file__)}"
MQTT_TOPIC_FILTER = "OPEN-AIR/configuration/instrument/trace"


class TracesGui(ttk.Frame):
    """
    A container frame that instantiates the DynamicGuiBuilder for the Trace configuration.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        """
        Initializes the Trace frame and the dynamic GUI builder.
        """
        if 'config' in kwargs:
            kwargs.pop('config')
        super().__init__(parent, *args, **kwargs)

        # --- Dynamic GUI Builder ---
        current_function_name = "__init__"
        debug_log(
            message=f"🛠️🟢 Entering {current_function_name} to initialize the TracesGui.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            config = {
                "base_topic": MQTT_TOPIC_FILTER,
                "log_to_gui_console": console_log,
                "log_to_gui_treeview": None  # Assuming no treeview for this component
            }

            self.dynamic_gui = DynamicGuiBuilder(
                parent=self,
                mqtt_util=mqtt_util,
                config=config
            )
            console_log("✅ Celebration of success! The TracesGui did initialize its dynamic GUI builder.")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

#####################################
### File: OPEN-AIR/display/left_50/top_100/3_Instrument/1_frequency/gui_frequency_1.py
#####################################
MQTT_TOPIC_FILTER = "OPEN-AIR/configuration/instrument/frequency"



# display_gui_child_pusher.py

#
# A GUI frame that uses the DynamicGuiBuilder to create widgets for frequency settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect
import tkinter as tk
from tkinter import ttk
import pathlib

# --- Module Imports ---
from workers.builder.dynamic_gui_builder import DynamicGuiBuilder
from display.logger import debug_log, console_log, log_visa_command

# --- Global Scope Variables ---
current_version = "20251127.000000.1"
current_version_hash = (20251127 * 0 * 1)
current_file = f"{os.path.basename(__file__)}"


class PresetPusherGui(ttk.Frame):
    """
    A container frame that instantiates the DynamicGuiBuilder for the Frequency configuration.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        """
        Initializes the Frequency frame and the dynamic GUI builder.
        """
        if 'config' in kwargs:
            kwargs.pop('config')
        super().__init__(parent, *args, **kwargs)

        # --- Dynamic GUI Builder ---
        current_function_name = "__init__"
        debug_log(
            message=f"🛠️🟢 Entering {current_function_name} to initialize the PresetPusherGui.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            config = {
                "base_topic": MQTT_TOPIC_FILTER,
                "log_to_gui_console": console_log,
                "log_to_gui_treeview": None  # Assuming no treeview for this component
            }

            self.dynamic_gui = DynamicGuiBuilder(
                parent=self,
                mqtt_util=mqtt_util,
                config=config
            )
            console_log("✅ Celebration of success! The PresetPusherGui did initialize its dynamic GUI builder.")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

#####################################
### File: OPEN-AIR/display/left_50/top_100/3_Instrument/4_markers/gui_markers.py
#####################################
# display/left_50/top_100/tab_1_instrument/sub_tab_2_settings/sub_tab_4_markers/gui_markers.py
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# A GUI frame that uses the DynamicGuiBuilder to create widgets for the marker settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect
import tkinter as tk
from tkinter import ttk
import pathlib

# --- Module Imports ---
from workers.builder.dynamic_gui_builder import DynamicGuiBuilder
from display.logger import debug_log, console_log, log_visa_command

# --- Global Scope Variables ---
current_version = "20251127.000000.1"
current_version_hash = (20251127 * 0 * 1)
current_file = f"{os.path.basename(__file__)}"
MQTT_TOPIC_FILTER = "OPEN-AIR/configuration/instrument/marker"


class MarkersGui(ttk.Frame):
    """
    A container frame that instantiates the DynamicGuiBuilder for the Marker configuration.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        """
        Initializes the Marker frame and the dynamic GUI builder.
        """
        if 'config' in kwargs:
            kwargs.pop('config')
        super().__init__(parent, *args, **kwargs)

        # --- Dynamic GUI Builder ---
        current_function_name = "__init__"
        debug_log(
            message=f"🛠️🟢 Entering {current_function_name} to initialize the MarkersGui.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            config = {
                "base_topic": MQTT_TOPIC_FILTER,
                "log_to_gui_console": console_log,
                "log_to_gui_treeview": None  # Assuming no treeview for this component
            }

            self.dynamic_gui = DynamicGuiBuilder(
                parent=self,
                mqtt_util=mqtt_util,
                config=config
            )
            console_log("✅ Celebration of success! The MarkersGui did initialize its dynamic GUI builder.")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

#####################################
### File: OPEN-AIR/display/left_50/top_100/3_Instrument/3_amplitude/gui_amplitude.py
#####################################
# display/left_50/top_100/tab_1_instrument/sub_tab_2_settings/sub_tab_3_amplitude/gui_amplitude_1.py
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# A GUI frame that uses the DynamicGuiBuilder to create widgets for the amplitude settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect
import tkinter as tk
from tkinter import ttk
import pathlib

# --- Module Imports ---
from workers.builder.dynamic_gui_builder import DynamicGuiBuilder
from display.logger import debug_log, console_log, log_visa_command

# --- Global Scope Variables ---
current_version = "20251127.000000.1"
current_version_hash = (20251127 * 0 * 1)
current_file = f"{os.path.basename(__file__)}"
MQTT_TOPIC_FILTER = "OPEN-AIR/configuration/instrument/amplitude"


class AmplitudeGui(ttk.Frame):
    """
    A container frame that instantiates the DynamicGuiBuilder for the Amplitude configuration.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        """
        Initializes the Amplitude frame and the dynamic GUI builder.
        """
        if 'config' in kwargs:
            kwargs.pop('config')
        super().__init__(parent, *args, **kwargs)

        # --- Dynamic GUI Builder ---
        current_function_name = "__init__"
        debug_log(
            message=f"🛠️🟢 Entering {current_function_name} to initialize the AmplitudeGui.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            config = {
                "base_topic": MQTT_TOPIC_FILTER,
                "log_to_gui_console": console_log,
                "log_to_gui_treeview": None  # Assuming no treeview for this component
            }

            self.dynamic_gui = DynamicGuiBuilder(
                parent=self,
                mqtt_util=mqtt_util,
                config=config
            )
            console_log("✅ Celebration of success! The AmplitudeGui did initialize its dynamic GUI builder.")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

#####################################
### File: OPEN-AIR/display/left_50/top_100/3_Instrument/2_bandwidth/gui_bandwidth.py
#####################################
MQTT_TOPIC_FILTER = "OPEN-AIR/configuration/instrument/bandwidth"















# display_gui_child_pusher.py

#
# A GUI frame that uses the DynamicGuiBuilder to create widgets for frequency settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect
import tkinter as tk
from tkinter import ttk
import pathlib

# --- Module Imports ---
from workers.builder.dynamic_gui_builder import DynamicGuiBuilder
from display.logger import debug_log, console_log, log_visa_command

# --- Global Scope Variables ---
current_version = "20251127.000000.1"
current_version_hash = (20251127 * 0 * 1)
current_file = f"{os.path.basename(__file__)}"


class PresetPusherGui(ttk.Frame):
    """
    A container frame that instantiates the DynamicGuiBuilder for the Frequency configuration.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        """
        Initializes the Frequency frame and the dynamic GUI builder.
        """
        if 'config' in kwargs:
            kwargs.pop('config')
        super().__init__(parent, *args, **kwargs)

        # --- Dynamic GUI Builder ---
        current_function_name = "__init__"
        debug_log(
            message=f"🛠️🟢 Entering {current_function_name} to initialize the PresetPusherGui.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            config = {
                "base_topic": MQTT_TOPIC_FILTER,
                "log_to_gui_console": console_log,
                "log_to_gui_treeview": None  # Assuming no treeview for this component
            }

            self.dynamic_gui = DynamicGuiBuilder(
                parent=self,
                mqtt_util=mqtt_util,
                config=config
            )
            console_log("✅ Celebration of success! The PresetPusherGui did initialize its dynamic GUI builder.")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

#####################################
### File: OPEN-AIR/display/left_50/top_100/5_sweeping/0_bands/gui_bands.py
#####################################
MQTT_TOPIC_FILTER = "OPEN-AIR/meta/frequency/bands/pointOfInterest"

# display/left_50/top_100/5_sweeping/0_bands/gui_bands.py
#
# This file (gui_bands.py) provides the GUI component for displaying MQTT data in a table related to frequency bands and exporting it.
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 44 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
from tkinter import filedialog

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from workers.exporters.worker_file_csv_export import CsvExportUtility
from workers.mqtt.worker_mqtt_data_flattening import MqttDataFlattenerUtility
from display.styling.style import THEMES, DEFAULT_THEME


Local_Debug_Enable = True





# --- Global Scope Variables ---
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("/", "/")

# --- No Magic Numbers (as per your instructions) ---


class InstrumentTranslatorGUI(ttk.Frame):
    """
    A GUI component for displaying MQTT data in a table and exporting it.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        """
        Initializes the GUI, sets up the layout, and subscribes to the MQTT topic.
        
        Args:
            parent (tk.Widget): The parent widget for this frame.
            mqtt_util (MqttControllerUtility): The MQTT utility instance for communication.
        """
        current_function_name = inspect.currentframe().f_code.co_name

        if Local_Debug_Enable:
            debug_log(
                message=f"🖥️🟢 Initializing the {self.__class__.__name__}.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

        try:
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash
            self.mqtt_util = mqtt_util
            self.csv_export_util = CsvExportUtility(print_to_gui_func=console_log)
            self.data_flattener = MqttDataFlattenerUtility(print_to_gui_func=console_log)
            self.current_class_name = self.__class__.__name__

            self._apply_styles(theme_name=DEFAULT_THEME)

            # --- MQTT Topic Entry Section ---
            topic_frame = ttk.LabelFrame(self, text="MQTT Topic Filter")
            topic_frame.pack(fill=tk.X, padx=10, pady=5)
            self.topic_entry = ttk.Entry(topic_frame, width=80)
            self.topic_entry.insert(0, MQTT_TOPIC_FILTER)
            self.topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            # --- MQTT Message Log Table ---
            self.table_frame = ttk.Frame(self)
            self.table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

            horizontal_scrollbar = ttk.Scrollbar(self.table_frame, orient=tk.HORIZONTAL)
            self.commands_table = ttk.Treeview(self.table_frame, xscrollcommand=horizontal_scrollbar.set, show="headings", style="Custom.Treeview")
            horizontal_scrollbar.config(command=self.commands_table.xview)
            
            vertical_scrollbar = ttk.Scrollbar(self.table_frame, orient=tk.VERTICAL, command=self.commands_table.yview)
            self.commands_table.config(yscrollcommand=vertical_scrollbar.set)

            horizontal_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)
            vertical_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            self.commands_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            self.mqtt_util.add_subscriber(topic_filter=f"{self.topic_entry.get()}/#", callback_func=self._on_commands_message)

            # --- File Controls Section ---
            file_frame = ttk.LabelFrame(self, text="File")
            file_frame.pack(fill=tk.X, padx=10, pady=5)
           
            # Button: Export to CSV
            self.export_button = ttk.Button(
                file_frame,
                text="Export to CSV",
                command=self._export_table_data
            )
            self.export_button.pack(side=tk.LEFT, padx=5, pady=5)


            # --- Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)

            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Instrument Translator GUI initialized successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                    file=self.current_file,
                    version=self.current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
    
    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")

        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])
        style.configure('TButton', background=colors["accent"], foreground=colors["text"], padding=colors["padding"] * 5, relief=colors["relief"], borderwidth=colors["border_width"] * 2)
        style.map('TButton', background=[('active', colors["secondary"])])
        
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

    def _on_commands_message(self, topic, payload):
        """
        Callback for when an MQTT message is received on the commands topic. 
        It processes the message, flattens the data, and updates or adds rows to the table.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        if Local_Debug_Enable:
            debug_log(
                message=f"🖥️🔵 Received MQTT message on topic '{topic}'. Processing message...",
                file=self.current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
        
        try:
            pivoted_rows = self.data_flattener.process_mqtt_message_and_pivot(
                topic=topic,
                payload=payload,
                topic_prefix=self.topic_entry.get()
            )

            if pivoted_rows:
                # Dynamically configure columns ONLY IF this is the first data payload.
                if not self.commands_table["columns"]:
                    new_headers = list(pivoted_rows[0].keys())
                    self.commands_table["columns"] = tuple(new_headers)
                    for col in new_headers:
                        self.commands_table.heading(col, text=col.replace("_", " ").title())
                        self.commands_table.column(col, width=150, stretch=True)

                # Iterate through each row of the new data to update or add
                for row in pivoted_rows:
                    parameter_path = row.get("Parameter")
                    
                    # Find if a row with this Parameter already exists
                    item_id_to_update = None
                    for item_id in self.commands_table.get_children():
                        row_values = self.commands_table.item(item_id, 'values')
                        if row_values and row_values[0] == parameter_path:
                            item_id_to_update = item_id
                            break
                    
                    if item_id_to_update:
                        # Update the existing row
                        new_values = [row.get(col, '') for col in self.commands_table["columns"]]
                        self.commands_table.item(item_id_to_update, values=new_values)
                        console_log(f"✅ Updated existing row for '{parameter_path}'.")
                    else:
                        # Insert a new row if it doesn't exist
                        new_values = [row.get(col, '') for col in self.commands_table["columns"]]
                        self.commands_table.insert('', tk.END, values=new_values)
                        console_log(f"✅ Added new row for '{parameter_path}'.")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 The data table construction has failed! A plague upon this error: {e}",
                    file=self.current_file,
                    version=self.current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

    def _export_table_data(self):
        """
        Opens a file dialog and exports the current data from the table to a CSV file.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        if Local_Debug_Enable:
            debug_log(
                message=f"🖥️🔵 Preparing to export table data to CSV.",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

        try:
            file_path = filedialog.asksaveasfilename(
                initialdir=os.getcwd(),
                title="Save Table Data as CSV",
                filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
                defaultextension=".csv"
            )
            
            if file_path:
                data = []
                headers = self.commands_table["columns"]
                for item_id in self.commands_table.get_children():
                    row_values = self.commands_table.item(item_id, 'values')
                    row_dict = dict(zip(headers, row_values))
                    data.append(row_dict)
                    
                self.csv_export_util.export_data_to_csv(data=data, file_path=file_path)
                console_log(f"✅ Data successfully exported to {file_path}!")
            else:
                console_log("🟡 CSV export canceled by user.")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                    file=self.current_file,
                    version=self.current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

#####################################
### File: OPEN-AIR/display/left_50/top_100/5_sweeping/2_configuration/gui_configuration.py
#####################################
MQTT_TOPIC_FILTER = "OPEN-AIR/configuration/sweeping"



# display_gui_child_pusher.py

#
# A GUI frame that uses the DynamicGuiBuilder to create widgets for frequency settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect
import tkinter as tk
from tkinter import ttk
import pathlib

# --- Module Imports ---
from workers.builder.dynamic_gui_builder import DynamicGuiBuilder
from display.logger import debug_log, console_log, log_visa_command

# --- Global Scope Variables ---
current_version = "20251127.000000.1"
current_version_hash = (20251127 * 0 * 1)
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class PresetPusherGui(ttk.Frame):
    """
    A container frame that instantiates the DynamicGuiBuilder for the Frequency configuration.
    """
    def __init__(self, parent, mqtt_util, config=None, *args, **kwargs):
        """
        Initializes the Frequency frame and the dynamic GUI builder.
        """
        if 'config' in kwargs:
            kwargs.pop('config')
        super().__init__(parent, *args, **kwargs)
        self.pack(fill=tk.BOTH, expand=True)

        # --- Dynamic GUI Builder ---
        current_function_name = "__init__"
        debug_log(
            message=f"🛠️🟢 Entering {current_function_name} to initialize the PresetPusherGui.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            config = {
                "base_topic": MQTT_TOPIC_FILTER,
                "log_to_gui_console": console_log,
                "log_to_gui_treeview": None  # Assuming no treeview for this component
            }

            self.dynamic_gui = DynamicGuiBuilder(
                parent=self,
                mqtt_util=mqtt_util,
                config=config
            )
            console_log("✅ Celebration of success! The PresetPusherGui did initialize its dynamic GUI builder.")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

#####################################
### File: OPEN-AIR/display/left_50/top_100/3_markers/2_peak_hunter/gui_peak_hunter.py
#####################################
MQTT_TOPIC_FILTER = "OPEN-AIR/repository/markers"

# display/left_50/top_100/3_markers/2_peak_hunter/gui_peak_hunter.py
#
# This file (gui_peak_hunter.py) provides the MarkerPeakHunterGUI component for the Peak Hunter tab, displaying marker data and tuning instruments based on selections.
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 44 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
from tkinter import filedialog

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from workers.exporters.worker_file_csv_export import CsvExportUtility
from workers.mqtt.worker_mqtt_data_flattening import MqttDataFlattenerUtility
from display.styling.style import THEMES, DEFAULT_THEME


Local_Debug_Enable = True





# --- Global Scope Variables ---
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("/", "/")

# --- No Magic Numbers (as per your instructions) ---


class MarkerPeakHunterGUI(ttk.Frame):
    """
    A GUI component for displaying MQTT data in a table and exporting it.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        """
        Initializes the GUI, sets up the layout, and subscribes to the MQTT topic.
        
        Args:
            parent (tk.Widget): The parent widget for this frame.
            mqtt_util (MqttControllerUtility): The MQTT utility instance for communication.
        """
        current_function_name = inspect.currentframe().f_code.co_name

        if Local_Debug_Enable:
            debug_log(
                message=f"🖥️🟢 Initializing the {self.__class__.__name__}.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

        try:
            if 'config' in kwargs:
                kwargs.pop('config')
            super().__init__(parent, *args, **kwargs)

            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash
            self.mqtt_util = mqtt_util
            self.csv_export_util = CsvExportUtility(print_to_gui_func=console_log)
            self.data_flattener = MqttDataFlattenerUtility(print_to_gui_func=console_log)
            self.current_class_name = self.__class__.__name__

            self._apply_styles(theme_name=DEFAULT_THEME)

            # --- MQTT Topic Entry Section ---
            topic_frame = ttk.LabelFrame(self, text="MQTT Topic Filter")
            topic_frame.pack(fill=tk.X, padx=10, pady=5)
            self.topic_entry = ttk.Entry(topic_frame, width=80)
            self.topic_entry.insert(0, MQTT_TOPIC_FILTER)
            self.topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            # --- MQTT Message Log Table ---
            self.table_frame = ttk.Frame(self)
            self.table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

            horizontal_scrollbar = ttk.Scrollbar(self.table_frame, orient=tk.HORIZONTAL)
            self.commands_table = ttk.Treeview(self.table_frame, xscrollcommand=horizontal_scrollbar.set, show="headings", style="Custom.Treeview")
            horizontal_scrollbar.config(command=self.commands_table.xview)
            
            vertical_scrollbar = ttk.Scrollbar(self.table_frame, orient=tk.VERTICAL, command=self.commands_table.yview)
            self.commands_table.config(yscrollcommand=vertical_scrollbar.set)

            horizontal_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)
            vertical_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            self.commands_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            self.mqtt_util.add_subscriber(topic_filter=f"{self.topic_entry.get()}/#", callback_func=self._on_commands_message)

            # --- File Controls Section ---
            file_frame = ttk.LabelFrame(self, text="File")
            file_frame.pack(fill=tk.X, padx=10, pady=5)
           
            # Button: Export to CSV
            self.export_button = ttk.Button(
                file_frame,
                text="Export to CSV",
                command=self._export_table_data
            )
            self.export_button.pack(side=tk.LEFT, padx=5, pady=5)


            # --- Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)

            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Instrument Translator GUI initialized successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                    file=self.current_file,
                    version=self.current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
    
    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")

        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])
        style.configure('TButton', background=colors["accent"], foreground=colors["text"], padding=colors["padding"] * 5, relief=colors["relief"], borderwidth=colors["border_width"] * 2)
        style.map('TButton', background=[('active', colors["secondary"])])
        
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

    def _on_commands_message(self, topic, payload):
        """
        Callback for when an MQTT message is received on the commands topic. 
        It processes the message, flattens the data, and updates or adds rows to the table.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        if Local_Debug_Enable:
            debug_log(
                message=f"🖥️🔵 Received MQTT message on topic '{topic}'. Processing message...",
                file=self.current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
        
        try:
            pivoted_rows = self.data_flattener.process_mqtt_message_and_pivot(
                topic=topic,
                payload=payload,
                topic_prefix=self.topic_entry.get()
            )

            if pivoted_rows:
                # Dynamically configure columns ONLY IF this is the first data payload.
                if not self.commands_table["columns"]:
                    new_headers = list(pivoted_rows[0].keys())
                    self.commands_table["columns"] = tuple(new_headers)
                    for col in new_headers:
                        self.commands_table.heading(col, text=col.replace("_", " ").title())
                        self.commands_table.column(col, width=150, stretch=True)

                # Iterate through each row of the new data to update or add
                for row in pivoted_rows:
                    parameter_path = row.get("Parameter")
                    
                    # Find if a row with this Parameter already exists
                    item_id_to_update = None
                    for item_id in self.commands_table.get_children():
                        row_values = self.commands_table.item(item_id, 'values')
                        if row_values and row_values[0] == parameter_path:
                            item_id_to_update = item_id
                            break
                    
                    if item_id_to_update:
                        # Update the existing row
                        new_values = [row.get(col, '') for col in self.commands_table["columns"]]
                        self.commands_table.item(item_id_to_update, values=new_values)
                        console_log(f"✅ Updated existing row for '{parameter_path}'.")
                    else:
                        # Insert a new row if it's not exist
                        new_values = [row.get(col, '') for col in self.commands_table["columns"]]
                        self.commands_table.insert('', tk.END, values=new_values)
                        console_log(f"✅ Added new row for '{parameter_path}'.")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 The data table construction has failed! A plague upon this error: {e}",
                    file=self.current_file,
                    version=self.current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

    def _export_table_data(self):
        """
        Opens a file dialog and exports the current data from the table to a CSV file.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        if Local_Debug_Enable:
            debug_log(
                message=f"🖥️🔵 Preparing to export table data to CSV.",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

        try:
            file_path = filedialog.asksaveasfilename(
                initialdir=os.getcwd(),
                title="Save Table Data as CSV",
                filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
                defaultextension=".csv"
            )
            
            if file_path:
                data = []
                headers = self.commands_table["columns"]
                for item_id in self.commands_table.get_children():
                    row_values = self.commands_table.item(item_id, 'values')
                    row_dict = dict(zip(headers, row_values))
                    data.append(row_dict)
                    
                self.csv_export_util.export_data_to_csv(data=data, file_path=file_path)
                console_log(f"✅ Data successfully exported to {file_path}!")
            else:
                console_log("🟡 CSV export canceled by user.")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                    file=self.current_file,
                    version=self.current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

#####################################
### File: OPEN-AIR/display/left_50/top_100/3_markers/1_showtime/gui_showtime.py
#####################################

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
from tkinter import filedialog
from collections import defaultdict


# --- Global Scope Variables ---
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parents[5]
current_file = str(current_file_path.relative_to(project_root)).replace("/", "/")
Current_Date = 20251213
Current_Time = 120000
Current_iteration = 44





# --- Graceful Dependency Importing ---
try:
    import pandas as pd
    import numpy as np
    PANDAS_NUMPY_AVAILABLE = True
except ImportError:
    pd = None
    np = None
    PANDAS_NUMPY_AVAILABLE = False

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from workers.importers.worker_marker_file_import_handling import maker_file_check_for_markers_file
# FIXED: Importing tuning functions from the correct location.
from workers.active.worker_active_marker_tune_and_collect import Push_Marker_to_Center_Freq, Push_Marker_to_Start_Stop_Freq
# NEW: Import the refactored logic function
from workers.markers.worker_marker_logic import calculate_frequency_range
from display.styling.style import THEMES, DEFAULT_THEME
from workers.Showtime.worker_showtime_read import load_marker_data
from workers.Showtime.worker_showtime_group import process_and_sort_markers
from workers.Showtime.worker_showtime_tune import on_tune_request_from_selection
from workers.Showtime.worker_showtime_create_group_buttons import create_group_buttons
from workers.Showtime.worker_showtime_create_device_buttons import create_device_buttons
from workers.Showtime.worker_showtime_create_zone_buttons import create_zone_buttons # NEW IMPORT
from workers.Showtime.worker_showtime_on_marker_button_click import on_marker_button_click
from workers.Showtime.worker_showtime_clear_group_buttons import clear_group_buttons
from workers.Showtime.worker_showtime_on_zone_toggle import on_zone_toggle
from workers.Showtime.worker_showtime_on_group_toggle import on_group_toggle


Local_Debug_Enable = True

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"

class ShowtimeTab(ttk.Frame):
    """
    A Tkinter Frame that dynamically creates buttons for each marker in the MARKERS.csv file.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        current_function = inspect.currentframe().f_code.co_name
        if 'config' in kwargs:
            kwargs.pop('config')
        super().__init__(parent, *args, **kwargs)

        self.mqtt_util = mqtt_util
        self.buttons = []
        self.marker_data = []
        self.column_headers = []
        self.grouped_markers = {}
        self.selected_zone = None
        self.selected_group = None
        self.selected_device_button = None
        self.Local_Debug_Enable = Local_Debug_Enable
        self.current_file = current_file
        self.current_version = current_version




        self._apply_styles(theme_name=DEFAULT_THEME)
        

        if not PANDAS_NUMPY_AVAILABLE:
            console_log("❌ Critical dependencies 'pandas' or 'numpy' not found. Showtime tab will be disabled.")
            for widget in self.winfo_children():
                widget.destroy()
            error_label = ttk.Label(self, text="Error: NumPy and Pandas libraries are required for this tab.", foreground="red")
            error_label.pack(pady=20)
            return
        
        parent_notebook = parent.master
        parent_notebook.bind("<<NotebookTabChanged>>", self._on_tab_selected)
        
        self._on_tab_selected(None)

    def _apply_styles(self, theme_name: str):
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])
        # FIXED: Apply wraplength to the base button style for consistent wrapping.
        style.configure('Custom.TButton',
                        background=colors["button_style_toggle"]["background"],
                        foreground=colors["button_style_toggle"]["foreground"],
                        padding=10, relief=colors["relief"],
                        wraplength=150,
                        borderwidth=colors["border_width"])
        style.map('Custom.TButton',
                  background=[('pressed', colors["accent"]), 
                              ('active', colors["hover_blue"])])
    
        style.configure('Group.TLabel',
                        background=colors["primary"],
                        foreground=colors["accent"],
                        font=('Helvetica', 12, 'bold'))

    def _create_widgets(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🛠️🟢 Creating widgets for ShowtimeTab.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function}",
            console_print_func=console_log
        )
        self.pack(fill=tk.BOTH, expand=True)

        # Main frame for the Showtime tab
        main_frame = ttk.Frame(self)
        main_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # Zones section
        self.zones_frame = ttk.LabelFrame(main_frame, text="Zones")
        self.zones_frame.pack(fill=tk.X, padx=5, pady=2)
        # Create zone buttons will go here.

        # Groups section
        self.groups_frame = ttk.LabelFrame(main_frame, text="Groups")
        self.groups_frame.pack(fill=tk.X, padx=5, pady=2)
        # Create group buttons will go here.

        # Devices section
        self.devices_frame = ttk.LabelFrame(main_frame, text="Devices")
        self.devices_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=2)
        # Create device buttons will go here.

        # Tune button
        tune_frame = ttk.Frame(main_frame)
        tune_frame.pack(fill=tk.X, padx=5, pady=5)
        tune_button = ttk.Button(tune_frame, text="Tune", command=lambda: on_tune_request_from_selection(self))
        tune_button.pack(side=tk.LEFT, fill=tk.X, expand=True)

        debug_log(
            message=f"✅ Widgets created for ShowtimeTab.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function}",
            console_print_func=console_log
        )

    def _on_tab_selected(self, event):
        current_function = inspect.currentframe().f_code.co_name
        
        if event is None or event.widget.tab(event.widget.select(), "text") == "Showtime":
            if Local_Debug_Enable:
                debug_log(
                    message="🛠️🟢 'Showtime' tab activated. Reloading marker data and buttons.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function}",
                    console_print_func=console_log
                )
            load_marker_data(self)
            process_and_sort_markers(self)
            create_zone_buttons(self)
            create_group_buttons(self)
            create_device_buttons(self)
    
            if Local_Debug_Enable:
                debug_log(
                    message="✅ 'Showtime' tab setup complete.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function}",
                    console_print_func=console_log
                )

#####################################
### File: OPEN-AIR/display/left_50/top_100/3_markers/3_Importer/gui_importer.py
#####################################
# display/left_40/top_100/tab_2_markers/sub_tab_3_Importer/gui_child_1_marker_importer.py
#
# This file provides a basic GUI component with buttons for importing marker data.
# It now serves as the presentation layer, with all file handling logic moved
# to a dedicated worker file.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import tkinter as tk
from tkinter import filedialog, ttk
import os
import inspect
import pathlib

# --- Graceful Dependency Importing ---
try:
    import pandas as pd
    PANDAS_AVAILABLE = True
except ImportError:
    pd = None
    PANDAS_AVAILABLE = False

# --- Module Imports ---
from display.logger import debug_log, console_log
from workers.importers.worker_marker_file_import_handling import (
    maker_file_check_for_markers_file
)
from display.styling.style import THEMES, DEFAULT_THEME
from workers.Importer.worker_importer_loader import *
from workers.Importer.worker_importer_appender import *
from workers.Importer.worker_importer_editor import *
from workers.Importer.worker_importer_saver import *

# --- Global Scope Variables ---
current_version = "20251127.000000.1"
current_version_hash = (20251127 * 0 * 1)
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parents[5]
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")

# --- Constants ---
DEFAULT_PAD_X = 5
DEFAULT_PAD_Y = 2

class MarkerImporterTab(ttk.Frame):
    """
    A stripped-down Tkinter Frame focused on displaying marker data and triggering
    actions via a separate worker module.
    """
    def __init__(self, master=None, app_instance=None, mqtt_util=None, **kwargs):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(
            message="🛠️🟢 Initializing MarkerImporterTab. The GUI is now lean and mean! 🎉",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function}",
            console_print_func=console_log
        )
        if 'config' in kwargs:
            kwargs.pop('config')
        super().__init__(master, **kwargs)

        self.app_instance = app_instance
        self.mqtt_util = mqtt_util
        self.tree_headers = []
        self.tree_data = []
        self.sort_column = None
        self.sort_direction = False
        self.current_file = current_file
        self.current_version = current_version

        self._apply_styles(theme_name=DEFAULT_THEME)
        self._create_widgets()

        if not PANDAS_AVAILABLE:
            console_log("❌ Critical dependency 'pandas' or 'numpy' not found. Marker Importer will have limited functionality.", local_debug_enabled=Local_Debug_Enable)
            # Optionally, disable the whole tab or show an error message
            error_label = ttk.Label(self, text="Error: NumPy and Pandas libraries are required for this tab.", foreground="red")
            error_label.pack(pady=20)
            return

        # Call the worker to check for an existing file on startup
        self.tree_headers, self.tree_data = maker_file_check_for_markers_file()
        self._update_treeview()

        debug_log(
            message="🛠️🟢 MarkerImporterTab has been fully instantiated. Now creating widgets!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function}",
            console_print_func=console_log
        )

    def _apply_styles(self, theme_name: str):
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")

        # General widget styling
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])

        # Table (Treeview) styling
        style.configure('Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

        style.configure('Markers.TEntry',
                        fieldbackground=colors["entry_bg"],
                        foreground=colors["entry_fg"],
                        insertbackground=colors["fg"],
                        selectbackground=colors["hover_blue"],
                        selectforeground=colors["text"])
        
        style.configure('TButton',
                        background=colors["secondary"],
                        foreground=colors["text"],
                        padding=10, relief=colors["relief"],
                        borderwidth=colors["border_width"])
        style.map('TButton',
                  background=[('pressed', colors["accent"]), 
                              ('active', colors["hover_blue"])])
        
        style.configure('Green.TButton', background='#6a9955', foreground='#ffffff')
        style.map('Green.TButton',
                  background=[('pressed', '!disabled', '#4a6f3b'),
                              ('active', '#8ab97c')],
                  foreground=[('pressed', '!disabled', '#ffffff'),
                              ('active', '#ffffff')])
        
        style.configure('Blue.TButton', 
                        background=colors["button_style_toggle"]["background"], 
                        foreground=colors["button_style_toggle"]["foreground"])
        style.map('Blue.TButton',
                  background=[('pressed', '!disabled', colors["button_style_toggle"]["Button_Pressed_Bg"]),
                              ('active', colors["button_style_toggle"]["Button_Hover_Bg"])],
                  foreground=[('pressed', '!disabled', colors["button_style_toggle"]["foreground"]),
                              ('active', colors["button_style_toggle"]["foreground"])])

        style.configure('Orange.TButton', 
                        background=colors["button_style_toggle"]["background"], 
                        foreground=colors["button_style_toggle"]["foreground"])
        style.map('Orange.TButton',
                  background=[('pressed', '!disabled', colors["button_style_toggle"]["Button_Pressed_Bg"]),
                              ('active', colors["button_style_toggle"]["Button_Hover_Bg"])],
                  foreground=[('pressed', '!disabled', colors["button_style_toggle"]["foreground"]),
                              ('active', colors["button_style_toggle"]["foreground"])])
        
        style.configure('Red.TButton', 
                        background=colors["button_style_toggle"]["background"], 
                        foreground=colors["button_style_toggle"]["foreground"])
        style.map('Red.TButton',
                  background=[('pressed', '!disabled', colors["button_style_toggle"]["Button_Pressed_Bg"]),
                              ('active', colors["button_style_toggle"]["Button_Hover_Bg"])],
                  foreground=[('pressed', '!disabled', colors["button_style_toggle"]["foreground"]),
                              ('active', colors["button_style_toggle"]["foreground"])])

    def _create_widgets(self):
        self.pack(fill=tk.BOTH, expand=True)
        
        load_markers_frame = ttk.LabelFrame(self, text="Load Markers", padding=(5,5,5,5))
        load_markers_frame.pack(fill=tk.X, padx=DEFAULT_PAD_X, pady=DEFAULT_PAD_Y)
        
        self.load_csv_button = ttk.Button(load_markers_frame, text="Load CSV Marker Set", style='Action.TButton', command=lambda: load_markers_file_action(self))
        self.load_csv_button.pack(side=tk.LEFT, padx=2, pady=2, fill=tk.X, expand=True)
        
        self.load_ias_html_button = ttk.Button(load_markers_frame, text="Load IAS HTML", style='Action.TButton', command=lambda: load_ias_html_action(self))
        self.load_ias_html_button.pack(side=tk.LEFT, padx=2, pady=2, fill=tk.X, expand=True)
        
        self.load_wwb_shw_button = ttk.Button(load_markers_frame, text="Load WWB.shw", style='Action.TButton', command=lambda: load_wwb_shw_action(self))
        self.load_wwb_shw_button.pack(side=tk.LEFT, padx=2, pady=2, fill=tk.X, expand=True)

        self.load_wwb_zip_button = ttk.Button(load_markers_frame, text="Load WWB.zip", style='Action.TButton', command=lambda: load_wwb_zip_action(self))
        self.load_wwb_zip_button.pack(side=tk.LEFT, padx=2, pady=2, fill=tk.X, expand=True)

        self.load_sb_pdf_button = ttk.Button(load_markers_frame, text="Load SB PDF", style='Action.TButton', command=lambda: load_sb_pdf_action(self))
        self.load_sb_pdf_button.pack(side=tk.LEFT, padx=2, pady=2, fill=tk.X, expand=True)
        
        self.load_sb_v2_pdf_button = ttk.Button(load_markers_frame, text="Load SB V2.pdf", style='Action.TButton', command=lambda: load_sb_v2_pdf_action(self))
        self.load_sb_v2_pdf_button.pack(side=tk.LEFT, padx=2, pady=2, fill=tk.X, expand=True)

        marker_table_frame = ttk.LabelFrame(self, text="Marker Editor", padding=(5,5,5,5))
        marker_table_frame.pack(fill=tk.BOTH, expand=True, padx=DEFAULT_PAD_X, pady=DEFAULT_PAD_Y)
        
        self.marker_tree = ttk.Treeview(marker_table_frame, show=("headings", "tree"))
        self.marker_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=DEFAULT_PAD_X, pady=DEFAULT_PAD_Y)
        self.marker_tree.column("#0", width=0, stretch=tk.NO)
        
        tree_yscroll = ttk.Scrollbar(marker_table_frame, orient="vertical", command=self.marker_tree.yview)
        tree_yscroll.pack(side=tk.RIGHT, fill=tk.Y)
        self.marker_tree.configure(yscrollcommand=tree_yscroll.set)
        
        tree_xscroll = ttk.Scrollbar(marker_table_frame, orient="horizontal", command=self.marker_tree.xview)
        tree_xscroll.pack(side=tk.BOTTOM, fill=tk.X)
        self.marker_tree.configure(xscrollcommand=tree_xscroll.set)

        self.marker_tree.bind("<Double-1>", lambda event: on_tree_double_click(self, event))
        self.marker_tree.bind("<Button-1>", lambda event: on_tree_header_click(self, event), add="+ ")
        self.marker_tree.bind("<Delete>", lambda event: delete_selected_row(self, event))

        append_markers_frame = ttk.LabelFrame(self, text="Append Markers", padding=(5,5,5,5))
        append_markers_frame.pack(fill=tk.X, padx=DEFAULT_PAD_X, pady=DEFAULT_PAD_Y)
        
        self.append_csv_button = ttk.Button(append_markers_frame, text="Append CSV Marker Set", style='Action.TButton', command=lambda: append_markers_file_action(self))
        self.append_csv_button.pack(side=tk.LEFT, padx=2, pady=2, fill=tk.X, expand=True)
        
        self.append_ias_html_button = ttk.Button(append_markers_frame, text="Append IAS HTML", style='Action.TButton', command=lambda: append_ias_html_action(self))
        self.append_ias_html_button.pack(side=tk.LEFT, padx=2, pady=2, fill=tk.X, expand=True)
        
        self.append_wwb_shw_button = ttk.Button(append_markers_frame, text="Append WWB.shw", style='Action.TButton', command=lambda: append_wwb_shw_action(self))
        self.append_wwb_shw_button.pack(side=tk.LEFT, padx=2, pady=2, fill=tk.X, expand=True)

        self.append_wwb_zip_button = ttk.Button(append_markers_frame, text="Append WWB.zip", style='Action.TButton', command=lambda: append_wwb_zip_action(self))
        self.append_wwb_zip_button.pack(side=tk.LEFT, padx=2, pady=2, fill=tk.X, expand=True)

        self.append_sb_pdf_button = ttk.Button(append_markers_frame, text="Append SB PDF", style='Action.TButton', command=lambda: append_sb_pdf_action(self))
        self.append_sb_pdf_button.pack(side=tk.LEFT, padx=2, pady=2, fill=tk.X, expand=True)
        
        self.append_sb_v2_pdf_button = ttk.Button(append_markers_frame, text="Append SB V2.pdf", style='Action.TButton', command=lambda: append_sb_v2_pdf_action(self))
        self.append_sb_v2_pdf_button.pack(side=tk.LEFT, padx=2, pady=2, fill=tk.X, expand=True)

        self.save_open_air_button = ttk.Button(self, text="Save Markers as Open Air.csv", style='Orange.TButton', command=lambda: save_open_air_file_action(self))
        self.save_open_air_button.pack(fill=tk.X, padx=DEFAULT_PAD_X, pady=DEFAULT_PAD_Y)

    def _update_treeview(self):
        self.marker_tree.delete(*self.marker_tree.get_children())
        standardized_headers = self.tree_headers if self.tree_headers else ["ZONE", "GROUP", "DEVICE", "NAME", "FREQ_MHZ", "PEAK"]
        self.marker_tree["columns"] = standardized_headers
        debug_log(
            message=f"🔁🔵 Now adding {len(self.tree_data)} rows to the Treeview. Headers: {standardized_headers}",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{inspect.currentframe().f_code.co_name}",
            console_print_func=console_log
        )
        for col in standardized_headers:
            self.marker_tree.heading(col, text=col, command=lambda c=col: on_tree_header_click(self, None))
            self.marker_tree.column(col, width=100)

        for row in self.tree_data:
            if isinstance(row, list):
                # Convert list to dictionary using headers
                row_dict = dict(zip(standardized_headers, row))
                values = [row_dict.get(raw_header, '') for raw_header in standardized_headers]
            elif isinstance(row, dict):
                values = [row.get(raw_header, '') for raw_header in standardized_headers]
            else:
                values = ["Error: Invalid row format"] * len(standardized_headers)
            self.marker_tree.insert("", "end", values=values)

#####################################
### File: OPEN-AIR/display/left_50/top_100/6_plotting/3_averaging/gui_averaging.py
#####################################
MQTT_TOPIC_FILTER = "OPEN-AIR/configuration/plotting/averaging"










# display_gui_child_pusher.py

#
# A GUI frame that uses the DynamicGuiBuilder to create widgets for frequency settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect
import tkinter as tk
from tkinter import ttk

# --- Module Imports ---
from workers.builder.dynamic_gui_builder import DynamicGuiBuilder
from display.logger import debug_log, console_log, log_visa_command
import pathlib

# --- Global Scope Variables ---
current_version = "20251127.000000.1"
current_version_hash = (20251127 * 0 * 1)
current_file = f"{os.path.basename(__file__)}"


class PresetPusherGui(ttk.Frame):
    """
    A container frame that instantiates the DynamicGuiBuilder for the Frequency configuration.
    """
    def __init__(self, parent, mqtt_util, config=None, *args, **kwargs):
        """
        Initializes the Frequency frame and the dynamic GUI builder.
        """
        if 'config' in kwargs:
            kwargs.pop('config')
        super().__init__(parent, *args, **kwargs)
        self.pack(fill=tk.BOTH, expand=True)

        # --- Dynamic GUI Builder ---
        current_function_name = "__init__"
        debug_log(
            message=f"🛠️🟢 Entering {current_function_name} to initialize the PresetPusherGui.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            config = {
                "base_topic": MQTT_TOPIC_FILTER,
                "log_to_gui_console": console_log,
                "log_to_gui_treeview": None  # Assuming no treeview for this component
            }

            self.dynamic_gui = DynamicGuiBuilder(
                parent=self,
                mqtt_util=mqtt_util,
                config=config
            )
            console_log("✅ Celebration of success! The PresetPusherGui did initialize its dynamic GUI builder.")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

#####################################
### File: OPEN-AIR/display/left_50/top_100/6_plotting/1_from_file/gui_from_file.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version corrects the styling of tables and entry widgets for a more cohesive look.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from display.styling.style import THEMES, DEFAULT_THEME

# --- Global Scope Variables ---
CURRENT_DATE = 20251127
CURRENT_TIME = 0
CURRENT_TIME_HASH = 0
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class is now designed as a self-contained "island" that manages its own MQTT state.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        print("--- DEBUG: Entering BaseGUIFrame.__init__() ---")
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # We apply the style at the top of the __init__ to affect all child widgets.
            self._apply_styles(theme_name=DEFAULT_THEME)

            # Create a label for the frame
            frame_label = ttk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = ttk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame, style="Custom.TEntry")
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = ttk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)

            # We now register our callback with the central utility instead of overwriting the client's callback.
            parent_folder = str(pathlib.Path(self.current_file).parent)
            subscription_topic = f"{parent_folder.replace('\\', '/')}/#"
            self.mqtt_util.add_subscriber(topic_filter=subscription_topic, callback_func=self._on_mqtt_message)


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings", style="Custom.Treeview")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            # New frame for log buttons, placed at the bottom below the table.
            log_button_frame = ttk.Frame(self)
            log_button_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=5)

            # Button 1: Log
            self.log_button = ttk.Button(
                log_button_frame, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = ttk.Button(
                log_button_frame, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        # General widget styling
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])

        # Table (Treeview) styling
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

        # Entry (textbox) styling
        style.configure('Custom.TEntry',
                        fieldbackground=colors["entry_bg"],
                        foreground=colors["entry_fg"],
                        bordercolor=colors["table_border"])
        
    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            message_content = json.loads(payload)["value"]
            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()

#####################################
### File: OPEN-AIR/display/left_50/top_100/6_plotting/2_statistical/gui_statistical.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version corrects the styling of tables and entry widgets for a more cohesive look.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from display.styling.style import THEMES, DEFAULT_THEME

# --- Global Scope Variables ---
CURRENT_DATE = 20251127
CURRENT_TIME = 0
CURRENT_TIME_HASH = 0
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class is now designed as a self-contained "island" that manages its own MQTT state.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # We apply the style at the top of the __init__ to affect all child widgets.
            self._apply_styles(theme_name=DEFAULT_THEME)

            # Create a label for the frame
            frame_label = ttk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = ttk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame, style="Custom.TEntry")
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = ttk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)

            # We now register our callback with the central utility instead of overwriting the client's callback.
            parent_folder = str(pathlib.Path(self.current_file).parent)
            subscription_topic = f"{parent_folder.replace('\\', '/')}/#"
            self.mqtt_util.add_subscriber(topic_filter=subscription_topic, callback_func=self._on_mqtt_message)


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings", style="Custom.Treeview")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            # New frame for log buttons, placed at the bottom below the table.
            log_button_frame = ttk.Frame(self)
            log_button_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=5)

            # Button 1: Log
            self.log_button = ttk.Button(
                log_button_frame, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = ttk.Button(
                log_button_frame, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        # General widget styling
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])

        # Table (Treeview) styling
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

        # Entry (textbox) styling
        style.configure('Custom.TEntry',
                        fieldbackground=colors["entry_bg"],
                        foreground=colors["entry_fg"],
                        bordercolor=colors["table_border"])
        
    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            message_content = json.loads(payload)["value"]
            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()

#####################################
### File: OPEN-AIR/display/left_50/top_100/6_plotting/2_3d/gui_3d.py
#####################################
# tabs/Plotting/tab_plotting_child_3D.py
#
# Stripped-down GUI for generating 3D plots, with all interactions
# connected to MQTT publishing.
#
# Author: Anthony Peter Kuzub
#
# Version 20251127.000000.1

import tkinter as tk
from tkinter import ttk
import pathlib
import os

from display.logger import debug_log, console_log, log_visa_command
from display.styling.style import THEMES, DEFAULT_THEME
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility

current_version = "UNKNOWN_VERSION.000000.0"
current_version_hash = 0
current_file_path = pathlib.Path(__file__).resolve()
project_root = pathlib.Path("/home/anthony/Documents/OPEN-AIR").resolve()
current_file = str(current_file_path.relative_to(project_root)).replace("\\\\", "/")

class Plotting3DTab(ttk.Frame):
    def __init__(self, master, mqtt_util, **kwargs):
        super().__init__(master, **kwargs)
        self.pack(fill=tk.BOTH, expand=True)

        self.mqtt_util = mqtt_util
        self.current_topic_prefix = self._get_topic_prefix()

        self._apply_styles(theme_name=DEFAULT_THEME)
        self._create_widgets()

    def _get_topic_prefix(self):
        relative_path = pathlib.Path(__file__).resolve().relative_to(pathlib.Path(__file__).resolve().parent.parent.parent)
        topic = str(relative_path).replace(os.sep, '/')
        return os.path.splitext(topic)[0]

    def _apply_styles(self, theme_name: str):
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TButton', background=colors["secondary"], foreground=colors["fg"])
        style.configure('TCombobox', fieldbackground=colors["entry_bg"], foreground=colors["entry_fg"])
        style.configure('TCheckbutton', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelFrame.Label', background=colors["bg"], foreground=colors["fg"])

    def _create_widgets(self):
        self.grid_columnconfigure(0, weight=1)

        self.plot_3d_frame = ttk.LabelFrame(self, text="3D Scans Over Time Plotting", padding="10")
        self.plot_3d_frame.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")

        self.open_folder_3d_button = ttk.Button(self.plot_3d_frame, text="Open Folder for 3D Plotting", command=lambda: self._publish_value("open_folder_for_3d_plotting", "clicked"))
        self.open_folder_3d_button.grid(row=0, column=0, columnspan=2, padx=5, pady=5, sticky="ew")

        self.discovered_series_3d_frame = ttk.LabelFrame(self.plot_3d_frame, text="Discovered Series of Scans (for 3D)", padding="10")
        self.discovered_series_3d_frame.grid(row=1, column=0, columnspan=2, padx=5, pady=5, sticky="nsew")
        self.dynamic_3d_buttons_frame = ttk.Frame(self.discovered_series_3d_frame)
        self.dynamic_3d_buttons_frame.pack(fill="both", expand=True)

        ttk.Button(self.dynamic_3d_buttons_frame, text="Group 'Mock_Group_A' (5 files)", command=lambda: self._publish_value("group_select", "Mock_Group_A")).grid(row=0, column=0, padx=5, pady=2, sticky="ew")
        ttk.Button(self.dynamic_3d_buttons_frame, text="Group 'Mock_Group_B' (3 files)", command=lambda: self._publish_value("group_select", "Mock_Group_B")).grid(row=1, column=0, padx=5, pady=2, sticky="ew")

        amplitude_threshold_frame = ttk.Frame(self.plot_3d_frame)
        amplitude_threshold_frame.grid(row=2, column=0, columnspan=2, padx=5, pady=5, sticky="ew")
        amplitude_threshold_frame.grid_columnconfigure(1, weight=1)

        ttk.Label(amplitude_threshold_frame, text="Amplitude Threshold (dBm):").grid(row=0, column=0, padx=5, pady=2, sticky="w")
        amplitude_threshold_var = tk.DoubleVar(self, value=-80.0)
        amplitude_threshold_entry = ttk.Entry(amplitude_threshold_frame, textvariable=amplitude_threshold_var)
        amplitude_threshold_entry.grid(row=0, column=1, padx=5, pady=2, sticky="ew")
        amplitude_threshold_entry.bind("<KeyRelease>", lambda e: self._publish_value("amplitude_threshold", amplitude_threshold_var.get()))

        self.generate_plot_scans_over_time_button = ttk.Button(self.plot_3d_frame, text="Generate 3D Plot of Scans Over Time", command=lambda: self._publish_value("generate_3d_plot", "clicked"))
        self.generate_plot_scans_over_time_button.grid(row=3, column=0, columnspan=2, padx=5, pady=5, sticky="ew")
        self.generate_plot_scans_over_time_button.config(state=tk.DISABLED)

    def _publish_value(self, element_name, value):
        if self.mqtt_util:
            self.mqtt_util.publish_message(
                topic=self.current_topic_prefix,
                subtopic=element_name,
                value=value
            )

#####################################
### File: OPEN-AIR/display/left_50/top_100/6_plotting/1_single/gui_single.py
#####################################
MQTT_TOPIC_FILTER = "OPEN-AIR/configuration/plotting/single"










# display_gui_child_pusher.py

#
# A GUI frame that uses the DynamicGuiBuilder to create widgets for frequency settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect
import tkinter as tk
from tkinter import ttk

# --- Module Imports ---
from workers.builder.dynamic_gui_builder import DynamicGuiBuilder
from display.logger import debug_log, console_log, log_visa_command
import pathlib

# --- Global Scope Variables ---
current_version = "20251127.000000.1"
current_version_hash = (20251127 * 0 * 1)
current_file = f"{os.path.basename(__file__)}"


class PresetPusherGui(ttk.Frame):
    """
    A container frame that instantiates the DynamicGuiBuilder for the Frequency configuration.
    """
    def __init__(self, parent, mqtt_util, config=None, *args, **kwargs):
        """
        Initializes the Frequency frame and the dynamic GUI builder.
        """
        if 'config' in kwargs:
            kwargs.pop('config')
        super().__init__(parent, *args, **kwargs)
        self.pack(fill=tk.BOTH, expand=True)

        # --- Dynamic GUI Builder ---
        current_function_name = "__init__"
        debug_log(
            message=f"🛠️🟢 Entering {current_function_name} to initialize the PresetPusherGui.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            config = {
                "base_topic": MQTT_TOPIC_FILTER,
                "log_to_gui_console": console_log,
                "log_to_gui_treeview": None  # Assuming no treeview for this component
            }

            self.dynamic_gui = DynamicGuiBuilder(
                parent=self,
                mqtt_util=mqtt_util,
                config=config
            )
            console_log("✅ Celebration of success! The PresetPusherGui did initialize its dynamic GUI builder.")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

#####################################
### File: OPEN-AIR/display/left_50/top_100/8_exepriment/4_one million nodes/gui_recon_data_publisher.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version corrects the styling of tables and entry widgets for a more cohesive look.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from display.styling.style import THEMES, DEFAULT_THEME

# --- Global Scope Variables ---
CURRENT_DATE = 20251127
CURRENT_TIME = 0
CURRENT_TIME_HASH = 0
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class is now designed as a self-contained "island" that manages its own MQTT state.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # We apply the style at the top of the __init__ to affect all child widgets.
            self._apply_styles(theme_name=DEFAULT_THEME)

            # Create a label for the frame
            frame_label = ttk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = ttk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame, style="Custom.TEntry")
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = ttk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Button for the new recon data publisher
            self.recon_button = ttk.Button(
                mqtt_frame,
                text="Start Recon",
                command=self._run_recon_publisher
            )
            self.recon_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)

            # We now register our callback with the central utility instead of overwriting the client's callback.
            parent_folder = str(pathlib.Path(self.current_file).parent)
            subscription_topic = f"{parent_folder.replace('\\', '/')}/#"
            self.mqtt_util.add_subscriber(topic_filter=subscription_topic, callback_func=self._on_mqtt_message)
            # We also need to subscribe to the recon root topic to display its messages
            self.mqtt_util.add_subscriber(topic_filter="Open-Air/Recon/#", callback_func=self._on_mqtt_message)


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings", style="Custom.Treeview")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            # New frame for log buttons, placed at the bottom below the table.
            log_button_frame = ttk.Frame(self)
            log_button_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=5)

            # Button 1: Log
            self.log_button = ttk.Button(
                log_button_frame, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = ttk.Button(
                log_button_frame, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        # General widget styling
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])

        # Table (Treeview) styling
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

        # Entry (textbox) styling
        style.configure('Custom.TEntry',
                        fieldbackground=colors["entry_bg"],
                        foreground=colors["entry_fg"],
                        bordercolor=colors["table_border"])
        
    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # FIX: Check for the new payload keys before attempting to access them.
            # This handles both the old and new payload formats gracefully.
            parsed_payload = json.loads(payload)

            if "Value_dBm" in parsed_payload:
                # New format from recon_data_publisher.py
                message_content = f"dBm: {parsed_payload['Value_dBm']}, Time: {parsed_payload['time']}, Device: {parsed_payload['Device']}"
            elif "value" in parsed_payload:
                # Old generic format
                message_content = parsed_payload['value']
            else:
                # Fallback if no known key is found
                message_content = payload

            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _run_recon_publisher(self):
        """
        Runs the recon_data_publisher in a separate thread.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Starting recon publisher in a new thread.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            self.recon_button.config(state=tk.DISABLED)
            
            # We run the publisher in a separate thread to prevent the GUI from freezing.
            publisher_thread = threading.Thread(target=recon_data_publisher, args=(self.mqtt_util, console_log), daemon=True)
            publisher_thread.start()
            
            self.recon_button.config(text="Running...")

            console_log("✅ Reconnaissance data publishing started!")
            self.after(500, self._check_thread_status, publisher_thread)

        except Exception as e:
            console_log(f"❌ Error starting recon publisher: {e}")
            self.recon_button.config(state=tk.NORMAL, text="Start Recon")
            debug_log(
                message=f"❌🔴 The recon publisher thread has gone rogue! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
    
    def _check_thread_status(self, thread):
        """
        Checks if the publisher thread is still alive and updates the button state.
        """
        if thread.is_alive():
            self.after(500, self._check_thread_status, thread)
        else:
            self.recon_button.config(state=tk.NORMAL, text="Start Recon")
            console_log("✅ Reconnaissance publishing complete.")

if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()

#####################################
### File: OPEN-AIR/display/left_50/top_100/8_exepriment/4_intermod/1_calculator/gui_child_1_calculator.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version corrects the styling of tables and entry widgets for a more cohesive look.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from display.styling.style import THEMES, DEFAULT_THEME

# --- Global Scope Variables ---
CURRENT_DATE = 20251127
CURRENT_TIME = 0
CURRENT_TIME_HASH = 0
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class is now designed as a self-contained "island" that manages its own MQTT state.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # We apply the style at the top of the __init__ to affect all child widgets.
            self._apply_styles(theme_name=DEFAULT_THEME)

            # Create a label for the frame
            frame_label = ttk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = ttk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame, style="Custom.TEntry")
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = ttk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)

            # We now register our callback with the central utility instead of overwriting the client's callback.
            parent_folder = str(pathlib.Path(self.current_file).parent)
            subscription_topic = f"{parent_folder.replace('\\', '/')}/#"
            self.mqtt_util.add_subscriber(topic_filter=subscription_topic, callback_func=self._on_mqtt_message)


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings", style="Custom.Treeview")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            # New frame for log buttons, placed at the bottom below the table.
            log_button_frame = ttk.Frame(self)
            log_button_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=5)

            # Button 1: Log
            self.log_button = ttk.Button(
                log_button_frame, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = ttk.Button(
                log_button_frame, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        # General widget styling
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])

        # Table (Treeview) styling
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

        # Entry (textbox) styling
        style.configure('Custom.TEntry',
                        fieldbackground=colors["entry_bg"],
                        foreground=colors["entry_fg"],
                        bordercolor=colors["table_border"])
        
    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            message_content = json.loads(payload)["value"]
            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()

#####################################
### File: OPEN-AIR/display/left_50/top_100/8_exepriment/4_intermod/2_future/gui_1_top.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version corrects the styling of tables and entry widgets for a more cohesive look.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from display.styling.style import THEMES, DEFAULT_THEME

# --- Global Scope Variables ---
CURRENT_DATE = 20251127
CURRENT_TIME = 0
CURRENT_TIME_HASH = 0
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class is now designed as a self-contained "island" that manages its own MQTT state.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # We apply the style at the top of the __init__ to affect all child widgets.
            self._apply_styles(theme_name=DEFAULT_THEME)

            # Create a label for the frame
            frame_label = ttk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = ttk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame, style="Custom.TEntry")
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = ttk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)

            # We now register our callback with the central utility instead of overwriting the client's callback.
            parent_folder = str(pathlib.Path(self.current_file).parent)
            subscription_topic = f"{parent_folder.replace('\\', '/')}/#"
            self.mqtt_util.add_subscriber(topic_filter=subscription_topic, callback_func=self._on_mqtt_message)


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings", style="Custom.Treeview")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            # New frame for log buttons, placed at the bottom below the table.
            log_button_frame = ttk.Frame(self)
            log_button_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=5)

            # Button 1: Log
            self.log_button = ttk.Button(
                log_button_frame, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = ttk.Button(
                log_button_frame, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        # General widget styling
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])

        # Table (Treeview) styling
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

        # Entry (textbox) styling
        style.configure('Custom.TEntry',
                        fieldbackground=colors["entry_bg"],
                        foreground=colors["entry_fg"],
                        bordercolor=colors["table_border"])
        
    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            message_content = json.loads(payload)["value"]
            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()

#####################################
### File: OPEN-AIR/display/left_50/top_100/8_exepriment/4_intermod/2_future/gui_2_bottom copy.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version corrects the styling of tables and entry widgets for a more cohesive look.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from display.styling.style import THEMES, DEFAULT_THEME

# --- Global Scope Variables ---
CURRENT_DATE = 20251127
CURRENT_TIME = 0
CURRENT_TIME_HASH = 0
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class is now designed as a self-contained "island" that manages its own MQTT state.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # We apply the style at the top of the __init__ to affect all child widgets.
            self._apply_styles(theme_name=DEFAULT_THEME)

            # Create a label for the frame
            frame_label = ttk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = ttk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame, style="Custom.TEntry")
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = ttk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)

            # We now register our callback with the central utility instead of overwriting the client's callback.
            parent_folder = str(pathlib.Path(self.current_file).parent)
            subscription_topic = f"{parent_folder.replace('\\', '/')}/#"
            self.mqtt_util.add_subscriber(topic_filter=subscription_topic, callback_func=self._on_mqtt_message)


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings", style="Custom.Treeview")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            # New frame for log buttons, placed at the bottom below the table.
            log_button_frame = ttk.Frame(self)
            log_button_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=5)

            # Button 1: Log
            self.log_button = ttk.Button(
                log_button_frame, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = ttk.Button(
                log_button_frame, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        # General widget styling
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])

        # Table (Treeview) styling
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

        # Entry (textbox) styling
        style.configure('Custom.TEntry',
                        fieldbackground=colors["entry_bg"],
                        foreground=colors["entry_fg"],
                        bordercolor=colors["table_border"])
        
    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            message_content = json.loads(payload)["value"]
            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()

#####################################
### File: OPEN-AIR/display/left_50/top_100/8_exepriment/4_intermod/2_future/gui_44_last.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version corrects the styling of tables and entry widgets for a more cohesive look.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from display.styling.style import THEMES, DEFAULT_THEME

# --- Global Scope Variables ---
CURRENT_DATE = 20251127
CURRENT_TIME = 0
CURRENT_TIME_HASH = 0
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class is now designed as a self-contained "island" that manages its own MQTT state.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # We apply the style at the top of the __init__ to affect all child widgets.
            self._apply_styles(theme_name=DEFAULT_THEME)

            # Create a label for the frame
            frame_label = ttk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = ttk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame, style="Custom.TEntry")
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = ttk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)

            # We now register our callback with the central utility instead of overwriting the client's callback.
            parent_folder = str(pathlib.Path(self.current_file).parent)
            subscription_topic = f"{parent_folder.replace('\\', '/')}/#"
            self.mqtt_util.add_subscriber(topic_filter=subscription_topic, callback_func=self._on_mqtt_message)


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings", style="Custom.Treeview")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            # New frame for log buttons, placed at the bottom below the table.
            log_button_frame = ttk.Frame(self)
            log_button_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=5)

            # Button 1: Log
            self.log_button = ttk.Button(
                log_button_frame, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = ttk.Button(
                log_button_frame, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        # General widget styling
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])

        # Table (Treeview) styling
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

        # Entry (textbox) styling
        style.configure('Custom.TEntry',
                        fieldbackground=colors["entry_bg"],
                        foreground=colors["entry_fg"],
                        bordercolor=colors["table_border"])
        
    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            message_content = json.loads(payload)["value"]
            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()

#####################################
### File: OPEN-AIR/display/left_50/top_100/8_exepriment/1_mosquitto/gui_7_experiment.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version corrects the styling of tables and entry widgets for a more cohesive look.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from display.styling.style import THEMES, DEFAULT_THEME

# --- Global Scope Variables ---
CURRENT_DATE = 20251127
CURRENT_TIME = 0
CURRENT_TIME_HASH = 0
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class is now designed as a self-contained "island" that manages its own MQTT state.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # We apply the style at the top of the __init__ to affect all child widgets.
            self._apply_styles(theme_name=DEFAULT_THEME)

            # Create a label for the frame
            frame_label = ttk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = ttk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame, style="Custom.TEntry")
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = ttk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)

            # We now register our callback with the central utility instead of overwriting the client's callback.
            parent_folder = str(pathlib.Path(self.current_file).parent)
            subscription_topic = f"{parent_folder.replace('\\', '/')}/#"
            self.mqtt_util.add_subscriber(topic_filter=subscription_topic, callback_func=self._on_mqtt_message)


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings", style="Custom.Treeview")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            # New frame for log buttons, placed at the bottom below the table.
            log_button_frame = ttk.Frame(self)
            log_button_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=5)

            # Button 1: Log
            self.log_button = ttk.Button(
                log_button_frame, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = ttk.Button(
                log_button_frame, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        # General widget styling
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])

        # Table (Treeview) styling
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

        # Entry (textbox) styling
        style.configure('Custom.TEntry',
                        fieldbackground=colors["entry_bg"],
                        foreground=colors["entry_fg"],
                        bordercolor=colors["table_border"])
        
    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            message_content = json.loads(payload)["value"]
            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()

#####################################
### File: OPEN-AIR/display/left_50/top_100/8_exepriment/2_file Paths/gui_file_paths.py
#####################################
MQTT_TOPIC_FILTER = "OPEN-AIR/configuration/application/filepaths"
# display/tabs/gui_child_1_pusher.py
#
# A GUI frame for displaying and controlling Presets via MQTT using the modular DynamicGuiBuilder.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import tkinter as tk
from tkinter import ttk

# --- Module Imports ---
# It's crucial that this path correctly points to the new modular builder
from workers.builder.dynamic_gui_builder import DynamicGuiBuilder
import pathlib

# --- Global Scope Variables ---
current_version = "20251127.000000.1"
current_version_hash = (20251127 * 0 * 1)
current_file = f"{os.path.basename(__file__)}"




class PresetPusherGui(ttk.Frame):
    """
    A container frame that instantiates the DynamicGuiBuilder for the Presets configuration.
    This replaces the old, monolithic code with a call to the reusable, modular component.
    """
    def __init__(self, parent, mqtt_util, config=None, *args, **kwargs):
        """
        Initializes the Presets frame and the dynamic GUI builder.
        """
        if 'config' in kwargs:
            kwargs.pop('config')
        super().__init__(parent, *args, **kwargs)
        self.pack(fill=tk.BOTH, expand=True)

        # --- Dynamic GUI Builder ---
        # Create an instance of the new, corrected, and modular builder,
        # passing the specific base topic for this GUI component.
        self.dynamic_gui = DynamicGuiBuilder(
            parent=self,
            mqtt_util=mqtt_util,
            config={"base_topic": MQTT_TOPIC_FILTER} # Pass config as a dictionary
        )

#####################################
### File: OPEN-AIR/display/left_50/top_100/8_exepriment/3_Application Configuration/gui_application_configuration.py
#####################################
MQTT_TOPIC_FILTER = "OPEN-AIR/configuration/application/Application_Info"










# display/left_50/top_100/tab_1_instrument/sub_tab_2_settings/sub_tab_1_frequency/gui_frequency_1.py
#
# A GUI frame that uses the DynamicGuiBuilder to create widgets for frequency settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect
import tkinter as tk
from tkinter import ttk

# --- Module Imports ---
from workers.builder.dynamic_gui_builder import DynamicGuiBuilder
from display.logger import debug_log, console_log, log_visa_command
import pathlib

# --- Global Scope Variables ---
current_version = "20251127.000000.1"
current_version_hash = (20251127 * 0 * 1)
current_file = f"{os.path.basename(__file__)}"


class PresetPusherGui(ttk.Frame):
    """
    A container frame that instantiates the DynamicGuiBuilder for the Frequency configuration.
    """
    def __init__(self, parent, mqtt_util, config=None, *args, **kwargs):
        """
        Initializes the Frequency frame and the dynamic GUI builder.
        """
        if 'config' in kwargs:
            kwargs.pop('config')
        super().__init__(parent, *args, **kwargs)
        self.pack(fill=tk.BOTH, expand=True)

        # --- Dynamic GUI Builder ---
        current_function_name = "__init__"
        debug_log(
            message=f"🛠️🟢 Entering {current_function_name} to initialize the PresetPusherGui.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            config = {
                "base_topic": MQTT_TOPIC_FILTER,
                "log_to_gui_console": console_log,
                "log_to_gui_treeview": None  # Assuming no treeview for this component
            }

            self.dynamic_gui = DynamicGuiBuilder(
                parent=self,
                mqtt_util=mqtt_util,
                config=config
            )
            console_log("✅ Celebration of success! The PresetPusherGui did initialize its dynamic GUI builder.")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

#####################################
### File: OPEN-AIR/display/left_50/top_100/1_Connection/1_Device/gui_Device.py
#####################################
# display/left_50/top_100/tab_1_instrument/sub_tab_1_connection/gui_1_active_Instrument.py
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

import os
current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)
current_file = f"{os.path.basename(__file__)}"

# A GUI frame that uses the DynamicGuiBuilder to create widgets for the active instrument connection.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import inspect
import tkinter as tk
from tkinter import ttk
import pathlib

# --- Module Imports ---
from workers.builder.dynamic_gui_builder import DynamicGuiBuilder
from display.logger import debug_log, console_log, log_visa_command



MQTT_TOPIC_FILTER = "OPEN-AIR/configuration/instrument/active"


class ActiveInstrumentGui(ttk.Frame):
    """
    A container frame that instantiates the DynamicGuiBuilder for the active instrument connection.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        """
        Initializes the Frequency frame and the dynamic GUI builder.
        """
        if 'config' in kwargs:
            kwargs.pop('config')
        super().__init__(parent, *args, **kwargs)

        # --- Dynamic GUI Builder ---
        current_function_name = "__init__"
        debug_log(
            message=f"🛠️🟢 Entering {current_function_name} to initialize the ActiveInstrumentGui.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            config = {
                "base_topic": MQTT_TOPIC_FILTER,
                "log_to_gui_console": console_log,
                "log_to_gui_treeview": None  # Assuming no treeview for this component
            }

            self.dynamic_gui = DynamicGuiBuilder(
                parent=self,
                mqtt_util=mqtt_util,
                config=config
            )
            console_log("✅ Celebration of success! The ActiveInstrumentGui did initialize its dynamic GUI builder.")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

#####################################
### File: OPEN-AIR/display/left_50/top_100/1_Connection/4_YAK/8_Memory/gui_memory.py
#####################################
# display/left_50/top_100/tab_1_instrument/sub_tab_4_YAK/sub_tab_8_Memory/gui_yak_memory.py
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# A GUI frame that uses the DynamicGuiBuilder to create widgets for the YAK Memory settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect
import tkinter as tk
from tkinter import ttk

# --- Module Imports ---
from workers.builder.dynamic_gui_builder import DynamicGuiBuilder
from display.logger import debug_log, console_log, log_visa_command
import pathlib

# --- Global Scope Variables ---
current_version = "20251127.000000.1"
current_version_hash = (20251127 * 0 * 1)
current_file = f"{os.path.basename(__file__)}"
MQTT_TOPIC_FILTER = "OPEN-AIR/yak/Memory"


class YakMemoryGui(ttk.Frame):
    """
    A container frame that instantiates the DynamicGuiBuilder for the YAK Memory configuration.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        """
        Initializes the YAK Memory frame and the dynamic GUI builder.
        """
        if 'config' in kwargs:
            kwargs.pop('config')
        super().__init__(parent, *args, **kwargs)

        # --- Dynamic GUI Builder ---
        current_function_name = "__init__"
        debug_log(
            message=f"🛠️🟢 Entering {current_function_name} to initialize the YakMemoryGui.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            config = {
                "base_topic": MQTT_TOPIC_FILTER,
                "log_to_gui_console": console_log,
                "log_to_gui_treeview": None  # Assuming no treeview for this component
            }

            self.dynamic_gui = DynamicGuiBuilder(
                parent=self,
                mqtt_util=mqtt_util,
                config=config
            )
            console_log("✅ Celebration of success! The YakMemoryGui did initialize its dynamic GUI builder.")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

#####################################
### File: OPEN-AIR/display/left_50/top_100/1_Connection/4_YAK/7_Markers/gui_yak_markers.py
#####################################
# display/left_50/top_100/tab_1_instrument/sub_tab_4_YAK/sub_tab_7_Markers/gui_yak_markers.py
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# A GUI frame that uses the DynamicGuiBuilder to create widgets for the YAK Markers settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect
import tkinter as tk
from tkinter import ttk

# --- Module Imports ---
from workers.builder.dynamic_gui_builder import DynamicGuiBuilder
from display.logger import debug_log, console_log, log_visa_command
import pathlib

# --- Global Scope Variables ---
current_version = "20251127.000000.1"
current_version_hash = (20251127 * 0 * 1)
current_file = f"{os.path.basename(__file__)}"
MQTT_TOPIC_FILTER = "OPEN-AIR/yak/Markers"


class YakMarkersGui(ttk.Frame):
    """
    A container frame that instantiates the DynamicGuiBuilder for the YAK Markers configuration.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        """
        Initializes the YAK Markers frame and the dynamic GUI builder.
        """
        if 'config' in kwargs:
            kwargs.pop('config')
        super().__init__(parent, *args, **kwargs)

        # --- Dynamic GUI Builder ---
        current_function_name = "__init__"
        debug_log(
            message=f"🛠️🟢 Entering {current_function_name} to initialize the YakMarkersGui.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            config = {
                "base_topic": MQTT_TOPIC_FILTER,
                "log_to_gui_console": console_log,
                "log_to_gui_treeview": None  # Assuming no treeview for this component
            }

            self.dynamic_gui = DynamicGuiBuilder(
                parent=self,
                mqtt_util=mqtt_util,
                config=config
            )
            console_log("✅ Celebration of success! The YakMarkersGui did initialize its dynamic GUI builder.")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

#####################################
### File: OPEN-AIR/display/left_50/top_100/1_Connection/4_YAK/2_Amplitude/gui_yak_amplitude.py
#####################################
# display/left_50/top_100/tab_1_instrument/sub_tab_4_YAK/sub_tab_2_Amplitude/gui_yak_amplitude.py
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# A GUI frame that uses the DynamicGuiBuilder to create widgets for the YAK Amplitude settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect
import tkinter as tk
from tkinter import ttk

# --- Module Imports ---
from workers.builder.dynamic_gui_builder import DynamicGuiBuilder
from display.logger import debug_log, console_log, log_visa_command
import pathlib

# --- Global Scope Variables ---
current_version = "20251127.000000.1"
current_version_hash = (20251127 * 0 * 1)
current_file = f"{os.path.basename(__file__)}"
MQTT_TOPIC_FILTER = "OPEN-AIR/yak/Amplitude"


class YakAmplitudeGui(ttk.Frame):
    """
    A container frame that instantiates the DynamicGuiBuilder for the YAK Amplitude configuration.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        """
        Initializes the YAK Amplitude frame and the dynamic GUI builder.
        """
        if 'config' in kwargs:
            kwargs.pop('config')
        super().__init__(parent, *args, **kwargs)

        # --- Dynamic GUI Builder ---
        current_function_name = "__init__"
        debug_log(
            message=f"🛠️🟢 Entering {current_function_name} to initialize the YakAmplitudeGui.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            config = {
                "base_topic": MQTT_TOPIC_FILTER,
                "log_to_gui_console": console_log,
                "log_to_gui_treeview": None  # Assuming no treeview for this component
            }

            self.dynamic_gui = DynamicGuiBuilder(
                parent=self,
                mqtt_util=mqtt_util,
                config=config
            )
            console_log("✅ Celebration of success! The YakAmplitudeGui did initialize its dynamic GUI builder.")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

#####################################
### File: OPEN-AIR/display/left_50/top_100/1_Connection/4_YAK/0_Frequency/gui_yak_frequency.py
#####################################
# display/left_50/top_100/tab_1_instrument/sub_tab_4_YAK/sub_tab_0_Frequency/gui_yak_frequency.py
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# A GUI frame that uses the DynamicGuiBuilder to create widgets for the YAK Frequency settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect
import tkinter as tk
from tkinter import ttk

# --- Module Imports ---
from workers.builder.dynamic_gui_builder import DynamicGuiBuilder
from display.logger import debug_log, console_log, log_visa_command
import pathlib

# --- Global Scope Variables ---
current_version = "20251127.000000.1"
current_version_hash = (20251127 * 0 * 1)
current_file = f"{os.path.basename(__file__)}"
MQTT_TOPIC_FILTER = "OPEN-AIR/yak/Frequency"


class YakFrequencyGui(ttk.Frame):
    """
    A container frame that instantiates the DynamicGuiBuilder for the YAK Frequency configuration.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        """
        Initializes the YAK Frequency frame and the dynamic GUI builder.
        """
        if 'config' in kwargs:
            kwargs.pop('config')
        super().__init__(parent, *args, **kwargs)

        # --- Dynamic GUI Builder ---
        current_function_name = "__init__"
        debug_log(
            message=f"🛠️🟢 Entering {current_function_name} to initialize the YakFrequencyGui.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            config = {
                "base_topic": MQTT_TOPIC_FILTER,
                "log_to_gui_console": console_log,
                "log_to_gui_treeview": None  # Assuming no treeview for this component
            }

            self.dynamic_gui = DynamicGuiBuilder(
                parent=self,
                mqtt_util=mqtt_util,
                config=config
            )
            console_log("✅ Celebration of success! The YakFrequencyGui did initialize its dynamic GUI builder.")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

#####################################
### File: OPEN-AIR/display/left_50/top_100/1_Connection/4_YAK/3_Trace/gui_yak_trace.py
#####################################
# display/left_50/top_100/tab_1_instrument/sub_tab_4_YAK/sub_tab_3_Trace/gui_yak_trace.py
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# A GUI frame that uses the DynamicGuiBuilder to create widgets for the YAK Trace settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect
import tkinter as tk
from tkinter import ttk

# --- Module Imports ---
from workers.builder.dynamic_gui_builder import DynamicGuiBuilder
from display.logger import debug_log, console_log, log_visa_command
import pathlib

# --- Global Scope Variables ---
current_version = "20251127.000000.1"
current_version_hash = (20251127 * 0 * 1)
current_file = f"{os.path.basename(__file__)}"
MQTT_TOPIC_FILTER = "OPEN-AIR/yak/Trace"


class YakTraceGui(ttk.Frame):
    """
    A container frame that instantiates the DynamicGuiBuilder for the YAK Trace configuration.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        """
        Initializes the YAK Trace frame and the dynamic GUI builder.
        """
        if 'config' in kwargs:
            kwargs.pop('config')
        super().__init__(parent, *args, **kwargs)

        # --- Dynamic GUI Builder ---
        current_function_name = "__init__"
        debug_log(
            message=f"🛠️🟢 Entering {current_function_name} to initialize the YakTraceGui.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            config = {
                "base_topic": MQTT_TOPIC_FILTER,
                "log_to_gui_console": console_log,
                "log_to_gui_treeview": None  # Assuming no treeview for this component
            }

            self.dynamic_gui = DynamicGuiBuilder(
                parent=self,
                mqtt_util=mqtt_util,
                config=config
            )
            console_log("✅ Celebration of success! The YakTraceGui did initialize its dynamic GUI builder.")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

#####################################
### File: OPEN-AIR/display/left_50/top_100/1_Connection/4_YAK/9_System/gui_yak_system.py
#####################################
# display/left_50/top_100/tab_1_instrument/sub_tab_4_YAK/sub_tab_9_System/gui_yak_system.py
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# A GUI frame that uses the DynamicGuiBuilder to create widgets for the YAK System settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect
import tkinter as tk
from tkinter import ttk

# --- Module Imports ---
from workers.builder.dynamic_gui_builder import DynamicGuiBuilder
from display.logger import debug_log, console_log, log_visa_command
import pathlib

# --- Global Scope Variables ---
current_version = "20251127.000000.1"
current_version_hash = (20251127 * 0 * 1)
current_file = f"{os.path.basename(__file__)}"
MQTT_TOPIC_FILTER = "OPEN-AIR/yak/System"


class YakSystemGui(ttk.Frame):
    """
    A container frame that instantiates the DynamicGuiBuilder for the YAK System configuration.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        """
        Initializes the YAK System frame and the dynamic GUI builder.
        """
        if 'config' in kwargs:
            kwargs.pop('config')
        super().__init__(parent, *args, **kwargs)

        # --- Dynamic GUI Builder ---
        current_function_name = "__init__"
        debug_log(
            message=f"🛠️🟢 Entering {current_function_name} to initialize the YakSystemGui.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            config = {
                "base_topic": MQTT_TOPIC_FILTER,
                "log_to_gui_console": console_log,
                "log_to_gui_treeview": None  # Assuming no treeview for this component
            }

            self.dynamic_gui = DynamicGuiBuilder(
                parent=self,
                mqtt_util=mqtt_util,
                config=config
            )
            console_log("✅ Celebration of success! The YakSystemGui did initialize its dynamic GUI builder.")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

#####################################
### File: OPEN-AIR/display/left_50/top_100/1_Connection/4_YAK/1_Bandwidth/gui_yak_bandwidth.py
#####################################
# display/left_50/top_100/tab_1_instrument/sub_tab_4_YAK/sub_tab_1_Bandwidth/gui_yak_bandwidth.py
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251129  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 1 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# A GUI frame that uses the DynamicGuiBuilder to create widgets for the YAK Bandwidth settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect
import tkinter as tk
from tkinter import ttk

# --- Module Imports ---
from workers.builder.dynamic_gui_builder import DynamicGuiBuilder
from display.logger import debug_log, console_log, log_visa_command
import pathlib

# --- Global Scope Variables ---
current_version = "20251127.000000.1"
current_version_hash = (20251127 * 0 * 1)
current_file = f"{os.path.basename(__file__)}"
MQTT_TOPIC_FILTER = "OPEN-AIR/yak/Bandwidth"


class YakBandwidthGui(ttk.Frame):
    """
    A container frame that instantiates the DynamicGuiBuilder for the YAK Bandwidth configuration.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        """
        Initializes the YAK Bandwidth frame and the dynamic GUI builder.
        """
        if 'config' in kwargs:
            kwargs.pop('config')
        super().__init__(parent, *args, **kwargs)

        # --- Dynamic GUI Builder ---
        current_function_name = "__init__"
        debug_log(
            message=f"🛠️🟢 Entering {current_function_name} to initialize the YakBandwidthGui.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            config = {
                "base_topic": MQTT_TOPIC_FILTER,
                "log_to_gui_console": console_log,
                "log_to_gui_treeview": None  # Assuming no treeview for this component
            }

            self.dynamic_gui = DynamicGuiBuilder(
                parent=self,
                mqtt_util=mqtt_util,
                config=config
            )
            console_log("✅ Celebration of success! The YakBandwidthGui did initialize its dynamic GUI builder.")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

#####################################
### File: OPEN-AIR/display/left_50/top_100/1_Connection/5_translator/gui_intrument_translator.py
#####################################
MQTT_TOPIC_FILTER = "OPEN-AIR/repository/scpi"



# display/gui_marker_editor.py
#
# A GUI component for editing markers, designed to handle both full data sets
# and single-value updates intelligently via MQTT.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
from tkinter import filedialog

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from workers.exporters.worker_file_csv_export import CsvExportUtility
from workers.mqtt.worker_mqtt_data_flattening import MqttDataFlattenerUtility
from display.styling.style import THEMES, DEFAULT_THEME


Local_Debug_Enable = True





# --- Global Scope Variables ---
CURRENT_DATE = 20251127
CURRENT_TIME = 0
REVISION_NUMBER = 1
current_version = "20251127.000000.1"
current_version_hash = 20251127 * 0 * 1
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")

# --- No Magic Numbers (as per your instructions) ---


class InstrumentTranslatorGUI(ttk.Frame):
    """
    A GUI component for displaying MQTT data in a table and exporting it.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        """
        Initializes the GUI, sets up the layout, and subscribes to the MQTT topic.
        
        Args:
            parent (tk.Widget): The parent widget for this frame.
            mqtt_util (MqttControllerUtility): The MQTT utility instance for communication.
        """
        current_function_name = inspect.currentframe().f_code.co_name

        if Local_Debug_Enable:
            debug_log(
                message=f"🖥️🟢 Initializing the {self.__class__.__name__}.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

        try:
            if 'config' in kwargs:
                kwargs.pop('config')
            super().__init__(parent, *args, **kwargs)

            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash
            self.mqtt_util = mqtt_util
            self.csv_export_util = CsvExportUtility(print_to_gui_func=console_log)
            self.data_flattener = MqttDataFlattenerUtility(print_to_gui_func=console_log)
            self.current_class_name = self.__class__.__name__

            self._apply_styles(theme_name=DEFAULT_THEME)

            # --- MQTT Topic Entry Section ---
            topic_frame = ttk.LabelFrame(self, text="MQTT Topic Filter")
            topic_frame.pack(fill=tk.X, padx=10, pady=5)
            self.topic_entry = ttk.Entry(topic_frame, width=80)
            self.topic_entry.insert(0, MQTT_TOPIC_FILTER)
            self.topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            # --- MQTT Message Log Table ---
            self.table_frame = ttk.Frame(self)
            self.table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

            horizontal_scrollbar = ttk.Scrollbar(self.table_frame, orient=tk.HORIZONTAL)
            self.commands_table = ttk.Treeview(self.table_frame, xscrollcommand=horizontal_scrollbar.set, show="headings", style="Custom.Treeview")
            horizontal_scrollbar.config(command=self.commands_table.xview)
            
            vertical_scrollbar = ttk.Scrollbar(self.table_frame, orient=tk.VERTICAL, command=self.commands_table.yview)
            self.commands_table.config(yscrollcommand=vertical_scrollbar.set)

            horizontal_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)
            vertical_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            self.commands_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            self.mqtt_util.add_subscriber(topic_filter=f"{self.topic_entry.get()}/#", callback_func=self._on_commands_message)

            # --- File Controls Section ---
            file_frame = ttk.LabelFrame(self, text="File")
            file_frame.pack(fill=tk.X, padx=10, pady=5)
           
            # Button: Export to CSV
            self.export_button = ttk.Button(
                file_frame,
                text="Export to CSV",
                command=self._export_table_data
            )
            self.export_button.pack(side=tk.LEFT, padx=5, pady=5)


            # --- Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)

            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Instrument Translator GUI initialized successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                    file=self.current_file,
                    version=self.current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
    
    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")

        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])
        style.configure('TButton', background=colors["accent"], foreground=colors["text"], padding=colors["padding"] * 5, relief=colors["relief"], borderwidth=colors["border_width"] * 2)
        style.map('TButton', background=[('active', colors["secondary"])])
        
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

    def _on_commands_message(self, topic, payload):
        """
        Callback for when an MQTT message is received on the commands topic. 
        It processes the message, flattens the data, and updates or adds rows to the table.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        if Local_Debug_Enable:
            debug_log(
                message=f"🖥️🔵 Received MQTT message on topic '{topic}'. Processing message...",
                file=self.current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
        
        try:
            pivoted_rows = self.data_flattener.process_mqtt_message_and_pivot(
                topic=topic,
                payload=payload,
                topic_prefix=self.topic_entry.get()
            )

            if pivoted_rows:
                # Dynamically configure columns ONLY IF this is the first data payload.
                if not self.commands_table["columns"]:
                    new_headers = list(pivoted_rows[0].keys())
                    self.commands_table["columns"] = tuple(new_headers)
                    for col in new_headers:
                        self.commands_table.heading(col, text=col.replace("_", " ").title())
                        self.commands_table.column(col, width=150, stretch=True)

                # Iterate through each row of the new data to update or add
                for row in pivoted_rows:
                    parameter_path = row.get("Parameter")
                    
                    # Find if a row with this Parameter already exists
                    item_id_to_update = None
                    for item_id in self.commands_table.get_children():
                        row_values = self.commands_table.item(item_id, 'values')
                        if row_values and row_values[0] == parameter_path:
                            item_id_to_update = item_id
                            break
                    
                    if item_id_to_update:
                        # Update the existing row
                        new_values = [row.get(col, '') for col in self.commands_table["columns"]]
                        self.commands_table.item(item_id_to_update, values=new_values)
                        console_log(f"✅ Updated existing row for '{parameter_path}'.")
                    else:
                        # Insert a new row if it doesn't exist
                        new_values = [row.get(col, '') for col in self.commands_table["columns"]]
                        self.commands_table.insert('', tk.END, values=new_values)
                        console_log(f"✅ Added new row for '{parameter_path}'.")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 The data table construction has failed! A plague upon this error: {e}",
                    file=self.current_file,
                    version=self.current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

    def _export_table_data(self):
        """
        Opens a file dialog and exports the current data from the table to a CSV file.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        if Local_Debug_Enable:
            debug_log(
                message=f"🖥️🔵 Preparing to export table data to CSV.",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

        try:
            file_path = filedialog.asksaveasfilename(
                initialdir=os.getcwd(),
                title="Save Table Data as CSV",
                filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
                defaultextension=".csv"
            )
            
            if file_path:
                data = []
                headers = self.commands_table["columns"]
                for item_id in self.commands_table.get_children():
                    row_values = self.commands_table.item(item_id, 'values')
                    row_dict = dict(zip(headers, row_values))
                    data.append(row_dict)
                    
                self.csv_export_util.export_data_to_csv(data=data, file_path=file_path)
                console_log(f"✅ Data successfully exported to {file_path}!")
            else:
                console_log("🟡 CSV export canceled by user.")

        except Exception as e:

            console_log(f"❌ Error in {current_function_name}: {e}")

            if Local_Debug_Enable:

                debug_log(

                    message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",

                    file=self.current_file,

                    version=self.current_version,

                    function=f"{self.__class__.__name__}.{current_function_name}",

                    console_print_func=console_log

                )

#####################################
### File: OPEN-AIR/display/left_50/top_100/4_presets/1_pusher/gui_pusher.py
#####################################
# display/left_50/top_100/tab_3_presets/sub_tab_1_pusher/gui_child_1_pusher.py
#
# A GUI frame with a button to manually load presets from a CSV file.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1
#
# MODIFIED: Simplified load logic to read the new, unified, normalized CSV structure
#           (Presets as Rows, Attributes as Columns) directly for stability.

import os
import inspect
import tkinter as tk
from tkinter import ttk, filedialog
import csv
import pathlib
import json

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from display.styling.style import THEMES, DEFAULT_THEME
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from workers.presets.worker_preset_pusher import PresetPusherWorker
import workers.utils.worker_project_paths as worker_project_paths

# --- Global Scope Variables ---
current_version = "20251127.000000.1"
current_version_hash = (20251127 * 0 * 1)
current_file = f"{os.path.basename(__file__)}"
# --- Constants ---
BUTTON_GRID_COLUMNS = 4
ALL_ATTRIBUTES = [
    "Active", "FileName", "NickName", "Start", "Stop", 
    "Center", "Span", "RBW", "VBW", "RefLevel", "Attenuation", 
    "MaxHold", "HighSens", "PreAmp", "Trace1Mode", "Trace2Mode", 
    "Trace3Mode", "Trace4Mode"
]

class PresetPusherGui(ttk.Frame):
    """
    A GUI frame that dynamically creates a grid of buttons for presets.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        """
        Initializes the Presets pusher GUI, loading data from CSV and creating buttons.
        """
        if 'config' in kwargs:
            kwargs.pop('config')
        super().__init__(parent, *args, **kwargs)
        self.pack(fill=tk.BOTH, expand=True)

        self.mqtt_util = mqtt_util
        self.preset_worker = PresetPusherWorker(mqtt_controller=self.mqtt_util)
        self.presets_data = []
        self.selected_preset_index = None
        self.buttons = []
        
        # UI Elements
        self.presets_frame = None
        self.info_frame = None
        self.info_labels = {}
        self.button_frame = None

        self._apply_styles(theme_name=DEFAULT_THEME)
        self._create_widgets()

        # Load data immediately
        self._load_presets_from_repo()
        
        console_log("✅ Celebration of success! The PresetPusherGui did initialize and load presets.")

    def _load_presets_from_repo(self):
        """
        Loads presets directly from the normalized CSV structure (Presets as Rows).
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        # 1. Resolve Path (Using getattr for safe access)
        filepath = None
        if hasattr(worker_project_paths, 'PRESET_REPO_PATH'):
            filepath = getattr(worker_project_paths, 'PRESET_REPO_PATH')
        
        if not filepath or not pathlib.Path(filepath).is_file():
            console_log("❌ Preset repository file not found. Starting with no presets.")
            return

        debug_log(
            message=f"🛠️🟢 Automatically loading normalized preset data from repository: {filepath}",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        self.presets_data = []
        try:
            with open(filepath, mode='r', newline='', encoding='utf-8') as csv_file:
                # Assuming the file is now in the normalized format (Preset rows, Attribute columns)
                csv_reader = csv.DictReader(csv_file)

                for row_dict in csv_reader:
                    
                    # Ensure row has the minimal required keys (Parameter/Preset_Key and Active)
                    if 'Parameter' in row_dict:
                        row_dict['Preset_Key'] = row_dict.pop('Parameter')
                    
                    # We treat the row dictionary as the monolithic preset dictionary
                    if str(row_dict.get('Active', 'false')).lower() == 'true':
                        self.presets_data.append(row_dict)
                    
            
            # Sort data by NickName numerically if possible, otherwise alphabetically
            self.presets_data.sort(key=lambda x: (x.get('NickName', '').isdigit(), int(x.get('NickName', '')) if x.get('NickName', '').isdigit() else x.get('NickName', '')))

            console_log(f"✅ Loaded {len(self.presets_data)} active presets from repository.")
            
            self._rebuild_gui()
            
        except Exception as e:
            console_log(f"❌ Error loading presets from repository: {e}")
            debug_log(
                message=f"🛠️🔴 Arrr, the code be capsized! Failed to load presets! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
    def _create_widgets(self):
        """
        Creates the main widgets, now removing the manual Load Button.
        """
        # Frame for the Preset Buttons
        self.presets_frame = ttk.LabelFrame(self, text="Available Presets")
        self.presets_frame.pack(fill=tk.X, padx=10, pady=5, side=tk.TOP)

        self.button_frame = ttk.Frame(self.presets_frame)
        self.button_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Frame for the Preset Details
        self.info_frame = ttk.LabelFrame(self, text="Selected Preset Details")
        self.info_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5, side=tk.BOTTOM)
        self.info_frame.grid_columnconfigure(0, weight=1)
        self.info_frame.grid_columnconfigure(1, weight=1)
        
        self._setup_info_labels()


    def _rebuild_gui(self):
        """
        Clears existing buttons and recreates them based on the newly loaded data.
        """
        # Clear existing buttons
        for button in self.buttons:
            button.destroy()
        self.buttons.clear()

        # Create new buttons
        for i, preset in enumerate(self.presets_data):
            # Pass the monolithic dictionary for processing
            button_text = self._format_button_text(preset)
            button = ttk.Button(
                self.button_frame,
                text=button_text,
                style='Custom.TButton',
                command=lambda p=preset: self.select_preset(p)
            )
            row = i // BUTTON_GRID_COLUMNS
            col = i % BUTTON_GRID_COLUMNS
            button.grid(row=row, column=col, padx=5, pady=5, sticky="ew")
            self.buttons.append(button)

        for i in range(BUTTON_GRID_COLUMNS):
            self.button_frame.grid_columnconfigure(i, weight=1)

        # Clear info labels
        for value_var in self.info_labels.values():
            value_var.set("")

    def _setup_info_labels(self):
        """
        Initializes the StringVar objects for the info labels.
        """
        for widget in self.info_frame.winfo_children():
            widget.destroy()
            
        row_count = 0
        for key in self._get_info_keys():
            label_text = f"{key}:"
            value_var = tk.StringVar(value="")
            
            label_widget = ttk.Label(self.info_frame, text=label_text)
            label_widget.grid(row=row_count, column=0, sticky="w", padx=5, pady=2)
            
            value_label = ttk.Label(self.info_frame, textvariable=value_var)
            value_label.grid(row=row_count, column=1, sticky="w", padx=5, pady=2)
            
            self.info_labels[key] = value_var
            row_count += 1
            
    def _get_info_keys(self):
        """Returns the list of keys to display in the info box, sorted by importance."""
        return ALL_ATTRIBUTES 

    def _format_button_text(self, preset):
        """
        Formats the text for each preset button.
        """
        nickname = preset.get("NickName", "N/A")
        start = preset.get("Start", "N/A")
        stop = preset.get("Stop", "N/A")
        center = preset.get("Center", "N/A")
        span = preset.get("Span", "N/A")

        return (
            f"{nickname}\n"
            f"ST: {start} / STP: {stop}\n"
            f"C: {center} / SP: {span}"
        )

    def select_preset(self, selected_preset):
        """
        This function is called when a preset button is clicked. It updates the
        displayed information and triggers the `selected_preset` function.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Reset previous selection style
        for button in self.buttons:
            button.config(style='Custom.TButton')
            
        # Find and apply new selection style
        for i, preset in enumerate(self.presets_data):
            if preset == selected_preset:
                self.buttons[i].config(style='Custom.Selected.TButton')
                break

        self._update_info_labels(selected_preset)
        
        # Build the ordered values list as required by the worker's API
        # The worker expects the preset key + all attributes.
        ordered_values = [selected_preset.get('Preset_Key', '')] 
        ordered_values.extend([selected_preset.get(key, '') for key in self._get_info_keys()]) 
        
        self.preset_worker.Tune_to_preset(ordered_values)
        
    def _update_info_labels(self, preset):
        """
        Updates the labels in the info box with the selected preset's details.
        """
        for key, value_var in self.info_labels.items():
            value_var.set(preset.get(key, "N/A"))

    def selected_preset(self, preset_values):
        """
        This is the core function called when a preset is selected.
        It prints the full list of values to the console.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🛠️🟢 The 'selected_preset' function has been called!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        console_log("--- Selected Preset Values ---")
        console_log(str(preset_values))
        console_log("------------------------------")
        
    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])
        
        style.configure('Custom.TButton',
                        background=colors["button_style_actuator"]["background"],
                        foreground=colors["button_style_actuator"]["foreground"],
                        padding=colors["padding"] * 5,
                        relief=colors["relief"],
                        borderwidth=colors["border_width"] * 2)

        style.map('Custom.TButton',
                  background=[('pressed', colors["button_style_actuator"]["Button_Pressed_Bg"]),
                              ('active', colors["button_style_actuator"]["Button_Hover_Bg"])],
                  foreground=[('pressed', colors["button_style_actuator"]["foreground"])])

        style.configure('Custom.Selected.TButton',
                        background=colors["button_style_toggle"]["Button_Selected_Bg"],
                        foreground=colors["button_style_toggle"]["Button_Selected_Fg"],
                        padding=colors["padding"] * 5,
                        relief=tk.SUNKEN,
                        borderwidth=colors["border_width"] * 2)
        
        style.map('Custom.Selected.TButton',
                  background=[('pressed', colors["button_style_toggle"]["Button_Pressed_Bg"]),
                              ('active', colors["button_style_toggle"]["Button_Hover_Bg"])],
                  foreground=[('pressed', colors["button_style_toggle"]["Button_Selected_Fg"])])

#####################################
### File: OPEN-AIR/display/left_50/top_100/4_presets/2_editor/gui_editor.py
#####################################
# display/left_50/top_100/4_presets/2_editor/gui_editor.py
#
# This file (gui_editor.py) provides the PresetEditorGUI component for editing preset data from a CSV, normalized for table display.
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 44 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#


import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
from tkinter import filedialog
import csv
import json
from decimal import Decimal
from tkinter import TclError

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
from workers.exporters.worker_file_csv_export import CsvExportUtility
from display.styling.style import THEMES, DEFAULT_THEME
import workers.utils.worker_project_paths

Local_Debug_Enable = True




# --- Global Scope Variables ---
CURRENT_DATE = 20251129
CURRENT_TIME = 222500
REVISION_NUMBER = 1
current_version = "20251127.000000.1"
current_version_hash = 20251127 * 0 * 1
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("/", "/")
# --- No Magic Numbers (as per your instructions) ---
MQTT_TOPIC_FILTER = "OPEN-AIR/repository/presets"
# Fallback path definition (actual path will be dynamically imported)
PRESET_REPO_PATH_FALLBACK = pathlib.Path("DATA/PRESET.CSV")

# FIXED LIST OF ATTRIBUTES (New static columns)
ATTRIBUTES = [
    "Active", "FileName", "NickName", "Start", "Stop", 
    "Center", "Span", "RBW", "VBW", "RefLevel", "Attenuation", 
    "MaxHold", "HighSens", "PreAmp", "Trace1Mode", "Trace2Mode", 
    "Trace3Mode", "Trace4Mode"
]
# The first column is always 'Parameter' (The Preset Key, e.g., PRESET_001)
HEADERS = ["Parameter"] + ATTRIBUTES 
# Fixed column width for all columns
COLUMN_WIDTH = 150


class PresetEditorGUI(ttk.Frame):
    """
    A GUI component for displaying and editing preset data from a CSV,
    normalized for table display.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        current_function_name = inspect.currentframe().f_code.co_name

        if Local_Debug_Enable:
            debug_log(
                message=f"🖥️🟢 Initializing the {self.__class__.__name__}. Normalized view active.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

        try:
            if 'config' in kwargs:
                kwargs.pop('config')
            super().__init__(parent, *args, **kwargs)

            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash
            self.mqtt_util = mqtt_util
            self.csv_export_util = CsvExportUtility(print_to_gui_func=console_log)
            # Normalized data model: {preset_key: {attribute: value, ...}, ...}
            self.normalized_data = {} 
            self.current_class_name = self.__class__.__name__

            self._apply_styles(theme_name=DEFAULT_THEME)

            # --- MQTT Message Log Table ---
            self.table_frame = ttk.Frame(self)
            self.table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

            horizontal_scrollbar = ttk.Scrollbar(self.table_frame, orient=tk.HORIZONTAL)
            self.commands_table = ttk.Treeview(self.table_frame, 
                                               xscrollcommand=horizontal_scrollbar.set, 
                                               show="headings", 
                                               columns=HEADERS, 
                                               style="Custom.Treeview")
            horizontal_scrollbar.config(command=self.commands_table.xview)
            
            vertical_scrollbar = ttk.Scrollbar(self.table_frame, orient=tk.VERTICAL, command=self.commands_table.yview)
            self.commands_table.config(yscrollcommand=vertical_scrollbar.set)

            horizontal_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)
            vertical_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            self.commands_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            # --- Create headers based on HEADERS (Columns) ---
            self._create_headers()
            
            self.mqtt_util.add_subscriber(topic_filter=f"{MQTT_TOPIC_FILTER}/#", callback_func=self._on_commands_message) 

            # --- NEW: Bind double-click event for cell editing ---
            self.commands_table.bind("<Double-1>", self._on_edit_cell)

            # --- Persistence Bindings (Load on Init, Save on Exit) ---
            parent_widget = parent
            while not isinstance(parent_widget, tk.Tk):
                if isinstance(parent_widget, ttk.Notebook):
                    parent_widget.bind("<<NotebookTabChanged>>", self._on_tab_change_save_data, add="+ ")
                    break
                parent_widget = parent_widget.master

            # --- File Controls Section ---
            file_frame = ttk.LabelFrame(self, text="File")
            file_frame.pack(fill=tk.X, padx=10, pady=5)
           
            # Button: Export to CSV (Normalized, Flat Structure)
            self.export_button = ttk.Button(
                file_frame,
                text="Export to CSV (Normalized)",
                command=self._export_table_data
            )
            self.export_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Button: Save to Internal Repository (Original Transposed Structure)
            # UPDATED TEXT to reflect the new normalized save format.
            self.save_repo_button = ttk.Button(
                file_frame,
                text="Save to Internal Repo (Normalized)",
                command=lambda: self._save_data_to_csv_from_normalized_model(file_path=self._resolve_preset_repo_path())
            )
            self.save_repo_button.pack(side=tk.LEFT, padx=5, pady=5)


            # --- Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)

            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Preset Editor GUI initialized successfully!")
            
            # --- Load initial data from CSV and render ---
            self._load_data_from_csv()
            self._update_treeview()

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                    file=self.current_file,
                    version=self.current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
    
    def _create_headers(self):
        """
        Creates all the columns in the Treeview and configures them with a fixed width.
        """
        self.commands_table["columns"] = HEADERS
        
        for col_name in HEADERS:
            display_name = col_name.replace('_', ' ').title()
            
            self.commands_table.heading(col_name, text=display_name, command=lambda c=col_name: self._sort_treeview(c, False))
            
            # All columns are fixed width 150px
            if col_name == "Parameter":
                self.commands_table.column(col_name, width=150, stretch=False, anchor='w')
            else:
                self.commands_table.column(col_name, width=COLUMN_WIDTH, stretch=False, anchor='center')
            
    def _load_data_from_csv(self):
        """
        Reads the original presets.csv, extracts preset data, and populates the 
        normalized_data dictionary.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        # 1. Resolve the correct path 
        csv_file_path = self._resolve_preset_repo_path()
        
        if not csv_file_path.exists():
            console_log("🟡 presets.csv not found. Starting with an empty table.")
            return

        try:
            with open(csv_file_path, mode='r', newline='', encoding='utf-8') as csv_file:
                csv_reader = csv.DictReader(csv_file)
                
                # Clear existing data
                self.normalized_data = {}

                for row in csv_reader:
                    preset_key = row.get("Parameter")
                    if preset_key:
                        self.normalized_data[preset_key] = {"Parameter": preset_key}
                        for attribute in ATTRIBUTES:
                            # Directly assign attributes from CSV, converting 'Active' to boolean
                            value = row.get(attribute, 'N/A')
                            if attribute == "Active":
                                self.normalized_data[preset_key][attribute] = value.lower() == 'true'
                            else:
                                self.normalized_data[preset_key][attribute] = value
                        
            console_log(f"✅ Data successfully loaded from {csv_file_path} and normalized in memory.")
        except Exception as e:
            console_log(f"❌ Error loading data from presets.csv: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 Failed to load and normalize CSV data. The error be: {e}",
                    file=self.current_file,
                    version=self.current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
            
    def _update_treeview(self):
        """
        Re-populates the Treeview from the internal normalized_data model.
        """
        current_function_name = inspect.currentframe().f_code.co_name

        # Clear existing rows
        self.commands_table.delete(*self.commands_table.get_children())
        
        # Insert new rows
        for preset_key in sorted(self.normalized_data.keys()):
            row_data = self.normalized_data[preset_key]
            
            # Create a list of values matching the column order (HEADERS)
            row_values = [row_data.get(header, 'N/A') for header in HEADERS]
            
            # Use the preset_key as the item ID (iid) for easy lookups
            self.commands_table.insert("", tk.END, iid=preset_key, values=row_values)

        if Local_Debug_Enable:
            debug_log(
                message=f"🖥️✅ Treeview updated with {len(self.normalized_data)} preset rows.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_commands_message(self, topic, payload):
        """
        Callback for when an MQTT message is received.
        Updates the internal normalized_data model and triggers a UI refresh and save.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        try:
            topic_parts = topic.split('/')
            
            # --- Case 1: Monolithic Preset Update (from another component/device) ---
            if len(topic_parts) == len(MQTT_TOPIC_FILTER.split('/')) + 1 and topic_parts[-2] == "presets":
                preset_key = topic_parts[-1]
                
                # 1. Check for a delete message (empty payload or null value)
                if payload == "" or payload.lower() == 'null':
                    self._delete_preset(preset_key)
                    # Trigger immediate save after deletion
                    self._save_data_to_csv_from_normalized_model(file_path=self._resolve_preset_repo_path())
                    return

                # 2. Parse the monolithic JSON blob
                preset_data_str = json.loads(payload)["value"]
                if preset_data_str.startswith('"') and preset_data_str.endswith('"'):
                    preset_data_str = preset_data_str.strip('"')

                preset_data = json.loads(preset_data_str)
                
                # 3. Update normalized_data model
                self.normalized_data[preset_key] = {"Parameter": preset_key}
                for attribute in ATTRIBUTES:
                    self.normalized_data[preset_key][attribute] = preset_data.get(attribute, 'N/A')
                    
                console_log(f"✅ Updated preset '{preset_key}' from monolithic MQTT topic.")
                
                # Trigger immediate save after successful update
                self._save_data_to_csv_from_normalized_model(file_path=self._resolve_preset_repo_path())
                
            # --- Case 2: Single Field Update (robustness for external single-field updates) ---
            elif len(topic_parts) == len(MQTT_TOPIC_FILTER.split('/')) + 2 and topic_parts[-3] == "presets":
                preset_key = topic_parts[-2]
                attribute = topic_parts[-1] 
                payload_value = json.loads(payload)["value"]
                
                # 1. Update normalized_data model
                if preset_key in self.normalized_data and attribute in self.normalized_data[preset_key]:
                    self.normalized_data[preset_key][attribute] = payload_value
                    console_log(f"✅ Updated attribute '{attribute}' for preset '{preset_key}'.")
                    
                # Trigger immediate save after single field update
                self._save_data_to_csv_from_normalized_model(file_path=self._resolve_preset_repo_path())
                
            # --- Final steps ---
            self._update_treeview()

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 Update failed! The error be: {e}",
                    file=self.current_file,
                    version=self.current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

    def _delete_preset(self, preset_key):
        """Removes a preset from the internal model and triggers a UI refresh."""
        if preset_key in self.normalized_data:
            del self.normalized_data[preset_key]
        self._update_treeview()

    def _on_edit_cell(self, event):
        """
        Event handler for a double-click on a table cell. Triggers **republish of the whole blob**
        after updating a single cell in the internal model.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        item_id = self.commands_table.identify_row(event.y)
        column_id = self.commands_table.identify_column(event.x)
        
        # Do not edit column #0 or the first column ('Parameter')
        if not item_id or not column_id or column_id == '#0' or column_id == '#1': 
            return 

        try:
            # 1. Identify the Preset (Row ID) and Attribute (Column Header)
            preset_key = item_id 
            col_identifier = self.commands_table.heading(column_id, 'id')
            attribute = col_identifier 
            current_value = self.commands_table.set(item_id, attribute)
            
            # 2. Create the editor widget (standard process)
            bbox = self.commands_table.bbox(item_id, column_id)
            if not bbox: return
            x, y, width, height = bbox
            edit_entry = ttk.Entry(self.commands_table, style="Markers.TEntry", name="cell_editor")
            edit_entry.place(x=x, y=y, width=width, height=height)
            edit_entry.insert(0, current_value)
            edit_entry.focus_set()
            edit_entry.select_range(0, tk.END)

            def on_update_cell(event):
                new_value = edit_entry.get()
                
                try:
                    # Update the internal model immediately
                    if preset_key in self.normalized_data:
                        self.normalized_data[preset_key][attribute] = new_value
                    
                    # 1. Rebuild the monolithic JSON blob from the updated internal model
                    updated_preset_data = {}
                    for attr in ATTRIBUTES:
                        updated_preset_data[attr] = self.normalized_data[preset_key].get(attr, 'N/A')
                        
                    monolithic_blob = json.dumps(updated_preset_data)
                    
                    # 2. Publish the monolithic blob to the single preset topic (triggers Case 1 logic)
                    topic = f"{MQTT_TOPIC_FILTER}/{preset_key}"
                    self.mqtt_util.publish_message(topic=topic, subtopic="", value=monolithic_blob, retain=True)

                    console_log(f"✅ Full blob for '{preset_key}' republished after '{attribute}' edit.")
                except Exception as e:
                    console_log(f"❌ Error sending cell update to MQTT. Error: {e}")

                edit_entry.destroy()
            
            edit_entry.bind("<Return>", on_update_cell)
            edit_entry.bind("<FocusOut>", on_update_cell)

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")

    def _export_table_data(self):
        """
        Opens a file dialog and exports the current data from the internal model to a new CSV file 
        in the clean, normalized format (rows are presets, columns are attributes), matching the table exactly.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        if Local_Debug_Enable:
            debug_log(
                message=f"🖥️🔵 Preparing to export table data to CSV.",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

        try:
            file_path = filedialog.asksaveasfilename(
                initialdir=os.getcwd(),
                title="Save Table Data as CSV (Normalized)",
                filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
                defaultextension=".csv"
            )
            
            if file_path:
                # Use the core saving logic, passing the path for user export
                self._save_data_to_csv_from_normalized_model(file_path=file_path)
                console_log(f"✅ Data successfully exported to {file_path}!")
            else:
                console_log("🟡 CSV export canceled by user.")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            
    # --- CORE FIX IMPLEMENTATION: Unifying the save logic ---
    def _save_data_to_csv_from_normalized_model(self, file_path: pathlib.Path):
        """
        Saves the normalized table data (Preset rows, Attribute columns) directly to a CSV,
        matching the table view exactly.
        
        This function is now the *only* core saving mechanism, used for both 
        user exports and internal repository persistence, ensuring identical formats.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        if Local_Debug_Enable:
            debug_log(
                message=f"💾🟢 Saving normalized data (table format) to: '{file_path}'",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
        
        try:
            # 1. Prepare the data for the normalized CSV structure (table view)
            final_csv_rows = []
            for preset_key in sorted(self.normalized_data.keys()):
                 final_csv_rows.append(self.normalized_data[preset_key])
                
            # 2. Write to the CSV file
            csv_headers = HEADERS # ["Parameter", "Active", "FileName", ...]
            
            with open(file_path, 'w', newline='', encoding='utf-8') as csvfile:
                writer = csv.DictWriter(csvfile, fieldnames=csv_headers) 
                
                writer.writeheader()
                writer.writerows(final_csv_rows)

            if file_path == self._resolve_preset_repo_path():
                 console_log(f"✅ Internal preset repository synchronized (Normalized format).")
            else:
                console_log(f"✅ Table data exported to '{file_path}'.")

        except Exception as e:
            console_log(f"❌ Error saving normalized CSV: {e}")
            if Local_Debug_Enable:
                debug_log(
                    message=f"❌🔴 Failed to save normalized CSV. The error be: {e}",
                    file=self.current_file,
                    version=self.current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
            
    def _on_tab_change_save_data(self, event):
        """Saves data to the internal repository path when the tab is exited."""
        current_function_name = inspect.currentframe().f_code.co_name
        
        tab_widget = event.widget
        selected_tab = tab_widget.select()
        
        current_tabs = [tab_widget.tab(i, "text") for i in tab_widget.tabs()]
        if not current_tabs:
            return

        try:
            current_tab_index = tab_widget.index(selected_tab)
        except TclError:
            return

        if current_tabs[current_tab_index] != "Preset Editor": 
            # Now calls the core, unified save function, ensuring the repo file is normalized.
            self._save_data_to_csv_from_normalized_model(file_path=self._resolve_preset_repo_path())
            if Local_Debug_Enable:
                debug_log(
                    message="💾🔵 Saving presets on tab exit.",
                    file=self.current_file,
                    version=self.current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )
            
    def _resolve_preset_repo_path(self):
        """Attempts to import the constant PRESET_REPO_PATH, falling back if necessary."""
        try:
            # Use the imported module
            import workers.worker_project_paths
            if hasattr(workers.worker_project_paths, 'PRESET_REPO_PATH'):
                return workers.worker_project_paths.PRESET_REPO_PATH
        except Exception:
            return PRESET_REPO_PATH_FALLBACK


    def _sort_treeview(self, column_name, ascending):
        """
        Sorts the treeview rows based on the values in the selected column.
        """
        preset_names = list(self.commands_table["columns"])
        try:
            col_index = preset_names.index(column_name)
        except ValueError:
            return 

        l = [(self.commands_table.set(k, column_name), k) for k in self.commands_table.get_children('')]
        
        l.sort(key=lambda x: str(x[0]), reverse=not ascending)
        
        for index, (val, k) in enumerate(l):
            self.commands_table.move(k, '', index)

        self.sort_column = column_name
        self.sort_direction = ascending

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")

        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])
        style.configure('TButton', background=colors["accent"], foreground=colors["text"], padding=colors["padding"] * 5, relief=colors["relief"], borderwidth=colors["border_width"] * 2)
        style.map('TButton', background=[('active', colors["secondary"])])
        
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

#####################################
### File: OPEN-AIR/display/left_50/top_100/4_presets/3_collector/gui_collector.py
#####################################
# tabs/Presets/tab_presets_child_device.py
#
# A simplified GUI component for managing presets on an instrument. This file
# serves as the "view," with a single button that triggers a command in the
# PresetFromDeviceWorker.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20251127.000000.1

import tkinter as tk
from tkinter import ttk, filedialog, simpledialog
import inspect
import os
from collections import defaultdict
from datetime import datetime

# --- Module Imports ---
from display.logger import debug_log, console_log, log_visa_command
from display.styling.style import THEMES, DEFAULT_THEME
from workers.presets.worker_preset_from_device import PresetFromDeviceWorker
from workers.mqtt.worker_mqtt_controller_util import MqttControllerUtility
import pathlib


# --- Global Scope Variables (as per your instructions) ---
current_version = "20251127.000000.1"
current_version_hash = (20251127 * 0 * 1)
current_file = f"{os.path.basename(__file__)}"

class DevicePresetsTab(ttk.Frame):
    """
    A minimal GUI component for the Presets Tab with a single button.
    """
    def __init__(self, parent, mqtt_util: MqttControllerUtility = None, *args, **kwargs):
        if 'config' in kwargs:
            kwargs.pop('config')
        super().__init__(parent, *args, **kwargs)

        self.mqtt_util = mqtt_util
        self.preset_worker = PresetFromDeviceWorker(mqtt_util=self.mqtt_util)
        
        self.collect_presets_button = None

        self.create_widgets()
        self.setup_layout()

    def create_widgets(self):
        self._apply_styles(theme_name=DEFAULT_THEME)
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(0, weight=1)

        main_frame = ttk.Frame(self)
        main_frame.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")
        main_frame.grid_columnconfigure(0, weight=1)

        self.collect_presets_button = ttk.Button(main_frame,
                                                 text="Collect presets",
                                                 command=self._on_collect_button_click,
                                                 style='Blue.TButton')
        self.collect_presets_button.grid(row=0, column=0, padx=5, pady=5, sticky="ew")

    def setup_layout(self):
        pass

    def _apply_styles(self, theme_name: str):
        """Applies a theme based on the central style definition."""
        colors = THEMES.get(theme_name)
        style = ttk.Style(self)
        style.theme_use("clam")
        style.configure('TFrame', background=colors["bg"])
        style.configure('TButton', background=colors["accent"], foreground=colors["text"])
        style.map('Blue.TButton',
                  background=[('!active', colors['accent']), ('active', colors['secondary'])])

    def _on_collect_button_click(self):
        """
        Calls the worker to initiate the process of collecting presets from the device.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 'Collect presets' button clicked. Initiating worker task.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        self.preset_worker.get_presets_from_device()
        console_log("✅ Preset collection task initiated.")

# Standalone block for testing purposes.
if __name__ == "__main__":
    root = tk.Tk()
    root.title("Device Presets Tab Test")
    
    class MockMqttUtil:
        def __init__(self):
            self.subscribers = defaultdict(list)
        def add_subscriber(self, topic_filter, callback_func):
            self.subscribers[topic_filter].append(callback_func)
        def publish_message(self, topic, subtopic, value, retain=False):
            full_topic = f"{topic}/{subtopic}" if subtopic else topic
            print(f"Mock publish: {full_topic} -> {value}")
            
    mqtt_utility = MockMqttUtil()
    app_frame = DevicePresetsTab(parent=root, mqtt_util=mqtt_utility)
    root.mainloop()

#####################################
### File: OPEN-AIR/display/splash/splash_screen.py
#####################################
# display/splash/splash_screen.py
#
# This file (splash_screen.py) provides the SplashScreen class for displaying a customizable splash screen on application startup.
# A complete and comprehensive pre-amble that describes the file and the functions within.
# The purpose is to provide clear documentation and versioning.
#
# The hash calculation drops the leading zero from the hour (e.g., 08 -> 8)
# As the current hour is 20, no change is needed.

Current_Date = 20251213  ##Update on the day the change was made
Current_Time = 120000  ## update at the time it was edited and compiled
Current_iteration = 44 ## a running version number - incriments by one each time 

current_version = f"{Current_Date}.{Current_Time}.{Current_iteration}"
current_version_hash = (Current_Date * Current_Time * Current_iteration)


# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#

import tkinter as tk
from tkinter import ttk
import os
import sys
import pathlib
import threading
import queue # For thread-safe status updates

# --- Path Setup ---
# This defines the absolute, true root path of the project, irrespective of the CWD.
SPLASH_ROOT_DIR = pathlib.Path(__file__).resolve().parent.parent.parent

# Assuming sys.path is already set up by main.py
from display.logger import debug_log, console_log, log_visa_command

# --- Global Scope Variables ---
current_version = "UNKNOWN_VERSION.000000.0" # Placeholder, update as needed
current_version_hash = 0
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")
Local_Debug_Enable = True

try:
    from PIL import Image, ImageTk
    PIL_AVAILABLE = True
except ImportError:
    Image = None
    ImageTk = None
    PIL_AVAILABLE = False
    if Local_Debug_Enable:
        debug_log(
            message="WARNING: Pillow (PIL) not available. Splash screen will not display image.",
            file=current_file,
            version=current_version,
            function="SplashScreen Module", # Module level function for logging
            console_print_func=console_log
        )

class SplashScreen(threading.Thread):
    def __init__(self):
        super().__init__()
        if Local_Debug_Enable:
            debug_log(
                message="DEBUG: Entering SplashScreen.__init__().",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.__init__",
                console_print_func=console_log
            )
        self.daemon = True # Allow main program to exit even if splash is still running
        self.splash_root = None # Will be created in the thread
        self.splash_window = None
        self.status_label = None
        self.status_queue = queue.Queue() # For thread-safe status updates
        self._fade_animation_id = None # To store after_id for fade animation
        self._status_update_id = None # To store after_id for status updates
        self._destroyed = False # Flag to prevent multiple destructions

        # --- Faked Status Messages (initial set) ---
        self.status_messages_list = [
            "Created by: Anthony Peter Kuzub",
            "www.like.audio",
            "Initializing...",
            "Loading GUI modules...",
        ]
        self.current_status_index = 0

        # Enqueue initial status messages
        for msg in self.status_messages_list:
            self.status_queue.put(msg)

        if Local_Debug_Enable:
            debug_log(
                message="DEBUG: Exiting SplashScreen.__init__().",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.__init__",
                console_print_func=console_log
            )

        self.splash_image = None
        
    def _init_ui(self):
        if Local_Debug_Enable:
            debug_log(
                message="DEBUG: Entering SplashScreen._init_ui().",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}._init_ui",
                console_print_func=console_log
            )
        self.splash_root = tk.Tk()
        self.splash_root.withdraw()
        
        self.splash_window = tk.Toplevel(self.splash_root)
        self.splash_window.overrideredirect(True)
        self.splash_window.attributes('-alpha', 0.0)

        image_path = None # Initialize image_path to avoid UnboundLocalError
        if PIL_AVAILABLE:
            try:
                image_path = os.path.join(SPLASH_ROOT_DIR, 'display', 'splash', 'OPEN AIR LOGO.png')
                pil_image = Image.open(image_path)
                self.splash_image = ImageTk.PhotoImage(pil_image)
            except Exception as e:
                if Local_Debug_Enable:
                    debug_log(
                        message=f"Splash screen error: Could not load image '{image_path}'. {e}",
                        file=current_file,
                        version=current_version,
                        function=f"{self.__class__.__name__}._init_ui",
                        console_print_func=console_log
                    )
                self.splash_image = None
        
        # Widgets and sizing based on image availability
        if self.splash_image:
            label = tk.Label(self.splash_window, image=self.splash_image, bd=0)
            label.pack()
            img_width = self.splash_image.width()
            img_height = self.splash_image.height()
        else:
            # Fallback text label if image not loaded
            label = tk.Label(self.splash_window, text="OPEN-AIR", font=("Helvetica", 24, "bold"), fg="white", bg="black")
            label.pack(expand=True, fill=tk.BOTH)
            # Use a default size for text-only splash
            img_width = 400 
            img_height = 200
            self.splash_window.config(bg="black") # Set background for text label if no image

        status_bar_height = 30 
        total_height = img_height + status_bar_height

        screen_width = self.splash_root.winfo_screenwidth()
        screen_height = self.splash_root.winfo_screenheight()
        x = (screen_width // 2) - (img_width // 2)
        y = (screen_height // 2) - (total_height // 2)
        self.splash_window.geometry(f'{img_width}x{total_height}+{x}+{y}')

        # Status Bar
        self.status_label = tk.Label(self.splash_window, text="", fg="white", bg="black", font=("Helvetica", 10))
        self.status_label.pack(fill=tk.X, side=tk.BOTTOM)
        if Local_Debug_Enable:
            debug_log(
                message="DEBUG: Exiting SplashScreen._init_ui().",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}._init_ui",
                console_print_func=console_log
            )

    def _update_status(self):
        if Local_Debug_Enable:
            debug_log(
                message="DEBUG: Entering _update_status().",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}._update_status",
                console_print_func=console_log
            )
        if not self.splash_window or not self.splash_window.winfo_exists():
            if Local_Debug_Enable:
                debug_log(
                    message="DEBUG: Splash window does not exist, stopping status updates.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}._update_status",
                    console_print_func=console_log
                )
            return

        try:
            message = self.status_queue.get_nowait()
            self.status_label.config(text=message)
            self.current_status_index += 1
            # Reschedule itself
            self._status_update_id = self.splash_window.after(800, self._update_status)
        except queue.Empty:
            # If no new messages, just reschedule to check again
            self._status_update_id = self.splash_window.after(800, self._update_status)
        
        if Local_Debug_Enable:
            debug_log(
                message="DEBUG: Exiting _update_status().",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}._update_status",
                console_print_func=console_log
            )

    def _fade_in(self, alpha=0.0):
        if Local_Debug_Enable:
            debug_log(
                message=f"DEBUG: Entering _fade_in(). Alpha: {alpha}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}._fade_in",
                console_print_func=console_log
            )
        if not self.splash_window or not self.splash_window.winfo_exists():
            if Local_Debug_Enable:
                debug_log(
                    message="DEBUG: Splash window does not exist, stopping fade-in.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}._fade_in",
                    console_print_func=console_log
                )
            return

        if alpha <= 1.0:
            self.splash_window.attributes('-alpha', alpha)
            self._fade_animation_id = self.splash_window.after(20, lambda: self._fade_in(alpha + 0.05))
        else:
            self._start_status_updates()
        if Local_Debug_Enable:
            debug_log(
                message=f"DEBUG: Exiting _fade_in(). Alpha: {alpha}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}._fade_in",
                console_print_func=console_log
            )

    def _start_status_updates(self):
        # Start status updates after fade-in is complete
        if self.splash_window and self.splash_window.winfo_exists():
            self._status_update_id = self.splash_window.after(100, self._update_status)

    def _fade_out(self, alpha=1.0):
        if Local_Debug_Enable:
            debug_log(
                message=f"DEBUG: Entering _fade_out(). Alpha: {alpha}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}._fade_out",
                console_print_func=console_log
            )
        if not self.splash_window or not self.splash_window.winfo_exists():
            if Local_Debug_Enable:
                debug_log(
                    message="DEBUG: Splash window does not exist, stopping fade-out.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}._fade_out",
                    console_print_func=console_log
                )
            return

        if alpha >= 0.0:
            self.splash_window.attributes('-alpha', alpha)
            self._fade_animation_id = self.splash_window.after(20, lambda: self._fade_out(alpha - 0.05))
        else:
            self._destroy_splash()
        if Local_Debug_Enable:
            debug_log(
                message=f"DEBUG: Exiting _fade_out(). Alpha: {alpha}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}._fade_out",
                console_print_func=console_log
            )

    def _destroy_splash(self):
        if Local_Debug_Enable:
            debug_log(
                message="DEBUG: Entering _destroy_splash().",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}._destroy_splash",
                console_print_func=console_log
            )
        if self._destroyed:
            if Local_Debug_Enable:
                debug_log(
                    message="DEBUG: _destroy_splash() called, but splash screen already destroyed.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}._destroy_splash",
                    console_print_func=console_log
                )
            return

        if self.splash_root and self.splash_root.winfo_exists():
            # Cancel any pending after calls
            if self._fade_animation_id:
                self.splash_root.after_cancel(self._fade_animation_id)
            if self._status_update_id:
                self.splash_root.after_cancel(self._status_update_id)
            try:
                self.splash_root.destroy()
            except tk.TclError as e:
                if Local_Debug_Enable:
                    debug_log(
                        message=f"ERROR: Tkinter TclError during splash screen destruction: {e}",
                        file=current_file,
                        version=current_version,
                        function=f"{self.__class__.__name__}._destroy_splash",
                        console_print_func=console_log
                    )
            finally:
                self._destroyed = True # Set the flag even if an error occurred during destroy
        else:
            self._destroyed = True # If root doesn't exist or already gone, mark as destroyed

        if Local_Debug_Enable:
            debug_log(
                message="DEBUG: Exiting _destroy_splash()..",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}._destroy_splash",
                console_print_func=console_log
            )

    def run(self):
        if Local_Debug_Enable:
            debug_log(
                message="DEBUG: Entering SplashScreen.run() thread.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.run",
                console_print_func=console_log
            )
        self._init_ui()
        self.splash_window.after(10, self._fade_in)
        self.splash_root.mainloop()
        if Local_Debug_Enable:
            debug_log(
                message="DEBUG: Exiting SplashScreen.run() thread.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.run",
                console_print_func=console_log
            )

    def hide(self):
        if Local_Debug_Enable:
            debug_log(
                message="DEBUG: Request to hide splash screen received.",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.hide",
                console_print_func=console_log
            )
        if self.splash_root and self.splash_root.winfo_exists():
            self.splash_root.after(0, self._destroy_splash) # Use after(0) for immediate execution in Tkinter's event loop
        else:
            if Local_Debug_Enable:
                debug_log(
                    message="DEBUG: Splash screen root not found or already destroyed, cannot hide.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.hide",
                    console_print_func=console_log
                )

    def set_status(self, message):
        if Local_Debug_Enable:
            debug_log(
                message=f"DEBUG: Setting splash screen status: {message}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.set_status",
                console_print_func=console_log
            )
        self.status_queue.put(message)

if __name__ == '__main__':
    # For testing the splash screen directly
    splash = SplashScreen()
    splash.start() # Start the splash screen in a new thread
    
    # Simulate some work
    import time
    
    splash.set_status("Doing important work...")
    
    splash.set_status("Almost done...")
    
    
    splash.hide() # Hide the splash screen
    
    # Keep the main thread alive for a bit to see if splash closes cleanly
    
    console_log("Main thread exiting.")

