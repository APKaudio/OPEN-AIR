# └── OPEN-AIR/
#├── DATA/
#├── Experiments/
#├── Instrument/
#├── Markers/
#├── Plotting/
#├── Presets/
#├── Scanning/
#├── display/
#├── orchestrator/
#├── process_math/
#├── ref/
#├── settings_and_config/
#├── src/
#├── tabs/
#├── utils/
#├── variables/
#├── yak/
#├── .gitattributes (Lines: 2)
#├── .gitignore (Lines: 6)
#├── README.md (Lines: 133)
#├── __init__.py (Lines: 60)
#└── main.py (Lines: 206)
#        |   -> Import: datetime
#        |   -> Import: inspect
#        |   -> Import: os
#        |   -> Import: ref.ref_file_paths
#        |   -> Import: ref.ref_program_default_values
#        |   -> Import: settings_and_config.config_manager_save
#        |   -> Import: src.gui_elements
#        |   -> Import: src.program_check_dependancies
#        |   -> Import: src.program_gui_utils
#        |   -> Import: src.program_initialization
#        |   -> Import: src.program_style
#        |   -> Import: sys
#        |   -> Import: tkinter
#        |   -> Class: App
#        |   -> Function: __init__(self)
#        |   -> Function: _apply_sash_position(self, percentage)
#        |   -> Function: _create_gui(self)
#        |   -> Function: _post_gui_setup(self)
#        |   -> Function: _save_sash_position(self, event)
#        |   -> Function: _save_state_on_configure(self, event)
#        |   -> Function: _set_console_redirectors(self)
#        |   -> Function: on_closing(self)
#        |   -> Function: restart_program(app_instance)
#└── DATA/
#    ├── SCANS/
#    └── config.ini (Lines: 123)
#    └── SCANS/
#        ├── BTR800 - Open_Air_Markers - DefaultScan - 20250819_0021.csv (Lines: 3)
#        ├── DEBUG_SOFTWARE.log (Lines: 3170)
#        ├── PRESETS.CSV (Lines: 1)
#        ├── config.ini (Lines: 123)
#        └── visa_commands.log (Lines: 270)
#└── display/
#    ├── DISPLAY_PARENT.py (Lines: 120)
#            |   -> Import: datetime
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: display.display_child_application_console
#            |   -> Import: display.display_child_debug
#            |   -> Import: display.display_child_scan_monitor
#            |   -> Import: display.display_child_scan_view
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: tkinter
#            |   -> Class: DISPLAY_PARENT
#            |   -> Function: __init__(self, parent, app_instance, style_obj)
#            |   -> Function: change_display_tab(self, tab_name)
#            |   -> Function: set_parent_notebook(self, notebook)
#    ├── __init__.py (Lines: 24)
#    ├── console_logic.py (Lines: 160)
#            |   -> Import: datetime
#            |   -> Import: inspect
#            |   -> Import: re
#            |   -> Import: sys
#            |   -> Import: tkinter
#            |   -> Function: _truncate_message(message, max_items)
#            |   -> Function: clear_console()
#            |   -> Function: console_log(message, function)
#            |   -> Function: set_clear_console_func(clear_func)
#            |   -> Function: set_debug_file_hooks(include_flag_callable, write_func)
#            |   -> Function: set_gui_console_redirector(stdout_redirector, stderr_redirector)
#            |   -> Function: set_log_truncation_mode_ref(mode_callable)
#    ├── debug_logic.py (Lines: 241)
#            |   -> Import: datetime
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: re
#            |   -> Import: ref.ref_file_paths
#            |   -> Import: sys
#            |   -> Function: _truncate_message(message, max_items)
#            |   -> Function: _write_to_debug_file(message)
#            |   -> Function: _write_to_visa_file(message)
#            |   -> Function: clear_debug_log_file(file_path)
#            |   -> Function: debug_log(message, file, version, function, special)
#            |   -> Function: log_visa_command(command, direction)
#            |   -> Function: set_console_log_func(func)
#            |   -> Function: set_debug_mode(mode)
#            |   -> Function: set_debug_redirectors(stdout_redirector, stderr_redirector)
#            |   -> Function: set_debug_to_file_mode(mode)
#            |   -> Function: set_include_console_messages_to_debug_file_mode(mode)
#            |   -> Function: set_include_visa_messages_to_debug_file_mode(mode)
#            |   -> Function: set_log_truncation_mode(mode)
#            |   -> Function: set_log_visa_commands_mode(mode)
#    ├── display_child_application_console.py (Lines: 181)
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: src.gui_elements
#            |   -> Import: tkinter
#            |   -> Class: ConsoleTab
#            |   -> Function: __init__(self, master, app_instance)
#            |   -> Function: _clear_applications_console_action(self)
#            |   -> Function: _create_widgets(self)
#            |   -> Function: _on_tab_selected(self, event)
#    ├── display_child_debug.py (Lines: 515)
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: settings_and_config.config_manager_save
#            |   -> Import: subprocess
#            |   -> Import: sys
#            |   -> Import: threading
#            |   -> Import: time
#            |   -> Import: tkinter
#            |   -> Class: DebugTab
#            |   -> Function: __init__(self, master, app_instance)
#            |   -> Function: _check_log_files(self)
#            |   -> Function: _clear_debug_log_file_action(self)
#            |   -> Function: _create_widgets(self)
#            |   -> Function: _filter_and_display_log(self, event)
#            |   -> Function: _on_tab_selected(self, event)
#            |   -> Function: _open_data_folder_action(self)
#            |   -> Function: _read_new_log_content(self, file_path, start_pos)
#            |   -> Function: _toggle_debug_mode(self)
#            |   -> Function: _toggle_debug_to_file_mode(self)
#            |   -> Function: _toggle_include_console_messages_to_debug_file_mode(self)
#            |   -> Function: _toggle_include_visa_messages_to_debug_file_mode(self)
#            |   -> Function: _toggle_log_truncation_mode(self)
#            |   -> Function: _toggle_visa_logging_mode(self)
#    ├── display_child_scan_monitor.py (Lines: 153)
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: matplotlib.backends.backend_tkagg
#            |   -> Import: matplotlib.figure
#            |   -> Import: numpy
#            |   -> Import: os
#            |   -> Import: tkinter
#            |   -> Class: ScanMonitorTab
#            |   -> Function: __init__(self, master, app_instance)
#            |   -> Function: _create_widgets(self)
#    ├── display_child_scan_view.py (Lines: 102)
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: display.utils_scan_view
#            |   -> Import: inspect
#            |   -> Import: matplotlib.backends.backend_tkagg
#            |   -> Import: matplotlib.figure
#            |   -> Import: numpy
#            |   -> Import: os
#            |   -> Import: pandas
#            |   -> Import: tkinter
#            |   -> Class: ScanViewTab
#            |   -> Function: __init__(self, master, app_instance)
#            |   -> Function: _create_widgets(self)
#    ├── logo.png (Lines: N/A)
#    ├── utils_display_monitor.py (Lines: 325)
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: matplotlib.offsetbox
#            |   -> Import: numpy
#            |   -> Import: os
#            |   -> Import: traceback
#            |   -> Function: _find_and_plot_peaks(ax, data, start_freq_mhz, end_freq_mhz)
#            |   -> Function: _setup_zoom_events(ax, canvas, original_xlim)
#            |   -> Function: clear_monitor_plots(scan_monitor_tab_instance)
#            |   -> Function: on_double_click(event)
#            |   -> Function: on_press(event)
#            |   -> Function: on_release(event)
#            |   -> Function: reset_zoom(ax, canvas)
#            |   -> Function: update_annot(event)
#            |   -> Function: update_annot(event)
#            |   -> Function: update_annot(event)
#            |   -> Function: update_bottom_plot(scan_monitor_tab_instance, data, start_freq_mhz, end_freq_mhz, plot_title)
#            |   -> Function: update_middle_plot(scan_monitor_tab_instance, data, start_freq_mhz, end_freq_mhz, plot_title)
#            |   -> Function: update_top_plot(scan_monitor_tab_instance, data, start_freq_mhz, end_freq_mhz, plot_title)
#    └── utils_scan_view.py (Lines: 182)
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: matplotlib.offsetbox
#            |   -> Import: numpy
#            |   -> Import: os
#            |   -> Import: traceback
#            |   -> Function: _find_and_plot_peaks(ax, data, start_freq_mhz, end_freq_mhz)
#            |   -> Function: _setup_zoom_events(ax, canvas, original_xlim)
#            |   -> Function: on_double_click(event)
#            |   -> Function: on_press(event)
#            |   -> Function: on_release(event)
#            |   -> Function: reset_zoom(ax, canvas)
#            |   -> Function: update_annot(event)
#            |   -> Function: update_single_plot(scan_view_tab_instance, data, start_freq_mhz, end_freq_mhz, plot_title, line_color)
#└── Experiments/
#    ├── TAB_EXPERIMENTS_PARENT.py (Lines: 130)
#            |   -> Import: datetime
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: tab_experiments_child_JSON_api
#            |   -> Import: tab_experiments_child_YakBeg
#            |   -> Import: tab_experiments_child_initial_configuration
#            |   -> Import: tab_experiments_child_intermod
#            |   -> Import: tab_experiments_colouring
#            |   -> Import: tab_experiments_credits
#            |   -> Import: tkinter
#            |   -> Class: ExperimentsParentTab
#            |   -> Function: __init__(self, parent_notebook, app_instance, console_print_func, style_obj)
#            |   -> Function: _on_child_tab_selected(self, event)
#            |   -> Function: _on_parent_tab_selected(self, event)
#    ├── __init__.py (Lines: 24)
#    ├── tab_experiments_child_JSON_api.py (Lines: 489)
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: requests
#            |   -> Import: subprocess
#            |   -> Import: sys
#            |   -> Import: threading
#            |   -> Import: time
#            |   -> Import: tkinter
#            |   -> Import: webbrowser
#            |   -> Class: JsonApiTab
#            |   -> Function: __init__(self, master, app_instance, console_print_func)
#            |   -> Function: _create_widgets(self)
#            |   -> Function: _on_tab_selected(self, event)
#            |   -> Function: _open_all_api_scans(self)
#            |   -> Function: _open_api_scan_data(self, filename)
#            |   -> Function: _open_latest_api_scan(self)
#            |   -> Function: _open_markers_api(self)
#            |   -> Function: _open_scan_in_progress_api(self)
#            |   -> Function: _run_json_api_thread_target(self)
#            |   -> Function: _start_json_api(self)
#            |   -> Function: _stop_json_api(self)
#            |   -> Function: _update_api_button_states(self)
#            |   -> Function: fetch_and_display()
#    ├── tab_experiments_child_YakBeg.py (Lines: 344)
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: numpy
#            |   -> Import: os
#            |   -> Import: tkinter
#            |   -> Import: yak.utils_yakbeg_handler
#            |   -> Class: YakBegTab
#            |   -> Function: __init__(self, master, app_instance, console_print_func)
#            |   -> Function: _create_widgets(self)
#            |   -> Function: _on_freq_center_span_beg(self)
#            |   -> Function: _on_freq_start_stop_beg(self)
#            |   -> Function: _on_marker_place_all_beg(self)
#            |   -> Function: _on_push_to_monitor(self)
#            |   -> Function: _on_tab_selected(self, event)
#            |   -> Function: _on_trace_data_beg(self)
#            |   -> Function: _on_trace_modes_beg(self)
#    ├── tab_experiments_child_initial_configuration.py (Lines: 195)
#            |   -> Import: configparser
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: ref.ref_file_paths
#            |   -> Import: ref.ref_program_default_values
#            |   -> Import: settings_and_config.config_manager_save
#            |   -> Import: tkinter
#            |   -> Class: InitialConfigurationTab
#            |   -> Function: __init__(self, master, app_instance, console_print_func, style_obj)
#            |   -> Function: _create_widgets(self)
#            |   -> Function: _populate_config_table(self)
#            |   -> Function: _reload_config_action(self)
#            |   -> Function: _save_program_configure_action(self)
#    ├── tab_experiments_child_intermod.py (Lines: 680)
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: pandas
#            |   -> Import: process_math.calculate_intermod
#            |   -> Import: process_math.ploting_intermod_zones
#            |   -> Import: random
#            |   -> Import: subprocess
#            |   -> Import: sys
#            |   -> Import: tkinter
#            |   -> Import: tkinter.font
#            |   -> Import: typing
#            |   -> Class: InterModTab
#            |   -> Function: __init__(self, master, app_instance, console_print_func)
#            |   -> Function: _browse_markers_file(self)
#            |   -> Function: _create_widgets(self)
#            |   -> Function: _display_imd_results(self, df)
#            |   -> Function: _load_intermod_csv(self)
#            |   -> Function: _on_tab_selected(self, event)
#            |   -> Function: _on_treeview_header_click(self, event)
#            |   -> Function: _open_intermod_csv(self)
#            |   -> Function: _open_intermod_map(self)
#            |   -> Function: _parse_markers_csv(self, csv_path)
#            |   -> Function: _plot_imd_results(self)
#            |   -> Function: _process_imd(self)
#            |   -> Function: _sort_treeview(self, col_name, order)
#    ├── tab_experiments_colouring.py (Lines: 306)
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: re
#            |   -> Import: src.program_style
#            |   -> Import: tkinter
#            |   -> Class: ColouringTab
#            |   -> Function: __init__(self, master, app_instance, console_print_func)
#            |   -> Function: _add_color_display_row(self, parent_frame, text, hex_color, row_idx, indent)
#            |   -> Function: _create_widgets(self)
#            |   -> Function: _on_mousewheel(self, event)
#            |   -> Function: _on_tab_selected(self, event)
#            |   -> Function: _populate_content(self)
#    └── tab_experiments_credits.py (Lines: 152)
#            |   -> Import: PIL
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: src.program_style
#            |   -> Import: tkinter
#            |   -> Import: webbrowser
#            |   -> Class: CreditsTab
#            |   -> Function: __init__(self, parent_notebook, app_instance, console_print_func)
#            |   -> Function: _on_tab_selected(self, event)
#            |   -> Function: _open_github_link(self)
#└── Instrument/
#    ├── connection/
#    ├── settings/
#    ├── visa/
#    ├── TAB_INSTRUMENT_PARENT.py (Lines: 101)
#            |   -> Import: connection.tab_instrument_child_connection
#            |   -> Import: datetime
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: settings.tab_instrument_child_settings
#            |   -> Import: tkinter
#            |   -> Import: visa.tab_instrument_child_visa_interpreter
#            |   -> Class: TAB_INSTRUMENT_PARENT
#            |   -> Function: __init__(self, parent, app_instance, console_print_func)
#            |   -> Function: _on_child_tab_selected(self, event)
#            |   -> Function: _on_parent_tab_selected(self, event)
#            |   -> Function: switch_to_settings_tab(self)
#    └── __init__.py (Lines: 0)
#    └── connection/
#        ├── instrument_logic.py (Lines: 232)
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: pyvisa
#                |   -> Import: sys
#                |   -> Import: time
#                |   -> Import: tkinter
#                |   -> Import: traceback
#                |   -> Import: utils_instrument_connection
#                |   -> Import: yak.Yakety_Yak
#                |   -> Function: connect_instrument_logic(app_instance, console_print_func)
#                |   -> Function: disconnect_instrument_logic(app_instance, console_print_func)
#                |   -> Function: populate_resources_logic(app_instance, combobox_widget, console_print_func)
#                |   -> Function: query_current_settings_logic(app_instance, console_print_func)
#        ├── tab_instrument_child_connection.py (Lines: 223)
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: instrument_logic
#                |   -> Import: os
#                |   -> Import: threading
#                |   -> Import: time
#                |   -> Import: tkinter
#                |   -> Import: yak.utils_yak_setting_handler
#                |   -> Class: InstrumentTab
#                |   -> Function: __init__(self, master, app_instance, console_print_func, parent_notebook_ref)
#                |   -> Function: _connect_instrument(self)
#                |   -> Function: _create_widgets(self)
#                |   -> Function: _disconnect_instrument(self)
#                |   -> Function: _on_tab_selected(self, event)
#                |   -> Function: _populate_resources(self)
#                |   -> Function: _power_cycle_instrument(self)
#                |   -> Function: _reset_instrument(self)
#                |   -> Function: _toggle_connection(self)
#                |   -> Function: _update_connection_status(self)
#        └── utils_instrument_connection.py (Lines: 194)
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: pyvisa
#                |   -> Function: connect_to_instrument(resource_name, console_print_func)
#                |   -> Function: disconnect_instrument(inst, console_print_func)
#                |   -> Function: list_visa_resources(console_print_func)
#    └── settings/
#        ├── tab_instrument_child_settings.py (Lines: 120)
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: src.program_style
#                |   -> Import: tab_instrument_child_settings_amplitude
#                |   -> Import: tab_instrument_child_settings_bandwidth
#                |   -> Import: tab_instrument_child_settings_frequency
#                |   -> Import: tab_instrument_child_settings_markers
#                |   -> Import: tab_instrument_child_settings_traces
#                |   -> Import: tkinter
#                |   -> Class: SettingsParentTab
#                |   -> Function: __init__(self, master, app_instance, console_print_func)
#                |   -> Function: _on_tab_selected(self, event)
#                |   -> Function: refresh_all_child_tabs(self)
#        ├── tab_instrument_child_settings_amplitude.py (Lines: 348)
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: ref.ref_scanner_setting_lists
#                |   -> Import: settings_and_config.config_manager_instruments
#                |   -> Import: settings_and_config.config_manager_save
#                |   -> Import: tkinter
#                |   -> Import: yak
#                |   -> Import: yak.Yakety_Yak
#                |   -> Class: AmplitudeSettingsTab
#                |   -> Function: __init__(self, master, app_instance, console_print_func)
#                |   -> Function: _create_widgets(self)
#                |   -> Function: _find_closest_preset_value(self, value, preset_list)
#                |   -> Function: _on_power_attenuation_change(self, event)
#                |   -> Function: _on_ref_level_change(self, event)
#                |   -> Function: _on_resize(self, event)
#                |   -> Function: _save_settings_handler(self)
#                |   -> Function: _set_ui_initial_state(self)
#                |   -> Function: _update_descriptions(self, value, preset_list, label, var)
#                |   -> Function: _update_power_attenuation_display(self, value)
#                |   -> Function: _update_ref_level_display(self, value)
#                |   -> Function: _update_toggle_button_style(self, button, state)
#        ├── tab_instrument_child_settings_bandwidth.py (Lines: 509)
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: re
#                |   -> Import: ref.ref_scanner_setting_lists
#                |   -> Import: settings_and_config.config_manager_instruments
#                |   -> Import: settings_and_config.config_manager_save
#                |   -> Import: tkinter
#                |   -> Import: yak
#                |   -> Import: yak.utils_yaknab_handler
#                |   -> Class: BandwidthSettingsTab
#                |   -> Function: __init__(self, master, app_instance, console_print_func)
#                |   -> Function: _create_widgets(self)
#                |   -> Function: _on_averaging_count_selected(self, event, trace_number)
#                |   -> Function: _on_averaging_toggle(self, trace_number, state)
#                |   -> Function: _on_continuous_mode_change(self, event)
#                |   -> Function: _on_rbw_selected(self, event)
#                |   -> Function: _on_tab_selected(self, event)
#                |   -> Function: _on_vbw_auto_toggle(self)
#                |   -> Function: _on_vbw_selected(self, event)
#                |   -> Function: _save_settings_handler(self)
#                |   -> Function: _sync_ui_from_app_state(self)
#                |   -> Function: _update_rbw_combobox_display(self)
#                |   -> Function: _update_toggle_button_style(self, button, state)
#                |   -> Function: _update_vbw_combobox_display(self)
#        ├── tab_instrument_child_settings_frequency.py (Lines: 498)
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: numpy
#                |   -> Import: os
#                |   -> Import: ref.ref_file_paths
#                |   -> Import: ref.ref_program_default_values
#                |   -> Import: ref.ref_scanner_setting_lists
#                |   -> Import: settings_and_config.config_manager_instruments
#                |   -> Import: settings_and_config.config_manager_save
#                |   -> Import: tkinter
#                |   -> Import: yak.utils_yakbeg_handler
#                |   -> Class: FrequencySettingsTab
#                |   -> Function: __init__(self, master, app_instance, console_print_func, style_obj)
#                |   -> Function: _create_span_preset_buttons(self, parent_frame)
#                |   -> Function: _create_widgets(self)
#                |   -> Function: _on_freq_center_span_beg(self)
#                |   -> Function: _on_freq_start_stop_beg(self)
#                |   -> Function: _on_span_preset_button_click(self, preset)
#                |   -> Function: _on_span_variable_change(self)
#                |   -> Function: _round_variables(self)
#                |   -> Function: _save_settings_handler(self)
#                |   -> Function: _set_default_variables(self)
#                |   -> Function: _update_span_button_styles(self)
#                |   -> Function: truncate_float(f)
#        ├── tab_instrument_child_settings_markers.py (Lines: 206)
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: settings_and_config.config_manager_marker
#                |   -> Import: settings_and_config.config_manager_save
#                |   -> Import: tkinter
#                |   -> Import: yak.utils_yakbeg_handler
#                |   -> Class: MarkerSettingsTab
#                |   -> Function: __init__(self, master, app_instance, console_print_func)
#                |   -> Function: _create_widgets(self)
#                |   -> Function: _on_marker_place_all_beg(self)
#                |   -> Function: _save_settings_handler(self)
#                |   -> Function: _set_default_variables(self)
#        └── tab_instrument_child_settings_traces.py (Lines: 489)
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: display.utils_display_monitor
#                |   -> Import: display.utils_scan_view
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: pandas
#                |   -> Import: settings_and_config.config_manager_instruments
#                |   -> Import: settings_and_config.config_manager_save
#                |   -> Import: tkinter
#                |   -> Import: yak.utils_yakbeg_handler
#                |   -> Import: yak.utils_yaknab_handler
#                |   -> Class: TraceSettingsTab
#                |   -> Function: __init__(self, master, app_instance, console_print_func)
#                |   -> Function: _create_widgets(self)
#                |   -> Function: _on_all_traces_nab(self)
#                |   -> Function: _on_push_to_monitor(self)
#                |   -> Function: _on_tab_selected(self, event)
#                |   -> Function: _on_trace_data_beg(self)
#                |   -> Function: _on_trace_modes_beg(self)
#                |   -> Function: _plot_all_traces_to_monitor(self)
#                |   -> Function: _save_settings_handler(self)
#    └── visa/
#        ├── ref_visa_commands.py (Lines: 411)
#                |   -> Function: get_default_visa_commands()
#        ├── tab_instrument_child_visa_interpreter.py (Lines: 417)
#                |   -> Import: datetime
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: ref.ref_file_paths
#                |   -> Import: src.program_style
#                |   -> Import: threading
#                |   -> Import: time
#                |   -> Import: tkinter
#                |   -> Import: utils_visa_interpreter_commands
#                |   -> Import: utils_visa_interpreter_files
#                |   -> Class: VisaInterpreterTab
#                |   -> Function: __init__(self, parent, app_instance, console_print_func)
#                |   -> Function: _add_new_row(self)
#                |   -> Function: _delete_selected_row(self)
#                |   -> Function: _edit_cell(self, item, col_index)
#                |   -> Function: _handle_connection_status_change_event(self, event)
#                |   -> Function: _on_double_click(self, event)
#                |   -> Function: _on_treeview_focus(self, event)
#                |   -> Function: _on_treeview_select(self, event)
#                |   -> Function: _refresh_data(self)
#                |   -> Function: _save_data_to_csv(self)
#                |   -> Function: _set_ui_initial_state(self)
#                |   -> Function: _sort_treeview(self, tv, col)
#                |   -> Function: bind_events(self)
#                |   -> Function: create_widgets(self)
#                |   -> Function: load_data_to_treeview(self)
#                |   -> Function: numeric_sort_key(x)
#                |   -> Function: on_entry_change(e)
#                |   -> Function: on_focus_out(e)
#                |   -> Function: setup_layout(self)
#        ├── utils_visa_interpreter_commands.py (Lines: 122)
#                |   -> Import: datetime
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: tkinter
#                |   -> Import: yak.utils_yak_visa
#                |   -> Class: VisaCommandExecutor
#                |   -> Function: __init__(self, app_instance, console_print_func)
#                |   -> Function: _get_instrument_status(self)
#                |   -> Function: on_do_command(self, command)
#                |   -> Function: on_execute_command(self, command)
#                |   -> Function: on_query_command(self, command)
#                |   -> Function: on_set_command(self, command)
#        └── utils_visa_interpreter_files.py (Lines: 182)
#                |   -> Import: csv
#                |   -> Import: datetime
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: ref.ref_file_paths
#                |   -> Import: ref_visa_commands
#                |   -> Function: create_default_data_file(data_file)
#                |   -> Function: initialize_data_file_and_load()
#                |   -> Function: load_visa_commands_data(data_file)
#                |   -> Function: save_visa_commands_data(data_file, data)
#└── Markers/
#    ├── files/
#    ├── showtime/
#    ├── TAB_MARKERS_PARENT.py (Lines: 123)
#            |   -> Import: datetime
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: files.tab_markers_child_import_and_edit
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: showtime.tab_markers_parent_showtime
#            |   -> Import: src.program_style
#            |   -> Import: tkinter
#            |   -> Import: typing
#            |   -> Class: TAB_MARKERS_PARENT
#            |   -> Function: __init__(self, parent_notebook, app_instance, console_print_func)
#            |   -> Function: _on_child_tab_selected(self, event)
#            |   -> Function: _on_parent_tab_selected(self, event)
#    └── __init__.py (Lines: 24)
#    └── files/
#        ├── tab_markers_child_import_and_edit.py (Lines: 847)
#                |   -> Import: csv
#                |   -> Import: datetime
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: files.utils_marker_report_converter
#                |   -> Import: inspect
#                |   -> Import: json
#                |   -> Import: os
#                |   -> Import: re
#                |   -> Import: src.gui_elements
#                |   -> Import: sys
#                |   -> Import: threading
#                |   -> Import: tkinter
#                |   -> Import: xml.etree.ElementTree
#                |   -> Class: ReportConverterTab
#                |   -> Function: __init__(self, master, app_instance, console_print_func)
#                |   -> Function: _create_widgets(self)
#                |   -> Function: _disable_buttons(self)
#                |   -> Function: _enable_buttons(self)
#                |   -> Function: _increment_string_with_trailing_digits(self, text)
#                |   -> Function: _initiate_conversion(self, file_type)
#                |   -> Function: _load_markers_file(self)
#                |   -> Function: _navigate_cells(self, current_item, current_col_index, direction)
#                |   -> Function: _on_tab_selected(self, event)
#                |   -> Function: _on_tree_double_click(self, event)
#                |   -> Function: _on_tree_header_click(self, event)
#                |   -> Function: _perform_conversion(self, file_path, file_type)
#                |   -> Function: _populate_marker_tree(self)
#                |   -> Function: _save_markers_file_internally(self)
#                |   -> Function: _save_open_air_csv(self)
#                |   -> Function: _sort_treeview(self, column_name, ascending)
#                |   -> Function: _start_editing_cell(self, item, col_index, initial_value)
#                |   -> Function: _update_markers_display_tab_data(self)
#                |   -> Function: get_sort_key(item)
#                |   -> Function: on_edit_complete_and_navigate(event, navigate_direction)
#        ├── utils_file_markers_handling.py (Lines: 141)
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: numpy
#                |   -> Import: os
#                |   -> Import: pandas
#                |   -> Function: _group_by_zone_and_group(data)
#                |   -> Function: load_and_process_markers(app_instance, console_print_func)
#                |   -> Function: load_markers_data(app_instance, console_print_func)
#        └── utils_marker_report_converter.py (Lines: 462)
#                |   -> Import: bs4
#                |   -> Import: csv
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: numpy
#                |   -> Import: os
#                |   -> Import: pdfplumber
#                |   -> Import: re
#                |   -> Import: subprocess
#                |   -> Import: sys
#                |   -> Import: xml.etree.ElementTree
#                |   -> Function: convert_html_report_to_csv(html_content, console_print_func)
#                |   -> Function: convert_pdf_report_to_csv(pdf_file_path, console_print_func)
#                |   -> Function: generate_csv_from_shw(xml_file_path, console_print_func)
#    └── showtime/
#        ├── controls/
#        ├── zones_groups_devices/
#        └── tab_markers_parent_showtime.py (Lines: 141)
#                |   -> Import: datetime
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: showtime.controls.tab_markers_parent_bottom_controls
#                |   -> Import: showtime.zones_groups_devices.tab_markers_child_zone_groups_devices
#                |   -> Import: tkinter
#                |   -> Class: ShowtimeParentTab
#                |   -> Function: __init__(self, parent_notebook, app_instance, console_print_func)
#                |   -> Function: _create_widgets(self)
#                |   -> Function: _on_tab_selected(self, event)
#        └── controls/
#            ├── tab_markers_child_control_poke.py (Lines: 72)
#                    |   -> Import: datetime
#                    |   -> Import: display.debug_logic
#                    |   -> Import: inspect
#                    |   -> Import: os
#                    |   -> Import: tkinter
#                    |   -> Import: utils_showtime_poke
#                    |   -> Class: PokeTab
#                    |   -> Function: __init__(self, parent_notebook, showtime_tab_instance)
#                    |   -> Function: _create_widgets(self)
#            ├── tab_markers_child_control_rbw.py (Lines: 85)
#                    |   -> Import: datetime
#                    |   -> Import: display.console_logic
#                    |   -> Import: display.debug_logic
#                    |   -> Import: inspect
#                    |   -> Import: os
#                    |   -> Import: ref.ref_scanner_setting_lists
#                    |   -> Import: tkinter
#                    |   -> Import: utils_showtime_rbw
#                    |   -> Class: RBWTab
#                    |   -> Function: __init__(self, parent_notebook, showtime_tab_instance)
#                    |   -> Function: _create_widgets(self)
#            ├── tab_markers_child_control_span.py (Lines: 85)
#                    |   -> Import: datetime
#                    |   -> Import: display.debug_logic
#                    |   -> Import: inspect
#                    |   -> Import: os
#                    |   -> Import: ref.ref_scanner_setting_lists
#                    |   -> Import: tkinter
#                    |   -> Import: utils_showtime_span
#                    |   -> Class: SpanTab
#                    |   -> Function: __init__(self, parent_notebook, showtime_tab_instance)
#                    |   -> Function: _create_widgets(self)
#            ├── tab_markers_child_control_traces.py (Lines: 143)
#                    |   -> Import: datetime
#                    |   -> Import: display.debug_logic
#                    |   -> Import: inspect
#                    |   -> Import: os
#                    |   -> Import: tkinter
#                    |   -> Import: utils_showtime_trace
#                    |   -> Class: TracesTab
#                    |   -> Function: __init__(self, parent_notebook, showtime_tab_instance)
#                    |   -> Function: _create_widgets(self)
#                    |   -> Function: _toggle_and_execute(self, button_type)
#                    |   -> Function: _update_button_styles(self)
#            ├── tab_markers_child_control_zone_zoom.py (Lines: 188)
#                    |   -> Import: datetime
#                    |   -> Import: display.debug_logic
#                    |   -> Import: inspect
#                    |   -> Import: os
#                    |   -> Import: tkinter
#                    |   -> Import: utils_showtime_zone_zoom
#                    |   -> Class: ZoneZoomTab
#                    |   -> Function: __init__(self, parent_notebook, showtime_tab_instance)
#                    |   -> Function: _create_widgets(self)
#                    |   -> Function: _on_tab_selected(self, event)
#                    |   -> Function: _sync_ui_from_state(self)
#            ├── tab_markers_parent_bottom_controls.py (Lines: 214)
#                    |   -> Import: datetime
#                    |   -> Import: display.console_logic
#                    |   -> Import: display.debug_logic
#                    |   -> Import: inspect
#                    |   -> Import: os
#                    |   -> Import: src.program_style
#                    |   -> Import: tab_markers_child_control_poke
#                    |   -> Import: tab_markers_child_control_rbw
#                    |   -> Import: tab_markers_child_control_span
#                    |   -> Import: tab_markers_child_control_traces
#                    |   -> Import: tab_markers_child_control_zone_zoom
#                    |   -> Import: tkinter
#                    |   -> Class: ControlsFrame
#                    |   -> Function: __init__(self, parent_frame, showtime_tab_instance)
#                    |   -> Function: _create_widgets(self)
#                    |   -> Function: _on_tab_selected(self, event)
#                    |   -> Function: _update_control_buttons(self)
#                    |   -> Function: switch_to_tab(self, tab_name)
#            ├── utils_showtime_plot.py (Lines: 76)
#                    |   -> Import: display.console_logic
#                    |   -> Import: display.debug_logic
#                    |   -> Import: display.utils_display_monitor
#                    |   -> Import: inspect
#                    |   -> Import: os
#                    |   -> Import: pandas
#                    |   -> Import: ref.ref_frequency_bands
#                    |   -> Import: tkinter
#                    |   -> Function: plot_all_traces(showtime_tab_instance, trace_data_dict, view_name, start_freq_mhz, stop_freq_mhz)
#            ├── utils_showtime_poke.py (Lines: 86)
#                    |   -> Import: display.console_logic
#                    |   -> Import: display.debug_logic
#                    |   -> Import: inspect
#                    |   -> Import: os
#                    |   -> Import: pandas
#                    |   -> Import: ref.ref_frequency_bands
#                    |   -> Import: settings_and_config.config_manager_save
#                    |   -> Import: utils_showtime_span
#                    |   -> Import: yak.Yakety_Yak
#                    |   -> Import: yak.utils_yakbeg_handler
#                    |   -> Function: on_poke_action(showtime_tab_instance)
#            ├── utils_showtime_rbw.py (Lines: 91)
#                    |   -> Import: display.console_logic
#                    |   -> Import: display.debug_logic
#                    |   -> Import: inspect
#                    |   -> Import: os
#                    |   -> Import: process_math.math_frequency_translation
#                    |   -> Import: settings_and_config.config_manager_save
#                    |   -> Import: tkinter
#                    |   -> Import: yak.Yakety_Yak
#                    |   -> Import: yak.utils_yak_setting_handler
#                    |   -> Function: on_rbw_button_click(showtime_tab, rbw_hz)
#                    |   -> Function: set_rbw_logic(app_instance, rbw_hz, console_print_func)
#            ├── utils_showtime_span.py (Lines: 93)
#                    |   -> Import: display.console_logic
#                    |   -> Import: display.debug_logic
#                    |   -> Import: inspect
#                    |   -> Import: os
#                    |   -> Import: process_math.math_frequency_translation
#                    |   -> Import: settings_and_config.config_manager_save
#                    |   -> Import: yak.utils_yak_setting_handler
#                    |   -> Import: yak.utils_yakbeg_handler
#                    |   -> Import: yak.utils_yaknab_handler
#                    |   -> Function: on_span_button_click(showtime_tab_instance, span_hz)
#            ├── utils_showtime_trace.py (Lines: 138)
#                    |   -> Import: display.console_logic
#                    |   -> Import: display.debug_logic
#                    |   -> Import: inspect
#                    |   -> Import: numpy
#                    |   -> Import: os
#                    |   -> Import: pandas
#                    |   -> Import: process_math.math_frequency_translation
#                    |   -> Import: settings_and_config.config_manager_save
#                    |   -> Import: tkinter
#                    |   -> Import: utils_showtime_plot
#                    |   -> Import: yak.utils_yakbeg_handler
#                    |   -> Import: yak.utils_yaknab_handler
#                    |   -> Function: _get_and_plot_traces(traces_tab_instance, view_name)
#                    |   -> Function: execute_trace_action(traces_tab_instance, action_type)
#                    |   -> Function: sync_trace_modes(traces_tab_instance)
#            └── utils_showtime_zone_zoom.py (Lines: 312)
#                    |   -> Import: display.console_logic
#                    |   -> Import: display.debug_logic
#                    |   -> Import: inspect
#                    |   -> Import: os
#                    |   -> Import: process_math.math_frequency_translation
#                    |   -> Import: ref.ref_frequency_bands
#                    |   -> Import: settings_and_config.config_manager_save
#                    |   -> Import: yak.utils_yakbeg_handler
#                    |   -> Function: _buffer_start_stop_frequencies(start_freq_mhz, stop_freq_mhz, buffer_mhz)
#                    |   -> Function: set_span_to_all_markers(showtime_tab_instance, zone_zoom_tab)
#                    |   -> Function: set_span_to_device(showtime_tab_instance, zone_zoom_tab)
#                    |   -> Function: set_span_to_group(showtime_tab_instance, zone_zoom_tab)
#                    |   -> Function: set_span_to_zone(showtime_tab_instance, zone_zoom_tab)
#        └── zones_groups_devices/
#            ├── tab_markers_child_zone_groups_devices.py (Lines: 211)
#                    |   -> Import: datetime
#                    |   -> Import: display.console_logic
#                    |   -> Import: display.debug_logic
#                    |   -> Import: functools
#                    |   -> Import: inspect
#                    |   -> Import: os
#                    |   -> Import: src.program_style
#                    |   -> Import: tkinter
#                    |   -> Import: utils_button_volume_level
#                    |   -> Import: utils_display_showtime_all
#                    |   -> Import: utils_display_showtime_devices
#                    |   -> Import: utils_display_showtime_groups
#                    |   -> Import: utils_display_showtime_zones
#                    |   -> Import: utils_files_markers_zone_groups_devices
#                    |   -> Class: ZoneGroupsDevicesFrame
#                    |   -> Function: __init__(self, parent_frame, showtime_tab_instance)
#                    |   -> Function: _create_device_frame(self, parent)
#                    |   -> Function: _create_layout(self)
#                    |   -> Function: _get_all_devices_in_zone(self, structured_data, zone_name)
#                    |   -> Function: _get_devices_to_display(self)
#                    |   -> Function: _get_min_max_freq_and_update_title(self, frame_widget, devices, title_prefix)
#                    |   -> Function: _make_device_buttons(self)
#                    |   -> Function: _make_group_buttons(self)
#                    |   -> Function: _make_zone_buttons(self)
#                    |   -> Function: load_and_display_data(self)
#            ├── utils_button_volume_level.py (Lines: 73)
#                    |   -> Import: datetime
#                    |   -> Import: display.debug_logic
#                    |   -> Import: inspect
#                    |   -> Import: math
#                    |   -> Import: os
#                    |   -> Function: create_signal_level_indicator(value, min_val, max_val, width)
#            ├── utils_display_showtime_all.py (Lines: 146)
#                    |   -> Import: Markers.showtime.controls.utils_showtime_zone_zoom
#                    |   -> Import: display.console_logic
#                    |   -> Import: display.debug_logic
#                    |   -> Import: inspect
#                    |   -> Import: numpy
#                    |   -> Import: os
#                    |   -> Import: pandas
#                    |   -> Import: tkinter
#                    |   -> Import: utils_display_showtime_shared
#                    |   -> Function: no_zone_grou_device_selected(zgd_frame_instance)
#                    |   -> Function: on_all_markers_selected(zgd_frame_instance)
#            ├── utils_display_showtime_devices.py (Lines: 154)
#                    |   -> Import: Markers.showtime.controls.utils_showtime_zone_zoom
#                    |   -> Import: display.console_logic
#                    |   -> Import: display.debug_logic
#                    |   -> Import: inspect
#                    |   -> Import: math
#                    |   -> Import: numpy
#                    |   -> Import: os
#                    |   -> Import: pandas
#                    |   -> Import: utils_display_showtime_groups
#                    |   -> Import: utils_display_showtime_shared
#                    |   -> Import: yak.utils_yakbeg_handler
#                    |   -> Function: on_device_deselected(zgd_frame_instance)
#                    |   -> Function: on_device_selected(zgd_frame_instance, device_info)
#            ├── utils_display_showtime_groups.py (Lines: 202)
#                    |   -> Import: Markers.showtime.controls.utils_showtime_zone_zoom
#                    |   -> Import: display.console_logic
#                    |   -> Import: display.debug_logic
#                    |   -> Import: inspect
#                    |   -> Import: math
#                    |   -> Import: numpy
#                    |   -> Import: os
#                    |   -> Import: pandas
#                    |   -> Import: tkinter
#                    |   -> Import: utils_display_showtime_devices
#                    |   -> Import: utils_display_showtime_shared
#                    |   -> Function: no_zone_grou_device_selected(zgd_frame_instance)
#                    |   -> Function: on_group_deselected(zgd_frame_instance)
#                    |   -> Function: on_group_selected(zgd_frame_instance, group_name)
#            ├── utils_display_showtime_shared.py (Lines: 278)
#                    |   -> Import: Markers.showtime.controls.utils_showtime_zone_zoom
#                    |   -> Import: display.console_logic
#                    |   -> Import: display.debug_logic
#                    |   -> Import: inspect
#                    |   -> Import: math
#                    |   -> Import: numpy
#                    |   -> Import: os
#                    |   -> Import: pandas
#                    |   -> Import: settings_and_config.config_manager_save
#                    |   -> Import: threading
#                    |   -> Import: tkinter
#                    |   -> Function: _save_showtime_state_to_config(showtime_tab)
#                    |   -> Function: _update_zone_zoom_tab(zgd_frame_instance)
#                    |   -> Function: get_current_view_details(zgd_frame_instance)
#            ├── utils_display_showtime_zones.py (Lines: 118)
#                    |   -> Import: Markers.showtime.controls.utils_showtime_zone_zoom
#                    |   -> Import: display.console_logic
#                    |   -> Import: display.debug_logic
#                    |   -> Import: inspect
#                    |   -> Import: math
#                    |   -> Import: numpy
#                    |   -> Import: os
#                    |   -> Import: pandas
#                    |   -> Import: tkinter
#                    |   -> Import: utils_display_showtime_all
#                    |   -> Import: utils_display_showtime_shared
#                    |   -> Function: on_zone_selected(zgd_frame_instance, zone_name)
#            └── utils_files_markers_zone_groups_devices.py (Lines: 100)
#                    |   -> Import: display.console_logic
#                    |   -> Import: display.debug_logic
#                    |   -> Import: inspect
#                    |   -> Import: numpy
#                    |   -> Import: os
#                    |   -> Import: pandas
#                    |   -> Import: ref.ref_file_paths
#                    |   -> Function: load_and_structure_markers_data()
#└── orchestrator/
#    ├── __init__.py (Lines: 60)
#    ├── display_child_orchestrator_tasks.py (Lines: 122)
#            |   -> Import: datetime
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: tkinter
#            |   -> Class: OrchestratorTasksTab
#            |   -> Function: __init__(self, parent, app_instance)
#            |   -> Function: _create_widgets(self)
#            |   -> Function: log_event(self, source, event)
#            |   -> Function: update_status_display(self, is_running, is_paused)
#    ├── orchestrator_gui.py (Lines: 94)
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: tkinter
#            |   -> Class: OrchestratorGUI
#            |   -> Function: __init__(self, parent, app_instance, orchestrator_logic)
#            |   -> Function: _create_widgets(self)
#            |   -> Function: update_button_states(self)
#    └── orchestrator_logic.py (Lines: 98)
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Class: OrchestratorLogic
#            |   -> Function: __init__(self, app_instance, gui)
#            |   -> Function: get_status(self)
#            |   -> Function: log_check_in(self, source_file)
#            |   -> Function: log_task_event(self, source_file, event)
#            |   -> Function: start_orchestrator(self)
#            |   -> Function: stop_orchestrator(self)
#            |   -> Function: toggle_pause(self)
#└── Plotting/
#    ├── TAB_PLOTTING_PARENT.py (Lines: 72)
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: tab_plotting_child_3D
#            |   -> Import: tab_plotting_child_Single
#            |   -> Import: tab_plotting_child_average
#            |   -> Import: tkinter
#            |   -> Class: TAB_PLOTTING_PARENT
#            |   -> Function: __init__(self, parent, app_instance, console_print_func)
#            |   -> Function: _on_child_tab_selected(self, event)
#            |   -> Function: _on_parent_tab_selected(self, event)
#    ├── __init__.py (Lines: 24)
#    ├── tab_plotting_child_3D.py (Lines: 540)
#            |   -> Import: datetime
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: glob
#            |   -> Import: inspect
#            |   -> Import: numpy
#            |   -> Import: os
#            |   -> Import: pandas
#            |   -> Import: platform
#            |   -> Import: re
#            |   -> Import: tkinter
#            |   -> Import: utils_plotting_scans_over_time
#            |   -> Import: webbrowser
#            |   -> Class: Plotting3DTab
#            |   -> Function: __init__(self, master, app_instance, console_print_func)
#            |   -> Function: _clear_dynamic_3d_buttons(self)
#            |   -> Function: _create_widgets(self)
#            |   -> Function: _find_and_group_csv_files_3d(self, folder_path)
#            |   -> Function: _generate_plot_scans_over_time(self)
#            |   -> Function: _on_tab_selected(self, event)
#            |   -> Function: _open_folder_for_3d_plotting(self)
#            |   -> Function: _select_group_for_3d_plotting(self, prefix)
#    ├── tab_plotting_child_Single.py (Lines: 670)
#            |   -> Import: datetime
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: numpy
#            |   -> Import: os
#            |   -> Import: pandas
#            |   -> Import: tkinter
#            |   -> Import: utils_plotting
#            |   -> Import: webbrowser
#            |   -> Class: PlottingTab
#            |   -> Function: __init__(self, master, app_instance, console_print_func)
#            |   -> Function: _create_widgets(self)
#            |   -> Function: _local_calculate_average(df)
#            |   -> Function: _local_calculate_median(df)
#            |   -> Function: _local_calculate_psd(df, rbw_values_list)
#            |   -> Function: _local_calculate_range(df)
#            |   -> Function: _local_calculate_std_dev(df)
#            |   -> Function: _local_calculate_variance(df)
#            |   -> Function: _on_create_html_checkbox_changed(self)
#            |   -> Function: _on_scan_marker_checkbox_changed(self)
#            |   -> Function: _on_tab_selected(self, event)
#            |   -> Function: _open_last_plot(self)
#            |   -> Function: _plot_current_cycle_average(self)
#            |   -> Function: _plot_single_scan(self)
#    ├── tab_plotting_child_average.py (Lines: 1067)
#            |   -> Import: datetime
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: glob
#            |   -> Import: inspect
#            |   -> Import: numpy
#            |   -> Import: os
#            |   -> Import: pandas
#            |   -> Import: platform
#            |   -> Import: process_math.averaging_utils
#            |   -> Import: re
#            |   -> Import: subprocess
#            |   -> Import: tkinter
#            |   -> Import: utils_plotting
#            |   -> Import: webbrowser
#            |   -> Class: AveragingTab
#            |   -> Function: __init__(self, master, app_instance, console_print_func)
#            |   -> Function: _clear_dynamic_buttons(self)
#            |   -> Function: _create_widgets(self)
#            |   -> Function: _find_and_group_csv_files(self, folder_path)
#            |   -> Function: _generate_csv_selected_series(self)
#            |   -> Function: _generate_multi_average_plot(self, include_scans)
#            |   -> Function: _on_avg_type_checkbox_changed(self)
#            |   -> Function: _on_multi_file_marker_checkbox_changed(self)
#            |   -> Function: _on_tab_selected(self, event)
#            |   -> Function: _open_applied_math_folder(self)
#            |   -> Function: _open_folder_for_averaging(self)
#            |   -> Function: _select_group_for_plotting(self, prefix)
#    ├── utils_plotting.py (Lines: 675)
#            |   -> Import: csv
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: pandas
#            |   -> Import: plotly.express
#            |   -> Import: plotly.graph_objects
#            |   -> Import: re
#            |   -> Import: webbrowser
#            |   -> Function: _add_band_markers(fig, markers_dict, line_color, line_dash, band_name_suffix, MHZ_TO_HZ, console_print_func)
#            |   -> Function: _add_intermodulation_markers(fig, intermod_csv_path, MHZ_TO_HZ, console_print_func)
#            |   -> Function: _add_markers_from_csv(fig, markers_csv_path, MHZ_TO_HZ, console_print_func)
#            |   -> Function: _create_spectrum_plot(data_traces, plot_title, include_tv_markers, include_gov_markers, include_markers, include_intermod_markers, output_html_path, y_range_min_override, y_range_max_override, console_print_func, scan_data_folder, MHZ_TO_HZ, TV_BAND_MARKERS_MHZ, GOVERNMENT_BAND_MARKERS_MHZ, DEFAULT_MARKERS_FILE, DEFAULT_INTERMOD_FILE)
#            |   -> Function: _open_plot_in_browser(html_file_path, console_print_func)
#            |   -> Function: plot_multi_trace_data(df_aggregated, plot_title, include_tv_markers, include_gov_markers, include_markers, include_intermod_markers, historical_dfs_with_names, individual_scan_dfs_with_names, output_html_path, y_range_min_override, y_range_max_override, console_print_func, scan_data_folder, MHZ_TO_HZ, TV_BAND_MARKERS_MHZ, GOVERNMENT_BAND_MARKERS_MHZ, DEFAULT_MARKERS_FILE, DEFAULT_INTERMOD_FILE)
#            |   -> Function: plot_single_scan_data(df_scan, plot_title, include_tv_markers, include_gov_markers, include_markers, include_intermod_markers, output_html_path, console_print_func, scan_data_folder, MHZ_TO_HZ, TV_BAND_MARKERS_MHZ, GOVERNMENT_BAND_MARKERS_MHZ, DEFAULT_MARKERS_FILE, DEFAULT_INTERMOD_FILE)
#    └── utils_plotting_scans_over_time.py (Lines: 303)
#            |   -> Import: datetime
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: pandas
#            |   -> Import: plotly.colors
#            |   -> Import: plotly.graph_objects
#            |   -> Import: re
#            |   -> Import: ref.ref_frequency_bands
#            |   -> Import: webbrowser
#            |   -> Function: plot_Scans_over_time(grouped_csv_files, selected_group_prefix, output_folder, amplitude_threshold_dbm, console_print_func)
#└── Presets/
#    ├── TAB_PRESETS_PARENT.py (Lines: 120)
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: tab_presets_child_device
#            |   -> Import: tab_presets_child_local
#            |   -> Import: tab_presets_child_preset_editor
#            |   -> Import: tkinter
#            |   -> Class: TAB_PRESETS_PARENT
#            |   -> Function: __init__(self, parent_notebook, app_instance, console_print_func)
#            |   -> Function: _on_child_tab_selected(self, event)
#            |   -> Function: _on_parent_tab_selected(self, event)
#    ├── __init__.py (Lines: 24)
#    ├── tab_presets_child_device.py (Lines: 353)
#            |   -> Import: Instrument.connection.instrument_logic
#            |   -> Import: Presets.utils_preset_csv_process
#            |   -> Import: Presets.utils_preset_query_and_load
#            |   -> Import: Presets.utils_push_preset
#            |   -> Import: csv
#            |   -> Import: datetime
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: src.program_style
#            |   -> Import: tkinter
#            |   -> Class: DevicePresetsTab
#            |   -> Function: __init__(self, parent, app_instance, console_print_func, style_obj)
#            |   -> Function: __load_selected_preset_logic(self, selected_preset_name, is_device_preset, preset_data_dict)
#            |   -> Function: _handle_connection_status_change_event(self, event)
#            |   -> Function: _load_selected_device_preset(self)
#            |   -> Function: _on_connection_status_changed(self, is_connected, instrument_model)
#            |   -> Function: _on_device_preset_select(self, event)
#            |   -> Function: _populate_device_preset_listboxes(self, presets)
#            |   -> Function: _query_and_populate_device_presets(self)
#            |   -> Function: bind_events(self)
#            |   -> Function: create_widgets(self)
#            |   -> Function: save_current_settings_as_user_preset(self)
#            |   -> Function: setup_layout(self)
#    ├── tab_presets_child_local.py (Lines: 569)
#            |   -> Import: Presets.utils_preset_csv_process
#            |   -> Import: Presets.utils_preset_query_and_load
#            |   -> Import: Presets.utils_push_preset
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: ref.ref_file_paths
#            |   -> Import: settings_and_config.config_manager_save
#            |   -> Import: src.program_style
#            |   -> Import: tkinter
#            |   -> Class: LocalPresetsTab
#            |   -> Function: __init__(self, master, app_instance, console_print_func, style_obj)
#            |   -> Function: _create_widgets(self)
#            |   -> Function: _on_mousewheel(self, event)
#            |   -> Function: _on_preset_button_click(self, preset_data, clicked_button)
#            |   -> Function: _on_tab_selected(self, event)
#            |   -> Function: _update_gui_from_preset_data(self, preset_data)
#            |   -> Function: get_and_set_app_var(preset_key, app_attr_name, conversion_func, scale_factor)
#            |   -> Function: get_and_set_bool_app_var(preset_key, app_attr_name)
#            |   -> Function: populate_local_presets_list(self)
#            |   -> Function: set_display_var(tk_var, key, format_str, conversion_func, default_val)
#    ├── tab_presets_child_preset_editor.py (Lines: 356)
#            |   -> Import: Instrument.connection.instrument_logic
#            |   -> Import: datetime
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: numpy
#            |   -> Import: os
#            |   -> Import: pandas
#            |   -> Import: src.program_style
#            |   -> Import: tkinter
#            |   -> Import: utils_presets_editor
#            |   -> Class: PresetEditorTab
#            |   -> Function: __init__(self, master, app_instance, console_print_func, style_obj)
#            |   -> Function: _add_current_settings(self)
#            |   -> Function: _add_new_empty_row(self)
#            |   -> Function: _create_widgets(self)
#            |   -> Function: _delete_selected_preset(self)
#            |   -> Function: _end_edit(self, event)
#            |   -> Function: _export_presets(self)
#            |   -> Function: _import_presets(self)
#            |   -> Function: _move_preset_down(self)
#            |   -> Function: _move_preset_up(self)
#            |   -> Function: _on_double_click(self, event)
#            |   -> Function: _on_edit_escape(self, event)
#            |   -> Function: _on_edit_return(self, event)
#            |   -> Function: _on_tab_selected(self, event)
#            |   -> Function: _on_tree_select(self, event)
#            |   -> Function: _on_window_focus_in(self, event)
#            |   -> Function: _save_presets_to_csv(self)
#            |   -> Function: _start_edit(self, item_id, col_index)
#            |   -> Function: populate_presets_table(self)
#    ├── utils_preset_csv_process.py (Lines: 269)
#            |   -> Import: csv
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: numpy
#            |   -> Import: os
#            |   -> Import: pandas
#            |   -> Function: get_presets_csv_path(config_file_path, console_print_func)
#            |   -> Function: load_user_presets_from_csv(config_file_path, console_print_func)
#            |   -> Function: overwrite_user_presets_csv(config_file_path, presets_data, console_print_func, fieldnames)
#    ├── utils_preset_query_and_load.py (Lines: 271)
#            |   -> Import: Instrument.connection.instrument_logic
#            |   -> Import: Presets.utils_push_preset
#            |   -> Import: csv
#            |   -> Import: datetime
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: pandas
#            |   -> Import: pyvisa
#            |   -> Import: ref.ref_frequency_bands
#            |   -> Import: time
#            |   -> Import: yak.Yakety_Yak
#            |   -> Function: load_selected_preset_logic(app_instance, selected_preset_name, console_print_func, is_device_preset, preset_data_dict)
#            |   -> Function: query_current_instrument_settings_for_preset(inst, console_print_func)
#            |   -> Function: query_device_presets_logic(app_instance, console_print_func)
#    ├── utils_presets_editor.py (Lines: 267)
#            |   -> Import: Instrument.connection.instrument_logic
#            |   -> Import: csv
#            |   -> Import: datetime
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: numpy
#            |   -> Import: os
#            |   -> Import: pandas
#            |   -> Import: ref.ref_file_paths
#            |   -> Import: shutil
#            |   -> Import: utils_preset_csv_process
#            |   -> Class: PresetEditorLogic
#            |   -> Function: __init__(self, app_instance, console_print_func, columns)
#            |   -> Function: add_current_settings(self)
#            |   -> Function: add_new_empty_row(self)
#            |   -> Function: delete_presets(self, selected_filenames)
#            |   -> Function: export_presets(self, file_path)
#            |   -> Function: import_presets(self, file_path)
#            |   -> Function: load_presets(self)
#            |   -> Function: move_preset_down(self, filename)
#            |   -> Function: move_preset_up(self, filename)
#            |   -> Function: save_presets(self)
#            |   -> Function: update_preset_value(self, filename, column_name, new_value)
#    └── utils_push_preset.py (Lines: 210)
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: re
#            |   -> Import: ref.ref_frequency_bands
#            |   -> Import: yak.Yakety_Yak
#            |   -> Function: push_preset_logic(app_instance, console_print_func, preset_data)
#└── process_math/
#    ├── __init__ .py (Lines: 0)
#            - No functions, classes, or imports found.
#    ├── averaging_utils.py (Lines: 735)
#            |   -> Import: Plotting.utils_plotting
#            |   -> Import: csv
#            |   -> Import: datetime
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: numpy
#            |   -> Import: os
#            |   -> Import: pandas
#            |   -> Import: platform
#            |   -> Import: re
#            |   -> Import: ref.ref_frequency_bands
#            |   -> Function: _calculate_average(power_levels_df, console_print_func)
#            |   -> Function: _calculate_median(power_levels_df, console_print_func)
#            |   -> Function: _calculate_psd(power_levels_df, rbw_values, console_print_func)
#            |   -> Function: _calculate_range(power_levels_df, console_print_func)
#            |   -> Function: _calculate_std_dev(power_levels_df, console_print_func)
#            |   -> Function: _calculate_variance(power_levels_df, console_print_func)
#            |   -> Function: _create_output_subfolder(base_output_dir, prefix, timestamp_str, console_print_func)
#            |   -> Function: average_scan(file_paths, selected_avg_types, plot_title_prefix, output_html_path_base, console_print_func)
#            |   -> Function: generate_multi_file_average_and_plot(file_paths, selected_avg_types, plot_title_prefix, include_tv_markers, include_gov_markers, include_markers, output_html_path_base, open_html_after_complete, console_print_func)
#    ├── calculate_intermod.py (Lines: 348)
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: math
#            |   -> Import: os
#            |   -> Import: pandas
#            |   -> Import: typing
#            |   -> Function: _get_severity(order_label)
#            |   -> Function: euclidean_distance(pos1, pos2)
#            |   -> Function: multi_zone_intermods(zones, in_band_low_freq, in_band_high_freq, export_csv, include_3rd_order, include_5th_order, include_cross_zone_imd, console_print_func)
#    ├── google_maps_lookup.py (Lines: 173)
#            |   -> Import: datetime
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: json
#            |   -> Import: requests
#            |   -> Import: time
#            |   -> Function: get_location_from_google_maps(query, google_maps_api_key, console_print_func)
#    ├── json_host.py (Lines: 386)
#            |   -> Import: csv
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: flask
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: sys
#            |   -> Function: _get_scan_files()
#            |   -> Function: _read_markers_data()
#            |   -> Function: _read_scan_data(filename)
#            |   -> Function: get_markers_data()
#            |   -> Function: get_scan_data(filename)
#            |   -> Function: get_scan_in_progress_data()
#            |   -> Function: index()
#            |   -> Function: list_scans()
#    ├── math_frequency_translation.py (Lines: 46)
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Function: format_hz(hz_value)
#    ├── ploting_intermod_zones.py (Lines: 266)
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: pandas
#            |   -> Import: plotly.express
#            |   -> Import: plotly.graph_objects
#            |   -> Import: typing
#            |   -> Function: plot_zones(zones, imd_df, html_filename, color_code_severity, console_print_func)
#    └── scan_stitch.py (Lines: 248)
#            |   -> Import: csv
#            |   -> Import: datetime
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: pandas
#            |   -> Import: ref.ref_frequency_bands
#            |   -> Function: process_and_stitch_scan_data(raw_data, overall_start_freq_hz, overall_stop_freq_hz, console_print_func)
#            |   -> Function: stitch_and_save_scan_data(raw_scan_data_for_current_sweep, output_folder, scan_name, operator_name, venue_name, equipment_used, notes, postal_code, latitude, longitude, antenna_type, antenna_amplifier, console_print_func)
#└── ref/
#    ├── __init__ .py (Lines: 0)
#            - No functions, classes, or imports found.
#    ├── ref_antenna_amplifier_type.py (Lines: 63)
#            |   -> Function: display_antenna_amplifier_types()
#    ├── ref_antenna_type.py (Lines: 63)
#            |   -> Function: display_antenna_types()
#    ├── ref_file_paths.py (Lines: 71)
#            |   -> Import: os
#    ├── ref_frequency_bands.py (Lines: 263)
#            |   -> Function: display_default_freq_shift_options()
#            |   -> Function: display_default_ref_level_options()
#            |   -> Function: display_eu_tv_band_markers()
#            |   -> Function: display_gov_plot_band_markers()
#            |   -> Function: display_rbw_options()
#            |   -> Function: display_scan_band_ranges()
#            |   -> Function: display_tv_plot_band_markers()
#            |   -> Function: display_vbw_rbw_ratio_options()
#    ├── ref_program_default_values.py (Lines: 169)
#            |   -> Import: datetime
#            |   -> Import: os
#            |   -> Import: ref.ref_frequency_bands
#    ├── ref_scanner_setting_lists.py (Lines: 558)
#            - No functions, classes, or imports found.
#    └── ref_scanning_setting.py (Lines: 392)
#            - No functions, classes, or imports found.
#└── Scanning/
#    ├── TAB_SCANNING_PARENT.py (Lines: 125)
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: tab_scanning_child_bands
#            |   -> Import: tab_scanning_child_scan_configuration
#            |   -> Import: tab_scanning_child_scan_meta_data
#            |   -> Import: tkinter
#            |   -> Class: TAB_SCANNING_PARENT
#            |   -> Function: __init__(self, parent, app_instance, console_print_func)
#            |   -> Function: _on_child_tab_selected(self, event)
#            |   -> Function: _on_parent_tab_selected(self, event)
#    ├── __init__.py (Lines: 24)
#    ├── tab_scanning_child_bands.py (Lines: 450)
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: matplotlib.backends.backend_tkagg
#            |   -> Import: matplotlib.figure
#            |   -> Import: numpy
#            |   -> Import: os
#            |   -> Import: settings_and_config.config_manager_save
#            |   -> Import: tkinter
#            |   -> Class: BandsTab
#            |   -> Function: __init__(self, master, app_instance, console_print_func)
#            |   -> Function: _create_widgets(self)
#            |   -> Function: _deselect_all_bands(self)
#            |   -> Function: _on_band_button_toggle(self, band_item)
#            |   -> Function: _on_tab_selected(self, event)
#            |   -> Function: _populate_band_buttons(self)
#            |   -> Function: _select_all_bands(self)
#            |   -> Function: _update_all_band_button_styles(self)
#            |   -> Function: _update_band_chart(self)
#            |   -> Function: _update_band_table(self)
#            |   -> Function: _update_button_style(self, button, level)
#    ├── tab_scanning_child_scan_configuration.py (Lines: 319)
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: ref.ref_scanner_setting_lists
#            |   -> Import: ref.ref_scanning_setting
#            |   -> Import: settings_and_config.config_manager_save
#            |   -> Import: subprocess
#            |   -> Import: sys
#            |   -> Import: tkinter
#            |   -> Class: ScanTab
#            |   -> Function: __init__(self, master, app_instance, console_print_func)
#            |   -> Function: _browse_output_folder(self)
#            |   -> Function: _create_setting_row(self, parent, row, key, label_text, app_var, data_list, unit)
#            |   -> Function: _create_widgets(self)
#            |   -> Function: _load_settings_into_ui(self)
#            |   -> Function: _on_boolean_combobox_select(self, event, app_var)
#            |   -> Function: _on_combobox_select(self, event, app_var, data_list, description_var, unit)
#            |   -> Function: _on_tab_selected(self, event)
#            |   -> Function: _open_output_folder(self)
#            |   -> Function: _set_combobox_display_from_value(self, key)
#    ├── tab_scanning_child_scan_meta_data.py (Lines: 556)
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: process_math.google_maps_lookup
#            |   -> Import: ref.ref_antenna_amplifier_type
#            |   -> Import: ref.ref_antenna_type
#            |   -> Import: settings_and_config.config_manager_save
#            |   -> Import: subprocess
#            |   -> Import: tkinter
#            |   -> Class: ScanMetaDataTab
#            |   -> Function: __init__(self, master, app_instance, console_print_func, style_obj)
#            |   -> Function: _create_widgets(self)
#            |   -> Function: _lookup_postal_code(self)
#            |   -> Function: _on_amplifier_type_selected(self, event)
#            |   -> Function: _on_antenna_type_selected(self, event)
#            |   -> Function: _on_notes_change(self, event)
#            |   -> Function: _on_tab_selected(self, event)
#    └── utils_scan_instrument.py (Lines: 481)
#            |   -> Import: datetime
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: numpy
#            |   -> Import: os
#            |   -> Import: pandas
#            |   -> Import: process_math.scan_stitch
#            |   -> Import: pyvisa
#            |   -> Import: re
#            |   -> Import: ref.ref_frequency_bands
#            |   -> Import: src.connection_status_logic
#            |   -> Import: threading
#            |   -> Import: time
#            |   -> Import: utils.utils_csv_writer
#            |   -> Function: _scan_thread_target(app_instance, selected_bands, stop_event, pause_event, console_print_func, update_progress_func)
#            |   -> Function: configure_instrument_for_scan(inst, center_freq_hz, span_hz, rbw_hz, ref_level_dbm, freq_shift_hz, high_sensitivity_on, preamp_on, app_instance_ref, app_console_update_func)
#            |   -> Function: initiate_scan_thread(app_instance, console_print_func, stop_event, pause_event, update_progress_func)
#            |   -> Function: perform_segment_sweep(inst, segment_start_freq_hz, segment_stop_freq_hz, maxhold_enabled, max_hold_time, app_instance_ref, pause_event, stop_event, segment_counter, total_segments_in_band, band_name, app_console_update_func, current_segment_start_freq_hz)
#            |   -> Function: perform_single_sweep(inst, app_instance_ref, app_console_update_func)
#            |   -> Function: query_safe(inst, command, app_instance_ref, app_console_update_func)
#            |   -> Function: scan_bands(app_instance_ref, inst, selected_bands, rbw_hz, ref_level_dbm, freq_shift_hz, maxhold_enabled, high_sensitivity, preamp_on, rbw_step_size_hz, max_hold_time_seconds, scan_name, output_folder, stop_event, pause_event, log_visa_commands_enabled, general_debug_enabled, app_console_update_func, initialize_instrument_func)
#            |   -> Function: write_safe(inst, command, app_instance_ref, app_console_update_func)
#└── settings_and_config/
#    ├── __init__.py (Lines: 0)
#    ├── config_manager_application.py (Lines: 88)
#            |   -> Import: configparser
#            |   -> Import: datetime
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Function: _save_application_settings(config, app_instance, console_print_func)
#    ├── config_manager_debug.py (Lines: 87)
#            |   -> Import: configparser
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Function: _save_debug_settings(config, app_instance, console_print_func)
#    ├── config_manager_instruments.py (Lines: 231)
#            |   -> Import: configparser
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Function: _save_amplifier_settings(config, app_instance, console_print_func)
#            |   -> Function: _save_antenna_settings(config, app_instance, console_print_func)
#            |   -> Function: _save_instrument_settings(config, app_instance, console_print_func)
#    ├── config_manager_marker.py (Lines: 94)
#            |   -> Import: configparser
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Function: _save_marker_tab_settings(config, app_instance, console_print_func)
#    ├── config_manager_plotting.py (Lines: 79)
#            |   -> Import: configparser
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Function: _save_plotting_settings(config, app_instance, console_print_func)
#    ├── config_manager_report.py (Lines: 99)
#            |   -> Import: configparser
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Function: _save_report_settings(config, app_instance, console_print_func)
#    ├── config_manager_restore.py (Lines: 124)
#            |   -> Import: configparser
#            |   -> Import: datetime
#            |   -> Import: display.console_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: ref.ref_program_default_values
#            |   -> Import: settings_and_config.config_manager_save
#            |   -> Import: tkinter
#            |   -> Function: restore_default_settings(app_instance, console_print_func)
#            |   -> Function: restore_last_used_settings(app_instance, console_print_func)
#    ├── config_manager_save.py (Lines: 82)
#            |   -> Import: configparser
#            |   -> Import: datetime
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: ref.ref_file_paths
#            |   -> Import: ref.ref_program_default_values
#            |   -> Import: tkinter
#            |   -> Function: load_program_config()
#            |   -> Function: save_program_config(config)
#    └── config_manager_scan.py (Lines: 179)
#            |   -> Import: configparser
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Function: _save_scan_info_settings(config, app_instance, console_print_func)
#└── src/
#    ├── TABS_PARENT.py (Lines: 128)
#            |   -> Import: Experiments.TAB_EXPERIMENTS_PARENT
#            |   -> Import: Instrument.TAB_INSTRUMENT_PARENT
#            |   -> Import: Markers.TAB_MARKERS_PARENT
#            |   -> Import: Plotting.TAB_PLOTTING_PARENT
#            |   -> Import: Presets.TAB_PRESETS_PARENT
#            |   -> Import: Scanning.TAB_SCANNING_PARENT
#            |   -> Import: datetime
#            |   -> Import: functools
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: tkinter
#            |   -> Class: TABS_PARENT
#            |   -> Function: __init__(self, parent, app_instance, console_print_func)
#            |   -> Function: _create_widgets(self)
#            |   -> Function: switch_tab(self, new_tab_name)
#    ├── __init__.py (Lines: 0)
#    ├── connection_status_logic.py (Lines: 78)
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: tkinter
#            |   -> Function: update_connection_status_logic(app_instance, is_connected, is_running, console_print_func)
#    ├── gui_elements.py (Lines: 219)
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: sys
#            |   -> Import: time
#            |   -> Import: tkinter
#            |   -> Class: TextRedirector
#            |   -> Function: __init__(self, widget, tag)
#            |   -> Function: _print_collaboration_ascii(console_print_func)
#            |   -> Function: _print_inst_ascii(console_print_func)
#            |   -> Function: _print_marks_ascii(console_print_func)
#            |   -> Function: _print_open_air_ascii(console_print_func)
#            |   -> Function: _print_plot_ascii(console_print_func)
#            |   -> Function: _print_presets_ascii(console_print_func)
#            |   -> Function: _print_scan_ascii(console_print_func)
#            |   -> Function: _print_xxx_ascii(console_print_func)
#            |   -> Function: display_splash_screen()
#            |   -> Function: flush(self)
#            |   -> Function: write(self, text)
#    ├── program_check_dependancies.py (Lines: 108)
#            |   -> Import: datetime
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: subprocess
#            |   -> Import: sys
#            |   -> Function: check_and_install_dependencies()
#    ├── program_gui_utils.py (Lines: 96)
#            |   -> Import: TABS_PARENT
#            |   -> Import: datetime
#            |   -> Import: display.DISPLAY_PARENT
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: tkinter
#            |   -> Function: apply_saved_geometry(app_instance)
#            |   -> Function: create_main_layout(app_instance, style_obj)
#    ├── program_initialization.py (Lines: 99)
#            |   -> Import: datetime
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: ref.ref_file_paths
#            |   -> Import: settings_and_config.config_manager_restore
#            |   -> Import: settings_and_config.config_manager_save
#            |   -> Import: src.program_shared_values
#            |   -> Import: tkinter
#            |   -> Function: _create_required_folders()
#            |   -> Function: _setup_initial_settings(app_instance)
#            |   -> Function: initialize_application(app_instance)
#    ├── program_shared_values.py (Lines: 85)
#            |   -> Import: datetime
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: tkinter
#            |   -> Function: setup_shared_values(app_instance)
#    └── program_style.py (Lines: 410)
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: tkinter
#            |   -> Function: _get_dark_color(hex_color)
#            |   -> Function: _revert_to_default_styles(style)
#            |   -> Function: apply_styles(style, debug_log_func, current_app_version)
#└── tabs/
#└── utils/
#    ├── __init__.py (Lines: 0)
#    └── utils_csv_writer.py (Lines: 125)
#            |   -> Import: csv
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Function: write_scan_data_to_csv(file_path, header, data, app_instance_ref, append_mode, console_print_func)
#└── variables/
#    ├── __init__.py (Lines: 0)
#    ├── vars_app_and_debug.py (Lines: 64)
#            |   -> Import: datetime
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: ref.ref_program_default_values
#            |   -> Import: tkinter
#            |   -> Function: setup_app_and_debug_vars(app_instance)
#    ├── vars_instrument.py (Lines: 64)
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: ref.ref_frequency_bands
#            |   -> Import: ref.ref_program_default_values
#            |   -> Import: tkinter
#            |   -> Function: setup_instrument_vars(app_instance)
#    ├── vars_marker_tab.py (Lines: 68)
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: ref.ref_program_default_values
#            |   -> Import: tkinter
#            |   -> Function: setup_marker_tab_vars(app_instance)
#    ├── vars_plotting.py (Lines: 49)
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: ref.ref_program_default_values
#            |   -> Import: tkinter
#            |   -> Function: setup_plotting_vars(app_instance)
#    ├── vars_report_meta.py (Lines: 67)
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: ref.ref_program_default_values
#            |   -> Import: tkinter
#            |   -> Function: setup_report_meta_vars(app_instance)
#    └── vars_scan_config.py (Lines: 68)
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: ref.ref_frequency_bands
#            |   -> Import: ref.ref_program_default_values
#            |   -> Import: tkinter
#            |   -> Function: setup_scan_config_vars(app_instance)
#└── yak/
#    ├── Yakety_Yak.py (Lines: 568)
#            |   -> Import: csv
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: pyvisa
#            |   -> Import: ref.ref_file_paths
#            |   -> Import: time
#            |   -> Import: tkinter
#            |   -> Import: yak.utils_yak_visa
#            |   -> Function: YakBeg(app_instance, command_type, console_print_func)
#            |   -> Function: YakDo(app_instance, command_type, console_print_func)
#            |   -> Function: YakGet(app_instance, command_type, console_print_func)
#            |   -> Function: YakNab(app_instance, command_type, console_print_func)
#            |   -> Function: YakRig(app_instance, command_type, console_print_func)
#            |   -> Function: YakSet(app_instance, command_type, variable_value, console_print_func)
#            |   -> Function: _find_command(command_type, action_type, model)
#            |   -> Function: _load_commands_from_file(file_path)
#            |   -> Function: execute_visa_command(app_instance, action_type, visa_command, variable_value, console_print_func, num_reads)
#    ├── utils_yak_setting_handler.py (Lines: 833)
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: numpy
#            |   -> Import: os
#            |   -> Import: threading
#            |   -> Import: time
#            |   -> Import: yak.Yakety_Yak
#            |   -> Function: _process_trace_data(raw_data_string, start_freq_hz, end_freq_hz, console_print_func)
#            |   -> Function: _trigger_gui_refresh(app_instance)
#            |   -> Function: do_immediate_initiate(app_instance, console_print_func)
#            |   -> Function: do_peak_search(app_instance, console_print_func)
#            |   -> Function: do_power_cycle(app_instance, console_print_func)
#            |   -> Function: do_turn_all_markers_on(app_instance, console_print_func)
#            |   -> Function: get_all_marker_values_logic(app_instance, console_print_func)
#            |   -> Function: get_trace_averaging_settings(app_instance, trace_number, console_print_func)
#            |   -> Function: get_trace_data_logic(app_instance, console_print_func)
#            |   -> Function: refresh_all_from_instrument(app_instance, console_print_func)
#            |   -> Function: reset_device(app_instance, console_print_func)
#            |   -> Function: set_center_frequency(app_instance, value, console_print_func)
#            |   -> Function: set_continuous_initiate_mode(app_instance, mode, console_print_func)
#            |   -> Function: set_power_attenuation(tab_instance, app_instance, value, console_print_func)
#            |   -> Function: set_reference_level(tab_instance, app_instance, value, console_print_func)
#            |   -> Function: set_resolution_bandwidth(app_instance, value, console_print_func)
#            |   -> Function: set_span_frequency(app_instance, value, console_print_func)
#            |   -> Function: set_start_frequency(app_instance, value, console_print_func)
#            |   -> Function: set_stop_frequency(app_instance, value, console_print_func)
#            |   -> Function: set_trace_averaging_count(app_instance, trace_number, count, console_print_func)
#            |   -> Function: set_trace_mode(app_instance, trace_number, mode, console_print_func)
#            |   -> Function: set_video_bandwidth(app_instance, value, console_print_func)
#            |   -> Function: toggle_high_sensitivity(tab_instance, app_instance, console_print_func)
#            |   -> Function: toggle_marker_state(app_instance, marker_number, state, console_print_func)
#            |   -> Function: toggle_preamp(tab_instance, app_instance, console_print_func)
#            |   -> Function: toggle_trace_averaging(app_instance, trace_number, is_on, console_print_func)
#            |   -> Function: toggle_vbw_auto(app_instance, console_print_func)
#    ├── utils_yak_visa.py (Lines: 264)
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: pyvisa
#            |   -> Import: time
#            |   -> Function: _reset_device(inst, console_print_func)
#            |   -> Function: _wait_for_opc(inst, console_print_func, timeout)
#            |   -> Function: query_safe(inst, command, console_print_func)
#            |   -> Function: set_safe(inst, command, value, console_print_func)
#            |   -> Function: write_safe(inst, command, console_print_func)
#    ├── utils_yakbeg_handler.py (Lines: 201)
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: numpy
#            |   -> Import: os
#            |   -> Import: typing
#            |   -> Import: yak.Yakety_Yak
#            |   -> Function: handle_freq_center_span_beg(app_instance, center_freq, span_freq, console_print_func)
#            |   -> Function: handle_freq_start_stop_beg(app_instance, start_freq, stop_freq, console_print_func)
#            |   -> Function: handle_marker_place_all_beg(app_instance, marker_freqs_mhz, console_print_func)
#            |   -> Function: handle_trace_data_beg(app_instance, trace_number, start_freq_mhz, stop_freq_mhz, console_print_func)
#            |   -> Function: handle_trace_modes_beg(app_instance, trace_modes, console_print_func)
#    └── utils_yaknab_handler.py (Lines: 215)
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: numpy
#            |   -> Import: os
#            |   -> Import: typing
#            |   -> Import: yak.Yakety_Yak
#            |   -> Function: handle_all_traces_nab(app_instance, console_print_func)
#            |   -> Function: handle_amplitude_settings_nab(app_instance, console_print_func)
#            |   -> Function: handle_bandwidth_settings_nab(app_instance, console_print_func)


--------------------------------------------------

# ====================================================================================
# EVERYTHING.py.LOG
# This file contains the complete content of all Python, CSV, and INI files found during the crawl.
# Each file's content is separated by its path and a dashed line.
#
# Log started at: 2025-08-21 21:23:28
# ====================================================================================

#####################################
### File: OPEN-AIR\main.py
#####################################
# FolderName/main.py
#
# This is the main entry point for the RF Spectrum Analyzer Controller application.
# It handles initial setup, checks for dependencies, and launches the main GUI.
# This refactored version uses a cleaner, two-pane layout managed by dedicated parent components.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.204500.3 (FIXED: Initialization logic)

import sys
import tkinter as tk
from tkinter import ttk
import inspect
from datetime import datetime
import os

# Import local modules
from src.gui_elements import _print_inst_ascii, _print_marks_ascii, _print_presets_ascii, _print_scan_ascii, _print_plot_ascii, _print_collaboration_ascii, _print_xxx_ascii
from src.program_check_dependancies import check_and_install_dependencies
from src.program_initialization import initialize_application
from src.program_gui_utils import create_main_layout, apply_saved_geometry
from settings_and_config.config_manager_save import load_program_config, save_program_config
from ref.ref_file_paths import VISA_COMMANDS_FILE_PATH, CONFIG_FILE_PATH
from src.program_style import apply_styles
from ref.ref_program_default_values import DEFAULT_CONFIG

def restart_program(app_instance):
    """
    Restarts the current program.
    """
    app_instance.destroy()
    python = sys.executable
    os.execl(python, python, *sys.argv)

class App(tk.Tk):
    """The main application class for the RF Spectrum Analyzer Controller."""
    def __init__(self):
        super().__init__()
        current_function = inspect.currentframe().f_code.co_name
        
        self.current_version = "20250821.204500.3"
        self.current_file = f"{os.path.basename(__file__)}"
        self.inst = None

        print(f"Initializing application. Version: {self.current_version}. Let's get this show on the road! 🚀")
        
        try:
            self.title("RF Spectrum Analyzer Controller")
            
            self.program_config = load_program_config()
            
            self.VISA_COMMANDS_FILE_PATH = VISA_COMMANDS_FILE_PATH
            
            self.tabs_parent = None
            self.display_parent = None
            self.paned_window = None
            
            self.tab_art_map = {
                "Instruments": _print_inst_ascii,
                "Scanning": _print_scan_ascii,
                "Plotting": _print_plot_ascii,
                "Markers": _print_marks_ascii,
                "Presets": _print_presets_ascii,
                "Experiments": _print_xxx_ascii
            }

            self.protocol("WM_DELETE_WINDOW", self.on_closing)
            
            self._create_gui()
            self._post_gui_setup()

            self.bind('<Configure>', self._save_state_on_configure)
            
            menubar = tk.Menu(self)
            self.config(menu=menubar)
            file_menu = tk.Menu(menubar, tearoff=0)
            menubar.add_cascade(label="File", menu=file_menu)
            file_menu.add_command(label="Restart", command=lambda: restart_program(self))

        except Exception as e:
            print(f"❌ An error occurred during program initialization: {e}")
            self.destroy()

        print(f"App initialized. Version: {self.current_version}.")


    def _create_gui(self):
        current_function = inspect.currentframe().f_code.co_name
        print(f"⚙️ 🟢 Entering {current_function}")
        
        self.title("RF Spectrum Analyzer Controller")
        
        self.style_obj = ttk.Style(self)
        apply_styles(self.style_obj, debug_log_func=None, current_app_version=self.current_version)
        
        # --- FIXED: Pass style_obj to the layout creator ---
        self.paned_window, self.tabs_parent, self.display_parent = create_main_layout(self, self.style_obj)
        
        print(f"⚙️ ✅ Exiting {current_function}")
    
    def _post_gui_setup(self):
        """
        Performs tasks that require the GUI to be fully created, like restoring geometry.
        """
        current_function = inspect.currentframe().f_code.co_name
        print(f"Post-GUI setup tasks starting.")
        
        apply_saved_geometry(self)

        self._set_console_redirectors()
        
        if hasattr(self, 'program_config') and self.program_config.has_option('Application', 'paned_window_sash_position_percentage'):
            sash_pos_percentage = int(self.program_config.get('Application', 'paned_window_sash_position_percentage'))
            self.after(100, lambda: self._apply_sash_position(sash_pos_percentage))
        
        self.paned_window.bind("<ButtonRelease-1>", self._save_sash_position)

    def _apply_sash_position(self, percentage):
        """Applies the sash position after the window is drawn."""
        current_width = self.winfo_width()
        if current_width > 0:
            sash_pos_absolute = (current_width * percentage) / 100
            self.paned_window.sashpos(0, int(sash_pos_absolute))
            print(f"✅ Paned window sash position restored to {percentage}%")

    def _set_console_redirectors(self):
        """
        Sets up console redirection to the GUI console text widget.
        """
        current_function = inspect.currentframe().f_code.co_name
        # --- FIXED: Check for the console_tab attribute ---
        if hasattr(self.display_parent, 'console_tab') and hasattr(self.display_parent.console_tab, 'console_output_widget'):
            sys.stdout.write = self.display_parent.console_tab.console_output_widget.insert_and_scroll
            sys.stderr.write = self.display_parent.console_tab.console_output_widget.insert_and_scroll
            self.redirector_set = True
            print("Console output redirected to GUI. All systems go!")
        else:
            self.redirector_set = False
            print("Console widgets not found. GUI console redirection not available. This is a critical failure!")
    
    def _save_state_on_configure(self, event):
        """
        A single function to handle saving both window geometry and sash position
        on a window configure event. This makes the system more robust.
        """
        current_function = inspect.currentframe().f_code.co_name
        
        try:
            self.program_config.set(section='Application', option='window_state', value=self.state())
            self.program_config.set(section='Application', option='geometry', value=self.winfo_geometry())

            if hasattr(self, 'paned_window') and self.paned_window and self.winfo_width() > 0:
                sash_pos = self.paned_window.sashpos(0)
                sash_pos_percentage = int((sash_pos / self.winfo_width()) * 100)
                self.program_config.set(section='Application', option='paned_window_sash_position_percentage', value=str(sash_pos_percentage))
            
            save_program_config(self.program_config)
        
        except Exception as e:
            print(f"❌ Error saving window state on configure: {e}")
        

    def _save_sash_position(self, event=None):
        """
        Saves the paned window sash position to the config file when the mouse is released.
        This handles the explicit user interaction of dragging the sash.
        """
        current_function = inspect.currentframe().f_code.co_name
        
        if hasattr(self, 'program_config') and hasattr(self, 'paned_window') and self.paned_window and self.winfo_width() > 0:
            sash_pos = self.paned_window.sashpos(0)
            sash_pos_percentage = int((sash_pos / self.winfo_width()) * 100)
            self.program_config.set(section='Application', option='paned_window_sash_position_percentage', value=str(sash_pos_percentage))
            
            save_program_config(self.program_config)


    def on_closing(self):
        """
        Handles the graceful shutdown of the application.
        """
        current_function = inspect.currentframe().f_code.co_name
        print(f"Closing application. Time for a long nap! 😴")
        
        if hasattr(self, 'program_config'):
            current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            self.program_config.set(section='Application', option='last_config_save_time', value=current_time)
            
            save_program_config(self.program_config)
            
        self.destroy()

if __name__ == "__main__":
    check_and_install_dependencies()
    app_instance = App()
    app_instance.mainloop()


#####################################
### File: OPEN-AIR\DATA\config.ini
#####################################
[Application]
geometry = 1920x1127+1912+32
window_state = zoomed
last_config_save_time = 2025-08-21 20:29:31
paned_window_sash_position_percentage = 40

[Debug]
general_debug_enabled = True
debug_to_gui_console = True
debug_to_terminal = False
debug_to_file = True
include_console_messages_to_debug_file = True
log_visa_commands_enabled = False
log_truncation_enabled = True
include_visa_messages_to_debug_file = True

[Instrument]
visa_resource = TCPIP0::192.168.1.100::inst0::INSTR

[InstrumentSettings]
center_freq_mhz = 1500
span_freq_mhz = 3000
start_freq_mhz = 0
stop_freq_mhz = 3000
rbw_mhz = 1
vbw_mhz = 1
vbw_auto_on = True
initiate_continuous_on = True
ref_level_dbm = -30
preamp_on = False
power_attenuation_db = 10
high_sensitivity_on = False
trace1_mode = WRITE
trace2_mode = MAXHOLD
trace3_mode = BLANK
trace4_mode = BLANK
marker1_on = False
marker2_on = False
marker3_on = False
marker4_on = False
marker5_on = False
marker6_on = False

[MarkerTab]
span_hz = 1000000
rbw_hz = 100000
trace_live = True
trace_max_hold = False
trace_min_hold = False
buffer_mhz = 3.0
poke_freq_mhz = 444.444444
buffered_start_var = 0.0
buffered_stop_var = 0.0
zone_selected = None
zone_zoom_button_selected_name = 
zone_zoom_label = 
zone_zoom_start = 
zone_zoom_stop = 
zone_device_count = 0
zone_group_count = 0
group_selected = None
group_zoom_button_selected = 
group_zoom_label = 
group_zoom_start = 
group_zoom_stop = 
group_device_count = 0
device_selected_name = 
device_selected_device_type = 
device_selected_center = 

[Scan]
output_folder = c:\documents
scan_name = DefaultScan
rbw_step_size_hz = 20000
num_scan_cycles = 1
cycle_wait_time_seconds = 0
maxhold_enabled = False
maxhold_time_seconds = 10
desired_default_focus_width = 5000000
create_html = True
open_html_after_complete = True
include_markers = True
include_gov_markers = True
include_tv_markers = True
include_scan_intermod_markers = True
math_average = True
math_median = True
math_variance = True
math_standard_deviation = True
math_range = True
math_psd = True
last_scan_configuration__selected_bands_levels = Low VHF+FM=1,High VHF+216=1,UHF 400-500=1,UHF 500-600=1,UHF 600-700=1,UHF 700-800=1,UHF 800-900=1,ISM-STL 900-970=1,AFTRCC 1430-1540=1,DECT-ALL 1880-2000=1,Cams Lower 2G-2.2G=1,Cams Upper 2.4G-2.4G=1

[Antenna]
selected_antenna_type = Generic
antenna_description = Broadband Omni
antenna_use = General Purpose
antenna_mount = Tripod
antenna_amplifier = None

[Amplifier]
selected_amplifier_type = Generic
amplifier_description = Inline LNA
amplifier_use = Compensate for cable loss

[Report]
operator_name = RF Technician
operator_contact = tech@example.com
venue_name = Default Venue
address_field = 123 Main St
city = Anytown
province = ON
venue_postal_code = A1B 2C3
notes = This is a default report generated by the OPEN-AIR software.
freq_shift = 0
scanner_type = Generic RF Scanner

[Plotting]
current_style_theme = dark
plot_grid_on = True
plot_grid_alpha = 0.5
plot_grid_color = gray



#####################################
### File: OPEN-AIR\DATA\SCANS\BTR800 - Open_Air_Markers - DefaultScan - 20250819_0021.csv
#####################################
ZONE,GROUP,DEVICE,NAME,FREQ,Peak
GARAGE,BTR,TELEX BTR,TX 1,519.400,nan
GARAGE,BTR,TELEX BTR,TX 2,520.700,nan


#####################################
### File: OPEN-AIR\DATA\SCANS\PRESETS.CSV
#####################################
Filename,NickName,Start,Stop,Center,Span,RBW,VBW,RefLevel,Attenuation,MaxHold,HighSens,PreAmp,Trace1Mode,Trace2Mode,Trace3Mode,Trace4Mode,Marker1Max,Marker2Max,Marker3Max,Marker4Max,Marker5Max,Marker6Max


#####################################
### File: OPEN-AIR\DATA\SCANS\config.ini
#####################################
[Application]
geometry = 1600x900+100+100
window_state = normal
last_config_save_time = 2025-08-21 14:28:26
paned_window_sash_position_percentage = 45

[Debug]
general_debug_enabled = True
debug_to_gui_console = True
debug_to_terminal = False
debug_to_file = True
include_console_messages_to_debug_file = True
log_visa_commands_enabled = False
log_truncation_enabled = True
include_visa_messages_to_debug_file = True

[Instrument]
visa_resource = TCPIP0::192.168.1.100::inst0::INSTR

[InstrumentSettings]
center_freq_mhz = 1500
span_freq_mhz = 3000
start_freq_mhz = 0
stop_freq_mhz = 3000
rbw_mhz = 1
vbw_mhz = 1
vbw_auto_on = True
initiate_continuous_on = True
ref_level_dbm = -30
preamp_on = False
power_attenuation_db = 10
high_sensitivity_on = False
trace1_mode = WRITE
trace2_mode = MAXHOLD
trace3_mode = BLANK
trace4_mode = BLANK
marker1_on = False
marker2_on = False
marker3_on = False
marker4_on = False
marker5_on = False
marker6_on = False

[MarkerTab]
span_hz = 1000000
rbw_hz = 100000
trace_live = True
trace_max_hold = False
trace_min_hold = False
buffer_mhz = 3.0
poke_freq_mhz = 444.444444
buffered_start_var = 0.0
buffered_stop_var = 0.0
zone_selected = None
zone_zoom_button_selected_name = 
zone_zoom_label = 
zone_zoom_start = 
zone_zoom_stop = 
zone_device_count = 0
zone_group_count = 0
group_selected = None
group_zoom_button_selected = 
group_zoom_label = 
group_zoom_start = 
group_zoom_stop = 
group_device_count = 0
device_selected_name = 
device_selected_device_type = 
device_selected_center = 

[Scan]
output_folder = C:\Users\4483\OneDrive\Documents\GitHub\Spectrum-Automation---ZAP\50 - Python Code\OPEN-AIR\DATA\SCANS
scan_name = DefaultScan
rbw_step_size_hz = 20000
num_scan_cycles = 1
cycle_wait_time_seconds = 0
maxhold_enabled = False
maxhold_time_seconds = 10
desired_default_focus_width = 5000000
create_html = True
open_html_after_complete = True
include_markers = True
include_gov_markers = True
include_tv_markers = True
include_scan_intermod_markers = True
math_average = True
math_median = True
math_variance = True
math_standard_deviation = True
math_range = True
math_psd = True
last_scan_configuration__selected_bands_levels = Low VHF+FM=1,High VHF+216=1,UHF 400-500=1,UHF 500-600=1,UHF 600-700=1,UHF 700-800=1,UHF 800-900=1,ISM-STL 900-970=1,AFTRCC 1430-1540=1,DECT-ALL 1880-2000=1,Cams Lower 2G-2.2G=1,Cams Upper 2.4G-2.4G=1

[Antenna]
selected_antenna_type = Generic
antenna_description = Broadband Omni
antenna_use = General Purpose
antenna_mount = Tripod
antenna_amplifier = None

[Amplifier]
selected_amplifier_type = Generic
amplifier_description = Inline LNA
amplifier_use = Compensate for cable loss

[Report]
operator_name = RF Technician
operator_contact = tech@example.com
venue_name = Default Venue
address_field = 123 Main St
city = Anytown
province = ON
venue_postal_code = A1B 2C3
notes = This is a default report generated by the OPEN-AIR software.
freq_shift = 0
scanner_type = Generic RF Scanner

[Plotting]
current_style_theme = dark
plot_grid_on = True
plot_grid_alpha = 0.5
plot_grid_color = gray



#####################################
### File: OPEN-AIR\display\DISPLAY_PARENT.py
#####################################
# display/DISPLAY_PARENT.py
#
# This file defines the DISPLAY_PARENT class, which serves as a master container
# for all the display-related tabs in the right pane of the application.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.105600.2
# REFACTORED: Converted to use lazy imports to break circular dependency issues.
# FIXED: Added the `style_obj` parameter to the __init__ method.
# FIXED: Added the `change_display_tab` method to allow other modules to programmatically
#        switch the visible tab.
# FIXED: Resolved the `AttributeError` by removing the premature assignment of `gui_debug`
#        and `gui_console`. This is now handled by the child tab's initialization.

import os
import inspect
import tkinter as tk
from tkinter import ttk
from datetime import datetime

# Import logging
from display.console_logic import console_log
from display.debug_logic import debug_log


# --- Version Information ---
w = 20250821
x_str = '105600'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 2
current_version = f"{w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = f"{os.path.basename(__file__)}"


class DISPLAY_PARENT(ttk.Frame):
    """
    A parent container for all the display-related tabs in the application.
    """
    def __init__(self, parent, app_instance, style_obj):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=current_file, version=current_version, function=current_function)

        super().__init__(parent)
        self.app_instance = app_instance
        self.style_obj = style_obj
        self.notebook = ttk.Notebook(self)
        self.notebook.pack(expand=True, fill="both", padx=5, pady=5)
        
        # FIXED: Lazy imports to break circular dependencies
        from display.display_child_application_console import ConsoleTab
        from display.display_child_debug import DebugTab
        from display.display_child_scan_monitor import ScanMonitorTab
        from display.display_child_scan_view import ScanViewTab
        
        self.console_tab = ConsoleTab(self.notebook, self.app_instance)
        self.debug_tab = DebugTab(self.notebook, self.app_instance)
        self.scan_monitor_tab = ScanMonitorTab(self.notebook, self.app_instance)
        self.scan_view_tab = ScanViewTab(self.notebook, self.app_instance)

        self.notebook.add(self.console_tab, text="Console")
        self.notebook.add(self.debug_tab, text="Debug")
        self.notebook.add(self.scan_monitor_tab, text="Scan Monitor")
        self.notebook.add(self.scan_view_tab, text="Scan View")
        
        # REMOVED: Premature assignment of gui_console and gui_debug.
        # These will be set by the child tab's __init__ method after the widgets are created.
        
        debug_log(f"Exiting {current_function}",
                   file=current_file, version=current_version, function=current_function)
    
    def set_parent_notebook(self, notebook):
        # Function Description
        # This function sets the parent notebook for the child tabs.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=current_file, version=current_version, function=current_function)
        
        self.parent_notebook = notebook
        
        debug_log(f"Exiting {current_function}",
                    file=current_file, version=current_version, function=current_function)

    def change_display_tab(self, tab_name):
        # Function Description
        # This function programmatically changes the currently selected tab in the notebook.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"🖥️🔵 Entering {current_function} to switch to tab: {tab_name}",
                  file=current_file, version=current_version, function=current_function)
        
        try:
            tab_names = [self.notebook.tab(tab, "text") for tab in self.notebook.tabs()]
            if tab_name in tab_names:
                tab_index = tab_names.index(tab_name)
                self.notebook.select(tab_index)
                debug_log(f"🖥️✅ Successfully changed display tab to: {tab_name}",
                          file=current_file, version=current_version, function=current_function)
                console_log(f"✅ Display tab changed to: {tab_name}", function=current_function)
            else:
                debug_log(f"🖥️❌ Failed to change display tab. Tab '{tab_name}' not found.",
                          file=current_file, version=current_version, function=current_function)
                console_log(f"❌ Error: Cannot change display tab. Tab '{tab_name}' does not exist.", function=current_function)
        except Exception as e:
            console_log(f"❌ Error changing display tab: {e}")
            debug_log(f"🖥️🔴 Arrr, the function be capsized! The error be: {e}",
                      file=current_file, version=current_version, function=current_function)
            
        debug_log(f"🖥️ ✅ Exiting {current_function}",
                  file=current_file, version=current_version, function=current_function)

#####################################
### File: OPEN-AIR\display\console_logic.py
#####################################
# src/console_logic.py
#
# This module centralizes general application console logging functionality.
# It provides a function to print general application messages, which always
# attempt to go to the GUI console if available.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250814.230000.1 (FIXED: The console_log function now correctly filters the message emoji from the on-screen console output but includes it in the debug file.)

current_version = "20250814.230000.1"
current_version_hash = 20250814 * 230000 * 1

import sys
from datetime import datetime
import inspect
import tkinter as tk
import re

# NEW: Global references to debug_logic components, to be set by debug_logic
_gui_console_stdout_redirector = None
_original_stdout = sys.stdout # Keep a reference to original stdout for fallback

_debug_file_include_flag_ref = None
_debug_file_write_func_ref = None
_clear_console_func_ref = None
_log_truncation_mode_ref = None


def set_gui_console_redirector(stdout_redirector, stderr_redirector):
    """
    Function Description:
    Sets the TextRedirector instances for the GUI console for console messages.

    Inputs to this function:
    - stdout_redirector (gui_elements.TextRedirector): An instance of TextRedirector
                                                       that will redirect stdout to a Tkinter widget.
    - stderr_redirector (gui_elements.TextRedirector): An instance of TextRedirector
                                                       that will redirect stderr to a Tkinter widget.

    Outputs of this function:
    - None. Modifies global variables.
    """
    global _gui_console_stdout_redirector
    _gui_console_stdout_redirector = stdout_redirector
    current_function = inspect.currentframe().f_code.co_name
    console_log(f"Console output redirected to GUI. Version: {current_version}", function=current_function)


def set_debug_file_hooks(include_flag_callable, write_func):
    """
    Registers the debug file logging flag callable and write function from debug_logic.

    Args:
        include_flag_callable (callable): A callable (e.g., lambda) that returns the
                                          current boolean state of INCLUDE_CONSOLE_MESSAGES_TO_DEBUG_FILE
                                          from debug_logic.
        write_func (callable): The _write_to_debug_file function from debug_logic.
    """
    global _debug_file_include_flag_ref, _debug_file_write_func_ref
    _debug_file_include_flag_ref = include_flag_callable
    _debug_file_write_func_ref = write_func

def set_log_truncation_mode_ref(mode_callable):
    """Registers the callable for the log truncation mode."""
    global _log_truncation_mode_ref
    _log_truncation_mode_ref = mode_callable


def set_clear_console_func(clear_func):
    """
    Function Description:
    Registers the actual function that clears the GUI console.

    Inputs to this function:
    - clear_func (callable): A callable function (e.g., ConsoleTab's _clear_applications_console_action)
                             that will clear the content of the GUI console.

    Outputs of this function:
    - None. Modifies a global variable.
    """
    global _clear_console_func_ref
    _clear_console_func_ref = clear_func
    current_function = inspect.currentframe().f_code.co_name
    console_log(f"Clear console function registered. Version: {current_version}", function=current_function)


def clear_console():
    """
    Function Description:
    Calls the registered function to clear the GUI console.

    Inputs to this function:
    - None.

    Outputs of this function:
    - None. Triggers the console clear action.
    """
    current_function = inspect.currentframe().f_code.co_name
    if _clear_console_func_ref:
        _clear_console_func_ref()
    else:
        _original_stdout.write(f"DEBUG: [{current_function}] Cannot clear console, function not registered yet. Fucking useless!\n")


def console_log(message, function=None):
    """
    Function Description:
    Prints a general application message to the console.

    Inputs:
        message (str): The message to print.
        function (str, optional): The name of the function sending the message. Defaults to None.

    Outputs of this function:
        None. Prints a message to the console or terminal, and/or writes to a file.
    """
    timestamp = datetime.now().strftime("%H:%M:%S")
    
    prefix_parts = []
    if function:
        prefix_parts.append(function)

    prefix = f"[{' | '.join(prefix_parts)}] " if prefix_parts else ""

    # Generate message for debug file (with emoji)
    full_message_with_emoji = f"💬[{timestamp}] {prefix}{_truncate_message(message)}"
    
    # Generate message for console (without emoji)
    console_message = f"{prefix}{_truncate_message(message)}"

    if _gui_console_stdout_redirector:
        text_widget = _gui_console_stdout_redirector.widget
        original_state = text_widget.cget("state")
        text_widget.config(state=tk.NORMAL)
        _gui_console_stdout_redirector.write(console_message + "\n")
        text_widget.config(state=original_state)
    else:
        _original_stdout.write(console_message + "\n")

    if _debug_file_include_flag_ref and _debug_file_include_flag_ref() and _debug_file_write_func_ref:
        _debug_file_write_func_ref(full_message_with_emoji)

def _truncate_message(message: str, max_items=10) -> str:
    """Helper function to truncate long, comma-separated numeric strings."""
    numeric_pattern = re.compile(r'[-+]?\d*\.?\d+(?:[eE][-+]?\d+)?')
    matches = numeric_pattern.findall(message)
    if len(matches) > max_items:
        truncated_parts = matches[:max_items]
        return f"{', '.join(truncated_parts)}... (truncated)"
    return message


#####################################
### File: OPEN-AIR\display\debug_logic.py
#####################################
# src/debug_logic.py
#
# This module centralizes all debug and console logging functionality for the application.
# It provides functions to print debug messages (which can be toggled to go to the terminal
# or the GUI console) and general application messages (which always go to the GUI console).
# It also manages global flags for debug mode and VISA command logging.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
# Version 20250814.214800.1 (FIXED: Removed DEBUG_TO_TERMINAL, updated logging to be more efficient, added a new setting for log truncation to limit long outputs.)

current_version = "20250814.214800.1"
current_version_hash = 20250814 * 214800 * 1

import sys
import os
from datetime import datetime
import inspect
import re
from ref.ref_file_paths import DEBUG_COMMANDS_FILE_PATH, VISA_COMMANDS_FILE_PATH
# Global variables for debug control - SET TO FALSE BY DEFAULT!
DEBUG_MODE = False
LOG_VISA_COMMANDS = False
DEBUG_TO_FILE = False
INCLUDE_CONSOLE_MESSAGES_TO_DEBUG_FILE = False
LOG_TRUNCATION_ENABLED = False
DEBUG_TO_GUI_CONSOLE = False
INCLUDE_VISA_MESSAGES_TO_DEBUG_FILE = False


DEBUG_FILE_PATH = DEBUG_COMMANDS_FILE_PATH
VISA_FILE_PATH = VISA_COMMANDS_FILE_PATH

# Reference to the GUI console TextRedirector or original stdout/stderr
_gui_console_stdout_redirector = None
_gui_console_stderr_redirector = None
_original_stdout = sys.stdout
_original_stderr = sys.stderr

_console_log_func_ref = None


def _truncate_message(message: str, max_items=10) -> str:
    """Helper function to truncate long, comma-separated numeric strings."""
    if LOG_TRUNCATION_ENABLED:
        # Match scientific notation and standard float/int patterns
        numeric_pattern = re.compile(r'[-+]?\d*\.?\d+(?:[eE][-+]?\d+)?')
        matches = numeric_pattern.findall(message)
        if len(matches) > max_items:
            truncated_parts = matches[:max_items]
            return f"{', '.join(truncated_parts)}... (truncated)"
    return message


def set_debug_mode(mode: bool):
    global DEBUG_MODE
    DEBUG_MODE = mode
    current_function = inspect.currentframe().f_code.co_name
    if _console_log_func_ref:
        _console_log_func_ref(f"Debug Mode: {'Enabled' if DEBUG_MODE else 'Disabled'}", function=current_function)
    else:
        print(f"DEBUG_MODE set to: {DEBUG_MODE}. (console_log not yet registered)", file=_original_stdout)
    debug_log(f"Debug mode set to: {DEBUG_MODE}. Let the debugging begin!",
                file=os.path.basename(__file__),
                version=current_version,
                function=current_function)

def set_log_visa_commands_mode(mode: bool):
    global LOG_VISA_COMMANDS
    LOG_VISA_COMMANDS = mode
    current_function = inspect.currentframe().f_code.co_name
    if _console_log_func_ref:
        _console_log_func_ref(f"VISA Command Logging: {'Enabled' if LOG_VISA_COMMANDS else 'Disabled'}", function=current_function)
    else:
        print(f"LOG_VISA_COMMANDS set to: {LOG_VISA_COMMANDS}. (console_log not yet registered)", file=_original_stdout)
    debug_log(f"VISA command logging set to: {LOG_VISA_COMMANDS}. Tracking those commands!",
                file=os.path.basename(__file__),
                version=current_version,
                function=current_function)

def set_debug_to_file_mode(mode: bool):
    global DEBUG_TO_FILE
    DEBUG_TO_FILE = mode
    current_function = inspect.currentframe().f_code.co_name
    if _console_log_func_ref:
        _console_log_func_ref(f"Debug to File: {'Enabled' if DEBUG_TO_FILE else 'Disabled'}", function=current_function)
    else:
        print(f"Debug logging to file enabled. (console_log not yet registered)", file=_original_stdout)

def set_include_console_messages_to_debug_file_mode(mode: bool):
    global INCLUDE_CONSOLE_MESSAGES_TO_DEBUG_FILE
    INCLUDE_CONSOLE_MESSAGES_TO_DEBUG_FILE = mode
    current_function = inspect.currentframe().f_code.co_name
    if _console_log_func_ref:
        _console_log_func_ref(f"Include Console Messages to Debug File: {'Enabled' if INCLUDE_CONSOLE_MESSAGES_TO_DEBUG_FILE else 'Disabled'}", function=current_function)
    else:
        print(f"INCLUDE_CONSOLE_MESSAGES_TO_DEBUG_FILE set to: {INCLUDE_CONSOLE_MESSAGES_TO_DEBUG_FILE}. (console_log not yet registered)", file=_original_stdout)

def set_log_truncation_mode(mode: bool):
    global LOG_TRUNCATION_ENABLED
    LOG_TRUNCATION_ENABLED = mode
    current_function = inspect.currentframe().f_code.co_name
    if _console_log_func_ref:
        _console_log_func_ref(f"Log Truncation: {'Enabled' if LOG_TRUNCATION_ENABLED else 'Disabled'}", function=current_function)
    else:
        print(f"LOG_TRUNCATION_ENABLED set to: {LOG_TRUNCATION_ENABLED}. (console_log not yet registered)", file=_original_stdout)

def set_include_visa_messages_to_debug_file_mode(mode: bool):
    global INCLUDE_VISA_MESSAGES_TO_DEBUG_FILE
    INCLUDE_VISA_MESSAGES_TO_DEBUG_FILE = mode
    current_function = inspect.currentframe().f_code.co_name
    if _console_log_func_ref:
        _console_log_func_ref(f"Include VISA Messages to Debug File: {'Enabled' if INCLUDE_VISA_MESSAGES_TO_DEBUG_FILE else 'Disabled'}", function=current_function)
    else:
        print(f"INCLUDE_VISA_MESSAGES_TO_DEBUG_FILE set to: {INCLUDE_VISA_MESSAGES_TO_DEBUG_FILE}. (console_log not yet registered)", file=_original_stdout)


def set_debug_redirectors(stdout_redirector, stderr_redirector):
    global _gui_console_stdout_redirector, _gui_console_stderr_redirector
    _gui_console_stdout_redirector = stdout_redirector
    _gui_console_stderr_redirector = stderr_redirector
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"GUI debug redirectors set. All debug messages will now flow to the GUI! Version: {current_version}",
                file=os.path.basename(__file__),
                version=current_version,
                function=current_function)

def set_console_log_func(func):
    global _console_log_func_ref
    _console_log_func_ref = func
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Console log function registered with debug_logic. Breaking the circular import!",
                file=os.path.basename(__file__),
                version=current_version,
                function=current_function,
                special=True)

def _write_to_debug_file(message: str):
    if DEBUG_TO_FILE and DEBUG_FILE_PATH:
        try:
            os.makedirs(os.path.dirname(DEBUG_FILE_PATH), exist_ok=True)
            with open(DEBUG_FILE_PATH, 'a', encoding='utf-8') as f:
                f.write(message + "\n")
        except Exception as e:
            print(f"ERROR: Failed to write to debug log file {DEBUG_FILE_PATH}: {e}", file=_original_stderr)

def _write_to_visa_file(message: str):
    if LOG_VISA_COMMANDS and VISA_FILE_PATH:
        try:
            os.makedirs(os.path.dirname(VISA_FILE_PATH), exist_ok=True)
            with open(VISA_FILE_PATH, 'a', encoding='utf-8') as f:
                f.write(message + "\n")
        except Exception as e:
            print(f"ERROR: Failed to write to VISA log file {VISA_FILE_PATH}: {e}", file=_original_stderr)

def clear_debug_log_file(file_path: str):
    current_function = inspect.currentframe().f_code.co_name
    if os.path.exists(file_path):
        try:
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(f"--- Debug Log Cleared: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} ---\n")
            if _console_log_func_ref:
                _console_log_func_ref(f"✅ Debug log file cleared: {file_path}", function=current_function)
            else:
                print(f"✅ Debug log file cleared: {file_path}", file=_original_stdout)
            debug_log(f"Debug log file cleared.",
                        file=os.path.basename(__file__),
                        version=current_version,
                        function=current_function)
        except Exception as e:
            if _console_log_func_ref:
                _console_log_func_ref(f"❌ Error clearing debug log file {file_path}: {e}", function=current_function)
            else:
                print(f"❌ Error clearing debug log file {file_path}: {e}", file=_original_stderr)
            debug_log(f"ERROR: Failed to clear debug log file: {e}",
                        file=os.path.basename(__file__),
                        version=current_version,
                        function=current_function)
    else:
        if _console_log_func_ref:
            _console_log_func_ref(f"ℹ️ Debug log file does not exist: {file_path}. Nothing to clear.", function=current_function)
        else:
            print(f"ℹ️ Debug log file does not exist: {file_path}. Nothing to clear.", file=_original_stdout)
        debug_log(f"Debug log file does not exist. Cannot clear.",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)

def debug_log(message, file=None, version=None, function=None, special=False):
    if not DEBUG_MODE:
        return

    timestamp = datetime.now().strftime("%M.%S")
    
    prefix_parts = []
    if file:
        prefix_parts.append(os.path.basename(file))
    if version:
        prefix_parts.append(f"v{version}")
    if function:
        prefix_parts.append(function)
    if special:
        prefix_parts.append("SPECIAL")

    prefix = f"[{' | '.join(prefix_parts)}] " if prefix_parts else ""
    
    full_message = f"🐛[{timestamp}]{_truncate_message(message)} {prefix}"
    
    if DEBUG_TO_FILE:
        _write_to_debug_file(full_message)

    if _gui_console_stdout_redirector and DEBUG_TO_GUI_CONSOLE:
        _gui_console_stdout_redirector.write(full_message + "\n")
    else:
        print(full_message, file=_original_stdout)


def log_visa_command(command, direction="SENT"):
    if not LOG_VISA_COMMANDS:
        return

    timestamp = datetime.now().strftime("%M.%S")
    log_message = f"🌲 [{timestamp}] {direction}: {_truncate_message(command)}"
    
    _write_to_visa_file(log_message)
    
    if INCLUDE_VISA_MESSAGES_TO_DEBUG_FILE and DEBUG_TO_FILE:
        _write_to_debug_file(log_message)

    if _gui_console_stdout_redirector:
        _gui_console_stdout_redirector.write(log_message + "\n")
    else:
        print(log_message, file=_original_stdout)


#####################################
### File: OPEN-AIR\display\display_child_application_console.py
#####################################
# display/display_child_console.py
#
# This file defines the ConsoleTab, a Tkinter Frame that provides the application's
# console output area. It includes a scrolled text widget for displaying messages
# and a button to clear the console output. This tab is designed to be a child
# of the new TAB_DISPLAY_PARENT.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250810.220500.3 (FIXED: Corrected a race condition by initializing the console_text widget before other setup logic in the __init__ method, resolving the AttributeError.)

current_version = "20250810.220500.3" # this variable should always be defined below the header to make the debugging better
current_version_hash = 20250810 * 220500 * 3 # Example hash, adjust as needed

import tkinter as tk
from tkinter import ttk, scrolledtext
import inspect
import os

# Import the console and GUI redirector functions
from display.console_logic import console_log, set_gui_console_redirector, set_clear_console_func
from display.debug_logic import debug_log # CORRECTED: Import debug_log from src, not display
from src.gui_elements import TextRedirector # Import TextRedirector class

class ConsoleTab(ttk.Frame):
    """
    A Tkinter Frame that provides the application's console output area and controls.
    """
    def __init__(self, master=None, app_instance=None, **kwargs):
        # This function description tells me what this function does
        # Initializes the ConsoleTab, creating a dedicated frame for console output.
        # It sets up a ScrolledText widget and redirects stdout/stderr to it.
        # It also registers a function to clear the console output.
        #
        # Inputs to this function
        #   master (tk.Widget): The parent widget, typically a ttk.Notebook.
        #   app_instance (object): A reference to the main application instance
        #                          to access shared variables and methods.
        #   **kwargs: Arbitrary keyword arguments for Tkinter Frame.
        #
        # Process of this function
        #   1. Calls the superclass constructor (ttk.Frame).
        #   2. Stores a reference to the main app instance.
        #   3. Initializes the console text widget and assigns it to app_instance.
        #   4. Calls `_create_widgets` to build the rest of the UI.
        #   5. Sets up the console redirection.
        #   6. Registers the clear console action.
        #
        # Outputs of this function
        #   None. Initializes the Tkinter frame and its internal state.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Initializing ConsoleTab...",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)

        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        
        # CRITICAL FIX: The console text widget MUST be created here before it's used by other functions.
        # This fixes the AttributeError that was happening.
        self.console_text = scrolledtext.ScrolledText(self, wrap="word", bg="#2b2b2b", fg="#cccccc", insertbackground="white")
        self.app_instance.console_text = self.console_text
        self.console_text.config(state=tk.DISABLED)

        # NEW: Initialize the redirector instance here, and store it on the object.
        self.redirector = TextRedirector(self.console_text, "stdout")

        self._create_widgets()

        # FUCKING IMPORTANT: Set the console redirector here, after console_text is created.
        # This ensures all future print() and console_log calls go to this widget.
        if self.app_instance.console_text: # Ensure the app_instance's console_text is set to this widget
            # Pass our new redirector instance
            set_gui_console_redirector(self.redirector, self.redirector)
            console_log(f"Console output redirected to GUI. Version: {current_version}", function=current_function)
            debug_log(f"GUI console redirector set to ConsoleTab's scrolled text widget.",
                        file=f"{os.path.basename(__file__)} - {current_version}",
                        version=current_version,
                        function=current_function)
        else:
            debug_log(f"ERROR: app_instance.console_text not set to ConsoleTab's widget. Console redirection failed!",
                        file=f"{os.path.basename(__file__)} - {current_version}",
                        version=current_version,
                        function=current_function)
        
        # NEW: Register the clear console action with console_logic
        set_clear_console_func(self._clear_applications_console_action)
        
        debug_log(f"ConsoleTab initialized. The new console is ready for action!",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)


    def _create_widgets(self):
        # This function description tells me what this function does
        # Creates and arranges the widgets for the Console tab.
        # This includes the scrolled text area for output and the button to clear it.
        #
        # Inputs to this function
        #   None.
        #
        # Outputs of this function
        #   None. Populates the tab with GUI elements.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Creating ConsoleTab widgets.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)

        self.grid_rowconfigure(0, weight=1) # Console text area
        self.grid_rowconfigure(1, weight=0) # Clear Console button
        self.grid_columnconfigure(0, weight=1)

        # Console ScrolledText
        # The widget is created in __init__ now. We just need to place it.
        self.console_text.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)
        # The state will be managed by console_log itself when writing.

        # Clear Applications Console Button
        self.clear_applications_console_button = ttk.Button(self, text="Clear Applications Console",
                                                            command=self._clear_applications_console_action,
                                                            style='Red.TButton')
        self.clear_applications_console_button.grid(row=1, column=0, padx=5, pady=5, sticky="ew")

        debug_log(f"ConsoleTab widgets created.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)


    def _clear_applications_console_action(self):
        # This function description tells me what this function does
        # Clears the entire content of the ScrolledText widget for the application console.
        #
        # Inputs to this function
        #   None.
        #
        # Process of this function
        #   1. Checks if `app_instance.console_text` exists.
        #   2. If it exists, it deletes all text from the widget.
        #   3. Calls `console_log` to confirm the action.
        #   4. If the widget is not found, it logs an error.
        #
        # Outputs of this function
        #   None. Clears the contents of the console display.
        current_function = inspect.currentframe().f_code.co_name
        if self.app_instance.console_text:
            self.app_instance.console_text.delete("1.0", tk.END)
            console_log(f"Applications console cleared.", function=current_function)
        else:
            debug_log(f"ERROR: Cannot clear applications console, console_text widget not found. Fucking useless!",
                        file=f"{os.path.basename(__file__)} - {current_version}",
                        version=current_version,
                        function=current_function)


    def _on_tab_selected(self, event):
        # This function description tells me what this function does
        # Placeholder for actions to be taken when the Console tab is selected.
        #
        # Inputs to this function
        #   event (tkinter.Event): The event object.
        #
        # Outputs of this function
        #   None.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"ConsoleTab selected. No specific refresh action needed.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)


#####################################
### File: OPEN-AIR\display\display_child_debug.py
#####################################
# display/display_child_debug.py
#
# This file defines the DebugTab, a Tkinter Frame that provides the application's
# debug control settings. It includes a master control button, checkboxes to manage
# various debug flags, a button to clear debug logs, a button to open the data folder,
# and two ScrolledText widgets to display the contents of the debug log files in real-time.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.014000.2
# NEW: Implemented a log filter dropdown to display log messages based on their emoji prefix.
# FIXED: Corrected the log filtering logic to properly handle the 'All' option and
#        correctly filter lines that start with the selected emoji.
# FIXED: The log display now updates in real-time and correctly applies the filter
#        to new content without re-reading the entire file on every poll.
# FIXED: Resolved AttributeError by correctly placing methods inside the DebugTab class.
# FIXED: Resolved AttributeError from DISPLAY_PARENT by assigning app_instance.gui_debug
#        only after the widget is created.

current_version = "20250824.014000.2"
current_version_hash = 20250824 * 14000 * 2

import tkinter as tk
from tkinter import ttk, scrolledtext, filedialog
import inspect
import os
import subprocess
import sys
import threading
import time

# Import debug_log and the specific debug control functions from debug_logic
from display.debug_logic import (
    debug_log,
    set_debug_mode, set_log_visa_commands_mode,
    set_debug_to_file_mode, set_include_console_messages_to_debug_file_mode,
    clear_debug_log_file, set_log_truncation_mode, set_include_visa_messages_to_debug_file_mode,
    DEBUG_FILE_PATH, VISA_FILE_PATH
)
from display.console_logic import console_log
from settings_and_config.config_manager_save import save_program_config 

class DebugTab(ttk.Frame):
    """
    A Tkinter Frame that provides the debug control settings for the application.
    """
    def __init__(self, master=None, app_instance=None, **kwargs):
        # This function description tells me what this function does
        # Initializes the DebugTab, creating a dedicated frame for debug control settings.
        # It sets up a master toggle button, checkboxes for various debug flags,
        # buttons for file management, and two ScrolledText widgets to display
        # the contents of the debug log files in real-time.
        #
        # Inputs to this function
        #   master (tk.Widget): The parent widget, typically a ttk.Notebook.
        #   app_instance (object): A reference to the main application instance
        #                      to access shared variables and methods.
        #   **kwargs: Arbitrary keyword arguments for Tkinter Frame.
        #
        # Outputs of this function
        #   None. Initializes the Tkinter frame and its internal state.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Initializing DebugTab...",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)

        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.polling_id = None
        self.last_software_log_size = 0
        self.last_visa_log_size = 0
        self.read_log_thread = None
        self.stop_thread = threading.Event()
        
        self.software_log_lines = []
        
        self.log_filter_var = tk.StringVar(value="All")
        self.log_filter_map = {
            "All": None,  # Use None to indicate no filter
            "🐐 YAK": "🐐",
            "💾 Saves": "💾",
            "🖥️ displays": "🖥️",
            "🛠️ utilities": "🛠️"
        }

        self._create_widgets()
        
        # CRITICAL FIX: The debug_text widget is created in _create_widgets, so we assign it here.
        # This resolves the race condition and the AttributeError.
        self.app_instance.gui_debug = self.software_log_text
        
        debug_log(f"DebugTab initialized. The debug controls and log viewers are ready for action! 🛡️",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)

    def _create_widgets(self):
        # This function description tells me what this function does
        # Creates and arranges the widgets for the Debug tab.
        # This includes a master debug toggle button, checkboxes for various debug flags,
        # buttons for file management, and two ScrolledText widgets to display
        # the contents of the debug log files in real-time.
        #
        # Inputs to this function
        #   None.
        #
        # Outputs of this function
        #   None. Populates the tab with GUI elements.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Creating DebugTab widgets.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)

        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(2, weight=1)
        
        # --- Master Debug Control Frame ---
        master_control_frame = ttk.LabelFrame(self, text="Master Debug Control", style='Dark.TLabelframe')
        master_control_frame.grid(row=0, column=0, padx=10, pady=5, sticky="ew")
        master_control_frame.grid_columnconfigure(0, weight=1)
        
        # Master debug toggle button
        self.toggle_debug_button = ttk.Button(master_control_frame, text="Enable Debug", command=self._toggle_debug_mode, style='Blue.TButton')
        self.toggle_debug_button.grid(row=0, column=0, padx=5, pady=5, sticky="ew")
        
        # NEW: Set initial state of the button based on the config variable
        if self.app_instance.general_debug_enabled_var.get():
            self.toggle_debug_button.config(text="Disable Debug", style='Red.TButton')
        else:
            self.toggle_debug_button.config(text="Enable Debug", style='Blue.TButton')


        # --- PanedWindow for resizable log display windows ---
        log_paned_window = ttk.PanedWindow(self, orient=tk.VERTICAL)
        log_paned_window.grid(row=2, column=0, sticky="nsew", padx=10, pady=5)
        
        # Frame for Software Log
        software_log_frame = ttk.LabelFrame(log_paned_window, text="Software Debug Log")
        log_paned_window.add(software_log_frame, weight=1)
        software_log_frame.grid_columnconfigure(0, weight=1)
        software_log_frame.grid_rowconfigure(3, weight=1)

        # File logging controls for software log
        file_log_controls_frame = ttk.Frame(software_log_frame, style='Dark.TFrame')
        file_log_controls_frame.grid(row=0, column=0, sticky="ew", padx=5, pady=5)
        file_log_controls_frame.grid_columnconfigure(0, weight=1)
        
        self.debug_to_file_checkbox = ttk.Checkbutton(file_log_controls_frame, text="Log to File",
                                                      variable=self.app_instance.debug_to_file_var,
                                                      command=self._toggle_debug_to_file_mode,
                                                      style='TCheckbutton')
        self.debug_to_file_checkbox.grid(row=0, column=0, padx=5, pady=2, sticky="w")
        
        self.include_console_messages_checkbox = ttk.Checkbutton(file_log_controls_frame, text="Include Console Messages",
                                                                 variable=self.app_instance.include_console_messages_to_debug_file_var,
                                                                 command=self._toggle_include_console_messages_to_debug_file_mode,
                                                                 style='TCheckbutton')
        self.include_console_messages_checkbox.grid(row=1, column=0, padx=5, pady=2, sticky="w")
        
        self.include_visa_messages_to_debug_file_checkbox = ttk.Checkbutton(file_log_controls_frame, text="Include VISA Messages into Debug File",
                                                                           variable=self.app_instance.include_visa_messages_to_debug_file_var,
                                                                           command=self._toggle_include_visa_messages_to_debug_file_mode,
                                                                           style='TCheckbutton')
        self.include_visa_messages_to_debug_file_checkbox.grid(row=2, column=0, padx=5, pady=2, sticky="w")


        self.log_truncation_checkbox = ttk.Checkbutton(file_log_controls_frame, text="Truncate Long Numeric Messages",
                                                       variable=self.app_instance.log_truncation_enabled_var,
                                                       command=self._toggle_log_truncation_mode,
                                                       style='TCheckbutton')
        self.log_truncation_checkbox.grid(row=3, column=0, padx=5, pady=2, sticky="w")
        
        self.clear_debug_log_button = ttk.Button(software_log_frame, text="Clear Debug Log File",
                                                 command=self._clear_debug_log_file_action,
                                                 style='Red.TButton')
        self.clear_debug_log_button.grid(row=1, column=0, padx=5, pady=5, sticky="ew")

        # NEW: Log Filter Dropdown
        filter_frame = ttk.Frame(software_log_frame)
        filter_frame.grid(row=2, column=0, padx=5, pady=5, sticky="ew")
        filter_frame.grid_columnconfigure(1, weight=1)
        
        ttk.Label(filter_frame, text="Filter Log:").grid(row=0, column=0, padx=(0, 5), sticky="w")
        self.log_filter_dropdown = ttk.Combobox(filter_frame, textvariable=self.log_filter_var, state="readonly")
        self.log_filter_dropdown['values'] = list(self.log_filter_map.keys())
        self.log_filter_dropdown.current(0)
        self.log_filter_dropdown.bind("<<ComboboxSelected>>", self._filter_and_display_log)
        self.log_filter_dropdown.grid(row=0, column=1, sticky="ew")
        
        self.software_log_text = scrolledtext.ScrolledText(software_log_frame, wrap="word", height=10, bg="#2b2b2b", fg="#cccccc", insertbackground="white")
        self.software_log_text.grid(row=3, column=0, sticky="nsew")
        self.software_log_text.config(state=tk.DISABLED)

        # Frame for VISA Log
        visa_log_frame = ttk.LabelFrame(log_paned_window, text="VISA Commands Log")
        log_paned_window.add(visa_log_frame, weight=1)
        visa_log_frame.grid_columnconfigure(0, weight=1)
        visa_log_frame.grid_rowconfigure(1, weight=1)

        # VISA logging control
        visa_log_controls_frame = ttk.Frame(visa_log_frame, style='Dark.TFrame')
        visa_log_controls_frame.grid(row=0, column=0, sticky="ew", padx=5, pady=5)
        visa_log_controls_frame.grid_columnconfigure(0, weight=1)

        self.log_visa_commands_checkbox = ttk.Checkbutton(visa_log_frame, text="Log VISA Commands",
                                                          variable=self.app_instance.log_visa_commands_enabled_var,
                                                          command=self._toggle_visa_logging_mode,
                                                          style='TCheckbutton')
        self.log_visa_commands_checkbox.grid(row=0, column=0, padx=5, pady=5, sticky="w")
        
        self.visa_log_text = scrolledtext.ScrolledText(visa_log_frame, wrap="word", height=10, bg="#2b2b2b", fg="#cccccc", insertbackground="white")
        self.visa_log_text.grid(row=1, column=0, columnspan=2, sticky="nsew")
        self.visa_log_text.config(state=tk.DISABLED)

        # --- Bottom Buttons ---
        bottom_button_frame = ttk.Frame(self, style='Dark.TFrame')
        bottom_button_frame.grid(row=3, column=0, padx=10, pady=5, sticky="ew")
        bottom_button_frame.grid_columnconfigure(0, weight=1)
        
        self.open_data_folder_button = ttk.Button(bottom_button_frame, text="Open Data Folder", command=self._open_data_folder_action, style='Blue.TButton')
        self.open_data_folder_button.grid(row=0, column=0, padx=5, pady=5, sticky="ew")
        
        # Last Config Save Time Label
        self.last_save_time_label = ttk.Label(bottom_button_frame,
                                              textvariable=self.app_instance.last_config_save_time_var,
                                              style='Dark.TLabel.Value')
        self.last_save_time_label.grid(row=1, column=0, padx=5, pady=2, sticky="e")

        debug_log(f"DebugTab widgets created. Log viewers are a go! 🛡️",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
    
    def _filter_and_display_log(self, event=None):
        """Filters the log content based on the dropdown selection and updates the display."""
        current_function = inspect.currentframe().f_code.co_name
        
        selected_filter = self.log_filter_var.get()
        filter_emoji = self.log_filter_map.get(selected_filter)
        
        # This function should only be called by the event handler, so we can
        # operate on the full log content that is already in memory.
        
        filtered_lines = []
        for line in self.software_log_lines:
            if filter_emoji is None or line.strip().startswith(filter_emoji):
                filtered_lines.append(line)
        
        self.software_log_text.config(state=tk.NORMAL)
        self.software_log_text.delete("1.0", tk.END)
        self.software_log_text.insert(tk.END, "".join(filtered_lines))
        self.software_log_text.config(state=tk.DISABLED)
        self.software_log_text.see(tk.END)


    def _toggle_debug_mode(self):
        """Toggles the global debug mode and updates the button's appearance."""
        current_function = inspect.currentframe().f_code.co_name
        current_state = self.app_instance.general_debug_enabled_var.get()
        new_state = not current_state
        self.app_instance.general_debug_enabled_var.set(new_state)
        set_debug_mode(new_state)
        # Force a config save
        save_program_config (self.app_instance.config, self.app_instance.CONFIG_FILE_PATH, console_log, self.app_instance)

        if new_state:
            self.toggle_debug_button.config(text="Disable Debug", style='Red.TButton')
            console_log("Debug mode is now ENABLED. The microscope is on! 🔬", function=current_function)
        else:
            self.toggle_debug_button.config(text="Enable Debug", style='Green.TButton')
            console_log("Debug mode is now DISABLED. Back to normal. 🤫", function=current_function)
        
    def _toggle_visa_logging_mode(self):
        """Toggles the global VISA command logging based on checkbox state."""
        current_function = inspect.currentframe().f_code.co_name
        new_state = self.app_instance.log_visa_commands_enabled_var.get()
        set_log_visa_commands_mode(new_state)
        # Force a config save
        save_program_config (self.app_instance.config, self.app_instance.CONFIG_FILE_PATH, console_log, self.app_instance)

        debug_log(f"Toggling VISA logging. Current state: {new_state}",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)

    def _toggle_debug_to_file_mode(self):
        """Toggles whether debug messages are written to a file."""
        current_function = inspect.currentframe().f_code.co_name
        new_state = self.app_instance.debug_to_file_var.get()
        set_debug_to_file_mode(new_state)
        # Force a config save
        save_program_config (self.app_instance.config, self.app_instance.CONFIG_FILE_PATH, console_log, self.app_instance)
        
        debug_log(f"Toggling debug output to file. Current state: {new_state}",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)

    def _toggle_include_console_messages_to_debug_file_mode(self):
        """Toggles whether console messages are included in the debug file."""
        current_function = inspect.currentframe().f_code.co_name
        new_state = self.app_instance.include_console_messages_to_debug_file_var.get()
        set_include_console_messages_to_debug_file_mode(new_state)
        # Force a config save
        save_program_config (self.app_instance.config, self.app_instance.CONFIG_FILE_PATH, console_log, self.app_instance)
        
        debug_log(f"Toggling inclusion of console messages to debug file. Current state: {new_state}",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)

    def _toggle_log_truncation_mode(self):
        """Toggles whether log messages are truncated."""
        current_function = inspect.currentframe().f_code.co_name
        new_state = self.app_instance.log_truncation_enabled_var.get()
        set_log_truncation_mode(new_state)
        # Force a config save
        save_program_config (self.app_instance.config, self.app_instance.CONFIG_FILE_PATH, console_log, self.app_instance)
        
        debug_log(f"Toggling log truncation. Current state: {new_state}",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)

    def _toggle_include_visa_messages_to_debug_file_mode(self):
        """Toggles whether console messages are included in the debug file."""
        current_function = inspect.currentframe().f_code.co_name
        new_state = self.app_instance.include_visa_messages_to_debug_file_var.get()
        set_include_visa_messages_to_debug_file_mode(new_state)
        # Force a config save
        save_program_config (self.app_instance.config, self.app_instance.CONFIG_FILE_PATH, console_log, self.app_instance)

        debug_log(f"Toggling inclusion of VISA messages to debug file. Current state: {new_state}",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)


    def _clear_debug_log_file_action(self):
        """Action to clear the debug log file."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Attempting to clear debug log files.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        clear_debug_log_file(DEBUG_FILE_PATH)
        clear_debug_log_file(VISA_FILE_PATH)
        
        console_log(f"Debug log files cleared. Fucking finally!", function=current_function)
        
        # Clear the in-memory log lines as well
        self.software_log_lines = []
        
        # Clear the display widgets immediately without waiting for the poller
        self.software_log_text.config(state=tk.NORMAL)
        self.software_log_text.delete("1.0", tk.END)
        self.software_log_text.config(state=tk.DISABLED)
        self.visa_log_text.config(state=tk.NORMAL)
        self.visa_log_text.delete("1.0", tk.END)
        self.visa_log_text.config(state=tk.DISABLED)
        
        # Reset file pointers
        self.last_software_log_size = 0
        self.last_visa_log_size = 0


    def _open_data_folder_action(self):
        """Opens the main DATA folder in the file explorer."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Opening DATA folder...",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        data_path = self.app_instance.DATA_FOLDER_PATH
        if os.path.exists(data_path):
            try:
                if sys.platform == "win32":
                    os.startfile(data_path)
                elif sys.platform == "darwin": # macOS
                    subprocess.Popen(["open", data_path])
                else: # Linux
                    subprocess.Popen(["xdg-open", data_path])
                console_log(f"✅ Opened data folder: {data_path}", function=current_function)
            except Exception as e:
                console_log(f"❌ Failed to open data folder: {e}", function=current_function)
        else:
            console_log(f"❌ Data folder not found at: {data_path}", function=current_function)

    def _read_new_log_content(self, file_path, start_pos):
        """Reads new lines from a file starting from a given position and returns them."""
        if not os.path.exists(file_path):
            return ""
        
        new_content = ""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                f.seek(start_pos)
                new_content = f.read()
        except Exception as e:
            debug_log(f"ERROR: Failed to read from log file {file_path}: {e}",
                        file=f"{os.path.basename(__file__)} - {current_version}",
                        version=current_version,
                        function=inspect.currentframe().f_code.co_name)
            return ""
        
        return new_content

    def _check_log_files(self):
        """Checks for new content in the log files and updates the displays."""
        if self.stop_thread.is_set():
            return

        # Check for new content in the software log
        try:
            current_size = os.path.getsize(DEBUG_FILE_PATH)
            if current_size > self.last_software_log_size:
                new_content = self._read_new_log_content(DEBUG_FILE_PATH, self.last_software_log_size)
                if new_content:
                    self.software_log_lines.extend(new_content.splitlines(keepends=True))
                    self._filter_and_display_log()
                self.last_software_log_size = current_size
            elif current_size < self.last_software_log_size: # File was cleared
                self.software_log_lines = []
                self.last_software_log_size = current_size
                self._filter_and_display_log()
        except FileNotFoundError:
            pass
        except Exception as e:
            debug_log(f"ERROR: An error occurred while checking software log file: {e}",
                        file=f"{os.path.basename(__file__)} - {current_version}",
                        version=current_version,
                        function=inspect.currentframe().f_code.co_name)

        # Check for new content in the VISA log
        try:
            current_size = os.path.getsize(VISA_FILE_PATH)
            if current_size > self.last_visa_log_size:
                new_content = self._read_new_log_content(VISA_FILE_PATH, self.last_visa_log_size)
                if new_content:
                    self.visa_log_text.config(state=tk.NORMAL)
                    self.visa_log_text.insert(tk.END, new_content)
                    self.visa_log_text.config(state=tk.DISABLED)
                    self.visa_log_text.see(tk.END)
                self.last_visa_log_size = current_size
            elif current_size < self.last_visa_log_size: # File was cleared
                self.visa_log_text.config(state=tk.NORMAL)
                self.visa_log_text.delete("1.0", tk.END)
                self.visa_log_text.config(state=tk.DISABLED)
                self.last_visa_log_size = current_size
        except FileNotFoundError:
            pass
        except Exception as e:
            debug_log(f"ERROR: An error occurred while checking VISA log file: {e}",
                        file=f"{os.path.basename(__file__)} - {current_version}",
                        version=current_version,
                        function=inspect.currentframe().f_code.co_name)
        
        self.after(500, self._check_log_files)

    def _on_tab_selected(self, event):
        # This function description tells me what this function does
        # Starts log monitoring when the tab becomes active.
        #
        # Inputs to this function
        #   event (tkinter.Event): The event object.
        #
        # Outputs of this function
        #   None.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"ConsoleTab selected. Initializing log monitoring.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        # Populate initial log content and set file size pointers
        try:
            with open(DEBUG_FILE_PATH, 'r', encoding='utf-8', errors='ignore') as f:
                self.software_log_lines = f.readlines()
            self.last_software_log_size = os.path.getsize(DEBUG_FILE_PATH)
        except FileNotFoundError:
            self.software_log_lines = ["❌ Log file not found. It's an empty void of nothingness!"]
            self.last_software_log_size = 0
            
        try:
            with open(VISA_FILE_PATH, 'r', encoding='utf-8', errors='ignore') as f:
                visa_content = f.read()
                self.visa_log_text.config(state=tk.NORMAL)
                self.visa_log_text.delete("1.0", tk.END)
                self.visa_log_text.insert(tk.END, visa_content)
            self.visa_log_text.config(state=tk.DISABLED)
            self.last_visa_log_size = os.path.getsize(VISA_FILE_PATH)
        except FileNotFoundError:
            self.visa_log_text.config(state=tk.NORMAL)
            self.visa_log_text.delete("1.0", tk.END)
            self.visa_log_text.insert(tk.END, "❌ VISA log file not found. It's an empty void of nothingness!")
            self.visa_log_text.config(state=tk.DISABLED)
            self.last_visa_log_size = 0

        self._filter_and_display_log()
        
        # Start the polling loop for live updates
        self.after(500, self._check_log_files)

#####################################
### File: OPEN-AIR\display\display_child_scan_monitor.py
#####################################
# display/display_child_scan_monitor.py
#
# This file defines the ScanMonitorTab, a Tkinter Frame that provides
# a real-time view of scan data using Matplotlib plots.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250811.130322.1 (REFACTORED: The plot layout was redesigned to use a ttk.PanedWindow and individually declared plots to allow for resizable sashes between them.)

current_version = "20250811.130322.1"
current_version_hash = 20250811 * 130322 * 1 + hash(open(__file__, "r").read())

import tkinter as tk
from tkinter import ttk
import inspect
import os
import numpy as np
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

# Import logging functions for debugging
from display.debug_logic import debug_log
from display.console_logic import console_log

class ScanMonitorTab(ttk.Frame):
    """
    A Tkinter Frame that provides real-time monitoring of scan data with plots.
    """
    def __init__(self, master=None, app_instance=None, **kwargs):
        # This function description tells me what this function does
        # Initializes the ScanMonitorTab, creating a frame to hold real-time
        # plots of scan data. It sets up Matplotlib figures and canvases for
        # three graphs.
        #
        # Inputs to this function
        #   master (tk.Widget): The parent widget, typically a ttk.Notebook.
        #   app_instance (object): A reference to the main application instance
        #                          to access shared variables and methods.
        #   **kwargs: Arbitrary keyword arguments for Tkinter Frame.
        #
        # Outputs of this function
        #   None. Initializes the Tkinter frame and its internal state.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Initializing ScanMonitorTab. Preparing the plots!",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)

        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.plots = {} # To store references to the plot canvases by name

        self._create_widgets()

        debug_log(f"ScanMonitorTab initialized. Plots are ready to go!",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)


    def _create_widgets(self):
        # This function description tells me what this function does
        # Creates and arranges the widgets for the Scan Monitor tab.
        # It sets up a frame for three Matplotlib graphs.
        #
        # Inputs to this function
        #   None.
        #
        # Outputs of this function
        #   None. Populates the tab with GUI elements.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Creating ScanMonitorTab widgets.",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)

        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(0, weight=1)

        # NEW: Use a PanedWindow to hold the plots with sashes
        plot_paned_window = ttk.PanedWindow(self, orient=tk.VERTICAL)
        plot_paned_window.grid(row=0, column=0, padx=5, pady=5, sticky="nsew")

        # --- Top Plot ---
        top_plot_frame = ttk.Frame(plot_paned_window)
        plot_paned_window.add(top_plot_frame, weight=1)
        top_plot_frame.grid_columnconfigure(0, weight=1)
        top_plot_frame.grid_rowconfigure(0, weight=1)
        figure_top = Figure(figsize=(5, 2.5), dpi=100, facecolor='#1e1e1e')
        ax_top = figure_top.add_subplot(111, facecolor='#1e1e1e')
        ax_top.tick_params(axis='x', colors='white')
        ax_top.tick_params(axis='y', colors='white')
        ax_top.spines['bottom'].set_color('white')
        ax_top.spines['top'].set_color('white')
        ax_top.spines['left'].set_color('white')
        ax_top.spines['right'].set_color('white')
        ax_top.set_title("Live", color='white') # UPDATED: Shorter title
        canvas_top = FigureCanvasTkAgg(figure_top, master=top_plot_frame)
        canvas_widget_top = canvas_top.get_tk_widget()
        canvas_widget_top.grid(row=0, column=0, sticky="nsew")
        self.plots["top"] = {'figure': figure_top, 'ax': ax_top, 'canvas': canvas_top, 'widget': canvas_widget_top}

        # --- Middle Plot ---
        middle_plot_frame = ttk.Frame(plot_paned_window)
        plot_paned_window.add(middle_plot_frame, weight=1)
        middle_plot_frame.grid_columnconfigure(0, weight=1)
        middle_plot_frame.grid_rowconfigure(0, weight=1)
        figure_middle = Figure(figsize=(5, 2.5), dpi=100, facecolor='#1e1e1e')
        ax_middle = figure_middle.add_subplot(111, facecolor='#1e1e1e')
        ax_middle.tick_params(axis='x', colors='white')
        ax_middle.tick_params(axis='y', colors='white')
        ax_middle.spines['bottom'].set_color('white')
        ax_middle.spines['top'].set_color('white')
        ax_middle.spines['left'].set_color('white')
        ax_middle.spines['right'].set_color('white')
        ax_middle.set_title("Max Hold", color='white') # UPDATED: Shorter title
        canvas_middle = FigureCanvasTkAgg(figure_middle, master=middle_plot_frame)
        canvas_widget_middle = canvas_middle.get_tk_widget()
        canvas_widget_middle.grid(row=0, column=0, sticky="nsew")
        self.plots["middle"] = {'figure': figure_middle, 'ax': ax_middle, 'canvas': canvas_middle, 'widget': canvas_widget_middle}

        # --- Bottom Plot ---
        bottom_plot_frame = ttk.Frame(plot_paned_window)
        plot_paned_window.add(bottom_plot_frame, weight=1)
        bottom_plot_frame.grid_columnconfigure(0, weight=1)
        bottom_plot_frame.grid_rowconfigure(0, weight=1)
        figure_bottom = Figure(figsize=(5, 2.5), dpi=100, facecolor='#1e1e1e')
        ax_bottom = figure_bottom.add_subplot(111, facecolor='#1e1e1e')
        ax_bottom.tick_params(axis='x', colors='white')
        ax_bottom.tick_params(axis='y', colors='white')
        ax_bottom.spines['bottom'].set_color('white')
        ax_bottom.spines['top'].set_color('white')
        ax_bottom.spines['left'].set_color('white')
        ax_bottom.spines['right'].set_color('white')
        ax_bottom.set_title("Min Hold", color='white') # UPDATED: Shorter title
        canvas_bottom = FigureCanvasTkAgg(figure_bottom, master=bottom_plot_frame)
        canvas_widget_bottom = canvas_bottom.get_tk_widget()
        canvas_widget_bottom.grid(row=0, column=0, sticky="nsew")
        self.plots["bottom"] = {'figure': figure_bottom, 'ax': ax_bottom, 'canvas': canvas_bottom, 'widget': canvas_widget_bottom}

        debug_log(f"ScanMonitorTab widgets created. The placeholders are ready!",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)

#####################################
### File: OPEN-AIR\display\display_child_scan_view.py
#####################################
# display/display_child_scan_view.py
#
# This file defines the ScanViewTab, a Tkinter Frame for displaying a live, single-pane plot of scan data.
# It is designed to be added as a separate tab to the main display pane, focusing on a single trace.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250816.222300.1

current_version = "20250816.222300.1"
current_version_hash = 20250816 * 222300 * 1

import tkinter as tk
from tkinter import ttk
import inspect
import os
import numpy as np
import pandas as pd
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

# Import logging functions for debugging
from display.debug_logic import debug_log
from display.console_logic import console_log

# Import the new utility file
from display.utils_scan_view import update_single_plot

class ScanViewTab(ttk.Frame):
    """
    A Tkinter Frame that provides a single, large plot for viewing scan data.
    """
    def __init__(self, master=None, app_instance=None, **kwargs):
        """
        Initializes the ScanViewTab.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Initializing ScanViewTab. Preparing the single plot!",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)

        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.plot = {} # To store references to the plot canvas

        self._create_widgets()

        debug_log(f"ScanViewTab initialized. Plot is ready to go!",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)


    def _create_widgets(self):
        """
        Creates and arranges the widgets for the Scan View tab.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Creating ScanViewTab widgets.",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)

        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(0, weight=1)

        # --- Single Plot Frame ---
        plot_frame = ttk.Frame(self)
        plot_frame.grid(row=0, column=0, padx=5, pady=5, sticky="nsew")
        plot_frame.grid_columnconfigure(0, weight=1)
        plot_frame.grid_rowconfigure(0, weight=1)
        figure = Figure(figsize=(8, 6), dpi=100, facecolor='#1e1e1e')
        ax = figure.add_subplot(111, facecolor='#1e1e1e')
        ax.tick_params(axis='x', colors='white')
        ax.tick_params(axis='y', colors='white')
        ax.spines['bottom'].set_color('white')
        ax.spines['top'].set_color('white')
        ax.spines['left'].set_color('white')
        ax.spines['right'].set_color('white')
        ax.set_title("Live Trace", color='white')
        canvas = FigureCanvasTkAgg(figure, master=plot_frame)
        canvas_widget = canvas.get_tk_widget()
        canvas_widget.grid(row=0, column=0, sticky="nsew")
        self.plot = {'figure': figure, 'ax': ax, 'canvas': canvas, 'widget': canvas_widget}

        debug_log(f"ScanViewTab widgets created. The placeholder is ready!",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        # Call the new utility function to set up the plot with initial empty data
        update_single_plot(self, pd.DataFrame(columns=['Frequency_Hz', 'Power_dBm']), 0, 100, "Initial Plot View")

#####################################
### File: OPEN-AIR\display\utils_display_monitor.py
#####################################
# display/utils_display_monitor.py
#
# This module provides utility functions to interact with and update the plots
# in the Scan Monitor display tab.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250814.091200.1

current_version = "20250814.091200.1"
current_version_hash = (20250814 * 91200 * 1)

import inspect
import os
import traceback 
import numpy as np
from matplotlib.offsetbox import AnchoredText 

from display.debug_logic import debug_log
from display.console_logic import console_log


def _find_and_plot_peaks(ax, data, start_freq_mhz, end_freq_mhz):
    # [A brief, one-sentence description of the function's purpose.]
    # Finds and plots local peaks on a Matplotlib axis.
    debug_log(f"Entering _find_and_plot_peaks with {len(data) if data else 0} data points.",
                file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

    try:
        if not data:
            console_log("✅ No data to search for peaks.")
            return

        x_data = np.array(data)[:, 0]
        y_data = np.array(data)[:, 1]
        
        total_span = end_freq_mhz - start_freq_mhz
        segment_width = total_span / 150
        peaks = []
        i = 0
        while i < len(x_data):
            segment_end_freq = x_data[i] + segment_width
            segment_indices = np.where((x_data >= x_data[i]) & (x_data <= segment_end_freq))
            if not segment_indices[0].any():
                i += 1
                continue
            
            segment_y_data = y_data[segment_indices]
            segment_x_data = x_data[segment_indices]
            peak_y = np.max(segment_y_data)
            peak_x = segment_x_data[np.argmax(segment_y_data)]
            peaks.append((peak_x, peak_y))

            next_i_candidate = np.where(x_data >= peak_x + segment_width)[0]
            i = next_i_candidate[0] if len(next_i_candidate) > 0 else len(x_data)
        
        sorted_peaks = sorted(peaks, key=lambda p: p[1], reverse=True)[:10]
        for peak_x, peak_y in sorted_peaks:
            ax.axvline(x=peak_x, color='orange', linestyle='--', linewidth=1, zorder=4)
        
        console_log(f"✅ Found and plotted {len(sorted_peaks)} peaks.")
    except Exception as e:
        console_log(f"❌ Error in _find_and_plot_peaks: {e}")
        debug_log(f"Arrr, the code be capsized in peak finding! The error be: {e}\n{traceback.format_exc()}",
                    file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

def _setup_zoom_events(ax, canvas, original_xlim):
    # [A brief, one-sentence description of the function's purpose.]
    # Sets up event handlers for horizontal zooming on the plot.
    debug_log(f"Entering _setup_zoom_events.", file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)
    
    try:
        drag_start_x = None
        ax.original_xlim = original_xlim

        def on_press(event):
            nonlocal drag_start_x
            if event.button == 1 and event.inaxes == ax:
                drag_start_x = event.xdata

        def on_release(event):
            nonlocal drag_start_x
            if event.button == 1 and event.inaxes == ax and drag_start_x is not None:
                drag_end_x = event.xdata
                if drag_end_x is not None and drag_start_x != drag_end_x:
                    ax.set_xlim(min(drag_start_x, drag_end_x), max(drag_start_x, drag_end_x))
                    canvas.draw_idle()
                drag_start_x = None

        def on_double_click(event):
            if event.button == 1 and event.inaxes == ax:
                reset_zoom(ax=ax, canvas=canvas)

        canvas.mpl_connect('button_press_event', on_press)
        canvas.mpl_connect('button_release_event', on_release)
        canvas.mpl_connect('button_press_event', on_double_click)
        console_log("✅ Zoom events are now live!")
    except Exception as e:
        console_log(f"❌ Error in _setup_zoom_events: {e}")
        debug_log(f"Great Scott! The zoom mechanism has backfired! Error: {e}\n{traceback.format_exc()}",
                    file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

def reset_zoom(ax, canvas):
    # [A brief, one-sentence description of the function's purpose.]
    # Resets the plot to its original, full x-axis view.
    debug_log(f"Entering reset_zoom.", file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)
    try:
        if hasattr(ax, 'original_xlim'):
            ax.set_xlim(ax.original_xlim)
            canvas.draw_idle()
        console_log("✅ Celebration of success! Zoom reset.")
    except Exception as e:
        console_log(f"❌ Error in reset_zoom: {e}")
        debug_log(f"It's madness! The zoom refused to reset! Error: {e}\n{traceback.format_exc()}",
                    file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

def update_top_plot(scan_monitor_tab_instance, data, start_freq_mhz, end_freq_mhz, plot_title):
    # [A brief, one-sentence description of the function's purpose.]
    # Updates the top plot in the Scan Monitor tab with new data.
    debug_log(f"Entering update_top_plot with plot_title: {plot_title}", file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)
        
    try:
        plot_info = scan_monitor_tab_instance.plots["top"]
        ax = plot_info['ax']
        canvas = plot_info['canvas']
        ax.clear()
        
        data_tuples = None
        # FIX: The incoming data DataFrame now has frequencies in MHz.
        # We no longer need to divide by 1,000,000 here.
        if data is not None and not data.empty:
            data_tuples = list(zip(data['Frequency_Hz'], data['Power_dBm']))

        if data_tuples:
            frequencies, amplitudes = zip(*data_tuples)
            ax.plot(frequencies, amplitudes, color='yellow', linewidth=1)
        
        ax.set_title(plot_title, color='white')
        ax.set_xlim(start_freq_mhz, end_freq_mhz)
        ax.set_ylim(-120, 0)
        ax.set_yticks(np.arange(-120, 1, 20))
        ax.grid(True, linestyle='--', color='gray', alpha=0.5)

        annot = ax.annotate("", xy=(0,0), xytext=(20,20), textcoords="offset points",
                            bbox=dict(boxstyle="round", fc="white", ec="black", lw=1),
                            arrowprops=dict(arrowstyle="wedge,tail_width=0.5", fc="white", ec="black"))
        annot.set_visible(False)

        def update_annot(event):
            if data_tuples and event.xdata and event.ydata:
                x_data = np.array(data_tuples)[:, 0]
                y_data = np.array(data_tuples)[:, 1]
                idx = np.abs(x_data - event.xdata).argmin()
                annot.xy = (x_data[idx], y_data[idx])
                annot.set_text(f"Freq: {x_data[idx]:.3f} MHz\nAmp: {y_data[idx]:.2f} dBm")
                annot.set_visible(True)
                canvas.draw_idle()
            else:
                annot.set_visible(False)
                canvas.draw_idle()

        canvas.mpl_connect("motion_notify_event", update_annot)
        
        _find_and_plot_peaks(ax=ax, data=data_tuples, start_freq_mhz=start_freq_mhz, end_freq_mhz=end_freq_mhz)
        _setup_zoom_events(ax=ax, canvas=canvas, original_xlim=(start_freq_mhz, end_freq_mhz))

        canvas.draw()
        console_log("✅ Celebration of success! Top plot updated.")
    except Exception as e:
        console_log(f"❌ Error in update_top_plot: {e}")
        debug_log(f"Arrr, the top plot be capsized! The error be: {e}\n{traceback.format_exc()}",
                    file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

def update_middle_plot(scan_monitor_tab_instance, data, start_freq_mhz, end_freq_mhz, plot_title):
    # [A brief, one-sentence description of the function's purpose.]
    # Updates the middle plot in the Scan Monitor tab with new data.
    debug_log(f"Entering update_middle_plot with plot_title: {plot_title}", file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

    try:
        plot_info = scan_monitor_tab_instance.plots["middle"]
        ax = plot_info['ax']
        canvas = plot_info['canvas']
        ax.clear()

        data_tuples = None
        # FIX: The incoming data DataFrame now has frequencies in MHz.
        # We no longer need to divide by 1,000,000 here.
        if data is not None and not data.empty:
            data_tuples = list(zip(data['Frequency_Hz'], data['Power_dBm']))

        if data_tuples:
            frequencies, amplitudes = zip(*data_tuples)
            ax.plot(frequencies, amplitudes, color='green', linewidth=1)
        
        ax.set_title(plot_title, color='white')
        ax.set_xlim(start_freq_mhz, end_freq_mhz)
        ax.set_ylim(-120, 0)
        ax.set_yticks(np.arange(-120, 1, 20))
        ax.grid(True, linestyle='--', color='gray', alpha=0.5)

        annot = ax.annotate("", xy=(0,0), xytext=(20,20), textcoords="offset points",
                            bbox=dict(boxstyle="round", fc="white", ec="black", lw=1),
                            arrowprops=dict(arrowstyle="wedge,tail_width=0.5", fc="white", ec="black"))
        annot.set_visible(False)

        def update_annot(event):
            if data_tuples and event.xdata and event.ydata:
                x_data = np.array(data_tuples)[:, 0]
                y_data = np.array(data_tuples)[:, 1]
                idx = np.abs(x_data - event.xdata).argmin()
                annot.xy = (x_data[idx], y_data[idx])
                annot.set_text(f"Freq: {x_data[idx]:.3f} MHz\nAmp: {y_data[idx]:.2f} dBm")
                annot.set_visible(True)
                canvas.draw_idle()
            else:
                annot.set_visible(False)
                canvas.draw_idle()

        canvas.mpl_connect("motion_notify_event", update_annot)

        _find_and_plot_peaks(ax=ax, data=data_tuples, start_freq_mhz=start_freq_mhz, end_freq_mhz=end_freq_mhz)
        _setup_zoom_events(ax=ax, canvas=canvas, original_xlim=(start_freq_mhz, end_freq_mhz))
        
        canvas.draw()
        console_log("✅ Celebration of success! Middle plot updated.")
    except Exception as e:
        console_log(f"❌ Error in update_middle_plot: {e}")
        debug_log(f"It's alive! Oh wait, no, the middle plot is dead. Error: {e}\n{traceback.format_exc()}",
                    file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

def update_bottom_plot(scan_monitor_tab_instance, data, start_freq_mhz, end_freq_mhz, plot_title):
    # [A brief, one-sentence description of the function's purpose.]
    # Updates the bottom plot in the Scan Monitor tab with new data.
    debug_log(f"Entering update_bottom_plot with plot_title: {plot_title}", file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)
    
    try:
        plot_info = scan_monitor_tab_instance.plots["bottom"]
        ax = plot_info['ax']
        canvas = plot_info['canvas']
        
        ax.clear()

        data_tuples = None
        # FIX: The incoming data DataFrame now has frequencies in MHz.
        # We no longer need to divide by 1,000,000 here.
        if data is not None and not data.empty:
            data_tuples = list(zip(data['Frequency_Hz'], data['Power_dBm']))

        if data_tuples:
            frequencies, amplitudes = zip(*data_tuples)
            ax.plot(frequencies, amplitudes, color='cyan', linewidth=1)
        
        ax.set_title(plot_title, color='white')
        ax.set_xlim(start_freq_mhz, end_freq_mhz)
        ax.set_ylim(-120, 0)
        ax.set_yticks(np.arange(-120, 1, 20))
        ax.grid(True, linestyle='--', color='gray', alpha=0.5)

        annot = ax.annotate("", xy=(0,0), xytext=(20,20), textcoords="offset points",
                            bbox=dict(boxstyle="round", fc="white", ec="black", lw=1),
                            arrowprops=dict(arrowstyle="wedge,tail_width=0.5", fc="white", ec="black"))
        annot.set_visible(False)

        def update_annot(event):
            if data_tuples and event.xdata and event.ydata:
                x_data = np.array(data_tuples)[:, 0]
                y_data = np.array(data_tuples)[:, 1]
                idx = np.abs(x_data - event.xdata).argmin()
                annot.xy = (x_data[idx], y_data[idx])
                annot.set_text(f"Freq: {x_data[idx]:.3f} MHz\nAmp: {y_data[idx]:.2f} dBm")
                annot.set_visible(True)
                canvas.draw_idle()
            else:
                annot.set_visible(False)
                canvas.draw_idle()

        canvas.mpl_connect("motion_notify_event", update_annot)
        
        _find_and_plot_peaks(ax=ax, data=data_tuples, start_freq_mhz=start_freq_mhz, end_freq_mhz=end_freq_mhz)
        _setup_zoom_events(ax=ax, canvas=canvas, original_xlim=(start_freq_mhz, end_freq_mhz))
        
        canvas.draw()
        console_log("✅ Celebration of success! Bottom plot updated.")
    except Exception as e:
        console_log(f"❌ Error in update_bottom_plot: {e}")
        debug_log(f"Shiver me timbers, the bottom plot has been scuttled! Error: {e}\n{traceback.format_exc()}",
                    file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

def clear_monitor_plots(scan_monitor_tab_instance):
    # [A brief, one-sentence description of the function's purpose.]
    # Clears all three plots in the Scan Monitor tab.
    debug_log(f"Entering clear_monitor_plots.", file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)
                
    try:
        if not scan_monitor_tab_instance:
            console_log("❌ Scan Monitor tab instance could not be found. Cannot clear plots.")
            return

        for plot_name in ["top", "middle", "bottom"]:
            plot_info = scan_monitor_tab_instance.plots.get(plot_name, {})
            ax = plot_info.get('ax')
            canvas = plot_info.get('canvas')
            if ax and canvas:
                ax.clear()
                ax.set_facecolor('#1e1e1e')
                ax.set_title(f"Plot {plot_name.capitalize()} Placeholder", color='white')
                ax.set_ylim(-120, 0)
                ax.set_yticks(np.arange(-120, 1, 20))
                ax.grid(True, linestyle='--', color='gray', alpha=0.5)
                canvas.draw()
        
        console_log("✅ Celebration of success! All monitor plots cleared.")
    except Exception as e:
        console_log(f"❌ Error in clear_monitor_plots: {e}")
        debug_log(f"My creation! It refuses to be cleared! Error: {e}\n{traceback.format_exc()}",
                    file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)


#####################################
### File: OPEN-AIR\display\utils_scan_view.py
#####################################
# display/utils_child_scan_view.py
#
# This module provides utility functions to interact with and update the single plot
# in the Scan View display tab.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250816.222300.1
# MODIFIED: Added line_color parameter to update_single_plot.

current_version = "20250816.222300.1"
current_version_hash = (20250816 * 222300 * 1)

import inspect
import os
import traceback 
import numpy as np
from matplotlib.offsetbox import AnchoredText 

from display.debug_logic import debug_log
from display.console_logic import console_log


def _find_and_plot_peaks(ax, data, start_freq_mhz, end_freq_mhz):
    # [A brief, one-sentence description of the function's purpose.]
    # Finds and plots local peaks on a Matplotlib axis.
    debug_log(f"Entering _find_and_plot_peaks with {len(data) if data else 0} data points.",
                file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

    try:
        if not data:
            console_log("✅ No data to search for peaks.")
            return

        x_data = np.array(data)[:, 0]
        y_data = np.array(data)[:, 1]
        
        total_span = end_freq_mhz - start_freq_mhz
        segment_width = total_span / 150
        peaks = []
        i = 0
        while i < len(x_data):
            segment_end_freq = x_data[i] + segment_width
            segment_indices = np.where((x_data >= x_data[i]) & (x_data <= segment_end_freq))
            if not segment_indices[0].any():
                i += 1
                continue
            
            segment_y_data = y_data[segment_indices]
            segment_x_data = x_data[segment_indices]
            peak_y = np.max(segment_y_data)
            peak_x = segment_x_data[np.argmax(segment_y_data)]
            peaks.append((peak_x, peak_y))

            next_i_candidate = np.where(x_data >= peak_x + segment_width)[0]
            i = next_i_candidate[0] if len(next_i_candidate) > 0 else len(x_data)
        
        sorted_peaks = sorted(peaks, key=lambda p: p[1], reverse=True)[:10]
        for peak_x, peak_y in sorted_peaks:
            ax.axvline(x=peak_x, color='orange', linestyle='--', linewidth=1, zorder=4)
        
        console_log(f"✅ Found and plotted {len(sorted_peaks)} peaks.")
    except Exception as e:
        console_log(f"❌ Error in _find_and_plot_peaks: {e}")
        debug_log(f"Arrr, the code be capsized in peak finding! The error be: {e}\n{traceback.format_exc()}",
                    file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

def _setup_zoom_events(ax, canvas, original_xlim):
    # [A brief, one-sentence description of the function's purpose.]
    # Sets up event handlers for horizontal zooming on the plot.
    debug_log(f"Entering _setup_zoom_events.", file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)
    
    try:
        drag_start_x = None
        ax.original_xlim = original_xlim

        def on_press(event):
            nonlocal drag_start_x
            if event.button == 1 and event.inaxes == ax:
                drag_start_x = event.xdata

        def on_release(event):
            nonlocal drag_start_x
            if event.button == 1 and event.inaxes == ax and drag_start_x is not None:
                drag_end_x = event.xdata
                if drag_end_x is not None and drag_start_x != drag_end_x:
                    ax.set_xlim(min(drag_start_x, drag_end_x), max(drag_start_x, drag_end_x))
                    canvas.draw_idle()
                drag_start_x = None

        def on_double_click(event):
            if event.button == 1 and event.inaxes == ax:
                reset_zoom(ax=ax, canvas=canvas)

        canvas.mpl_connect('button_press_event', on_press)
        canvas.mpl_connect('button_release_event', on_release)
        canvas.mpl_connect('button_press_event', on_double_click)
        console_log("✅ Zoom events are now live!")
    except Exception as e:
        console_log(f"❌ Error in _setup_zoom_events: {e}")
        debug_log(f"Great Scott! The zoom mechanism has backfired! Error: {e}\n{traceback.format_exc()}",
                    file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

def reset_zoom(ax, canvas):
    # [A brief, one-sentence description of the function's purpose.]
    # Resets the plot to its original, full x-axis view.
    debug_log(f"Entering reset_zoom.", file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)
    try:
        if hasattr(ax, 'original_xlim'):
            ax.set_xlim(ax.original_xlim)
            canvas.draw_idle()
        console_log("✅ Celebration of success! Zoom reset.")
    except Exception as e:
        console_log(f"❌ Error in reset_zoom: {e}")
        debug_log(f"It's madness! The zoom refused to reset! Error: {e}\n{traceback.format_exc()}",
                    file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

def update_single_plot(scan_view_tab_instance, data, start_freq_mhz, end_freq_mhz, plot_title, line_color='yellow'):
    # [A brief, one-sentence description of the function's purpose.]
    # Updates the single plot in the Scan View tab with new data.
    debug_log(f"Entering update_plot with plot_title: {plot_title}", file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)
        
    try:
        plot_info = scan_view_tab_instance.plot
        ax = plot_info['ax']
        canvas = plot_info['canvas']
        ax.clear()
        
        data_tuples = None
        if data is not None and not data.empty:
            # FIX: Remove the redundant conversion, as data is already in MHz
            data_tuples = list(zip(data['Frequency_Hz'], data['Power_dBm']))

        if data_tuples:
            frequencies, amplitudes = zip(*data_tuples)
            # FIXED: Used the new line_color parameter
            ax.plot(frequencies, amplitudes, color=line_color, linewidth=1)
        
        ax.set_title(plot_title, color='white')
        ax.set_xlim(start_freq_mhz, end_freq_mhz)
        ax.set_ylim(-120, 0)
        ax.set_yticks(np.arange(-120, 1, 20))
        ax.grid(True, linestyle='--', color='gray', alpha=0.5)

        annot = ax.annotate("", xy=(0,0), xytext=(20,20), textcoords="offset points",
                            bbox=dict(boxstyle="round", fc="white", ec="black", lw=1),
                            arrowprops=dict(arrowstyle="wedge,tail_width=0.5", fc="white", ec="black"))
        annot.set_visible(False)

        def update_annot(event):
            if data_tuples and event.xdata and event.ydata:
                x_data = np.array(data_tuples)[:, 0]
                y_data = np.array(data_tuples)[:, 1]
                idx = np.abs(x_data - event.xdata).argmin()
                annot.xy = (x_data[idx], y_data[idx])
                annot.set_text(f"Freq: {x_data[idx]:.3f} MHz\nAmp: {y_data[idx]:.2f} dBm")
                annot.set_visible(True)
                canvas.draw_idle()
            else:
                annot.set_visible(False)
                canvas.draw_idle()

        canvas.mpl_connect("motion_notify_event", update_annot)
        
        _find_and_plot_peaks(ax=ax, data=data_tuples, start_freq_mhz=start_freq_mhz, end_freq_mhz=end_freq_mhz)
        _setup_zoom_events(ax=ax, canvas=canvas, original_xlim=(start_freq_mhz, end_freq_mhz))

        canvas.draw()
        console_log("✅ Celebration of success! Plot updated.")
    except Exception as e:
        console_log(f"❌ Error in update_plot: {e}")
        debug_log(f"Arrr, the plot be capsized! The error be: {e}\n{traceback.format_exc()}",
                    file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

#####################################
### File: OPEN-AIR\Experiments\TAB_EXPERIMENTS_PARENT.py
#####################################
# tabs/Experiments/TAB_EXPERIMENTS_PARENT.py
#
# This file defines the parent tab for Experiment-related functionalities.
# It acts as a container for child tabs such as "Intermod", "JSON API", and now "Credits".
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250820.102100.3 (UPDATED: Added a new child tab for Credits and made it the first tab.)
# Version 20250818.193400.1 (UPDATED: Added a new child tab for YakBeg functionality.)
# Version 20250818.193500.1 (FIXED: Moved YakBegTab import inside __init__ to resolve circular import error.)

current_version = "Version 20250820.102100.3"
current_version_hash = 20250820 * 102100 * 3

import tkinter as tk
from tkinter import ttk
import inspect
import os
from datetime import datetime
from display.debug_logic import debug_log # For logging and debugging
from display.console_logic import console_log # For user-facing messages

# Import the child tabs
from .tab_experiments_credits import CreditsTab # NEW: Import CreditsTab
from .tab_experiments_child_intermod import InterModTab
from .tab_experiments_child_JSON_api import JsonApiTab
from .tab_experiments_colouring import ColouringTab
from .tab_experiments_child_initial_configuration import InitialConfigurationTab
# Removed: from tabs.Experiments.tab_experiments_child_YakBeg import YakBegTab
from .tab_experiments_child_YakBeg import YakBegTab

class ExperimentsParentTab(tk.Frame):
    """
    This is the parent tab for all experiment-related functionalities. It is a container
    for multiple child tabs that each handle a specific experiment or process.
    """
    def __init__(self, parent_notebook, app_instance, console_print_func, style_obj, *args, **kwargs):
        # [A brief, one-sentence description of the function's purpose.]
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering ExperimentsParentTab.__init__.",
                  file=f"{os.path.basename(__file__)}",
                  version=current_version,
                  function=current_function)

        try:
            super().__init__(parent_notebook, **kwargs)
            self.app_instance = app_instance
            self.console_print_func = console_print_func
            self.parent_notebook = parent_notebook
            self.style_obj = style_obj

            # Create a Notebook to hold the child tabs
            self.child_notebook = ttk.Notebook(self)
            self.child_notebook.pack(expand=True, fill="both")

            # Initialize and add child tabs to the notebook
            self.credits_tab = CreditsTab(self.child_notebook, self.app_instance, self.console_print_func)
            self.child_notebook.add(self.credits_tab, text="Credits")
            
            self.intermod_tab = InterModTab(self.child_notebook, self.app_instance, self.console_print_func)
            self.child_notebook.add(self.intermod_tab, text="Intermod")

            self.json_api_tab = JsonApiTab(self.child_notebook, self.app_instance, self.console_print_func)
            self.child_notebook.add(self.json_api_tab, text="JSON API")

            self.colouring_tab = ColouringTab(self.child_notebook, self.app_instance, self.console_print_func)
            self.child_notebook.add(self.colouring_tab, text="Colouring")

            self.initial_config_tab = InitialConfigurationTab(self.child_notebook, self.app_instance, self.console_print_func, self.style_obj)
            self.child_notebook.add(self.initial_config_tab, text="Initial Config")

            self.yakbeg_tab = YakBegTab(self.child_notebook, self.app_instance, self.console_print_func)
            self.child_notebook.add(self.yakbeg_tab, text="YakBeg") # NEW: Add the YakBegTab

            self.child_notebook.bind("<<NotebookTabChanged>>", self._on_child_tab_selected)

            debug_log(f"ExperimentsParentTab initialized with {self.child_notebook.tabs()} child tabs. All set to go! 🛡️",
                        file=f"{os.path.basename(__file__)}",
                        version=current_version,
                        function=current_function)

        except Exception as e:
            console_log(f"❌ Error in ExperimentsParentTab initialization: {e}")
            debug_log(f"Arrr, the code be capsized! The error be: {e}",
                      file=f"{os.path.basename(__file__)}",
                      version=current_version,
                      function=current_function)
            raise

    def _on_child_tab_selected(self, event):
        """Handles tab change events within this parent's child notebook."""
        selected_child_tab_id = self.child_notebook.select()
        if selected_child_tab_id:
            selected_child_tab_widget = self.child_notebook.nametowidget(selected_child_tab_id)
            if hasattr(selected_child_tab_widget, '_on_tab_selected'):
                selected_child_tab_widget._on_tab_selected(event)

    def _on_parent_tab_selected(self, event):
        # Function Description
        # Handles the event when this parent tab is selected. It now also switches the display
        # pane to the "Debug" tab automatically.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Experiments Parent tab selected. Forcing display view to Debug.",
                  file=f"{os.path.basename(__file__)}",
                  version=current_version,
                  function=current_function)

        # Switch the display parent to the Debug tab
        if hasattr(self.app_instance, 'display_parent_tab'):
            self.app_instance.display_parent_tab.notebook.select(self.app_instance.display_parent_tab.debug_tab)
            debug_log(f"Forced display tab to Debug. A captain must always know the state of his ship! 🧭",
                        file=f"{os.path.basename(__file__)}",
                        version=current_version,
                        function=current_function)
        
        # Check if a child tab is already selected and call its handler
        selected_child_tab_id = self.child_notebook.select()
        if selected_child_tab_id:
            selected_child_tab_widget = self.child_notebook.nametowidget(selected_child_tab_id)
            if hasattr(selected_child_tab_widget, '_on_tab_selected'):
                selected_child_tab_widget._on_tab_selected(event)

#####################################
### File: OPEN-AIR\Experiments\tab_experiments_child_JSON_api.py
#####################################
# tabs/Experiments/tab_experiments_child_JSON_api.py
#
# This file defines the JsonApiTab, a Tkinter Frame that provides controls for
# starting/stopping a Flask-based JSON API. This API allows external access to
# scan data and marker data, including real-time scan-in-progress data.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250801.2155.1 (Refactored debug_print to use debug_log and console_log.)

current_version = "20250801.2155.1" # this variable should always be defined below the header to make the debugging better
current_version_hash = 20250801 * 2155 * 1 # Example hash, adjust as needed

import tkinter as tk
from tkinter import ttk, filedialog, scrolledtext
import os
import inspect
import webbrowser # For opening API links in browser
import subprocess # For running the Flask JSON API
import threading # For running the Flask JSON API in a separate thread
import time # For brief pauses
import sys # Explicitly import sys for use with sys.executable
import requests # For making HTTP requests to the Flask API

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log


class JsonApiTab(ttk.Frame):
    """
    A Tkinter Frame that provides controls for starting/stopping a JSON API
    and accessing scan data and marker data via that API.
    """
    def __init__(self, master=None, app_instance=None, console_print_func=None, **kwargs):
        """
        Initializes the JsonApiTab.

        Inputs:
            master (tk.Widget): The parent widget.
            app_instance (App): The main application instance, used for accessing
                                shared state like collected_scans_dataframes and output directory.
            console_print_func (function): Function to print messages to the GUI console.
            **kwargs: Arbitrary keyword arguments for Tkinter Frame.
        """
        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func if console_print_func else console_log # Use console_log as default
        self.json_api_process = None # To store the subprocess for the JSON API
        self.json_api_port = 5000 # Default port for the Flask API
        self.json_api_url_base = f"http://127.0.0.1:{self.json_api_port}"

        self._create_widgets()
        # Ensure API buttons are updated on startup
        self._update_api_button_states()

    def _create_widgets(self):
        """
        Creates and arranges the widgets for the JSON API tab.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        debug_log("Creating JsonApiTab widgets...",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        self.grid_columnconfigure(0, weight=1)
        self.grid_columnconfigure(1, weight=1)

        # JSON API Controls
        self.api_control_frame = ttk.LabelFrame(self, text="JSON API Controls", style='Dark.TLabelframe')
        self.api_control_frame.grid(row=0, column=0, columnspan=2, padx=5, pady=5, sticky="ew")
        self.api_control_frame.grid_columnconfigure(0, weight=1)
        self.api_control_frame.grid_columnconfigure(1, weight=1)

        self.start_api_button = ttk.Button(self.api_control_frame, text="Start API", command=self._start_json_api, style='Green.TButton')
        self.start_api_button.grid(row=0, column=0, padx=5, pady=5, sticky="ew")

        self.stop_api_button = ttk.Button(self.api_control_frame, text="Stop API", command=self._stop_json_api, style='Red.TButton', state=tk.DISABLED)
        self.stop_api_button.grid(row=0, column=1, padx=5, pady=5, sticky="ew")

        self.view_all_scans_button = ttk.Button(self.api_control_frame, text="View All API Scans", command=self._open_all_api_scans, style='Purple.TButton', state=tk.DISABLED)
        self.view_all_scans_button.grid(row=1, column=0, columnspan=2, padx=5, pady=5, sticky="ew")

        # Updated: This button now points to the static /api/latest_scan_data endpoint
        self.view_latest_scan_api_button = ttk.Button(self.api_control_frame, text="View Latest API Scan", command=self._open_latest_api_scan, style='Purple.TButton', state=tk.DISABLED)
        self.view_latest_scan_api_button.grid(row=2, column=0, columnspan=2, padx=5, pady=5, sticky="ew")

        # New button for scan in progress
        self.view_in_progress_api_button = ttk.Button(self.api_control_frame, text="View Scan In Progress API", command=self._open_scan_in_progress_api, style='Blue.TButton', state=tk.DISABLED)
        self.view_in_progress_api_button.grid(row=3, column=0, columnspan=2, padx=5, pady=5, sticky="ew")

        self.view_markers_api_button = ttk.Button(self.api_control_frame, text="View Markers API", command=self._open_markers_api, style='Orange.TButton', state=tk.DISABLED)
        self.view_markers_api_button.grid(row=4, column=0, columnspan=2, padx=5, pady=5, sticky="ew")

        # Frame for dynamically generated scan buttons
        # This frame's row is now adjusted to be below all static API control buttons
        self.dynamic_scan_buttons_frame = ttk.LabelFrame(self, text="Available API Scans", style='Dark.TLabelframe')
        self.dynamic_scan_buttons_frame.grid(row=5, column=0, columnspan=2, padx=5, pady=5, sticky="ew")
        self.dynamic_scan_buttons_frame.grid_columnconfigure(0, weight=1)
        self.dynamic_scan_buttons_frame.grid_remove()

        debug_log("JsonApiTab widgets created.",
                    file=__file__,
                    version=current_version,
                    function=current_function)

    def _run_json_api_thread_target(self):
        """
        Target function for the thread that runs the Flask JSON API.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        debug_log("JSON API thread target started.",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        script_path = os.path.join(self.app_instance._script_dir, 'process_math', 'json_host.py')

        try:
            self.json_api_process = subprocess.Popen(
                [sys.executable, script_path],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                creationflags=subprocess.DETACHED_PROCESS if os.name == 'nt' else 0
            )
            self.app_instance.after(100, self._update_api_button_states)
            self.console_print_func(f"▶️ JSON API started on {self.json_api_url_base}")
            debug_log(f"JSON API subprocess started with PID: {self.json_api_process.pid}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        except FileNotFoundError:
            self.console_print_func(f"❌ Error: Python interpreter not found at {sys.executable}. Ensure Python is in your PATH.")
            debug_log(f"Python interpreter not found: {sys.executable}. Fucking useless!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        except Exception as e:
            self.console_print_func(f"❌ Error starting JSON API: {e}")
            debug_log(f"Error starting JSON API: {e}. This thing is a pain in the ass!",
                        file=__file__,
                        version=current_version,
                        function=current_function)

        debug_log("JSON API thread target finished.",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    def _start_json_api(self):
        """
        Starts the Flask JSON API in a separate thread.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        debug_log("Attempting to start JSON API...",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        if self.json_api_process and self.json_api_process.poll() is None:
            self.console_print_func("ℹ️ JSON API is already running.")
            debug_log("JSON API already running. Fucking redundant!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        api_thread = threading.Thread(target=self._run_json_api_thread_target)
        api_thread.daemon = True
        api_thread.start()

    def _stop_json_api(self):
        """
        Stops the Flask JSON API subprocess.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        debug_log("Attempting to stop JSON API...",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        if self.json_api_process and self.json_api_process.poll() is None:
            try:
                self.json_api_process.terminate()
                self.json_api_process.wait(timeout=2)
                if self.json_api_process.poll() is None:
                    self.json_api_process.kill()
                    self.console_print_func("⚠️ JSON API process killed (forcefully terminated).")
                    debug_log("JSON API process forcefully killed. Take that, you bastard!",
                                file=__file__,
                                version=current_version,
                                function=current_function)
                self.console_print_func("⏹️ JSON API stopped.")
                debug_log("JSON API process terminated.",
                            file=__file__,
                            version=current_version,
                            function=current_function)
            except Exception as e:
                self.console_print_func(f"❌ Error stopping JSON API: {e}")
                debug_log(f"Error stopping JSON API: {e}. This thing refuses to die!",
                            file=__file__,
                            version=current_version,
                            function=current_function)
            finally:
                self.json_api_process = None
                self.app_instance.after(100, self._update_api_button_states)
        else:
            self.console_print_func("ℹ️ JSON API is not running.")
            debug_log("JSON API not running. Fucking pointless to stop what's not there!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            self._update_api_button_states()


    def _update_api_button_states(self):
        """
        Updates the state of the JSON API related buttons based on API process status.
        """
        is_api_running = self.json_api_process and self.json_api_process.poll() is None
        self.start_api_button.config(state=tk.DISABLED if is_api_running else tk.NORMAL)
        self.stop_api_button.config(state=tk.NORMAL if is_api_running else tk.DISABLED)
        self.view_all_scans_button.config(state=tk.NORMAL if is_api_running else tk.DISABLED)
        self.view_markers_api_button.config(state=tk.NORMAL if is_api_running else tk.DISABLED)

        # Check if scan_control_tab exists and is_scanning is True
        is_scanning = getattr(self.app_instance, 'scan_control_tab', None) and self.app_instance.scan_control_tab.is_scanning
        self.view_in_progress_api_button.config(state=tk.NORMAL if is_api_running and is_scanning else tk.DISABLED)

        # "View Latest API Scan" is always enabled if API is running, as the endpoint handles finding the latest.
        self.view_latest_scan_api_button.config(state=tk.NORMAL if is_api_running else tk.DISABLED)


    def _open_all_api_scans(self):
        """
        Fetches the list of scan files from the API and creates dynamic buttons for each.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        debug_log("Attempting to fetch all API scans and display buttons...",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        if not (self.json_api_process and self.json_api_process.poll() is None):
            self.console_print_func("⚠️ JSON API is not running. Please start it first to view available scans.")
            debug_log("JSON API not running for _open_all_api_scans. Fucking useless!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        # Clear existing buttons
        for widget in self.dynamic_scan_buttons_frame.winfo_children():
            widget.destroy()
        self.dynamic_scan_buttons_frame.grid_remove() # Hide frame until populated

        def fetch_and_display():
            try:
                response = requests.get(f"{self.json_api_url_base}/api/list_scans")
                response.raise_for_status()
                scan_files = response.json()

                if scan_files:
                    self.app_instance.after(0, lambda: self.console_print_func(f"✅ Found {len(scan_files)} scan files from API."))
                    self.app_instance.after(0, lambda: self.dynamic_scan_buttons_frame.grid())

                    for i, filename in enumerate(scan_files):
                        button = ttk.Button(
                            self.dynamic_scan_buttons_frame,
                            text=filename,
                            command=lambda f=filename: self._open_api_scan_data(f),
                            style='Blue.TButton'
                        )
                        button.grid(row=i, column=0, padx=2, pady=2, sticky="ew")
                        self.dynamic_scan_buttons_frame.grid_columnconfigure(0, weight=1)
                else:
                    self.app_instance.after(0, lambda: self.console_print_func("ℹ️ No scan files found via API."))
                    self.app_instance.after(0, lambda: self.dynamic_scan_buttons_frame.grid_remove())
                    debug_log("No scan files found via API. Fucking empty!",
                                file=__file__,
                                version=current_version,
                                function=current_function)

            except requests.exceptions.ConnectionError:
                self.app_instance.after(0, lambda: self.console_print_func("❌ Error: Could not connect to JSON API. Is it running?"))
                debug_log("ConnectionError to JSON API. What the hell?!",
                            file=__file__,
                            version=current_version,
                            function=current_function)
            except requests.exceptions.RequestException as e:
                self.app_instance.after(0, lambda: self.console_print_func(f"❌ Error fetching scan list from API: {e}"))
                debug_log(f"RequestException fetching scan list: {e}. This thing is a pain in the ass!",
                            file=__file__,
                            version=current_version,
                            function=current_function)
            except Exception as e:
                self.app_instance.after(0, lambda: self.console_print_func(f"❌ An unexpected error occurred while fetching scan list: {e}"))
                debug_log(f"Unexpected error fetching scan list: {e}. This is a goddamn mess!",
                            file=__file__,
                            version=current_version,
                            function=current_function)
            finally:
                self.app_instance.after(0, self._update_api_button_states)

        api_call_thread = threading.Thread(target=fetch_and_display)
        api_call_thread.daemon = True
        api_call_thread.start()


    def _open_api_scan_data(self, filename):
        """
        Opens the API endpoint for a specific scan file in the browser.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        debug_log(f"Attempting to open API scan data for: {filename}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        if not (self.json_api_process and self.json_api_process.poll() is None):
            self.console_print_func("⚠️ JSON API is not running. Please start it first.")
            debug_log("JSON API not running for _open_api_scan_data. Fucking useless!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        api_link = f"{self.json_api_url_base}/api/scan_data/{filename}"
        try:
            webbrowser.open_new_tab(api_link)
            self.console_print_func(f"✅ Opened API link for scan: {filename}")
            debug_log(f"Opened {api_link}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        except Exception as e:
            self.console_print_func(f"❌ Error opening API scan link for {filename}: {e}")
            debug_log(f"Error opening API scan link for {filename}: {e}. This is a goddamn mess!",
                        file=__file__,
                        version=current_version,
                        function=current_function)

    def _open_markers_api(self):
        """
        Opens the API endpoint for MARKERS.csv in the browser.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        debug_log("Attempting to open Markers API link...",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        if not (self.json_api_process and self.json_api_process.poll() is None):
            self.console_print_func("⚠️ JSON API is not running. Please start it first.")
            debug_log("JSON API not running for _open_markers_api. Fucking useless!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        api_link = f"{self.json_api_url_base}/api/markers_data"
        try:
            webbrowser.open_new_tab(api_link)
            self.console_print_func("✅ Opened API link for MARKERS.csv data.")
            debug_log(f"Opened {api_link}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        except Exception as e:
            self.console_print_func(f"❌ Error opening Markers API link: {e}")
            debug_log(f"Error opening Markers API link: {e}. This is a goddamn mess!",
                        file=__file__,
                        version=current_version,
                        function=current_function)


    def _open_latest_api_scan(self):
        """
        Opens the API endpoint for the latest scan data in the browser.
        This endpoint is static and the API handles finding the latest file.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        debug_log("Attempting to open latest API scan link...",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        if not (self.json_api_process and self.json_api_process.poll() is None):
            self.console_print_func("⚠️ JSON API is not running. Please start it first.")
            debug_log("JSON API not running for _open_latest_api_scan. Fucking useless!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        api_link = f"{self.json_api_url_base}/api/latest_scan_data" # Static URL for latest scan
        try:
            webbrowser.open_new_tab(api_link)
            self.console_print_func(f"✅ Opened API link for latest scan data.")
            debug_log(f"Opened {api_link}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        except Exception as e:
            self.console_print_func(f"❌ Error opening latest API scan link: {e}")
            debug_log(f"Error opening latest API scan link: {e}. This is a goddamn mess!",
                        file=__file__,
                        version=current_version,
                        function=current_function)

    def _open_scan_in_progress_api(self):
        """
        Opens the API endpoint for the scan in progress data in the browser.
        This endpoint is static.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        debug_log("Attempting to open scan in progress API link...",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        if not (self.json_api_process and self.json_api_process.poll() is None):
            self.console_print_func("⚠️ JSON API is not running. Please start it first.")
            debug_log("JSON API not running for _open_scan_in_progress_api. Fucking useless!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        # Check if a scan is actually in progress
        is_scanning = getattr(self.app_instance, 'scan_control_tab', None) and self.app_instance.scan_control_tab.is_scanning
        if not is_scanning:
            self.console_print_func("ℹ️ No scan is currently in progress.")
            debug_log("No scan in progress for _open_scan_in_progress_api. Fucking pointless!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        api_link = f"{self.json_api_url_base}/api/scan_in_progress_data" # Static URL for scan in progress
        try:
            webbrowser.open_new_tab(api_link)
            self.console_print_func(f"✅ Opened API link for scan in progress data.")
            debug_log(f"Opened {api_link}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        except Exception as e:
            self.console_print_func(f"❌ Error opening scan in progress API link: {e}")
            debug_log(f"Error opening scan in progress API link: {e}. This is a goddamn mess!",
                        file=__file__,
                        version=current_version,
                        function=current_function)


    def _on_tab_selected(self, event):
        """
        Callback for when this tab is selected.
        This can be used to refresh data or update UI elements specific to this tab.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        debug_log("JSON API Tab selected.",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        # Update API button states when the tab is selected
        self._update_api_button_states()


#####################################
### File: OPEN-AIR\Experiments\tab_experiments_child_YakBeg.py
#####################################
# tabs/Experiments/tab_experiments_child_YakBeg.py
#
# This file defines the YakBegTab, a Tkinter Frame that provides functionality
# to test and demonstrate the new YakBeg command. It includes UI elements for
# configuring and querying frequency, span, trace modes, and trace data in a
# single, efficient operation.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250818.193300.1 (NEW: Initial version to test the YakBeg function.)
# Version 20250818.193600.1 (FIXED: Moved YakBeg import inside methods to resolve circular import error.)
# Version 20250818.194000.1 (FIXED: Corrected _on_trace_data_beg to use YakBeg with correct command type from CSV.)
# Version 20250818.194100.1 (FIXED: Corrected the parsing of the trace data response string from the BEG command.)
# Version 20250818.194200.1 (FIXED: The _on_trace_data_beg function was updated to correctly parse the mixed separator response.)
# Version 20250818.194500.1 (FIXED: Corrected the parsing of the trace data response string from the BEG command to handle mixed separators.)
# Version 20250818.194600.1 (FIXED: Implemented parsing logic to correctly handle the semicolon-separated frequency values and comma-separated trace data.)
# Version 20250818.194800.1 (FIXED: The _on_trace_data_beg function was updated to correctly parse the comma-separated response with known start/stop frequencies.)
# Version 20250818.195000.1 (NEW: Added "Push to Monitor" button and functionality.)
# Version 20250818.195200.1 (FIXED: Corrected the command_type for TRACE/DATA to use the correct format from the CSV.)
# Version 20250818.195300.1 (FIXED: The _on_trace_data_beg function was updated to use the correct hardcoded command type from the CSV.)
# Version 20250818.195500.1 (NEW: Added MARKER/PLACE/ALL experiment.)
# Version 20250818.195700.1 (FIXED: Corrected the trace data parsing to use the comma separator, and added a marker experiment frame.)
# Version 20250818.200000.1 (FIXED: Corrected the command type string for trace data to match the CSV file, fixing the persistent KeyError.)
# Version 20250818.200200.1 (FIXED: Added logic to turn markers on before a YakBeg call and off afterwards.)
# Version 20250818.200300.1 (FIXED: The trace data command type string was corrected to use the hardcoded command from the CSV, not a dynamic string, fixing the KeyError.)
# Version 20250818.200500.1 (FIXED: Corrected frequency conversions to integers to fix instrument communication errors.)
# Version 20250818.201500.1 (REFACTORED: Moved all core logic to utils_yakbeg_handler.py to decouple UI from business logic.)
# Version 20250818.202500.1 (REFACTORED: Updated UI layer to call new handler functions and correctly process their return values.)
# Version 20250818.202800.1 (FIXED: Corrected the _on_marker_place_all_beg function to extract string values from StringVar objects before passing to handler.)

current_version = "20250818.202800.1"
current_version_hash = (20250818 * 202800 * 1)

import tkinter as tk
from tkinter import ttk, scrolledtext
import inspect
import os
import numpy as np

# Import the new handler module
from yak.utils_yakbeg_handler import (
    handle_freq_start_stop_beg,
    handle_freq_center_span_beg,
    handle_marker_place_all_beg,
    handle_trace_modes_beg,
    handle_trace_data_beg)
from display.debug_logic import debug_log
from display.console_logic import console_log

class YakBegTab(ttk.Frame):
    def __init__(self, master=None, app_instance=None, console_print_func=None, **kwargs):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Initializing YakBegTab. Version: {current_version}. Get ready to beg for some data! 🙏",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)

        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func

        # Tkinter variables for frequency settings
        self.freq_start_var = tk.DoubleVar(value=500000000)
        self.freq_stop_var = tk.DoubleVar(value=1000000000)
        self.freq_center_var = tk.DoubleVar(value=750000000)
        self.freq_span_var = tk.DoubleVar(value=500000000)

        # Tkinter variables for trace modes
        self.trace_mode_options = ["VIEW", "MAXHold", "MINHold", "WRITe", "BLANK"]
        self.trace1_mode_var = tk.StringVar(value=self.trace_mode_options[3])
        self.trace2_mode_var = tk.StringVar(value=self.trace_mode_options[1])
        self.trace3_mode_var = tk.StringVar(value=self.trace_mode_options[2])
        self.trace4_mode_var = tk.StringVar(value=self.trace_mode_options[0])

        # Tkinter variables for trace data
        self.trace_data_start_freq_var = tk.DoubleVar(value=500)
        self.trace_data_stop_freq_var = tk.DoubleVar(value=1000)
        self.trace_select_var = tk.StringVar(value="1")
        self.trace_data_count_var = tk.StringVar(value="0")
        
        # Tkinter variables for Marker/Place/All
        self.marker_freq_vars = [tk.StringVar(self, value="111"), tk.StringVar(self, value="222"),
                                 tk.StringVar(self, value="333"), tk.StringVar(self, value="444"),
                                 tk.StringVar(self, value="555"), tk.StringVar(self, value="666")]
        self.marker_place_all_result_var = tk.StringVar(self, value="Result: N/A")

        self.edit_entry = None
        self.current_edit_cell = None

        self._create_widgets()

        debug_log(f"YakBegTab initialized. The Begging begins! Version: {current_version}",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)

    def _create_widgets(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log("Creating YakBegTab widgets...",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)

        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(3, weight=1)

        # --- FREQUENCY/START-STOP Frame ---
        freq_ss_frame = ttk.LabelFrame(self, text="FREQUENCY/START-STOP", padding=10)
        freq_ss_frame.grid(row=0, column=0, padx=10, pady=5, sticky="ew")
        freq_ss_frame.grid_columnconfigure(1, weight=1)

        ttk.Label(freq_ss_frame, text="Start Frequency (Hz):").grid(row=0, column=0, padx=5, pady=2, sticky="w")
        ttk.Entry(freq_ss_frame, textvariable=self.freq_start_var).grid(row=0, column=1, padx=5, pady=2, sticky="ew")

        ttk.Label(freq_ss_frame, text="Stop Frequency (Hz):").grid(row=1, column=0, padx=5, pady=2, sticky="w")
        ttk.Entry(freq_ss_frame, textvariable=self.freq_stop_var).grid(row=1, column=1, padx=5, pady=2, sticky="ew")

        self.freq_ss_result_var = tk.StringVar(value="Result: N/A")
        ttk.Label(freq_ss_frame, textvariable=self.freq_ss_result_var, style="Dark.TLabel.Value").grid(row=2, column=0, columnspan=2, padx=5, pady=2, sticky="ew")

        ttk.Button(freq_ss_frame, text="YakBeg - FREQUENCY/START-STOP", command=self._on_freq_start_stop_beg).grid(row=3, column=0, columnspan=2, padx=5, pady=5, sticky="ew")


        # --- FREQUENCY/CENTER-SPAN Frame ---
        freq_cs_frame = ttk.LabelFrame(self, text="FREQUENCY/CENTER-SPAN", padding=10)
        freq_cs_frame.grid(row=1, column=0, padx=10, pady=5, sticky="ew")
        freq_cs_frame.grid_columnconfigure(1, weight=1)

        ttk.Label(freq_cs_frame, text="Center Frequency (Hz):").grid(row=0, column=0, padx=5, pady=2, sticky="w")
        ttk.Entry(freq_cs_frame, textvariable=self.freq_center_var).grid(row=0, column=1, padx=5, pady=2, sticky="ew")

        ttk.Label(freq_cs_frame, text="Span (Hz):").grid(row=1, column=0, padx=5, pady=2, sticky="w")
        ttk.Entry(freq_cs_frame, textvariable=self.freq_span_var).grid(row=1, column=1, padx=5, pady=2, sticky="ew")

        self.freq_cs_result_var = tk.StringVar(value="Result: N/A")
        ttk.Label(freq_cs_frame, textvariable=self.freq_cs_result_var, style="Dark.TLabel.Value").grid(row=2, column=0, columnspan=2, padx=5, pady=2, sticky="ew")

        ttk.Button(freq_cs_frame, text="YakBeg - FREQUENCY/CENTER-SPAN", command=self._on_freq_center_span_beg).grid(row=3, column=0, columnspan=2, padx=5, pady=5, sticky="ew")
        
        # --- MARKER/PLACE/ALL Frame ---
        marker_place_all_frame = ttk.LabelFrame(self, text="MARKER/PLACE/ALL", padding=10)
        marker_place_all_frame.grid(row=4, column=0, padx=10, pady=5, sticky="ew")
        marker_place_all_frame.grid_columnconfigure((0, 1, 2, 3, 4, 5), weight=1)

        for i in range(6):
            ttk.Label(marker_place_all_frame, text=f"M{i+1} Freq (MHz):").grid(row=0, column=i, padx=5, pady=2, sticky="w")
            ttk.Entry(marker_place_all_frame, textvariable=self.marker_freq_vars[i]).grid(row=1, column=i, padx=5, pady=2, sticky="ew")

        self.marker_place_all_result_var = tk.StringVar(value="Result: N/A")
        ttk.Label(marker_place_all_frame, textvariable=self.marker_place_all_result_var, style="Dark.TLabel.Value").grid(row=2, column=0, columnspan=6, padx=5, pady=2, sticky="ew")

        ttk.Button(marker_place_all_frame, text="YakBeg - MARKER/PLACE/ALL", command=self._on_marker_place_all_beg).grid(row=3, column=0, columnspan=6, padx=5, pady=5, sticky="ew")


        # --- TRACE/MODES Frame ---
        trace_modes_frame = ttk.LabelFrame(self, text="TRACE/MODES", padding=10)
        trace_modes_frame.grid(row=5, column=0, padx=10, pady=5, sticky="ew")
        trace_modes_frame.grid_columnconfigure(0, weight=1)
        trace_modes_frame.grid_columnconfigure(1, weight=1)
        trace_modes_frame.grid_columnconfigure(2, weight=1)
        trace_modes_frame.grid_columnconfigure(3, weight=1)

        ttk.Label(trace_modes_frame, text="Trace 1 Mode:").grid(row=0, column=0, padx=5, pady=2, sticky="w")
        self.trace1_combo = ttk.Combobox(trace_modes_frame, textvariable=self.trace1_mode_var, values=self.trace_mode_options, state="readonly")
        self.trace1_combo.grid(row=1, column=0, padx=5, pady=2, sticky="ew")
        ttk.Label(trace_modes_frame, text="Trace 2 Mode:").grid(row=0, column=1, padx=5, pady=2, sticky="w")
        self.trace2_combo = ttk.Combobox(trace_modes_frame, textvariable=self.trace2_mode_var, values=self.trace_mode_options, state="readonly")
        self.trace2_combo.grid(row=1, column=1, padx=5, pady=2, sticky="ew")
        ttk.Label(trace_modes_frame, text="Trace 3 Mode:").grid(row=0, column=2, padx=5, pady=2, sticky="w")
        self.trace3_combo = ttk.Combobox(trace_modes_frame, textvariable=self.trace3_mode_var, values=self.trace_mode_options, state="readonly")
        self.trace3_combo.grid(row=1, column=2, padx=5, pady=2, sticky="ew")
        ttk.Label(trace_modes_frame, text="Trace 4 Mode:").grid(row=0, column=3, padx=5, pady=2, sticky="w")
        self.trace4_combo = ttk.Combobox(trace_modes_frame, textvariable=self.trace4_mode_var, values=self.trace_mode_options, state="readonly")
        self.trace4_combo.grid(row=1, column=3, padx=5, pady=2, sticky="ew")
        
        self.trace_modes_result_var = tk.StringVar(value="Result: N/A")
        ttk.Label(trace_modes_frame, textvariable=self.trace_modes_result_var, style="Dark.TLabel.Value").grid(row=2, column=0, columnspan=4, padx=5, pady=2, sticky="ew")
        
        ttk.Button(trace_modes_frame, text="YakBeg - TRACE/MODES", command=self._on_trace_modes_beg).grid(row=3, column=0, columnspan=4, padx=5, pady=5, sticky="ew")


        # --- TRACE/DATA Frame ---
        trace_data_frame = ttk.LabelFrame(self, text="TRACE/DATA", padding=10)
        trace_data_frame.grid(row=6, column=0, padx=10, pady=5, sticky="nsew")
        trace_data_frame.grid_columnconfigure(0, weight=1)
        trace_data_frame.grid_rowconfigure(2, weight=1)
        
        trace_data_controls_frame = ttk.Frame(trace_data_frame)
        trace_data_controls_frame.grid(row=0, column=0, sticky="ew")
        trace_data_controls_frame.grid_columnconfigure(0, weight=1)
        trace_data_controls_frame.grid_columnconfigure(1, weight=1)
        trace_data_controls_frame.grid_columnconfigure(2, weight=1)

        ttk.Label(trace_data_controls_frame, text="Trace #:", style="TLabel").grid(row=0, column=0, padx=5, pady=2, sticky="w")
        self.trace_select_combo = ttk.Combobox(trace_data_controls_frame, textvariable=self.trace_select_var, values=["1", "2", "3", "4"], state="readonly")
        self.trace_select_combo.grid(row=0, column=1, padx=5, pady=2, sticky="ew")
        self.trace_select_combo.set("1")

        ttk.Label(trace_data_controls_frame, text="# of points:", style="TLabel").grid(row=0, column=2, padx=5, pady=2, sticky="w")
        ttk.Label(trace_data_controls_frame, textvariable=self.trace_data_count_var, style="Dark.TLabel.Value").grid(row=0, column=3, padx=5, pady=2, sticky="ew")

        ttk.Label(trace_data_controls_frame, text="Start Freq (MHz):", style="TLabel").grid(row=1, column=0, padx=5, pady=2, sticky="w")
        ttk.Entry(trace_data_controls_frame, textvariable=self.trace_data_start_freq_var).grid(row=1, column=1, padx=5, pady=2, sticky="ew")

        ttk.Label(trace_data_controls_frame, text="Stop Freq (MHz):", style="TLabel").grid(row=1, column=2, padx=5, pady=2, sticky="w")
        ttk.Entry(trace_data_controls_frame, textvariable=self.trace_data_stop_freq_var).grid(row=1, column=3, padx=5, pady=2, sticky="ew")
        
        ttk.Button(trace_data_controls_frame, text="YakBeg - TRACE/DATA", command=self._on_trace_data_beg).grid(row=2, column=0, columnspan=4, padx=5, pady=5, sticky="ew")

        # Table to display trace data
        columns = ("Frequency (MHz)", "Value (dBm)")
        self.trace_data_tree = ttk.Treeview(trace_data_frame, columns=columns, show="headings", style='Treeview')
        self.trace_data_tree.heading("Frequency (MHz)", text="Frequency (MHz)", anchor=tk.W)
        self.trace_data_tree.heading("Value (dBm)", text="Value (dBm)", anchor=tk.W)
        self.trace_data_tree.grid(row=1, column=0, sticky="nsew", padx=5, pady=5)
        
        vsb = ttk.Scrollbar(trace_data_frame, orient="vertical", command=self.trace_data_tree.yview)
        vsb.grid(row=1, column=1, sticky="ns")
        self.trace_data_tree.configure(yscrollcommand=vsb.set)
        
        # New button to push data to monitor
        ttk.Button(self, text="Push Trace Data to Monitor", command=self._on_push_to_monitor, style="Green.TButton").grid(row=7, column=0, padx=10, pady=5, sticky="ew")

    def _on_freq_start_stop_beg(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"YakBeg for FREQUENCY/START-STOP triggered.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)

        from yak.utils_yakbeg_handler import handle_freq_start_stop_beg # Lazy import

        start_freq = self.freq_start_var.get()
        stop_freq = self.freq_stop_var.get()

        start_resp, stop_resp, span_resp, center_resp = handle_freq_start_stop_beg(self.app_instance, start_freq, stop_freq, self.console_print_func)

        if start_resp is not None and stop_resp is not None:
            self.freq_start_var.set(start_resp)
            self.freq_stop_var.set(stop_resp)
            self.freq_ss_result_var.set(f"Result: {start_resp} Hz; {stop_resp} Hz")
        else:
            self.freq_ss_result_var.set("Result: FAILED")


    def _on_freq_center_span_beg(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"YakBeg for FREQUENCY/CENTER-SPAN triggered.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)
        
        center_freq = self.freq_center_var.get()
        span_freq = self.freq_span_var.get()
        
        center_resp, span_resp = handle_freq_center_span_beg(self.app_instance, center_freq, span_freq, self.console_print_func)

        if center_resp is not None and span_resp is not None:
            self.freq_center_var.set(center_resp)
            self.freq_span_var.set(span_resp)
            self.freq_cs_result_var.set(f"Result: {center_resp} Hz; {span_resp} Hz")
        else:
            self.freq_cs_result_var.set("Result: FAILED")


    def _on_marker_place_all_beg(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"YakBeg for MARKER/PLACE/ALL triggered.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)
        
        # FIXED: Get the string value from each StringVar before passing to the handler.
        marker_freqs_mhz = [v.get() for v in self.marker_freq_vars]
        
        response = handle_marker_place_all_beg(self.app_instance, marker_freqs_mhz, self.console_print_func)
        self.marker_place_all_result_var.set(f"Result: {response}")


    def _on_trace_modes_beg(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"YakBeg for TRACE/MODES triggered.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)
        
        trace_modes = [
            self.trace1_mode_var.get(),
            self.trace2_mode_var.get(),
            self.trace3_mode_var.get(),
            self.trace4_mode_var.get()
        ]
        
        response = handle_trace_modes_beg(self.app_instance, trace_modes, self.console_print_func)
        self.trace_modes_result_var.set(f"Result: {response}")


    def _on_trace_data_beg(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"YakBeg for TRACE/DATA triggered.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)
        
        trace_number = self.trace_select_var.get()
        start_freq_mhz = self.trace_data_start_freq_var.get()
        stop_freq_mhz = self.trace_data_stop_freq_var.get()
        
        processed_data = handle_trace_data_beg(self.app_instance, trace_number, start_freq_mhz, stop_freq_mhz, self.console_print_func)

        if processed_data:
            self.trace_data_count_var.set(str(len(processed_data)))
            self.trace_data_tree.delete(*self.trace_data_tree.get_children())
            
            for freq, value in processed_data:
                self.trace_data_tree.insert("", "end", values=(f"{freq:.3f}", f"{value:.2f}"))
            
            self.console_print_func(f"✅ Received and displayed {len(processed_data)} data points.")
        else:
            self.trace_data_count_var.set("0")
            self.trace_data_tree.delete(*self.trace_data_tree.get_children())
            self.console_print_func("❌ Trace data retrieval failed.")

    def _on_tab_selected(self, event):
        """Called when this tab is selected."""
        pass # No specific actions needed on selection
        
    def _on_push_to_monitor(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Push to Monitor button clicked. Let's see if we can get this trace on screen! 🖥️",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)
        
        trace_number = self.trace_select_var.get()
        data = []
        for item in self.trace_data_tree.get_children():
            values = self.trace_data_tree.item(item, 'values')
            data.append((float(values[0]), float(values[1])))
        
        start_freq_mhz = self.trace_data_start_freq_var.get()
        stop_freq_mhz = self.trace_data_stop_freq_var.get()
        
      # handle_push_to_monitor(self.app_instance, self.trace_select_var, self.trace_data_tree, start_freq_mhz, stop_freq_mhz, self.console_print_func)


#####################################
### File: OPEN-AIR\Experiments\tab_experiments_child_initial_configuration.py
#####################################
# tabs/Experiments/tab_experiments_child_initial_configuration.py
#
# This file defines the InitialConfigurationTab, a child tab for the Experiments
# section. It provides a GUI for viewing and editing the application's configuration
# file in a user-friendly manner, allowing for dynamic updates without restarting.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.112000.1
# NEW: Created a new child tab for managing the initial configuration.
# FIXED: Corrected the load_config call to use the proper arguments, resolving the TypeError.

import tkinter as tk
from tkinter import ttk, scrolledtext, filedialog
import inspect
import os
from configparser import ConfigParser

# Import logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log

# Import config management functions
from settings_and_config.config_manager_save import load_program_config, save_program_config 
from ref.ref_program_default_values import DEFAULT_CONFIG
from ref.ref_file_paths import DATA_FOLDER_PATH, CONFIG_FILE_PATH

# --- Version Information ---
w = 20250821
x_str = '112000'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = f"{os.path.basename(__file__)}"


class InitialConfigurationTab(ttk.Frame):
    def __init__(self, master=None, app_instance=None, console_print_func=None, style_obj=None, **kwargs):
        # This function description tells me what this function does
        # Initializes the InitialConfigurationTab, a Tkinter Frame for viewing and
        # editing the application's configuration.
        #
        # Inputs to this function
        #   master (tk.Widget): The parent widget, typically a ttk.Notebook.
        #   app_instance (object): A reference to the main application instance.
        #   console_print_func (function): A function to print messages to the console.
        #   style_obj (ttk.Style): The application's style object.
        #   **kwargs: Arbitrary keyword arguments for Tkinter Frame.
        #
        # Outputs of this function
        #   None. Initializes the Tkinter frame and its internal state.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"📕🟢 Initializing InitialConfigurationTab...",
                  file=current_file, version=current_version, function=current_function)

        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func
        self.style_obj = style_obj
        self.config_file_path = CONFIG_FILE_PATH
        self.config_data = None
        self.config_text_widget = None

        self._create_widgets()
        self._populate_config_table()
        
        debug_log(f"📕✅ InitialConfigurationTab initialized.",
                  file=current_file, version=current_version, function=current_function)

    def _create_widgets(self):
        # This function description tells me what this function does
        # Creates and lays out the widgets for the configuration tab, including a
        # text area for displaying the config and buttons for saving and reloading.
        #
        # Inputs to this function
        #   None.
        #
        # Outputs of this function
        #   None. Populates the tab with GUI elements.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"📕🟢 Creating widgets for InitialConfigurationTab.",
                  file=current_file, version=current_version, function=current_function)

        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(1, weight=1)

        control_frame = ttk.Frame(self)
        control_frame.grid(row=0, column=0, padx=10, pady=5, sticky="ew")
        control_frame.grid_columnconfigure(0, weight=1)
        control_frame.grid_columnconfigure(1, weight=1)
        
        save_button = ttk.Button(control_frame, text="Save Config", command=self._save_program_configure_action, style='Green.TButton')
        save_button.grid(row=0, column=0, padx=5, pady=5, sticky="ew")

        reload_button = ttk.Button(control_frame, text="Reload Config", command=self._reload_config_action, style='Orange.TButton')
        reload_button.grid(row=0, column=1, padx=5, pady=5, sticky="ew")

        self.config_text_widget = scrolledtext.ScrolledText(self, wrap="word", height=25, bg="#2b2b2b", fg="#cccccc", insertbackground="white", font=("Courier", 10))
        self.config_text_widget.grid(row=1, column=0, padx=10, pady=5, sticky="nsew")
        
        debug_log(f"📕✅ Widgets created.",
                  file=current_file, version=current_version, function=current_function)
    
    def _populate_config_table(self):
        # This function description tells me what this function does
        # Reads the config file and populates the text widget with its content.
        #
        # Inputs to this function
        #   None.
        #
        # Outputs of this function
        #   None. Updates the text widget with the config file content.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"📕🟢 Populating config table from file: {self.config_file_path}",
                  file=current_file, version=current_version, function=current_function)

        try:
            # FIXED: Corrected the load_config call to match the function's signature
            # It now passes the DEFAULT_CONFIG dictionary and the file path as separate arguments.
            self.config_data, _, _ = load_program_config(DEFAULT_CONFIG, self.config_file_path)

            self.config_text_widget.config(state=tk.NORMAL)
            self.config_text_widget.delete('1.0', tk.END)
            
            with open(self.config_file_path, 'r') as f:
                content = f.read()
                self.config_text_widget.insert(tk.END, content)
            
            self.config_text_widget.config(state=tk.DISABLED)
            
            debug_log(f"📕✅ Config table populated successfully.",
                      file=current_file, version=current_version, function=current_function)

        except Exception as e:
            console_log(f"❌ Error populating config table: {e}")
            debug_log(f"📕🔴 Failed to populate config table. Error: {e}",
                      file=current_file, version=current_version, function=current_function)
    
    def _save_program_configure_action(self):
        # This function description tells me what this function does
        # Handles the action of saving the edited config back to the file.
        #
        # Inputs to this function
        #   None.
        #
        # Outputs of this function
        #   None. Saves the config file.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"📕🟢 Attempting to save config file...",
                  file=current_file, version=current_version, function=current_function)

        try:
            current_content = self.config_text_widget.get('1.0', tk.END)
            # This is a dangerous operation - it overwrites the config
            # We'll re-implement a safer save later, but for now this works.
            with open(CONFIG_FILE_PATH, 'w') as f:
                f.write(current_content)
            
            console_log(f"✅ Configuration saved successfully! You'll need to restart to see all changes take effect.")
            debug_log(f"📕✅ Configuration saved. Arrr, the treasure be safely stowed! ⚓️",
                      file=current_file, version=current_version, function=current_function)

        except Exception as e:
            console_log(f"❌ Error saving configuration: {e}")
            debug_log(f"📕🔴 Failed to save configuration. Error: {e}",
                      file=current_file, version=current_version, function=current_function)

    def _reload_config_action(self):
        # This function description tells me what this function does
        # Handles the action of reloading the config file from disk.
        #
        # Inputs to this function
        #   None.
        #
        # Outputs of this function
        #   None. Reloads the config file and updates the text widget.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"📕🟢 Reloading config from disk...",
                  file=current_file, version=current_version, function=current_function)
        
        self._populate_config_table()
        
        console_log("✅ Configuration reloaded from disk.")
        debug_log(f"📕✅ Reloaded config. The map be fresh! 🗺️",
                  file=current_file, version=current_version, function=current_function)

#####################################
### File: OPEN-AIR\Experiments\tab_experiments_child_intermod.py
#####################################
# tabs/Experiments/tab_experiments_child_intermod.py
#
# This file defines the InterModTab, a Tkinter Frame for Intermodulation Distortion analysis.
# It allows users to select a markers CSV file, calculate IMD products based on various
# options (e.g., 3rd/5th order, in-band filtering), display results in a Treeview,
# and generate/open an HTML plot of the intermodulation zones.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250801.2150.1 (Refactored debug_print to use debug_log and console_log.)

current_version = "20250801.2150.1" # this variable should always be defined below the header to make the debugging better
current_version_hash = 20250801 * 2150 * 1 # Example hash, adjust as needed

import tkinter as tk
from tkinter import ttk, filedialog, scrolledtext
import inspect
import pandas as pd
import os
import subprocess
from typing import Dict, List, Tuple
from tkinter.font import Font
import sys

# Import the intermodulation calculation and plotting functions - CORRECTED PATHS
from process_math.calculate_intermod import multi_zone_intermods, ZoneData
from process_math.ploting_intermod_zones import plot_zones

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log

class InterModTab(ttk.Frame):
    """
    A Tkinter Frame that contains controls and display for Intermodulation Distortion analysis.
    """
    def __init__(self, master=None, app_instance=None, console_print_func=None, **kwargs):
        """
        Initializes the InterModTab.
        """
        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func if console_print_func else console_log # Use console_log as default

        self.markers_file_path_var = tk.StringVar(self, value="")
        self.intermod_results_csv_path = "INTERMOD.csv"
        self.zones_dashboard_html_path = "zones_dashboard.html"

        self.filter_in_band_enabled_var = tk.BooleanVar(self, value=False)
        self.in_band_min_freq_var = tk.DoubleVar(self, value=470.0)
        self.in_band_max_freq_var = tk.DoubleVar(self, value=608.0)
        self.include_3rd_order_var = tk.BooleanVar(self, value=True)
        self.include_5th_order_var = tk.BooleanVar(self, value=True)
        self.color_code_severity_var = tk.BooleanVar(self, value=True)
        self.export_filtered_csv_var = tk.BooleanVar(self, value=True)

        # Variable to store the last loaded/generated DataFrame for sorting/plotting
        self.last_imd_df = pd.DataFrame()

        self._create_widgets()

    def _create_widgets(self):
        """
        Creates and arranges the widgets for the Inter Mod tab.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        debug_log("Creating widgets for InterModTab...",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(0, weight=0)
        self.grid_rowconfigure(1, weight=0)
        self.grid_rowconfigure(2, weight=0)
        self.grid_rowconfigure(3, weight=1)

        # --- CSV File Selection Frame ---
        file_selection_frame = ttk.LabelFrame(self, text="Marker CSV File Selection", style='Dark.TLabelframe')
        file_selection_frame.grid(row=0, column=0, padx=10, pady=10, sticky="ew")
        file_selection_frame.grid_columnconfigure(1, weight=1)

        ttk.Label(file_selection_frame, text="Markers CSV Path:", style='TLabel').grid(row=0, column=0, sticky="w", padx=5, pady=2)
        ttk.Entry(file_selection_frame, textvariable=self.markers_file_path_var, style='TEntry', state='readonly').grid(row=0, column=1, sticky="ew", padx=5, pady=2)
        ttk.Button(file_selection_frame, text="Browse MARKERS.CSV", command=self._browse_markers_file, style='Blue.TButton').grid(row=0, column=2, padx=5, pady=2)

        # --- IMD Calculation Options Frame ---
        options_frame = ttk.LabelFrame(self, text="Intermodulation Calculation Options", style='Dark.TLabelframe')
        options_frame.grid(row=1, column=0, padx=10, pady=10, sticky="ew")
        options_frame.grid_columnconfigure(0, weight=1)
        options_frame.grid_columnconfigure(1, weight=1)

        row_idx = 0
        ttk.Checkbutton(options_frame, text="Filter In-Band (MHz)", variable=self.filter_in_band_enabled_var, style='TCheckbutton').grid(row=row_idx, column=0, sticky="w", padx=5, pady=2)
        in_band_frame = ttk.Frame(options_frame, style='Dark.TFrame')
        in_band_frame.grid(row=row_idx, column=1, sticky="ew", padx=5, pady=2)
        in_band_frame.grid_columnconfigure(0, weight=1)
        in_band_frame.grid_columnconfigure(1, weight=1)
        ttk.Label(in_band_frame, text="Min:", style='TLabel').grid(row=0, column=0, sticky="w")
        ttk.Entry(in_band_frame, textvariable=self.in_band_min_freq_var, style='TEntry', width=8).grid(row=0, column=0, sticky="e", padx=(0,5))
        ttk.Label(in_band_frame, text="Max:", style='TLabel').grid(row=0, column=1, sticky="w")
        ttk.Entry(in_band_frame, textvariable=self.in_band_max_freq_var, style='TEntry', width=8).grid(row=0, column=1, sticky="e")
        row_idx += 1

        ttk.Checkbutton(options_frame, text="Include 3rd Order IMD (2f1-f2, 2f2-f1)", variable=self.include_3rd_order_var, style='TCheckbutton').grid(row=row_idx, column=0, columnspan=2, sticky="w", padx=5, pady=2); row_idx += 1
        ttk.Checkbutton(options_frame, text="Include 5th Order IMD (3f1-2f2, 3f2-2f1)", variable=self.include_5th_order_var, style='TCheckbutton').grid(row=row_idx, column=0, columnspan=2, sticky="w", padx=5, pady=2); row_idx += 1
        ttk.Checkbutton(options_frame, text="Color-Code Plot by Severity", variable=self.color_code_severity_var, style='TCheckbutton').grid(row=row_idx, column=0, columnspan=2, sticky="w", padx=5, pady=2); row_idx += 1
        ttk.Checkbutton(options_frame, text="Export Filtered CSV", variable=self.export_filtered_csv_var, style='TCheckbutton').grid(row=row_idx, column=0, columnspan=2, sticky="w", padx=5, pady=2); row_idx += 1


        # --- Action Buttons Frame ---
        action_buttons_frame = ttk.Frame(self, style='Dark.TFrame')
        action_buttons_frame.grid(row=2, column=0, padx=10, pady=10, sticky="ew")
        action_buttons_frame.grid_columnconfigure(0, weight=1)
        action_buttons_frame.grid_columnconfigure(1, weight=1)
        action_buttons_frame.grid_columnconfigure(2, weight=1)
        action_buttons_frame.grid_columnconfigure(3, weight=1) # Added for new buttons

        ttk.Button(action_buttons_frame, text="Calculate IMD", command=self._process_imd, style='Green.TButton').grid(row=0, column=0, padx=5, pady=5, sticky="ew")
        ttk.Button(action_buttons_frame, text="Open Intermod CSV", command=self._open_intermod_csv, style='Blue.TButton').grid(row=0, column=1, padx=5, pady=5, sticky="ew")
        ttk.Button(action_buttons_frame, text="Plot Results", command=self._plot_imd_results, style='Purple.TButton').grid(row=0, column=2, padx=5, pady=5, sticky="ew")
        ttk.Button(action_buttons_frame, text="Load Intermod CSV", command=self._load_intermod_csv, style='Orange.TButton').grid(row=0, column=3, padx=5, pady=5, sticky="ew")


        # --- Treeview for IMD Results Display ---
        results_frame = ttk.LabelFrame(self, text="Intermodulation Results (INTERMOD.csv)", style='Dark.TLabelframe')
        results_frame.grid(row=3, column=0, padx=10, pady=10, sticky="nsew")
        results_frame.grid_rowconfigure(0, weight=1)
        results_frame.grid_columnconfigure(0, weight=1)

        self.imd_treeview = ttk.Treeview(results_frame, show="headings")
        self.imd_treeview.grid(row=0, column=0, sticky="nsew")

        # Scrollbars for Treeview
        tree_scrollbar_y = ttk.Scrollbar(results_frame, orient="vertical", command=self.imd_treeview.yview)
        tree_scrollbar_y.grid(row=0, column=1, sticky="ns")
        self.imd_treeview.configure(yscrollcommand=tree_scrollbar_y.set)

        tree_scrollbar_x = ttk.Scrollbar(results_frame, orient="horizontal", command=self.imd_treeview.xview)
        tree_scrollbar_x.grid(row=1, column=0, sticky="ew")
        self.imd_treeview.configure(xscrollcommand=tree_scrollbar_x.set)

        # Bind click event for column sorting
        self.imd_treeview.bind("<Button-1>", self._on_treeview_header_click)

        debug_log("InterModTab widgets created.",
                    file=__file__,
                    version=current_version,
                    function=current_function)

    def _browse_markers_file(self):
        """Opens a file dialog to select the MARKERS.CSV file."""
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        file_path = filedialog.askopenfilename(
            title="Select MARKERS.CSV",
            filetypes=[("CSV files", "*.csv")]
        )
        if file_path:
            self.markers_file_path_var.set(file_path)
            self.console_print_func(f"Selected Markers CSV: {file_path}")
            debug_log(f"Selected Markers CSV: {file_path}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        else:
            self.console_print_func("No Markers CSV file selected.")
            debug_log("No Markers CSV file selected. What a waste of a click!",
                        file=__file__,
                        version=current_version,
                        function=current_function)

    def _parse_markers_csv(self, csv_path: str) -> ZoneData:
        """
        Parses the markers CSV file to extract zone data, including frequencies and associated devices.
        Returns:
            zones_data: dict
              Keys = zone names from 'ZONE' column
              Values = tuple of (list of (frequency, device_name) tuples, (x, y) coordinates)
        """
        import random
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        debug_log(f"Parsing {csv_path}...",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        zones_data = {}
        try:
            df = pd.read_csv(csv_path)

            # Ensure required columns exist
            required_columns = ["ZONE", "FREQ", "DEVICE", "NAME"]
            if not all(col in df.columns for col in required_columns):
                raise ValueError(f"CSV must contain columns: {', '.join(required_columns)}")

            for zone_name in df["ZONE"].unique():
                zone_df = df[df["ZONE"] == zone_name].dropna(subset=["FREQ"])

                # Combine DEVICE and NAME for a more descriptive device_name
                # Handle cases where DEVICE or NAME might be missing/NaN
                freq_device_pairs = []
                for _, row in zone_df.iterrows():
                    freq = row["FREQ"]
                    device = str(row["DEVICE"]) if pd.notna(row["DEVICE"]) else "Unknown Device"
                    name = str(row["NAME"]) if pd.notna(row["NAME"]) else "Unknown Name"

                    # If both DEVICE and NAME are "None - None - G10" or similar, just use the NAME
                    if "None - None" in device and "None" in name:
                        device_name = name
                    elif "None - None" in device:
                        device_name = name
                    elif "None" in name:
                        device_name = device
                    else:
                        device_name = f"{device} - {name}"

                    freq_device_pairs.append((freq, device_name))

                # Assign dummy coordinates if not available in CSV
                # You should replace this with your actual coordinate lookup if available!
                x = hash(zone_name) % 100
                y = (hash(zone_name) // 100) % 100
                zones_data[zone_name] = (freq_device_pairs, (x, y))

            self.console_print_func(f"Successfully parsed {len(zones_data)} zones from CSV.")
            debug_log(f"Parsed zones data: {zones_data}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return zones_data

        except Exception as e:
            self.console_print_func(f"❌ Failed to parse markers CSV: {e}")
            debug_log(f"Error parsing markers CSV: {e}. This CSV is a stubborn bastard!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return {}

    def _display_imd_results(self, df: pd.DataFrame):
        """Displays the intermodulation results DataFrame in the Treeview."""
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        debug_log(f"Displaying IMD results. DataFrame has {len(df)} rows.",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        # Clear existing data
        for item in self.imd_treeview.get_children():
            self.imd_treeview.delete(item)

        if df.empty:
            self.console_print_func("No IMD results to display.")
            debug_log("IMD DataFrame is empty, no results to display. Fucking empty!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        # Define the desired order of columns for display
        display_columns = [
            "Zone_1", "Device_1", "Parent_Freq1",
            "Zone_2", "Device_2", "Parent_Freq2",
            "Type", "Order", "Distance", "Frequency_MHz", "Severity"
        ]

        # Ensure all display_columns exist in the DataFrame, add missing ones if necessary
        for col in display_columns:
            if col not in df.columns:
                df[col] = "N/A"

        # Set columns for Treeview
        self.imd_treeview["columns"] = display_columns
        for col in display_columns:
            self.imd_treeview.heading(col, text=col.replace('_', ' '), anchor="center")
            self.imd_treeview.column(col, width=Font().measure(col.replace('_', ' ')) + 15, anchor="center")

        # Insert data and adjust column widths
        for index, row in df.iterrows():
            try:
                values_to_insert = []
                for col in display_columns:
                    value = row[col]
                    if isinstance(value, (int, float)):
                        if col == "Frequency_MHz" or col == "Parent_Freq1" or col == "Parent_Freq2":
                            str_value = f"{value:.3f}"
                        elif col == "Distance":
                            str_value = f"{value:.2f}"
                        else:
                            str_value = str(value)
                    else:
                        str_value = str(value)

                    values_to_insert.append(str_value)

                    current_width = self.imd_treeview.column(col, "width")
                    new_width = Font().measure(str_value) + 15
                    if new_width > current_width:
                        self.imd_treeview.column(col, width=new_width)

                self.imd_treeview.insert("", "end", values=values_to_insert)
            except Exception as e:
                self.console_print_func(f"❌ Error displaying IMD row (index {index}): {row.to_dict()} - {e}")
                debug_log(f"Error inserting row into Treeview (index {index}): {row.to_dict()} - {e}. This row is a pain in the ass!",
                            file=__file__,
                            version=current_version,
                            function=current_function)
                continue
        self.console_print_func(f"Displayed {len(df)} IMD products.")
        self.last_imd_df = df.copy()


    def _process_imd(self):
        """
        Initiates the IMD calculation and plot generation based on selected options.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        self.console_print_func("\n--- Starting IMD Calculation & Plot Generation ---")
        debug_log("Starting IMD Calculation & Plot Generation...",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        markers_csv_path = self.markers_file_path_var.get()
        if not markers_csv_path or not os.path.exists(markers_csv_path):
            self.console_print_func("Error: Please select a valid MARKERS.CSV file first.")
            debug_log("No valid Markers CSV selected. Fucking useless!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        try:
            # 1. Parse Markers CSV to ZoneData
            zones = self._parse_markers_csv(markers_csv_path)
            if not zones:
                self.console_print_func("IMD calculation aborted due to empty or invalid zone data.")
                debug_log("Empty or invalid zone data after parsing. What the hell?!",
                            file=__file__,
                            version=current_version,
                            function=current_function)
                return

            # Determine output paths relative to the markers CSV
            output_dir = os.path.dirname(markers_csv_path)
            intermod_csv_output = os.path.join(output_dir, self.intermod_results_csv_path)
            zones_html_output = os.path.join(output_dir, self.zones_dashboard_html_path)

            # 2. Calculate Intermodulation Products
            self.console_print_func("Calculating intermodulation products...")
            debug_log(f"Calling multi_zone_intermods with zones: {zones}",
                        file=__file__,
                        version=current_version,
                        function=current_function)

            imd_results_df = multi_zone_intermods(
                zones=zones,
                include_cross_zone=True,
                export_csv=intermod_csv_output,
                filter_in_band=self.filter_in_band_enabled_var.get(),
                in_band_min_freq=self.in_band_min_freq_var.get(),
                in_band_max_freq=self.in_band_max_freq_var.get(),
                include_3rd_order=self.include_3rd_order_var.get(),
                include_5th_order=self.include_5th_order_var.get()
            )
            debug_log(f"multi_zone_intermods returned DataFrame. Type: {type(imd_results_df)}, Shape: {imd_results_df.shape}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            debug_log(f"First 5 rows of IMD DataFrame:\n{imd_results_df.head().to_string()}",
                        file=__file__,
                        version=current_version,
                        function=current_function)


            self.console_print_func(f"IMD calculation complete. Results saved to: {intermod_csv_output}")
            self.console_print_func(f"Total IMD products found (after filters): {len(imd_results_df)}")

            # 3. Display results in Treeview
            self._display_imd_results(imd_results_df)
            self.console_print_func("✅ IMD analysis results displayed.")

            self.console_print_func("--- IMD Analysis Complete! ---")
            debug_log("IMD Analysis Complete. Fucking awesome!",
                        file=__file__,
                        version=current_version,
                        function=current_function)

        except Exception as e:
            self.console_print_func(f"❌ An error occurred during IMD analysis: {e}")
            debug_log(f"Error during IMD analysis: {e}. This bugger is being problematic!",
                        file=__file__,
                        version=current_version,
                        function=current_function)

    def _open_intermod_map(self):
        """
        Opens the generated HTML intermod map in the default web browser.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log

        markers_csv_path = self.markers_file_path_var.get()
        if not markers_csv_path:
            self.console_print_func("Error: Please select a Markers CSV file and run IMD calculation first to generate the map.")
            debug_log("No Markers CSV selected, cannot open map. Fucking useless!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        output_dir = os.path.dirname(markers_csv_path)
        html_file_path = os.path.join(output_dir, self.zones_dashboard_html_path)

        if not os.path.exists(html_file_path):
            self.console_print_func(f"Error: Intermod map HTML file not found at {html_file_path}. Please run IMD calculation first.")
            debug_log(f"HTML map not found: {html_file_path}. Where the hell is it?!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        try:
            if sys.platform == "win32":
                os.startfile(html_file_path)
            elif sys.platform == "darwin": # macOS
                subprocess.Popen(["open", html_file_path])
            else: # Linux
                subprocess.Popen(["xdg-open", html_file_path])
            self.console_print_func(f"✅ Opened Intermod Map: {html_file_path}")
            debug_log(f"Opened Intermod Map: {html_file_path}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        except Exception as e:
            self.console_print_func(f"❌ Failed to open Intermod Map: {e}")
            debug_log(f"Error opening Intermod Map: {e}. This is a goddamn mess!",
                        file=__file__,
                        version=current_version,
                        function=current_function)

    def _open_intermod_csv(self):
        """
        Opens the generated INTERMOD.csv file in the default associated application.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log

        markers_csv_path = self.markers_file_path_var.get()
        if not markers_csv_path:
            self.console_print_func("Error: Please select a Markers CSV file and run IMD calculation first to generate the CSV.")
            debug_log("No Markers CSV selected, cannot open intermod CSV. Fucking useless!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        output_dir = os.path.dirname(markers_csv_path)
        csv_file_path = os.path.join(output_dir, self.intermod_results_csv_path)

        if not os.path.exists(csv_file_path):
            self.console_print_func(f"Error: Intermod CSV file not found at {csv_file_path}. Please run IMD calculation first.")
            debug_log(f"Intermod CSV file not found: {csv_file_path}. Where the hell is it?!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        try:
            if sys.platform == "win32":
                os.startfile(csv_file_path)
            elif sys.platform == "darwin": # macOS
                subprocess.Popen(["open", csv_file_path])
            else: # Linux
                subprocess.Popen(["xdg-open", csv_file_path])
            self.console_print_func(f"✅ Opened Intermod CSV: {csv_file_path}")
            debug_log(f"Opened Intermod CSV: {csv_file_path}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        except Exception as e:
            self.console_print_func(f"❌ Failed to open Intermod CSV: {e}")
            debug_log(f"Error opening Intermod CSV: {e}. This is a goddamn mess!",
                        file=__file__,
                        version=current_version,
                        function=current_function)

    def _plot_imd_results(self):
        """
        Generates and opens the Plotly HTML dashboard based on the last calculated/loaded IMD results.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log

        if self.last_imd_df.empty:
            self.console_print_func("Error: No IMD results available to plot. Please calculate or load results first.")
            debug_log("No IMD data to plot. Fucking empty!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        markers_csv_path = self.markers_file_path_var.get()
        if not markers_csv_path or not os.path.exists(markers_csv_path):
            self.console_print_func("Error: Markers CSV path is required to generate the plot (for zone coordinates). Please select it.")
            debug_log("Markers CSV path missing for plotting. Fucking useless!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        try:
            zones = self._parse_markers_csv(markers_csv_path)
            if not zones:
                self.console_print_func("Error: Cannot plot without valid zone data from Markers CSV.")
                debug_log("No zones parsed for plotting. What the hell?!",
                            file=__file__,
                            version=current_version,
                            function=current_function)
                return

            output_dir = os.path.dirname(markers_csv_path)
            zones_html_output = os.path.join(output_dir, self.zones_dashboard_html_path)

            self.console_print_func("Generating Plotly dashboard...")
            plot_zones(
                zones=zones,
                imd_df=self.last_imd_df,
                html_filename=zones_html_output,
                color_code_severity=self.color_code_severity_var.get()
            )
            self.console_print_func(f"Plotly dashboard generated: {zones_html_output}")
            self._open_intermod_map() # Reuse existing method to open the HTML
            self.console_print_func("✅ Intermodulation map opened in browser.")

        except Exception as e:
            self.console_print_func(f"❌ An error occurred during plot generation: {e}")
            debug_log(f"Error during plot generation: {e}. This bugger is being problematic!",
                        file=__file__,
                        version=current_version,
                        function=current_function)

    def _load_intermod_csv(self):
        """
        Loads an existing INTERMOD.csv file into the Treeview for display and makes it available for plotting.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log

        file_path = filedialog.askopenfilename(
            title="Select Intermod Results CSV",
            filetypes=[("CSV files", "*.csv")],
            initialdir=os.path.dirname(self.markers_file_path_var.get()) if self.markers_file_path_var.get() else os.getcwd()
        )
        if not file_path:
            self.console_print_func("No Intermod CSV file selected for loading.")
            debug_log("No Intermod CSV selected for loading. Fucking useless!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        try:
            df = pd.read_csv(file_path)
            self._display_imd_results(df)
            self.console_print_func(f"✅ Loaded IMD results from: {file_path}")
            debug_log(f"Loaded IMD results from: {file_path}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        except Exception as e:
            self.console_print_func(f"❌ Failed to load Intermod CSV: {e}")
            debug_log(f"Error loading Intermod CSV: {e}. This CSV is a stubborn bastard!",
                        file=__file__,
                        version=current_version,
                        function=current_function)


    def _on_treeview_header_click(self, event):
        """
        Handles clicks on Treeview column headers to sort the data.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log

        region = self.imd_treeview.identify("region", event.x, event.y)
        if region == "heading":
            col = self.imd_treeview.identify_column(event.x)
            column_id = int(col.replace('#', '')) - 1

            if 0 <= column_id < len(self.imd_treeview["columns"]):
                column_name = self.imd_treeview["columns"][column_id]
                debug_log(f"Header '{column_name}' clicked for sorting.",
                            file=__file__,
                            version=current_version,
                            function=current_function)

                if not hasattr(self, '_sort_order'):
                    self._sort_order = {}

                current_sort_order = self._sort_order.get(column_name, 'ascending')
                new_sort_order = 'descending' if current_sort_order == 'ascending' else 'ascending'
                self._sort_order[column_name] = new_sort_order

                self._sort_treeview(column_name, new_sort_order)
            else:
                debug_log(f"Clicked column ID {column_id} is out of bounds for current columns. What the hell?!",
                            file=__file__,
                            version=current_version,
                            function=current_function)
        else:
            debug_log(f"Click not on heading region: {region}. Fucking useless click!",
                        file=__file__,
                        version=current_version,
                        function=current_function)

    def _sort_treeview(self, col_name, order):
        """
        Sorts the Treeview content by the given column and order.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        debug_log(f"Sorting Treeview by column '{col_name}' in '{order}' order.",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        if self.last_imd_df.empty:
            self.console_print_func("No data to sort.")
            debug_log("No data in last_imd_df to sort. Fucking empty!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        if col_name not in self.last_imd_df.columns:
            self.console_print_func(f"Error: Cannot sort by column '{col_name}' as it does not exist in the data.")
            debug_log(f"Column '{col_name}' not found for sorting. What the hell?!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        ascending = (order == 'ascending')

        numeric_cols = ["Frequency_MHz", "Parent_Freq1", "Parent_Freq2", "Distance"]
        for num_col in numeric_cols:
            if num_col in self.last_imd_df.columns:
                self.last_imd_df[num_col] = pd.to_numeric(self.last_imd_df[num_col], errors='coerce')

        sorted_df = self.last_imd_df.sort_values(by=col_name, ascending=ascending, na_position='last')

        self._display_imd_results(sorted_df)
        self.console_print_func(f"Sorted results by '{col_name}' ({order}).")

    def _on_tab_selected(self, event):
        """
        Called when this tab is selected in the notebook.
        Can be used to refresh data or update UI elements specific to this tab.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        debug_log("Inter Mod Tab selected.",
                    file=__file__,
                    version=current_version,
                    function=current_function)


#####################################
### File: OPEN-AIR\Experiments\tab_experiments_colouring.py
#####################################
# tabs/Experiments/tab_experiments_colouring.py
#
# This file defines the ColouringTab, a Tkinter Frame that provides
# functionality to read and display the color palette defined in style.py.
# It will show each color variable's name and a small colored box.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
#
#
# Version 20250816.200000.12 (FIXED: The tab now dynamically reads and displays all colors and styles from `program_style.py`, with clear labels and live previews of buttons.)

current_version = "20250816.200000.12"
current_version_hash = 20250816 * 200000 * 12

import tkinter as tk
from tkinter import ttk, TclError
import inspect
import os
import re

# Import the COLOR_PALETTE and other styles from style.py
from src.program_style import COLOR_PALETTE, COLOR_PALETTE_TABS, _get_dark_color
from display.debug_logic import debug_log
from display.console_logic import console_log

class ColouringTab(ttk.Frame):
    """
    A Tkinter Frame that displays the color palette defined in style.py.
    It shows each color variable's name and a small colored box representing its value,
    along with sections for font sizes and common UI element styles.
    """
    def __init__(self, master=None, app_instance=None, console_print_func=None, **kwargs):
        """
        Initializes the ColouringTab.

        Inputs:
            master (tk.Widget): The parent widget.
            app_instance (App): The main application instance.
            console_print_func (function): Function to print messages to the GUI console.
            **kwargs: Arbitrary keyword arguments for Tkinter Frame.
        """
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__)
        debug_log(f"Initializing ColouringTab...",
                    file=f"{current_file} - {current_version}",
                    version=current_version,
                    function=current_function)

        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func if console_print_func else console_log

        self._create_widgets()

        debug_log(f"ColouringTab initialized. Ready to display colors and styles!",
                    file=f"{current_file} - {current_version}",
                    version=current_version,
                    function=current_function)

    def _create_widgets(self):
        """
        Creates the widgets for the Colouring tab, including a scrollable frame
        to display the color variables, font sizes, and common UI element styles.
        """
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__)
        debug_log(f"Creating ColouringTab widgets...",
                    file=f"{current_file} - {current_version}",
                    version=current_version,
                    function=current_function)

        # Create a Canvas and a Scrollbar for scrollable content
        self.canvas = tk.Canvas(self, background=COLOR_PALETTE['background'], highlightthickness=0)
        self.scrollbar = ttk.Scrollbar(self, orient="vertical", command=self.canvas.yview)
        self.scrollable_frame = ttk.Frame(self.canvas, style='Dark.TFrame')

        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: self.canvas.configure(
                scrollregion=self.canvas.bbox("all")
            )
        )
        # Bind mouse wheel for scrolling
        self.canvas.bind_all("<MouseWheel>", self._on_mousewheel) # For Windows/macOS
        self.canvas.bind_all("<Button-4>", self._on_mousewheel) # For Linux (scroll up)
        self.canvas.bind_all("<Button-5>", self._on_mousewheel) # For Linux (scroll down)


        self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
        self.canvas.configure(yscrollcommand=self.scrollbar.set)

        self.canvas.pack(side="left", fill="both", expand=True)
        self.scrollbar.pack(side="right", fill="y")

        self._populate_content()

    def _on_mousewheel(self, event):
        """Handles mouse wheel scrolling for the canvas."""
        if self.canvas.winfo_exists(): # Check if canvas still exists
            if event.num == 4 or event.delta > 0: # Scroll up
                self.canvas.yview_scroll(-1, "unit")
            elif event.num == 5 or event.delta < 0: # Scroll down
                self.canvas.yview_scroll(1, "unit")

    def _populate_content(self):
        """
        Populates the scrollable frame with color palette, font sizes, and common styles.
        """
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__)
        debug_log(f"Populating ColouringTab content...",
                    file=f"{current_file} - {current_version}",
                    version=current_version,
                    function=current_function)

        # Clear any existing widgets in the scrollable frame
        for widget in self.scrollable_frame.winfo_children():
            widget.destroy()

        row_idx = 0

        # --- Section 1: Color Palette (Grouped Horizontally) ---
        color_palette_main_frame = ttk.LabelFrame(self.scrollable_frame, text="Color Palette", style='Dark.TLabelframe', padding=(10, 10))
        color_palette_main_frame.grid(row=row_idx, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        color_palette_main_frame.grid_columnconfigure(0, weight=1)
        color_palette_main_frame.grid_columnconfigure(1, weight=1)
        color_palette_main_frame.grid_columnconfigure(2, weight=1)
        row_idx += 1

        # Frame for Defaults/Globals
        defaults_frame = ttk.LabelFrame(color_palette_main_frame, text="Defaults / Globals", style='Dark.TLabelframe', padding=(5, 5))
        defaults_frame.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)
        defaults_frame.grid_columnconfigure(0, weight=1) # For color name label
        defaults_frame.grid_columnconfigure(1, weight=0) # For color box

        # Frame for Buttons
        buttons_color_frame = ttk.LabelFrame(color_palette_main_frame, text="Button Colors", style='Dark.TLabelframe', padding=(5, 5))
        buttons_color_frame.grid(row=0, column=1, sticky="nsew", padx=5, pady=5)
        buttons_color_frame.grid_columnconfigure(0, weight=1)
        buttons_color_frame.grid_columnconfigure(1, weight=0)

        # Frame for Parent Tabs
        parent_tabs_color_frame = ttk.LabelFrame(color_palette_main_frame, text="Parent Tab Colors", style='Dark.TLabelframe', padding=(5, 5))
        parent_tabs_color_frame.grid(row=0, column=2, sticky="nsew", padx=5, pady=5)
        parent_tabs_color_frame.grid_columnconfigure(0, weight=1)
        parent_tabs_color_frame.grid_columnconfigure(1, weight=0)


        default_row_idx = 0
        button_row_idx = 0
        parent_tab_row_idx = 0

        for color_name, color_value in COLOR_PALETTE.items():
            if '_btn' in color_name: # Simple check for button related colors
                self._add_color_display_row(buttons_color_frame, f"{color_name}: {color_value}", color_value, button_row_idx)
                button_row_idx += 1
            elif color_name in ['white', 'black']:
                self._add_color_display_row(defaults_frame, f"{color_name}: {color_value}", color_value, default_row_idx)
                default_row_idx += 1
            else: # Defaults/Globals
                self._add_color_display_row(defaults_frame, f"{color_name}: {color_value}", color_value, default_row_idx)
                default_row_idx += 1
        
        # New loop for COLOR_PALETTE_TABS
        for tab_name, tab_colors in COLOR_PALETTE_TABS.items():
            ttk.Label(parent_tabs_color_frame, text=f"--- {tab_name.replace('_', ' ').title()} ---",
                      style='Dark.TLabel.Value', font=('Helvetica', 11, 'bold')).grid(row=parent_tab_row_idx, column=0, columnspan=2, pady=(10, 2), sticky="w", padx=5)
            parent_tab_row_idx += 1
            for state_name, hex_code in tab_colors.items():
                self._add_color_display_row(parent_tabs_color_frame, f"{state_name}: {hex_code}", hex_code, parent_tab_row_idx, indent=1)
                parent_tab_row_idx += 1
                if state_name == 'active':
                    # Add inactive color as well for clarity
                    inactive_color = _get_dark_color(hex_code)
                    self._add_color_display_row(parent_tabs_color_frame, f"inactive: {inactive_color}", inactive_color, parent_tab_row_idx, indent=1)
                    parent_tab_row_idx += 1


        # --- Section 2: Font Sizes ---
        font_sizes_frame = ttk.LabelFrame(self.scrollable_frame, text="Common Font Sizes (Helvetica)", style='Dark.TLabelframe', padding=(10, 10))
        font_sizes_frame.grid(row=row_idx, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        font_sizes_frame.grid_columnconfigure(0, weight=1)
        row_idx += 1

        common_font_sizes = [9, 10, 11, 12, 13, 14, 25, 100] # Based on style.py analysis
        current_font_row = 0
        for size in common_font_sizes:
            ttk.Label(font_sizes_frame, text=f"Font Size {size}pt", # Removed "Example Text"
                      background=COLOR_PALETTE['background'],
                      foreground=COLOR_PALETTE['foreground'],
                      font=('Helvetica', size, 'bold' if size >= 12 else '')).grid(row=current_font_row, column=0, sticky="w", padx=5, pady=2)
            current_font_row += 1

        # --- Section 3: Common UI Element Styles ---
        ui_styles_frame = ttk.LabelFrame(self.scrollable_frame, text="Common UI Element Styles", style='Dark.TLabelframe', padding=(10, 10))
        ui_styles_frame.grid(row=row_idx, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        ui_styles_frame.grid_columnconfigure(0, weight=1)
        ui_styles_frame.grid_columnconfigure(1, weight=1)
        row_idx += 1

        # Define some conceptual styles based on style.py
        common_ui_styles = {
            "TLabel (Default)": {"widget_type": "label", "style_name": "TLabel"},
            "Dark.TLabel.Value": {"widget_type": "label", "style_name": "Dark.TLabel.Value"},
            "Red.TLabel.Value": {"widget_type": "label", "style_name": "Red.TLabel.Value"},
            "TEntry (Default)": {"widget_type": "entry", "style_name": "TEntry"},
            "TButton (Default)": {"widget_type": "button", "style_name": "TButton"},
            "Green.TButton": {"widget_type": "button", "style_name": "Green.TButton"},
            "Red.TButton": {"widget_type": "button", "style_name": "Red.TButton"},
            "Orange.TButton": {"widget_type": "button", "style_name": "Orange.TButton"},
            "Blue.TButton": {"widget_type": "button", "style_name": "Blue.TButton"},
            "Purple.TButton": {"widget_type": "button", "style_name": "Purple.TButton"},
            "StartScan.TButton": {"widget_type": "button", "style_name": "StartScan.TButton"},
            "PauseScan.TButton": {"widget_type": "button", "style_name": "PauseScan.TButton"},
            "StopScan.TButton": {"widget_type": "button", "style_name": "StopScan.TButton"},
            "LocalPreset.TButton": {"widget_type": "button", "style_name": "LocalPreset.TButton"},
            "SelectedPreset.Orange.TButton": {"widget_type": "button", "style_name": "SelectedPreset.Orange.TButton"},
            "DeviceButton.Blinking.TButton": {"widget_type": "button", "style_name": "DeviceButton.Blinking.TButton"},
            "ControlButton.Active.TButton": {"widget_type": "button", "style_name": "ControlButton.Active.TButton"},
            "Band.Low.TButton": {"widget_type": "button", "style_name": "Band.Low.TButton"},
            "Band.Medium.TButton": {"widget_type": "button", "style_name": "Band.Medium.TButton"},
            "Band.High.TButton": {"widget_type": "button", "style_name": "Band.High.TButton"},
        }
        
        current_ui_row = 0
        for display_name, properties in common_ui_styles.items():
            try:
                style_name = properties['style_name']
                # FIXED: Changed `self.app_instance.style` to `self.app_instance.style_obj`
                style_spec = self.app_instance.style_obj.lookup(style_name, 'font')
                if style_spec:
                    style_font = style_spec
                else:
                    style_font = ("Helvetica", 9)
            except TclError:
                style_font = ("Helvetica", 9)

            style_box = ttk.Frame(ui_styles_frame, style='Dark.TFrame', relief="solid", borderwidth=1)
            style_box.grid(row=current_ui_row, column=0, columnspan=2, sticky="ew", padx=5, pady=5)
            style_box.grid_columnconfigure(0, weight=1) # For the label/button inside the box

            # Display style name and font
            ttk.Label(style_box, text=f"Style: {display_name} (Font: {style_font})",
                      background=COLOR_PALETTE['background'], foreground=COLOR_PALETTE['foreground'],
                      font=('Helvetica', 10, 'bold')).grid(row=0, column=0, sticky="w", padx=5, pady=2)

            example_text = display_name
            
            if properties.get("widget_type") == "button":
                example_widget = ttk.Button(style_box, text=example_text, style=style_name)
            elif properties.get("widget_type") == "entry":
                example_widget = ttk.Entry(style_box, style=style_name)
                example_widget.insert(0, example_text)
            else: # label
                example_widget = ttk.Label(style_box, text=example_text, style=style_name)
                
            example_widget.grid(row=1, column=0, sticky="w", padx=5, pady=2)

            current_ui_row += 1


        self.scrollable_frame.update_idletasks() # Update layout to ensure scrollregion is calculated correctly

    def _add_color_display_row(self, parent_frame, text, hex_color, row_idx, indent=0):
        """Helper to add a row for color display."""
        current_file = os.path.basename(__file__)
        current_function = inspect.currentframe().f_code.co_name

        padx_val = 5 + (indent * 15) # Indent nested colors

        # Label for color name and hex value
        color_label = ttk.Label(parent_frame, text=text,
                                background=COLOR_PALETTE['background'],
                                foreground=COLOR_PALETTE['foreground'],
                                font=('Helvetica', 9))
        color_label.grid(row=row_idx, column=0, sticky="w", padx=padx_val, pady=2)

        # Small frame to display the color
        color_box = tk.Frame(parent_frame, width=20, height=20, relief="solid", borderwidth=1, background=hex_color)
        color_box.grid(row=row_idx, column=1, sticky="e", padx=5, pady=2)

        debug_log(f"Displayed color: {text} with hex: {hex_color}",
                    file=f"{current_file} - {current_version}",
                    version=current_version,
                    function=current_function)


    def _on_tab_selected(self, event):
        """
        Called when this tab is selected in the notebook.
        Refreshes the displayed colors and styles.
        """
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__)
        debug_log(f"ColouringTab selected. Refreshing color and style display.",
                    file=f"{current_file} - {current_version}",
                    version=current_version,
                    function=current_function)
        self._populate_content()

#####################################
### File: OPEN-AIR\Experiments\tab_experiments_credits.py
#####################################
# tabs/Experiments/tab_experiments_credits.py
#
# This file defines the CreditsTab, a Tkinter Frame that provides
# a button to open the project's GitHub page for credits and contribution details.
# It also displays the project's logo.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version W.X.Y
#

current_version = "Version 20250820.102600.4"
current_version_hash = 20250820 * 102600 * 4

import tkinter as tk
from tkinter import ttk
import inspect
import os
import webbrowser # For opening the GitHub link
from display.debug_logic import debug_log
from display.console_logic import console_log
from src.program_style import COLOR_PALETTE
from PIL import Image, ImageTk # For handling images

class CreditsTab(tk.Frame):
    """
    A Tkinter Frame for displaying credits, the project logo, and a link to the GitHub repository.
    """
    def __init__(self, parent_notebook, app_instance, console_print_func, *args, **kwargs):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering CreditsTab.__init__.",
                  file=f"{os.path.basename(__file__)}",
                  version=current_version,
                  function=current_function)

        try:
            super().__init__(parent_notebook, **kwargs)
            self.app_instance = app_instance
            self.console_print_func = console_print_func
            self.parent_notebook = parent_notebook

            self.configure(background=COLOR_PALETTE["background"])
            
            # Load and display the logo image
            try:
                # Construct the path to the image
                script_dir = os.path.dirname(__file__)
                logo_path = os.path.join(script_dir, '..', '..', 'display', 'logo.png')
                
                # Check if the file exists before trying to open it
                if os.path.exists(logo_path):
                    original_image = Image.open(logo_path)
                    
                    self.logo_image = ImageTk.PhotoImage(original_image)
                    logo_label = tk.Label(self, image=self.logo_image, background=COLOR_PALETTE["background"])
                    logo_label.pack(pady=(20, 10))
                else:
                    self.console_print_func(f"❌ Logo image not found at: {logo_path}")
                    debug_log(f"Arrr, the logo be missing! The path be: {logo_path}",
                                file=f"{os.path.basename(__file__)}",
                                version=current_version,
                                function=current_function)
            except Exception as e:
                self.console_print_func(f"❌ Error loading logo image: {e}")
                debug_log(f"A curse on these image files! Error loading logo: {e}",
                            file=f"{os.path.basename(__file__)}",
                            version=current_version,
                            function=current_function)

            # Label for title
            ttk.Label(
                self,
                text="Project Credits",
                font=('Helvetica', 14, 'bold'),
                background=COLOR_PALETTE["background"],
                foreground=COLOR_PALETTE["foreground"]
            ).pack(pady=(10, 5))

            # Button to open GitHub page
            open_github_button = tk.Button(
                self,
                text="Open on GitHub",
                font=('Helvetica', 13, 'bold'),
                bg=COLOR_PALETTE['blue_btn'],
                fg=COLOR_PALETTE['white'],
                activebackground=COLOR_PALETTE['blue_btn_active'],
                activeforeground=COLOR_PALETTE['white'],
                compound="left",
                command=self._open_github_link
            )
            open_github_button.pack(pady=10, padx=10)

            console_print_func("✅ Credits Tab initialized successfully.")
            debug_log(f"All components for CreditsTab are up and running! 🚀",
                      file=f"{os.path.basename(__file__)}",
                      version=current_version,
                      function=current_function)
        except Exception as e:
            console_print_func(f"❌ Error in CreditsTab initialization: {e}")
            debug_log(f"Arrr, the code be capsized! The error be: {e}",
                      file=f"{os.path.basename(__file__)}",
                      version=current_version,
                      function=current_function)
            raise

    def _open_github_link(self):
        # [A brief, one-sentence description of the function's purpose.]
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering _open_github_link with arguments: N/A",
                  file=f"{os.path.basename(__file__)}",
                  version=current_version,
                  function=current_function)

        try:
            github_url = "https://github.com/APKaudio/Spectrum-Automation---ZAP"
            webbrowser.open_new_tab(url=github_url)
            self.console_print_func("✅ Opening GitHub page in browser.")
            debug_log(f"Opening GitHub link: {github_url}. Anchors aweigh! ⛵",
                      file=f"{os.path.basename(__file__)}",
                      version=current_version,
                      function=current_function)

            console_log("✅ Celebration of success!")
        except Exception as e:
            self.console_print_func(f"❌ Error opening GitHub link: {e}")
            debug_log(f"Arrr, the code be capsized! The error be: {e}",
                      file=f"{os.path.basename(__file__)}",
                      version=current_version,
                      function=current_function)


    def _on_tab_selected(self, event):
        """
        Handles the event when this child tab is selected.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering _on_tab_selected.",
                  file=f"{os.path.basename(__file__)}",
                  version=current_version,
                  function=current_function)
        
        # No specific actions needed for this tab on selection.
        console_log("✅ Celebration of success!")

#####################################
### File: OPEN-AIR\Instrument\TAB_INSTRUMENT_PARENT.py
#####################################
# tabs/Instrument/TAB_INSTRUMENT_PARENT.py
#
# This file defines the TAB_INSTRUMENT_PARENT class, which serves as a container
# for all instrument-related child tabs.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250815.103400.1
# REFACTORED: The monolithic SettingsTab has been replaced with the new SettingsParentTab container.

current_version = "20250815.103400.1"
current_version_hash = (20250815 * 103400 * 1)

import tkinter as tk
from tkinter import ttk
import inspect
import os
from datetime import datetime

from .connection.tab_instrument_child_connection import InstrumentTab
from .visa.tab_instrument_child_visa_interpreter import VisaInterpreterTab
from .settings.tab_instrument_child_settings import SettingsParentTab

from display.debug_logic import debug_log
from display.console_logic import console_log

# Import the new SettingsParentTab that now contains the refactored settings UI.


class TAB_INSTRUMENT_PARENT(ttk.Frame):
    """
    A parent tab for Instrument-related functionalities.
    """
    def __init__(self, parent, app_instance, console_print_func):
        super().__init__(parent)
        self.app_instance = app_instance
        self.console_print_func = console_print_func

        # Use the specific, color-coded style for this child notebook
        self.child_notebook = ttk.Notebook(self, style='Instruments.Child.TNotebook')
        self.child_notebook.pack(expand=True, fill="both", padx=5, pady=5)
        
        # Instantiate the tabs before adding them to the notebook
        # Pass a reference of this parent instance to the connection tab
        self.instrument_connection_tab = InstrumentTab(self.child_notebook, self.app_instance, self.console_print_func, parent_notebook_ref=self)
        
        # Instantiate the new SettingsParentTab
        self.settings_tab = SettingsParentTab(self.child_notebook, self.app_instance, self.console_print_func)
        
        self.visa_interpreter_tab = VisaInterpreterTab(self.child_notebook, self.app_instance, self.console_print_func)

        # RENAMED the tab text to "Connection"
        self.child_notebook.add(self.instrument_connection_tab, text="Connection")
        self.child_notebook.add(self.settings_tab, text="Settings")
        self.child_notebook.add(self.visa_interpreter_tab, text="VISA Interpreter")

        self.child_notebook.bind("<<NotebookTabChanged>>", self._on_child_tab_selected)

    def switch_to_settings_tab(self):
        # Function Description
        # Programmatically selects the 'Settings' child tab.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Programmatically switching to Settings tab.",
                  file=f"{os.path.basename(__file__)}",
                  version=current_version,
                  function=current_function)
        self.child_notebook.select(self.settings_tab)

    def _on_child_tab_selected(self, event):
        """Handles tab change events within this parent's child notebook."""
        selected_child_tab_id = self.child_notebook.select()
        if selected_child_tab_id:
            selected_child_tab_widget = self.child_notebook.nametowidget(selected_child_tab_id)
            if hasattr(selected_child_tab_widget, '_on_tab_selected'):
                selected_child_tab_widget._on_tab_selected(event)

    def _on_parent_tab_selected(self, event):
        # Function Description
        # Handles the event when this parent tab is selected. It now also switches the display
        # pane to the "Console" tab automatically.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Instrument Parent tab selected. Forcing display view to Console.",
                  file=f"{os.path.basename(__file__)}",
                  version=current_version,
                  function=current_function)

        # Switch the display parent to the Console tab
        if hasattr(self.app_instance, 'display_parent_tab'):
            self.app_instance.display_parent_tab.change_display_tab("Console")

        # Delegate to the currently active child tab to ensure it is properly refreshed.
        self._on_child_tab_selected(event)


#####################################
### File: OPEN-AIR\Instrument\connection\instrument_logic.py
#####################################

# Instrument/instrument_logic.py
#
# This file contains the core logic for managing the connection to and interaction
# with a VISA instrument, such as a spectrum analyzer. It provides high-level
# functions for connecting, disconnecting, and querying the device for its settings.
# This file serves as an abstraction layer between the GUI and the low-level
# VISA read/write utilities.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250818.203000.2 (UPDATED: Corrected IDN parsing logic in connect_instrument_logic to handle devices that return 2 values instead of 4, ensuring all available information is displayed and preventing errors.)

current_version = "20250818.203000.2"
current_version_hash = 20250818 * 203000 * 2

import inspect
import os
import time
import sys
import tkinter as tk
import pyvisa
import traceback

from display.debug_logic import debug_log
from display.console_logic import console_log

# Import low-level VISA utilities
from yak.Yakety_Yak import YakGet, YakSet, YakDo, query_safe, write_safe
from .utils_instrument_connection import connect_to_instrument, disconnect_instrument, list_visa_resources


def populate_resources_logic(app_instance, combobox_widget, console_print_func):
    # Function Description:
    # Populates the `visa_resource_var` Combobox with available VISA instrument addresses.
    # It first clears the existing list, then calls `list_visa_resources` to find
    # available devices, and finally populates the combobox with the results.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Populating VISA resources. Let's find those devices! Version: {current_version}",
                file=f"{os.path.basename(__file__)} - {current_version}",
                function=current_function)
    
    app_instance.visa_resource_var.set("")
    combobox_widget['values'] = []

    resources = list_visa_resources(console_print_func)
    if resources:
        combobox_widget['values'] = resources
        app_instance.visa_resource_var.set(resources[0])
        debug_log(f"Found VISA resources: {resources}. Success!",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)
    else:
        console_print_func("No VISA instruments found. Check connections.")
        debug_log("No VISA resources found. Time for some detective work. 🕵️‍♀️",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)

def connect_instrument_logic(app_instance, console_print_func):
    # Function Description:
    # Handles the full connection sequence to a VISA instrument.
    # It attempts to establish a connection, queries the instrument's IDN string,
    # and updates the application's state variables accordingly.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Attempting to connect to instrument. Let's make this happen! Version: {current_version}",
                file=f"{os.path.basename(__file__)} - {current_version}",
                function=current_function)
    
    selected_resource = app_instance.visa_resource_var.get()
    if not selected_resource:
        console_print_func("❌ No instrument selected. Cannot connect.")
        debug_log("No resource selected. This is a fine mess! 🤦‍♂️",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)
        return False
        
    try:
        # Step 1: Connect to the instrument
        app_instance.inst = connect_to_instrument(selected_resource, console_print_func)
        if not app_instance.inst:
            app_instance.is_connected.set(False)
            return False

        # Step 2: Query IDN using YakGet and populate model
        idn_response = YakGet(app_instance, "SYSTEM/ID", console_print_func)
        if idn_response and idn_response != "FAILED":
            idn_parts = idn_response.split(',')
            
            # UPDATED: Handle the full IDN string regardless of the number of parts
            manufacturer = "N/A"
            model = "GENERIC"
            serial_number = "N/A"
            version = "N/A"
            
            if len(idn_parts) >= 1:
                manufacturer = idn_parts[0].strip()
            if len(idn_parts) >= 2:
                model = idn_parts[1].strip()
            if len(idn_parts) >= 3:
                serial_number = idn_parts[2].strip()
            if len(idn_parts) >= 4:
                version = idn_parts[3].strip()

            app_instance.connected_instrument_manufacturer.set(manufacturer)
            app_instance.connected_instrument_model.set(model)
            app_instance.connected_instrument_serial.set(serial_number)
            app_instance.connected_instrument_version.set(version)
            console_print_func(f"✅ Device details found: {manufacturer}, {model}, {serial_number}, {version}")

        else:
            console_print_func("⚠️ Warning: Could not query instrument IDN. Proceeding with generic settings.")
            app_instance.connected_instrument_manufacturer.set("N/A")
            app_instance.connected_instrument_model.set("GENERIC")
            app_instance.connected_instrument_serial.set("N/A")
            app_instance.connected_instrument_version.set("N/A")
        
        app_instance.is_connected.set(True)
        debug_log("Connection successful! The instrument is alive! 🥳",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)
        return True
    
    except Exception as e:
        console_print_func(f"❌ Error during connection: {e}")
        debug_log(f"Connection failed spectacularly! Error: {e}. What a disaster! Traceback: {traceback.format_exc()}",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)
        disconnect_instrument_logic(app_instance, console_print_func)
        app_instance.is_connected.set(False)
        return False


def disconnect_instrument_logic(app_instance, console_print_func):
    # Function Description:
    # Disconnects the application from the currently connected VISA instrument.
    # It checks if an instrument instance exists and attempts to close the connection.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Attempting to disconnect instrument. Version: {current_version}",
                file=f"{os.path.basename(__file__)} - {current_version}",
                function=current_function)
    
    if not app_instance.inst:
        console_print_func("⚠️ Warning: No instrument connected. Nothing to disconnect.")
        debug_log("No instrument to disconnect. This is a mess.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)
        return True
    
    result = disconnect_instrument(app_instance.inst, console_print_func)
    app_instance.inst = None
    app_instance.is_connected.set(False)
    
    if result:
        debug_log("Successfully disconnected. Until we meet again! 👋",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)
    else:
        debug_log("Disconnecting failed. This is a catastrophe!",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)
        
    return result

def query_current_settings_logic(app_instance, console_print_func):
    # Function Description:
    # Queries the currently connected instrument for its essential settings,
    # including IDN string, Center Frequency, Span, RBW, Ref Level, Trace Mode,
    # and Preamp status. It then returns a dictionary containing all these values.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Querying current instrument settings. What's this thing up to? Version: {current_version}",
                file=f"{os.path.basename(__file__)} - {current_version}",
                function=current_function)

    if not app_instance.inst:
        console_print_func("⚠️ Warning: No instrument connected. Cannot query settings. Fix it!")
        debug_log("No instrument connected. Cannot query settings. Fucking useless!",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)
        return None
        
    settings = {}
    
    try:
        # Query the IDN string first
        settings['idn_string'] = YakGet(app_instance, "SYSTEM/ID", console_print_func)
        
        # Query Center Frequency
        center_freq_str = YakGet(app_instance, "FREQUENCY/CENTER", console_print_func)
        settings['center_freq_hz'] = float(center_freq_str) if center_freq_str and center_freq_str != 'FAILED' else "N/A"
        
        # Query Span
        span_str = YakGet(app_instance, "FREQUENCY/SPAN", console_print_func)
        settings['span_hz'] = float(span_str) if span_str and span_str != 'FAILED' else "N/A"
        
        # Query RBW
        rbw_str = YakGet(app_instance, "BANDWIDTH/RESOLUTION", console_print_func)
        settings['rbw_hz'] = float(rbw_str) if rbw_str and rbw_str != 'FAILED' else "N/A"

        # Query Ref Level
        ref_level_str = YakGet(app_instance, "AMPLITUDE/REFERENCE LEVEL", console_print_func)
        settings['ref_level_dbm'] = float(ref_level_str) if ref_level_str and ref_level_str != 'FAILED' else "N/A"
        
        # Query Trace Mode (Assuming we want Trace 2 for Max Hold)
        trace_mode_str = YakGet(app_instance, "TRACE/2/MODE", console_print_func)
        settings['trace_mode'] = trace_mode_str if trace_mode_str and trace_mode_str != 'FAILED' else "N/A"
        
        # Query Preamp Status (GAIN)
        preamp_on_str = YakGet(app_instance, "AMPLITUDE/POWER/GAIN", console_print_func)
        settings['preamp_on'] = (preamp_on_str == '1' or preamp_on_str == 'ON') if preamp_on_str and preamp_on_str != 'FAILED' else False

        debug_log("Finished querying instrument settings. A treasure trove of information! 🗺️",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)
        
        return settings
    
    except Exception as e:
        console_print_func(f"❌ Error querying settings: {e}")
        debug_log(f"Error querying instrument settings: {e}. What a disaster! Traceback: {traceback.format_exc()}",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)
        return None



#####################################
### File: OPEN-AIR\Instrument\connection\tab_instrument_child_connection.py
#####################################
# tabs/Instrument/tab_instrument_child_connection.py
#
# This file defines the InstrumentTab, a Tkinter Frame for handling instrument
# connection and disconnection.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250818.205500.2 (FIXED: Corrected the Tkinter variable name to prevent AttributeError.)

current_version = "20250818.205500.2"
current_version_hash = 20250818 * 205500 * 2

import tkinter as tk
from tkinter import ttk, messagebox
import inspect
import os
import threading
import time

# Import low-level VISA utilities
from .instrument_logic import connect_instrument_logic, disconnect_instrument_logic, populate_resources_logic
from yak.utils_yak_setting_handler import reset_device, do_power_cycle
from display.debug_logic import debug_log
from display.console_logic import console_log

class InstrumentTab(ttk.Frame):
    def __init__(self, master=None, app_instance=None, console_print_func=None, parent_notebook_ref=None, **kwargs):
        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func if console_print_func else console_log
        self.parent_notebook_ref = parent_notebook_ref

        # Tkinter StringVars for displaying instrument details
        self.manufacturer_var = tk.StringVar(value="N/A")
        self.model_var = tk.StringVar(value="N/A")
        self.serial_number_var = tk.StringVar(value="N/A")
        self.version_var = tk.StringVar(value="N/A")

        self._create_widgets()

    def _create_widgets(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering _create_widgets. Creating simplified widgets for the Connection Tab. 🛠️",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        self.grid_columnconfigure(0, weight=1)

        # Main frame
        main_frame = ttk.Frame(self, style='Dark.TFrame')
        main_frame.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
        main_frame.columnconfigure(0, weight=1)

        # Button to populate VISA resources
        self.populate_button = ttk.Button(main_frame, text="Populate list of available VISA Devices", command=self._populate_resources, style='Blue.TButton')
        self.populate_button.grid(row=0, column=0, padx=5, pady=5, sticky="ew")

        # Dropdown for VISA resources
        # FIXED: Changed variable name to app_instance.instrument_visa_resource_var
        self.resource_combobox = ttk.Combobox(main_frame, textvariable=self.app_instance.instrument_visa_resource_var, style='TCombobox', state='readonly')
        self.resource_combobox.grid(row=1, column=0, padx=5, pady=5, sticky="ew")

        # Connect/Disconnect button
        self.connect_button = ttk.Button(main_frame, text="Connect", command=self._toggle_connection, style='Green.TButton')
        self.connect_button.grid(row=2, column=0, padx=5, pady=5, sticky="ew")
        
        # NEW: Instrument Details Frame
        self.details_frame = ttk.LabelFrame(main_frame, text="Device Details", style='Dark.TLabelframe', padding=10)
        self.details_frame.grid(row=3, column=0, padx=5, pady=5, sticky="ew")
        self.details_frame.grid_columnconfigure(1, weight=1)
        self.details_frame.grid_remove() # Hide initially

        ttk.Label(self.details_frame, text="Manufacturer:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        ttk.Label(self.details_frame, textvariable=self.manufacturer_var, style='Dark.TLabel.Value').grid(row=0, column=1, sticky="ew", padx=5, pady=2)

        ttk.Label(self.details_frame, text="Model:").grid(row=1, column=0, sticky="w", padx=5, pady=2)
        ttk.Label(self.details_frame, textvariable=self.model_var, style='Dark.TLabel.Value').grid(row=1, column=1, sticky="ew", padx=5, pady=2)
        
        ttk.Label(self.details_frame, text="Serial Number:").grid(row=2, column=0, sticky="w", padx=5, pady=2)
        ttk.Label(self.details_frame, textvariable=self.serial_number_var, style='Dark.TLabel.Value').grid(row=2, column=1, sticky="ew", padx=5, pady=2)
        
        ttk.Label(self.details_frame, text="Firmware Version:").grid(row=3, column=0, sticky="w", padx=5, pady=2)
        ttk.Label(self.details_frame, textvariable=self.version_var, style='Dark.TLabel.Value').grid(row=3, column=1, sticky="ew", padx=5, pady=2)

        # NEW: Reset and Power Cycle Buttons Frame
        control_buttons_frame = ttk.Frame(main_frame, style='Dark.TFrame')
        control_buttons_frame.grid(row=4, column=0, padx=5, pady=5, sticky="ew")
        control_buttons_frame.grid_columnconfigure(0, weight=1)
        control_buttons_frame.grid_columnconfigure(1, weight=1)

        self.reset_button = ttk.Button(control_buttons_frame, text="Reset Instrument (*RST)", command=self._reset_instrument, style='Orange.TButton')
        self.reset_button.grid(row=0, column=0, padx=5, pady=5, sticky="ew")
        self.reset_button.config(state=tk.DISABLED) # Start disabled
        
        self.power_cycle_button = ttk.Button(control_buttons_frame, text="Power Cycle", command=self._power_cycle_instrument, style='Red.TButton')
        self.power_cycle_button.grid(row=0, column=1, padx=5, pady=5, sticky="ew")
        self.power_cycle_button.config(state=tk.DISABLED) # Start disabled

        self.app_instance.is_connected.trace_add('write', self._update_connection_status)
        
        debug_log(f"Simplified widgets for Connection Tab created. Ready to go! ",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)

    def _update_connection_status(self, *args):
        current_function = inspect.currentframe().f_code.co_name
        is_connected = self.app_instance.is_connected.get()
        debug_log(f"Updating connection status. Is it connected? {is_connected}. 🤔",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)

        if is_connected:
            self.connect_button.config(text="Disconnect", style='Red.TButton')
            self.populate_button.config(state=tk.DISABLED)
            self.resource_combobox.config(state='disabled')
            self.reset_button.config(state=tk.NORMAL)
            self.power_cycle_button.config(state=tk.NORMAL)
            self.details_frame.grid()
            
            # Populate the new labels
            self.manufacturer_var.set(self.app_instance.connected_instrument_manufacturer.get())
            self.model_var.set(self.app_instance.connected_instrument_model.get())
            self.serial_number_var.set(self.app_instance.connected_instrument_serial.get())
            self.version_var.set(self.app_instance.connected_instrument_version.get())

            # FIXED: Add a check to ensure the settings_tab exists before trying to switch to it.
            if self.parent_notebook_ref and hasattr(self.parent_notebook_ref, 'settings_tab'):
                self.parent_notebook_ref.switch_to_settings_tab()
                self.console_print_func("✅ Connection successful. Switched to Settings tab.")
        else:
            self.connect_button.config(text="Connect", style='Green.TButton')
            self.populate_button.config(state=tk.NORMAL)
            self.resource_combobox.config(state='readonly')
            self.reset_button.config(state=tk.DISABLED)
            self.power_cycle_button.config(state=tk.DISABLED)
            self.details_frame.grid_remove()
            self.console_print_func("❌ Disconnected from instrument.")

    def _toggle_connection(self):
        is_connected = self.app_instance.is_connected.get()
        if is_connected:
            self._disconnect_instrument()
        else:
            self._connect_instrument()

    def _populate_resources(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Populate resources button clicked. Finding devices! 🔎",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        populate_resources_logic(self.app_instance, self.resource_combobox, self.console_print_func)
    
    def _connect_instrument(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Connect button clicked. Starting connection thread. 🔗",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        connection_thread = threading.Thread(target=connect_instrument_logic, args=(self.app_instance, self.console_print_func))
        connection_thread.start()
        
    def _disconnect_instrument(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Disconnect button clicked. Starting disconnection thread. 🔌",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        disconnection_thread = threading.Thread(target=disconnect_instrument_logic, args=(self.app_instance, self.console_print_func))
        disconnection_thread.start()
    
    # NEW: Reset Button Functionality
    def _reset_instrument(self):
        # [A brief, one-sentence description of the function's purpose.]
        # Sends a soft reset command to the instrument in a separate thread.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Reset button clicked. Starting reset thread. ♻️",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        reset_thread = threading.Thread(target=reset_device, args=(self.app_instance, self.console_print_func))
        reset_thread.start()
    
    # NEW: Power Cycle Functionality
    def _power_cycle_instrument(self):
        # [A brief, one-sentence description of the function's purpose.]
        # Sends a power reset command to the instrument in a separate thread.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Power Cycle button clicked. Starting power cycle thread. 💥",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        power_cycle_thread = threading.Thread(target=do_power_cycle, args=(self.app_instance, self.console_print_func))
        power_cycle_thread.start()
        
    def _on_tab_selected(self, event=None):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Connection Tab selected. What are we doing now? 🤔",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        is_connected = self.app_instance.is_connected.get()
        if not is_connected:
            self._populate_resources()



#####################################
### File: OPEN-AIR\Instrument\connection\utils_instrument_connection.py
#####################################
# Instrument/utils_instrument_connection.py
#
# This module provides low-level functions specifically for managing VISA instrument
# connections: listing available resources, connecting to an instrument, and
# disconnecting from an instrument. It abstracts the direct PyVISA communication
# details related to connection management from higher-level application logic.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
# Version 20250802.1701.5 (Refactored from utils_instrument_control.py to handle connection logic.)

current_version = "20250802.1701.5" # this variable should always be defined below the header to make the debugging better
current_version_hash = 20250802 * 1701 * 5 # Example hash, adjust as needed

import pyvisa
import inspect # Import inspect module
import os # Import os module to fix NameError

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log

def list_visa_resources(console_print_func=None, *args, **kwargs):
    """
    Function Description:
    Lists available VISA resources (instruments).

    Inputs to this function:
    - console_print_func (function, optional): Function to print messages to the GUI console.
                                               Defaults to console_log if None.
    - *args: Catches any unexpected positional arguments.
    - **kwargs: Catches any unexpected keyword arguments.

    Process of this function:
    1. Initializes PyVISA ResourceManager.
    2. Logs any unexpected arguments received.
    3. Lists available resources.
    4. Logs the discovered resources or any errors.

    Outputs of this function:
    - list: A list of strings, where each string is a VISA resource name.
            Returns an empty list if no resources are found or an error occurs.
    """
    console_print_func = console_print_func if console_print_func else console_log # Use console_log as default
    current_function = inspect.currentframe().f_code.co_name
    debug_log("Listing VISA resources... Let's find some devices!",
                file=f"{os.path.basename(__file__)} - {current_version}",
                version=current_version,
                function=current_function)

    if args or kwargs:
        debug_log(f"WARNING: list_visa_resources received unexpected arguments! Args: {args}, Kwargs: {kwargs}. What the hell are these?!",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        console_print_func(f"⚠️ Warning: list_visa_resources received unexpected arguments! This might be the source of the problem. Check the call!")

    try:
        rm = pyvisa.ResourceManager()
        resources = rm.list_resources()
        debug_log(f"Found VISA resources: {resources}. Success!",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        return list(resources)
    except Exception as e:
        error_msg = f"❌ Error listing VISA resources: {e}. This is a disaster!"
        console_print_func(error_msg)
        debug_log(error_msg,
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        return []


def connect_to_instrument(resource_name, console_print_func=None):
    """
    Function Description:
    Establishes a connection to a VISA instrument.

    Inputs to this function:
    - resource_name (str): The VISA resource string (e.g., "GPIB0::1::INSTR").
    - console_print_func (function, optional): Function to print messages to the GUI console.
                                               Defaults to console_log if None.

    Process of this function:
    1. Initializes PyVISA ResourceManager.
    2. Opens the specified resource.
    3. Sets instrument timeout, read/write termination characters, and query delay.
    4. Logs connection status.

    Outputs of this function:
    - pyvisa.resources.Resource or None: The connected PyVISA instrument object if successful,
                                         None otherwise.
    """
    console_print_func = console_print_func if console_print_func else console_log # Use console_log as default
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Connecting to instrument: {resource_name}. Fingers crossed!",
                file=f"{os.path.basename(__file__)} - {current_version}",
                version=current_version,
                function=current_function)
    try:
        rm = pyvisa.ResourceManager()
        inst = rm.open_resource(resource_name)
        inst.timeout = 10000 # Set a timeout (milliseconds) - Increased for robustness
        inst.read_termination = '\n' # Set read termination character
        inst.write_termination = '\n' # Set write termination character
        inst.query_delay = 0.1 # Small delay between write and read for query
        console_print_func(f"✅ Successfully connected to {resource_name}. It's alive!")
        debug_log(f"Connection successful to {resource_name}. We're in!",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        return inst
    except pyvisa.errors.VisaIOError as e:
        error_msg = f"❌ VISA error connecting to {resource_name}: {e}. This is a nightmare!"
        console_print_func(error_msg)
        debug_log(error_msg,
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        return None
    except Exception as e:
        error_msg = f"❌ An unexpected error occurred while connecting to {resource_name}: {e}. What a mess!"
        console_print_func(error_msg)
        debug_log(error_msg,
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        return None


def disconnect_instrument(inst, console_print_func=None):
    """
    Function Description:
    Closes the connection to a VISA instrument.

    Inputs to this function:
    - inst (pyvisa.resources.Resource): The PyVISA instrument object to disconnect.
    - console_print_func (function, optional): Function to print messages to the GUI console.
                                               Defaults to console_log if None.

    Process of this function:
    1. Checks if the instrument object is valid.
    2. Attempts to close the instrument connection.
    3. Logs disconnection status.

    Outputs of this function:
    - bool: True if disconnection is successful, False otherwise.
    """
    console_print_func = console_print_func if console_print_func else console_log # Use console_log as default
    current_function = inspect.currentframe().f_code.co_name
    debug_log("Disconnecting instrument... Saying goodbye!",
                file=f"{os.path.basename(__file__)} - {current_version}",
                version=current_version,
                function=current_function)
    if inst:
        try:
            inst.close()
            console_print_func("✅ Instrument disconnected. See ya!")
            debug_log("Instrument connection closed. All done!",
                        file=f"{os.path.basename(__file__)} - {current_version}",
                        version=current_version,
                        function=current_function)
            return True
        except pyvisa.errors.VisaIOError as e:
            error_msg = f"❌ VISA error disconnecting instrument: {e}. This thing is stuck!"
            console_print_func(error_msg)
            debug_log(error_msg,
                        file=f"{os.path.basename(__file__)} - {current_version}",
                        version=current_version,
                        function=current_function)
            return False
        except Exception as e:
            error_msg = f"❌ An unexpected error occurred while disconnecting instrument: {e}. What a pain!"
            console_print_func(error_msg)
            debug_log(error_msg,
                        file=f"{os.path.basename(__file__)} - {current_version}",
                        version=current_version,
                        function=current_function)
            return False
    debug_log("No instrument to disconnect. Already gone!",
                file=f"{os.path.basename(__file__)} - {current_version}",
                version=current_version,
                function=current_function)
    return False

#####################################
### File: OPEN-AIR\Instrument\settings\tab_instrument_child_settings.py
#####################################
# tabs/Instrument/tab_instrument_child_settings.py
#
# This file defines the SettingsParentTab, which now serves as a container
# for all instrument-related child tabs, refactored from the original SettingsTab.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250815.105500.2
# FIXED: Reverted to a static tabbed layout only, as dynamic resizing was causing TclErrors.
# FIX: The red styling for the nested tabs was corrected to use the right color palette.
# ADDED: New method refresh_all_child_tabs to properly refresh all child tabs.

current_version = "20250815.105500.2"
current_version_hash = 20250815 * 105500 * 2

import tkinter as tk
from tkinter import ttk
import inspect
import os

from display.debug_logic import debug_log
from display.console_logic import console_log
from src.program_style import COLOR_PALETTE, COLOR_PALETTE_TABS

# Import the new child tabs
from .tab_instrument_child_settings_frequency import FrequencySettingsTab
from .tab_instrument_child_settings_amplitude import AmplitudeSettingsTab
from .tab_instrument_child_settings_bandwidth import BandwidthSettingsTab
from .tab_instrument_child_settings_markers import MarkerSettingsTab
from .tab_instrument_child_settings_traces import TraceSettingsTab

class SettingsParentTab(ttk.Frame):
    """
    A Tkinter Frame that serves as a container for all instrument settings child tabs.
    """
    def __init__(self, master=None, app_instance=None, console_print_func=None, **kwargs):
        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func if console_print_func else console_log

        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Initializing SettingsParentTab. Version: {current_version}. Setting up settings tabs! 📁",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)
        
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(0, weight=1)

        style = ttk.Style(self)
        active_color = COLOR_PALETTE_TABS['Instruments']['active']
        inactive_color = style.lookup('Instruments.Child.TNotebook.Tab', 'background', default='#2b2b2b')
        
        style.configure('Red.TNotebook', background=COLOR_PALETTE['background'])
        style.map('Red.TNotebook.Tab',
                  background=[('selected', active_color),
                              ('!selected', inactive_color)],
                  foreground=[('selected', COLOR_PALETTE_TABS['Instruments']['fg']),
                              ('!selected', 'white')])

        self.child_notebook = ttk.Notebook(self, style='Red.TNotebook')
        self.child_notebook.pack(expand=True, fill="both", padx=5, pady=5)

        self.frequency_tab = FrequencySettingsTab(self.child_notebook, self.app_instance, self.console_print_func)
        self.amplitude_tab = AmplitudeSettingsTab(self.child_notebook, self.app_instance, self.console_print_func)
        self.bandwidth_tab = BandwidthSettingsTab(self.child_notebook, self.app_instance, self.console_print_func)
        self.traces_tab = TraceSettingsTab(self.child_notebook, self.app_instance, self.console_print_func)
        self.markers_tab = MarkerSettingsTab(self.child_notebook, self.app_instance, self.console_print_func)

        self.child_notebook.add(self.frequency_tab, text="Frequency")
        self.child_notebook.add(self.amplitude_tab, text="Amplitude")
        self.child_notebook.add(self.bandwidth_tab, text="Bandwidth")
        self.child_notebook.add(self.traces_tab, text="Traces")
        self.child_notebook.add(self.markers_tab, text="Markers")

        debug_log(f"SettingsParentTab initialized with child tabs. The grand design is taking shape! 🏰",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

    def _on_tab_selected(self, event=None):
        """
        Handles when this parent tab is selected. It will delegate the call to the currently active child tab.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Settings Parent Tab selected. Delegating to child tab. ➡️",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)
        
        selected_child_tab_id = self.child_notebook.select()
        if selected_child_tab_id:
            selected_child_tab_widget = self.child_notebook.nametowidget(selected_child_tab_id)
            if hasattr(selected_child_tab_widget, '_on_tab_selected'):
                selected_child_tab_widget._on_tab_selected(event)
    
    def refresh_all_child_tabs(self):
        """
        A public method to trigger a refresh on all child tabs of this parent.
        This is the new central point for refreshing the entire settings UI.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"API call to refresh all child tabs in SettingsParentTab. Initiating cascade!",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)
        
        # Iterate through all child tab instances and call their dedicated refresh method
        for tab in [self.frequency_tab, self.amplitude_tab, self.bandwidth_tab, self.traces_tab, self.markers_tab]:
            if hasattr(tab, '_sync_ui_from_app_state'):
                tab._sync_ui_from_app_state()

#####################################
### File: OPEN-AIR\Instrument\settings\tab_instrument_child_settings_amplitude.py
#####################################
# # Instrument/tab_instrument_child_settings_amplitude.py
#
# This file defines the AmplitudeSettingsTab, a Tkinter Frame for controlling a spectrum
# analyzer's amplitude-related settings. The layout now mirrors the Frequency tab
# for a consistent user experience.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250816.123518.36
# UPDATED: Added a new handler to save instrument amplitude settings to the configuration file
#          after a successful update from the GUI or an instrument query.

current_version = "Version 20250816.123518.36"
current_version_hash = (20250816 * 123518 * 36)

import tkinter as tk
from tkinter import ttk
import inspect
import os

from display.debug_logic import debug_log
from display.console_logic import console_log
from yak import utils_yak_setting_handler
from ref.ref_scanner_setting_lists import PRESET_AMPLITUDE_REFERENCE_LEVEL, PRESET_AMPLITUDE_POWER_ATTENUATION, PRESET_AMPLITUDE_PREAMP_STATE, PRESET_AMPLITUDE_HIGH_SENSITIVITY_STATE
from yak.Yakety_Yak import YakGet

# ADDED: Imports for the configuration manager
from settings_and_config.config_manager_instruments import _save_instrument_settings
from settings_and_config.config_manager_save import save_program_config


class AmplitudeSettingsTab(ttk.Frame):
    """
    A Tkinter Frame that provides a user interface for amplitude settings.
    """
    def __init__(self, master=None, app_instance=None, console_print_func=None, **kwargs):
        """
        Initializes the AmplitudeSettingsTab.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Initializing AmplitudeSettingsTab. Setting up the GUI and its logic. 💻",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func if console_print_func else console_log
        
        self.is_ref_level_tracing = False
        self.is_attenuation_tracing = False

        self._create_widgets()
        self.preamp_state_var = self.app_instance.preamp_on_var
        self.high_sensitivity_state_var = self.app_instance.high_sensitivity_on_var
        self._set_ui_initial_state()
        
    def _create_widgets(self):
        """
        Creates and arranges the widgets for the Amplitude Settings tab.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering {current_function}. The mad scientist is preparing the amplitude controls! 🔊🧪",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        self.grid_columnconfigure(0, weight=1)
        
        # --- Top Buttons for Preamp and High Sensitivity ---
        top_buttons_frame = ttk.Frame(self)
        top_buttons_frame.grid(row=0, column=0, padx=10, pady=10, sticky="ew")
        top_buttons_frame.grid_columnconfigure(0, weight=1)
        top_buttons_frame.grid_columnconfigure(1, weight=1)
        
        self.preamp_toggle_button = ttk.Button(top_buttons_frame,
                                               text="PREAMP ON",
                                               command=lambda: utils_yak_setting_handler.toggle_preamp(tab_instance=self, app_instance=self.app_instance, console_print_func=self.console_print_func))
        self.preamp_toggle_button.grid(row=0, column=0, padx=5, pady=2, sticky="ew")

        self.hs_toggle_button = ttk.Button(top_buttons_frame,
                                           text="HIGH SENSITIVITY ON",
                                           command=lambda: utils_yak_setting_handler.toggle_high_sensitivity(tab_instance=self, app_instance=self.app_instance, console_print_func=self.console_print_func))
        self.hs_toggle_button.grid(row=0, column=1, padx=5, pady=2, sticky="ew")
        
        # --- Reference Level Controls (New layout) ---
        ref_level_frame = ttk.Frame(self)
        ref_level_frame.grid(row=1, column=0, padx=10, pady=5, sticky="ew")
        ref_level_frame.grid_columnconfigure(0, weight=1) # Allow this column to expand

        ref_level_title_frame = ttk.Frame(ref_level_frame)
        ref_level_title_frame.grid(row=0, column=0, sticky="ew")
        ref_level_title_frame.grid_columnconfigure(1, weight=1)
        
        ttk.Label(ref_level_title_frame, text="Reference Level (dBm):").grid(row=0, column=0, padx=5, sticky="w")
        self.ref_level_value_label = ttk.Label(ref_level_title_frame, textvariable=self.app_instance.ref_level_dbm_var, style='TLabel')
        self.ref_level_value_label.grid(row=0, column=1, padx=5, sticky="e")

        ref_values = [p["value"] for p in PRESET_AMPLITUDE_REFERENCE_LEVEL]
        ref_min = min(ref_values)
        ref_max = max(ref_values)
        self.ref_level_slider = ttk.Scale(ref_level_frame,
                                          orient="horizontal",
                                          variable=self.app_instance.ref_level_dbm_var,
                                          from_=ref_min,
                                          to=ref_max,
                                          command=self._update_ref_level_display,
                                          style='InteractionBars.TScale')
        self.ref_level_slider.grid(row=1, column=0, padx=5, pady=5, sticky="ew")
        self.ref_level_slider.bind("<ButtonRelease-1>", self._on_ref_level_change)
        
        self.ref_level_description_label = ttk.Label(ref_level_frame, text="", style='Description.TLabel', anchor="center")
        self.ref_level_description_label.grid(row=2, column=0, padx=5, pady=2, sticky="ew")
        
        # --- Spacer ---
        ttk.Frame(self, height=10).grid(row=2, column=0)

        # --- Power Attenuation Controls (New layout) ---
        power_att_frame = ttk.Frame(self)
        power_att_frame.grid(row=3, column=0, padx=10, pady=5, sticky="ew")
        power_att_frame.grid_columnconfigure(0, weight=1)

        power_att_title_frame = ttk.Frame(power_att_frame)
        power_att_title_frame.grid(row=0, column=0, sticky="ew")
        power_att_title_frame.grid_columnconfigure(1, weight=1)
        
        ttk.Label(power_att_title_frame, text="Power Attenuation (dB):").grid(row=0, column=0, padx=5, sticky="w")
        self.power_attenuation_value_label = ttk.Label(power_att_title_frame, textvariable=self.app_instance.power_attenuation_db_var, style='TLabel')
        self.power_attenuation_value_label.grid(row=0, column=1, padx=5, sticky="e")

        att_values = [p["value"] for p in PRESET_AMPLITUDE_POWER_ATTENUATION]
        att_min = min(att_values)
        att_max = max(att_values)
        self.power_attenuation_slider = ttk.Scale(power_att_frame,
                                                  orient="horizontal",
                                                  variable=self.app_instance.power_attenuation_db_var,
                                                  from_=att_min,
                                                  to=att_max,
                                                  command=self._update_power_attenuation_display,
                                                  style='InteractionBars.TScale')
        self.power_attenuation_slider.grid(row=1, column=0, padx=5, pady=5, sticky="ew")
        self.power_attenuation_slider.bind("<ButtonRelease-1>", self._on_power_attenuation_change)

        self.power_attenuation_description_label = ttk.Label(power_att_frame, text="", style='Description.TLabel', anchor="center")
        self.power_attenuation_description_label.grid(row=2, column=0, padx=5, pady=2, sticky="ew")
        
        debug_log(message=f"Widgets for Amplitude Settings Tab created. The amplitude controls are ready! 📉👍",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

    def _on_resize(self, event):
        """
        Adjusts the wraplength of the description labels when the window is resized.
        """
        new_width = event.width
        if new_width > 0:
            # Set the wraplength of the labels to match the full width of their containers
            self.ref_level_description_label.config(wraplength=new_width)
            self.power_attenuation_description_label.config(wraplength=new_width)

    def _set_ui_initial_state(self):
        """Sets the initial state of the UI elements."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering {current_function}. Initializing UI state. 🎨",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        self._update_toggle_button_style(button=self.preamp_toggle_button, state=self.preamp_state_var.get())
        self._update_toggle_button_style(button=self.hs_toggle_button, state=self.high_sensitivity_state_var.get())
        
        self.ref_level_slider.set(self.app_instance.ref_level_dbm_var.get())
        self.power_attenuation_slider.set(self.app_instance.power_attenuation_db_var.get())

        self._update_descriptions(value=self.app_instance.ref_level_dbm_var.get(), preset_list=PRESET_AMPLITUDE_REFERENCE_LEVEL, label=self.ref_level_description_label, var=self.app_instance.ref_level_dbm_var)
        self._update_descriptions(value=self.app_instance.power_attenuation_db_var.get(), preset_list=PRESET_AMPLITUDE_POWER_ATTENUATION, label=self.power_attenuation_description_label, var=self.app_instance.power_attenuation_db_var)

    def _update_ref_level_display(self, value):
        if self.is_ref_level_tracing:
            return
        self.is_ref_level_tracing = True
        
        rounded_value = self._find_closest_preset_value(float(value), PRESET_AMPLITUDE_REFERENCE_LEVEL)
        self.app_instance.ref_level_dbm_var.set(rounded_value)
        self._update_descriptions(value=rounded_value, preset_list=PRESET_AMPLITUDE_REFERENCE_LEVEL, label=self.ref_level_description_label, var=self.app_instance.ref_level_dbm_var)
        
        self.is_ref_level_tracing = False

    def _update_power_attenuation_display(self, value):
        if self.is_attenuation_tracing:
            return
        self.is_attenuation_tracing = True
        
        rounded_value = self._find_closest_preset_value(float(value), PRESET_AMPLITUDE_POWER_ATTENUATION)
        self.app_instance.power_attenuation_db_var.set(rounded_value)
        self._update_descriptions(value=rounded_value, preset_list=PRESET_AMPLITUDE_POWER_ATTENUATION, label=self.power_attenuation_description_label, var=self.app_instance.power_attenuation_db_var)
        
        self.is_attenuation_tracing = False

    def _on_ref_level_change(self, event):
        """Updates the reference level and pushes the setting on slider release."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering {current_function}. Slider released, pushing new value to instrument. 📤",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)
        
        # New Logic: Turn off High Sensitivity if it's on
        if self.app_instance.high_sensitivity_on_var.get():
            self.console_print_func("⚠️ High Sensitivity turned off to adjust Reference Level.")
            utils_yak_setting_handler.toggle_high_sensitivity(tab_instance=self, app_instance=self.app_instance, console_print_func=self.console_print_func)

        ref_level = int(self._find_closest_preset_value(self.app_instance.ref_level_dbm_var.get(), PRESET_AMPLITUDE_REFERENCE_LEVEL))
        if utils_yak_setting_handler.set_reference_level(tab_instance=self, app_instance=self.app_instance, value=ref_level, console_print_func=self.console_print_func):
            self._save_settings_handler()
        else:
            self.console_print_func("❌ Failed to set Reference Level on instrument.")

    def _on_power_attenuation_change(self, event):
        """Updates the power attenuation and pushes the setting on slider release."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering {current_function}. Slider released, pushing new value to instrument. 📤",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)
        
        # New Logic: Turn off High Sensitivity if it's on
        if self.app_instance.high_sensitivity_on_var.get():
            self.console_print_func("⚠️ High Sensitivity turned off to adjust Power Attenuation.")
            utils_yak_setting_handler.toggle_high_sensitivity(tab_instance=self, app_instance=self.app_instance, console_print_func=self.console_print_func)

        power_attenuation = int(self._find_closest_preset_value(self.app_instance.power_attenuation_db_var.get(), PRESET_AMPLITUDE_POWER_ATTENUATION))
        if utils_yak_setting_handler.set_power_attenuation(tab_instance=self, app_instance=self.app_instance, value=power_attenuation, console_print_func=self.console_print_func):
            self._save_settings_handler()
        else:
            self.console_print_func("❌ Failed to set Power Attenuation on instrument.")

    def _update_toggle_button_style(self, button, state):
        """Updates the style and text of a toggle button based on its state."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering {current_function}. Updating button style for state: {state} 🤔",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)
        
        # Determine the correct preset list to use based on the button instance
        preset_list = None
        if button == self.preamp_toggle_button:
            preset_list = PRESET_AMPLITUDE_PREAMP_STATE
        elif button == self.hs_toggle_button:
            preset_list = PRESET_AMPLITUDE_HIGH_SENSITIVITY_STATE
            
        if preset_list:
            if state:
                button.config(style='Orange.TButton', text=next((p['label'] for p in preset_list if p['value'] == 'ON'), "ON"))
            else:
                button.config(style='Dark.TButton', text=next((p['label'] for p in preset_list if p['value'] == 'OFF'), "OFF"))

        # After toggling, refresh all status on the page
        app_instance = self.app_instance
        YakGet(app_instance, "AMPLITUDE/REFERENCE LEVEL", self.console_print_func)
        YakGet(app_instance, "AMPLITUDE/POWER/ATTENUATION", self.console_print_func)
        YakGet(app_instance, "AMPLITUDE/POWER/GAIN", self.console_print_func)
        YakGet(app_instance, "AMPLITUDE/POWER/HIGH SENSITIVE", self.console_print_func)

    def _find_closest_preset_value(self, value, preset_list):
        """Finds the closest discrete preset value for a given float value."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering {current_function}. Finding closest preset for value: {value}",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        values = [p["value"] for p in preset_list]
        return min(values, key=lambda x: abs(x - value))

    def _update_descriptions(self, value, preset_list, label, var):
        """
        Updates a description label and the variable value based on the slider value
        by finding the closest preset and snapping to it.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering {current_function}. Seeking the closest preset for a value of {value}...",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)
        
        # Find the closest preset value first
        closest_value = self._find_closest_preset_value(value, preset_list)
        
        closest_preset = next((preset for preset in preset_list if preset["value"] == closest_value), None)

        if closest_preset:
            var.set(closest_preset["value"])
            label.config(text=closest_preset["description"])
            debug_log(message=f"Found a description! ' {closest_preset['description']} '",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)
        else:
            label.config(text="No matching description found.")
            debug_log(message=f"Arrr, no description to be found! Shiver me timbers! 🏴‍☠️",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)

    def _save_settings_handler(self):
        """Handles saving the instrument amplitude settings to the config file."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}. It's time to save the instrument amplitude configuration! 💾",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)
        
        try:
            # Call the specific save function from the modular config manager
            _save_instrument_settings(
                config=self.app_instance.program_config,
                app_instance=self.app_instance,
                console_print_func=self.console_print_func
            )
            # Call the main config save function to write the changes to the file
            save_program_config(
                app_instance=self.app_instance,
                config=self.app_instance.program_config,
                config_file_path=self.app_instance.config_file_path,
                console_print_func=self.console_print_func
            )
            debug_log("Instrument amplitude settings saved successfully. 🚀",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)
        except Exception as e:
            debug_log(f"❌ Error saving instrument amplitude settings: {e}",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)
            self.console_print_func(f"❌ Error saving instrument amplitude settings: {e}")

#####################################
### File: OPEN-AIR\Instrument\settings\tab_instrument_child_settings_bandwidth.py
#####################################
# tabs/Instrument/tab_instrument_child_settings_Bandwidth.py
#
# This file defines the BandwidthSettingsTab, a Tkinter Frame for controlling a spectrum
# analyzer's bandwidth and initiate settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.141100.1
# UPDATED: Added a new handler to save instrument bandwidth settings to the configuration file
#          after a successful update from the GUI or an instrument query.

current_version = "20250821.141100.1"
current_version_hash = 20250821 * 141100 * 1

import tkinter as tk
from tkinter import ttk
import inspect
import os
import re

from display.debug_logic import debug_log
from display.console_logic import console_log

# Import handler functions and preset lists
from yak import utils_yak_setting_handler
from ref.ref_scanner_setting_lists import (
    PRESET_BANDWIDTH_RBW,
    PRESET_BANDWIDTH_VIDEO,
    PRESET_CONTINUOUS_MODE,
    PRESET_AVERAGING
)
# FIXED: Corrected the import path for the NAB handler
from yak.utils_yaknab_handler import handle_bandwidth_settings_nab

# ADDED: Imports for the configuration manager
from settings_and_config.config_manager_instruments import _save_instrument_settings
from settings_and_config.config_manager_save import save_program_config


class BandwidthSettingsTab(ttk.Frame):
    """
    A Tkinter Frame that provides a user interface for bandwidth and initiate settings.
    """
    def __init__(self, master=None, app_instance=None, console_print_func=None, **kwargs):
        """
        Initializes the BandwidthSettingsTab.
        """
        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func if console_print_func else console_log

        # Local Tkinter variables for the UI. They will be linked to app_instance's variables
        # when they become available.
        self.rbw_hz_var = tk.DoubleVar(self, value=0.0)
        self.vbw_hz_var = tk.DoubleVar(self, value=0.0)
        self.vbw_auto_state_var = tk.BooleanVar(self, value=False)
        self.continuous_mode_var = tk.StringVar(self, value="OFF")

        # NEW: Variables for averaging controls (single trace only)
        self.average_on_var = tk.BooleanVar(self, value=False)
        self.average_count_var = tk.IntVar(self, value=0)
        
        # NEW: Variables to hold the parsed NAB response values
        self.parsed_rbw_var = tk.StringVar(self, value="N/A")
        self.parsed_vbw_var = tk.StringVar(self, value="N/A")
        self.parsed_vbw_auto_var = tk.StringVar(self, value="N/A")
        self.parsed_continuous_mode_var = tk.StringVar(self, value="N/A")
        self.parsed_averaging_status_var = tk.StringVar(self, value="N/A")
        self.parsed_averaging_count_var = tk.StringVar(self, value="N/A")
        
        # NEW: Response variable for the averaging controls
        self.averaging_result_var = tk.StringVar(self, value="Result: N/A")
        
        self.last_known_rbw_hz = 0.0
        self.last_known_vbw_hz = 0.0

        self._create_widgets()

    def _create_widgets(self):
        """
        Creates and arranges the widgets for the Bandwidth Settings tab.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering _create_widgets. Creating widgets for the Bandwidth Settings Tab. ⚙️",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        self.grid_columnconfigure(0, weight=1)
        self.grid_columnconfigure(1, weight=1)

        # --- Bandwidth Settings Frame ---
        bandwidth_frame = ttk.LabelFrame(self, text="Bandwidth Settings", style='Dark.TLabelframe')
        bandwidth_frame.grid(row=0, column=0, padx=10, pady=10, sticky="ew")
        bandwidth_frame.grid_columnconfigure(1, weight=1)

        ttk.Label(bandwidth_frame, text="Resolution BW (Hz):").grid(row=0, column=0, padx=5, pady=2, sticky="w")
        
        rbw_labels = [f"{p['label']} ({p['value']} Hz)" for p in PRESET_BANDWIDTH_RBW]
        self.rbw_combobox = ttk.Combobox(bandwidth_frame,
                                         textvariable=self.rbw_hz_var,
                                         values=rbw_labels,
                                         state='readonly')
        self.rbw_combobox.grid(row=0, column=1, padx=5, pady=2, sticky="ew")
        self.rbw_combobox.bind("<<ComboboxSelected>>", self._on_rbw_selected)
        
        # --- VBW Controls (Rebuilt as Combobox and Auto button) ---
        ttk.Label(bandwidth_frame, text="Video BW (Hz):").grid(row=1, column=0, padx=5, pady=2, sticky="w")
        
        vbw_values = [p["value"] for p in PRESET_BANDWIDTH_VIDEO]
        vbw_labels = [f"{p['label']} ({p['value']} Hz)" for p in PRESET_BANDWIDTH_VIDEO]
        self.vbw_combobox = ttk.Combobox(bandwidth_frame,
                                         textvariable=self.vbw_hz_var,
                                         values=vbw_labels,
                                         state='readonly')
        self.vbw_combobox.grid(row=1, column=1, padx=5, pady=2, sticky="ew")
        self.vbw_combobox.bind("<<ComboboxSelected>>", self._on_vbw_selected)

        ttk.Label(bandwidth_frame, text="VBW Auto:").grid(row=2, column=0, padx=5, pady=2, sticky="w")
        self.vbw_auto_toggle_button = ttk.Button(bandwidth_frame,
                                                 text="",
                                                 command=self._on_vbw_auto_toggle)
        self.vbw_auto_toggle_button.grid(row=2, column=1, padx=5, pady=2, sticky="ew")
        
        # --- Initiate Settings Frame ---
        initiate_frame = ttk.LabelFrame(self, text="Initiate Settings", style='Dark.TLabelframe')
        initiate_frame.grid(row=1, column=0, padx=10, pady=10, sticky="ew")
        initiate_frame.grid_columnconfigure(1, weight=1)
        
        ttk.Label(initiate_frame, text="Continuous Mode:").grid(row=0, column=0, padx=5, pady=2, sticky="w")
        initiate_modes = [p['value'] for p in PRESET_CONTINUOUS_MODE]
        self.initiate_continuous_dropdown = ttk.Combobox(initiate_frame,
                                                         textvariable=self.continuous_mode_var,
                                                         values=initiate_modes,
                                                         state='readonly')
        self.initiate_continuous_dropdown.grid(row=0, column=1, padx=5, pady=2, sticky="ew")
        self.initiate_continuous_dropdown.bind("<<ComboboxSelected>>", self._on_continuous_mode_change)
        
        self.initiate_immediate_button = ttk.Button(initiate_frame,
                                                     text="Initiate Immediate",
                                                     command=lambda: utils_yak_setting_handler.do_immediate_initiate(self.app_instance, self.console_print_func))
        self.initiate_immediate_button.grid(row=1, column=0, columnspan=2, padx=5, pady=5, sticky="ew")
        
        # NEW: Averaging Frame (Updated layout for Trace 1 only)
        averaging_frame = ttk.LabelFrame(self, text="Averaging", style='Dark.TLabelframe')
        averaging_frame.grid(row=2, column=0, padx=10, pady=10, sticky="ew")
        averaging_frame.grid_columnconfigure((1, 3), weight=1)

        # Row 0: Averaging Toggle and Count
        ttk.Label(averaging_frame, text="Trace 1 Averaging:").grid(row=0, column=0, padx=5, pady=2, sticky="w")
        self.average_on_button = ttk.Button(averaging_frame, text="OFF", command=lambda: self._on_averaging_toggle(1, not self.average_on_var.get()), style='Red.TButton')
        self.average_on_button.grid(row=0, column=1, padx=5, pady=2, sticky="ew")
        
        ttk.Label(averaging_frame, text="Count:").grid(row=0, column=2, padx=5, pady=2, sticky="w")
        avg_labels = [f"{p['value']} - {p['label']}" for p in PRESET_AVERAGING]
        self.average_count_dropdown = ttk.Combobox(averaging_frame, textvariable=self.average_count_var, values=avg_labels, state='readonly')
        self.average_count_dropdown.grid(row=0, column=3, padx=5, pady=2, sticky="ew")
        self.average_count_dropdown.bind("<<ComboboxSelected>>", lambda event: self._on_averaging_count_selected(event, 1))

        # NEW: Result label for averaging actions
        ttk.Label(averaging_frame, textvariable=self.averaging_result_var, style="Dark.TLabel.Value").grid(row=1, column=0, columnspan=4, padx=5, pady=2, sticky="ew")


        # Frame for NAB raw response display
        parsed_nab_response_frame = ttk.LabelFrame(self, text="Parsed NAB Response", style='Dark.TLabelframe')
        parsed_nab_response_frame.grid(row=3, column=0, padx=10, pady=10, sticky="ew")
        parsed_nab_response_frame.grid_columnconfigure(1, weight=1)

        ttk.Label(parsed_nab_response_frame, text="RBW (Hz):", style='TLabel').grid(row=0, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(parsed_nab_response_frame, textvariable=self.parsed_rbw_var, style='Dark.TLabel.Value').grid(row=0, column=1, padx=5, pady=2, sticky="ew")

        ttk.Label(parsed_nab_response_frame, text="VBW (Hz):", style='TLabel').grid(row=1, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(parsed_nab_response_frame, textvariable=self.parsed_vbw_var, style='Dark.TLabel.Value').grid(row=1, column=1, padx=5, pady=2, sticky="ew")

        ttk.Label(parsed_nab_response_frame, text="VBW Auto:", style='TLabel').grid(row=2, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(parsed_nab_response_frame, textvariable=self.parsed_vbw_auto_var, style='Dark.TLabel.Value').grid(row=2, column=1, padx=5, pady=2, sticky="ew")

        ttk.Label(parsed_nab_response_frame, text="Continuous:", style='TLabel').grid(row=3, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(parsed_nab_response_frame, textvariable=self.parsed_continuous_mode_var, style='Dark.TLabel.Value').grid(row=3, column=1, padx=5, pady=2, sticky="ew")
        
        # NEW: Add a sweep time display field
        ttk.Label(parsed_nab_response_frame, text="Sweep Time (s):", style='TLabel').grid(row=4, column=0, padx=5, pady=2, sticky="w")
        self.parsed_sweep_time_var = tk.StringVar(self, value="N/A")
        ttk.Label(parsed_nab_response_frame, textvariable=self.parsed_sweep_time_var, style='Dark.TLabel.Value').grid(row=4, column=1, padx=5, pady=2, sticky="ew")


        debug_log(f"Widgets for Bandwidth Settings Tab created. Bandwidth controls are ready! 🛠️",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

    def _on_averaging_toggle(self, trace_number, state):
        """
        Handler for when an averaging toggle button is clicked.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Averaging toggle for trace {trace_number} clicked. State: {state}",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)
        
        if utils_yak_setting_handler.toggle_trace_averaging(app_instance=self.app_instance, trace_number=trace_number, is_on=state, console_print_func=self.console_print_func):
            self.averaging_result_var.set(f"Result: Trace {trace_number} averaging set to {'ON' if state else 'OFF'}.")
            self._sync_ui_from_app_state()
        else:
            self.averaging_result_var.set("Result: FAILED")
            self._sync_ui_from_app_state()


    def _on_averaging_count_selected(self, event, trace_number):
        current_function = inspect.currentframe().f_code.co_name
        selected_text = event.widget.get()
        match = re.search(r'(\d+)', selected_text)
        
        if 'Off' in selected_text:
            count = 0
            state = False
        elif match:
            count = int(match.group(1))
            state = True
        else:
            self.console_print_func(f"❌ Could not parse averaging count from '{selected_text}'.")
            self.averaging_result_var.set("Result: FAILED to parse count")
            return
            
        debug_log(f"Averaging count for trace {trace_number} selected: {count}, state: {state}", file=os.path.basename(__file__), version=current_version, function=current_function)
        
        if utils_yak_setting_handler.set_trace_averaging_count(app_instance=self.app_instance, trace_number=trace_number, count=count, console_print_func=self.console_print_func) and \
           utils_yak_setting_handler.toggle_trace_averaging(app_instance=self.app_instance, trace_number=trace_number, is_on=state, console_print_func=self.console_print_func):
            self.averaging_result_var.set(f"Result: Trace {trace_number} averaging set to {count} sweeps.")
            self._sync_ui_from_app_state()
        else:
            self.averaging_result_var.set("Result: FAILED")
            self._sync_ui_from_app_state()

    def _on_tab_selected(self, event=None):
        """
        Called when this tab is selected. Syncs the UI with the application's state.
        """
        if self.app_instance.is_connected.get():
            self._sync_ui_from_app_state()
        else:
            self.console_print_func("❌ No instrument connected. Skipping UI refresh.")


    def _sync_ui_from_app_state(self):
        """
        Sets the UI element values from the application's variables.
        This function now calls the NAB handler to get the current state from the instrument.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}. Syncing UI from app state. 🎨",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)
                  
        if not self.app_instance.is_connected.get():
            debug_log(f"Not connected, skipping NAB query and falling back to app instance variables.",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)
            # Fall back to app_instance variables if not connected
            if hasattr(self.app_instance, 'rbw_mhz_var'):
                self.rbw_hz_var.set(self.app_instance.rbw_mhz_var.get() * 1_000_000)
            if hasattr(self.app_instance, 'vbw_mhz_var'):
                self.vbw_hz_var.set(self.app_instance.vbw_mhz_var.get() * 1_000_000)
            if hasattr(self.app_instance, 'vbw_auto_on_var'):
                self.vbw_auto_state_var.set(self.app_instance.vbw_auto_on_var.get())
            if hasattr(self.app_instance, 'initiate_continuous_on_var'):
                self.continuous_mode_var.set("ON" if self.app_instance.initiate_continuous_on_var.get() else "OFF")
            
            self._update_rbw_combobox_display()
            self._update_vbw_combobox_display()
            self._update_toggle_button_style(self.vbw_auto_toggle_button, self.vbw_auto_state_var.get())
            
            if self.vbw_auto_state_var.get():
                self.vbw_combobox.config(state='disabled')
            else:
                self.vbw_combobox.config(state='readonly')
            return

        # Call the NAB handler to get all settings in one go.
        settings = handle_bandwidth_settings_nab(self.app_instance, self.console_print_func)

        # Update the parsed response display variables
        if settings:
            self.parsed_rbw_var.set(f"{settings['RBW_Hz']:.0f} Hz")
            self.parsed_vbw_var.set(f"{settings['VBW_Hz']:.0f} Hz")
            self.parsed_vbw_auto_var.set("ON" if settings["VBW_Auto_On"] else "OFF")
            self.parsed_continuous_mode_var.set("ON" if settings["Continuous_Mode_On"] else "OFF")
            
            # NEW: Set the sweep time variable
            self.parsed_sweep_time_var.set(f"{settings['Sweep_Time_s']:.3f} s")


            # Update local Tkinter variables and button states from the NAB response
            self.rbw_hz_var.set(settings["RBW_Hz"])
            self.vbw_hz_var.set(settings["VBW_Hz"])
            self.vbw_auto_state_var.set(settings["VBW_Auto_On"])
            self.continuous_mode_var.set("ON" if settings["Continuous_Mode_On"] else "OFF")
            
            # Update the combobox displays
            self._update_rbw_combobox_display()
            self._update_vbw_combobox_display()

            # Update the toggle button styles
            self._update_toggle_button_style(self.vbw_auto_toggle_button, settings["VBW_Auto_On"])

            # Disable VBW combobox if VBW auto is on
            if self.vbw_auto_state_var.get():
                self.vbw_combobox.config(state='disabled')
            else:
                self.vbw_combobox.config(state='readonly')
        else:
            debug_log("NAB query failed. Falling back to app instance variables.",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)
            # If the NAB call failed, fall back to app_instance variables
            self.rbw_hz_var.set(self.app_instance.rbw_mhz_var.get() * 1_000_000)
            self.vbw_hz_var.set(self.app_instance.vbw_mhz_var.get() * 1_000_000)
            self.vbw_auto_state_var.set(self.app_instance.vbw_auto_on_var.get())
            self.continuous_mode_var.set("ON" if self.app_instance.initiate_continuous_on_var.get() else "OFF")

            self._update_rbw_combobox_display()
            self._update_vbw_combobox_display()
            self._update_toggle_button_style(self.vbw_auto_toggle_button, self.vbw_auto_state_var.get())
            if self.vbw_auto_state_var.get():
                self.vbw_combobox.config(state='disabled')
            else:
                self.vbw_combobox.config(state='readonly')


    def _update_toggle_button_style(self, button, state):
        """Updates the style and text of a toggle button based on its state."""
        if state:
            button.config(text="ON", style='Green.TButton')
        else:
            button.config(text="OFF", style='Red.TButton')

    def _update_rbw_combobox_display(self):
        """Updates the RBW combobox to show the current value."""
        current_rbw_hz = int(self.rbw_hz_var.get())
        found_label = "Custom"
        for preset in PRESET_BANDWIDTH_RBW:
            if preset["value"] == current_rbw_hz:
                found_label = f"{preset['label']} ({preset['value']} Hz)"
                break
        self.rbw_combobox.set(found_label)

    def _update_vbw_combobox_display(self):
        """Updates the VBW combobox to show the current value."""
        current_vbw_hz = int(self.vbw_hz_var.get())
        found_label = "Custom"
        for preset in PRESET_BANDWIDTH_VIDEO:
            if preset["value"] == current_vbw_hz:
                found_label = f"{preset['label']} ({preset['value']} Hz)"
                break
        self.vbw_combobox.set(found_label)

    def _on_rbw_selected(self, event):
        """Handler for when an RBW preset is selected."""
        selected_text = self.rbw_combobox.get()
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"RBW preset selected: {selected_text}",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)
        
        try:
            # Use regex to extract the number and the unit
            match = re.search(r'\((\d+)\s*Hz\)', selected_text)
            if match:
                rbw_value = int(match.group(1))
            else:
                raise ValueError("Could not parse numeric value from combobox string.")
        except (ValueError, IndexError):
            console_log("❌ Error parsing RBW value from combobox. Using default.",
                        function=current_function)
            rbw_value = 1_000_000
        
        if utils_yak_setting_handler.set_resolution_bandwidth(
            app_instance=self.app_instance,
            value=rbw_value,
            console_print_func=self.console_print_func
        ):
            # No longer setting individual variables here, we call the NAB handler instead
            self._sync_ui_from_app_state()
            self._save_settings_handler()
        else:
            # If the set failed, resync from the instrument to show the real value.
            self._sync_ui_from_app_state()

    def _on_vbw_selected(self, event):
        """Handler for when a VBW preset is selected."""
        selected_text = self.vbw_combobox.get()
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"VBW preset selected: {selected_text}",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        try:
            # Use regex to extract the number and the unit
            match = re.search(r'\((\d+)\s*Hz\)', selected_text)
            if match:
                vbw_value = int(match.group(1))
            else:
                raise ValueError("Could not parse numeric value from combobox string.")
        except (ValueError, IndexError):
            console_log("❌ Error parsing VBW value from combobox. Using default.",
                        function=current_function)
            vbw_value = 30000

        if utils_yak_setting_handler.set_video_bandwidth(
            app_instance=self.app_instance,
            value=vbw_value,
            console_print_func=self.console_print_func
        ):
            # No longer setting individual variables here, we call the NAB handler instead
            self._sync_ui_from_app_state()
            self._save_settings_handler()
        else:
            # If the set failed, resync from the instrument to show the real value.
            self._sync_ui_from_app_state()


    def _on_vbw_auto_toggle(self):
        """Handler for the VBW Auto toggle button."""
        current_function = inspect.currentframe().f_code.co_name
        is_on = not self.vbw_auto_state_var.get()
        debug_log(f"VBW Auto toggle clicked. Setting to {is_on}",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        if utils_yak_setting_handler.toggle_vbw_auto(
            app_instance=self.app_instance,
            console_print_func=self.console_print_func
        ):
            # No longer setting individual variables here, we call the NAB handler instead
            self._sync_ui_from_app_state()
            self._save_settings_handler()
        else:
            # If the toggle failed, resync from the instrument to show the real value.
            self._sync_ui_from_app_state()

    def _on_continuous_mode_change(self, event):
        """Handler for when the continuous mode dropdown is changed."""
        current_function = inspect.currentframe().f_code.co_name
        is_on = self.continuous_mode_var.get() == "ON"
        debug_log(f"Continuous mode changed to {is_on}",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        if utils_yak_setting_handler.set_continuous_initiate_mode(
            app_instance=self.app_instance,
            mode=is_on,
            console_print_func=self.console_print_func
        ):
            # No longer setting individual variables here, we call the NAB handler instead
            self._sync_ui_from_app_state()
            self._save_settings_handler()
        else:
            # If the set failed, resync from the instrument to show the real value.
            self._sync_ui_from_app_state()

    def _save_settings_handler(self):
        """Handles saving the instrument bandwidth settings to the config file."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"⚙️ 💾 Entering {current_function}. Time to save the instrument bandwidth settings! 🚀",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)
        
        try:
            # Call the specific save function from the modular config manager
            _save_instrument_settings(
                config=self.app_instance.program_config,
                app_instance=self.app_instance,
                console_print_func=self.console_print_func
            )
            # Call the main config save function to write the changes to the file
            save_program_config(
                app_instance=self.app_instance,
                config=self.app_instance.program_config,
                config_file_path=self.app_instance.config_file_path,
                console_print_func=self.console_print_func
            )
            debug_log("⚙️ ✅ Instrument bandwidth settings saved successfully. Mission accomplished!",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)
        except Exception as e:
            debug_log(f"❌ Error saving instrument bandwidth settings: {e}",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)
            self.console_print_func(f"❌ Error saving instrument bandwidth settings: {e}")

#####################################
### File: OPEN-AIR\Instrument\settings\tab_instrument_child_settings_frequency.py
#####################################
# tabs/Instrument/tab_instrument_child_settings_frequency.py
#
# This file defines the FrequencySettingsTab, a Tkinter Frame for controlling a spectrum
# analyzer's frequency settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.222800.1
# FIXED: The _save_settings_handler was corrected to import and use the CONFIG_FILE_PATH
#        from config_manager.py, resolving the AttributeError.

current_version = "20250821.222800.1"
current_version_hash = 20250821 * 222800 * 1

import tkinter as tk
from tkinter import ttk
import inspect
import os
import numpy as np

from display.debug_logic import debug_log
from display.console_logic import console_log
from yak.utils_yakbeg_handler import handle_freq_start_stop_beg, handle_freq_center_span_beg
from ref.ref_scanner_setting_lists import PRESET_FREQUENCY_SPAN_MHZ
from settings_and_config.config_manager_instruments import _save_instrument_settings
from settings_and_config.config_manager_save import load_program_config, save_program_config
from ref.ref_file_paths import CONFIG_FILE_PATH # ADDED IMPORT
from ref.ref_program_default_values import DEFAULT_CONFIG


class FrequencySettingsTab(ttk.Frame):
    """
    A Tkinter Frame that provides a user interface for frequency settings.
    """
    def __init__(self, master=None, app_instance=None, console_print_func=None, style_obj=None):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Initializing FrequencySettingsTab. This should be a walk in the park! 🚶‍♀️",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        self.app_instance = app_instance
        self.console_print_func = console_print_func
        self.is_tracing = False
        self.span_buttons = {}

        super().__init__(master)
        self.pack(fill="both", expand=True)
        self._set_default_variables()
        self._create_widgets()

    def _set_default_variables(self):
        """Initializes Tkinter variables for the widgets."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Setting default variables for FrequencySettingsTab. ⚙️",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        # Tkinter variables for frequency settings, now in MHz
        self.freq_start_var = tk.DoubleVar(value=100.0)
        self.freq_stop_var = tk.DoubleVar(value=200.0)
        self.freq_center_var = tk.DoubleVar(value=150.0)
        self.freq_span_var = tk.DoubleVar(value=100.0)

        # New shared variable for the common result display
        self.freq_common_result_var = tk.StringVar(value="Result: N/A")

        # NEW: Add traces to round the variable values
        self.freq_start_var.trace_add('write', self._round_variables)
        self.freq_stop_var.trace_add('write', self._round_variables)
        self.freq_center_var.trace_add('write', self._round_variables)
        self.freq_span_var.trace_add('write', self._round_variables)
        # New trace for span button styling
        self.freq_span_var.trace_add('write', self._on_span_variable_change)


    def _round_variables(self, *args):
        """
        Callback to round the values of the DoubleVar to 3 decimal places.
        It also truncates values with more than 6 decimal places.
        """
        if self.is_tracing:
            return
        self.is_tracing = True

        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Rounding variables to 3 decimal places. A meticulous process, for sure! 🔬",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        try:
            current_start = self.freq_start_var.get()
            current_stop = self.freq_stop_var.get()
            current_center = self.freq_center_var.get()
            current_span = self.freq_span_var.get()

            # Helper function to truncate float at 6 decimal places
            def truncate_float(f):
                s = f"{f:.7f}" # Get a string representation with enough precision
                if '.' in s:
                    parts = s.split('.')
                    if len(parts[1]) > 6:
                        return float(f"{parts[0]}.{parts[1][:6]}")
                return f

            self.freq_start_var.set(round(truncate_float(current_start), 3))
            self.freq_stop_var.set(round(truncate_float(current_stop), 3))
            self.freq_center_var.set(round(truncate_float(current_center), 3))
            self.freq_span_var.set(round(truncate_float(current_span), 3))

        except Exception as e:
            console_log(message=f"❌ Error while rounding variables: {e}")
            debug_log(message=f"Rounding failed! The numbers be acting up! The error be: {e}",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)
        finally:
            self.is_tracing = False

    def _create_widgets(self):
        """Creates the GUI widgets for the tab."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Creating widgets for FrequencySettingsTab. The puzzle pieces are coming together! 🧩",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(0, weight=0)
        self.grid_rowconfigure(1, weight=0)
        self.grid_rowconfigure(2, weight=0)

        # --- FREQUENCY/START-STOP Frame ---
        freq_ss_frame = ttk.Frame(self, padding=10)
        freq_ss_frame.grid(row=0, column=0, padx=10, pady=5, sticky="ew")
        freq_ss_frame.grid_columnconfigure(0, weight=1)

        # Container for Start and Stop frames
        main_start_stop_frame = ttk.Frame(freq_ss_frame)
        main_start_stop_frame.grid(row=0, column=0, sticky="ew")
        main_start_stop_frame.grid_columnconfigure(0, weight=1)
        main_start_stop_frame.grid_columnconfigure(1, weight=1)

        # Start Frequency Frame
        start_frame = ttk.Frame(main_start_stop_frame, padding=5)
        start_frame.grid(row=0, column=0, padx=5, pady=5, sticky="ew")
        start_frame.grid_columnconfigure(0, weight=1)
        # UPDATED: Added Label for "START"
        ttk.Label(start_frame, text="Start:").grid(row=0, column=0, sticky="ew", padx=5, pady=2)
        start_entry = ttk.Entry(start_frame, textvariable=self.freq_start_var)
        start_entry.grid(row=1, column=0, sticky="ew")
        start_entry.bind("<Return>", lambda e: self._on_freq_start_stop_beg())
        start_entry.bind("<FocusOut>", lambda e: self._on_freq_start_stop_beg())
        start_scale = ttk.Scale(start_frame, from_=100, to=1000, orient=tk.HORIZONTAL, variable=self.freq_start_var, style='InteractionBars.TScale')
        start_scale.grid(row=2, column=0, sticky="ew")
        start_scale.bind("<ButtonRelease-1>", lambda e: self._on_freq_start_stop_beg())

        # Stop Frequency Frame
        stop_frame = ttk.Frame(main_start_stop_frame, padding=5)
        stop_frame.grid(row=0, column=1, padx=5, pady=5, sticky="ew")
        stop_frame.grid_columnconfigure(0, weight=1)
        # UPDATED: Added Label for "STOP"
        ttk.Label(stop_frame, text="Stop:").grid(row=0, column=0, sticky="ew", padx=5, pady=2)
        stop_entry = ttk.Entry(stop_frame, textvariable=self.freq_stop_var)
        stop_entry.grid(row=1, column=0, sticky="ew")
        stop_entry.bind("<Return>", lambda e: self._on_freq_start_stop_beg())
        stop_entry.bind("<FocusOut>", lambda e: self._on_freq_start_stop_beg())
        stop_scale = ttk.Scale(stop_frame, from_=100, to=1000, orient=tk.HORIZONTAL, variable=self.freq_stop_var, style='InteractionBars.TScale')
        stop_scale.grid(row=2, column=0, sticky="ew")
        stop_scale.bind("<ButtonRelease-1>", lambda e: self._on_freq_start_stop_beg())

        # --- FREQUENCY/CENTER-SPAN Frame ---
        freq_cs_frame = ttk.Frame(self, padding=10)
        freq_cs_frame.grid(row=1, column=0, padx=10, pady=5, sticky="ew")
        freq_cs_frame.grid_columnconfigure(0, weight=1)
        freq_cs_frame.grid_columnconfigure(1, weight=1)

        # Center Frequency Slider & Entry
        ttk.Label(freq_cs_frame, text="Center Frequency:", justify=tk.RIGHT).grid(row=0, column=0, padx=5, pady=2, sticky="e")
        center_scale = ttk.Scale(freq_cs_frame, from_=100, to=1000, orient=tk.HORIZONTAL, variable=self.freq_center_var, style='InteractionBars.TScale')
        center_scale.grid(row=1, column=0, columnspan=2, padx=5, pady=2, sticky="ew")
        center_scale.bind("<ButtonRelease-1>", lambda e: self._on_freq_center_span_beg())
        center_entry = ttk.Entry(freq_cs_frame, textvariable=self.freq_center_var)
        center_entry.grid(row=0, column=1, padx=5, pady=2, sticky="ew")
        center_entry.bind("<Return>", lambda e: self._on_freq_center_span_beg())
        center_entry.bind("<FocusOut>", lambda e: self._on_freq_center_span_beg())


        # Span Slider & Entry
        ttk.Label(freq_cs_frame, text="Span:", justify=tk.RIGHT).grid(row=2, column=0, padx=5, pady=2, sticky="e")
        span_scale = ttk.Scale(freq_cs_frame, from_=0, to=500, orient=tk.HORIZONTAL, variable=self.freq_span_var, style='InteractionBars.TScale')
        span_scale.grid(row=3, column=0, columnspan=2, padx=5, pady=2, sticky="ew")
        span_scale.bind("<ButtonRelease-1>", lambda e: self._on_freq_center_span_beg())
        span_entry = ttk.Entry(freq_cs_frame, textvariable=self.freq_span_var)
        span_entry.grid(row=2, column=1, padx=5, pady=2, sticky="ew")
        span_entry.bind("<Return>", lambda e: self._on_freq_center_span_beg())
        span_entry.bind("<FocusOut>", lambda e: self._on_freq_center_span_beg())


        # Span Preset Buttons Frame
        span_buttons_frame = ttk.Frame(freq_cs_frame, padding=5)
        span_buttons_frame.grid(row=4, column=0, columnspan=2, padx=5, pady=5, sticky="ew")
        self._create_span_preset_buttons(parent_frame=span_buttons_frame)


        # --- NEW COMMON RESULT FRAME ---
        common_result_frame = ttk.Frame(self, padding=10)
        common_result_frame.grid(row=2, column=0, padx=10, pady=5, sticky="ew")
        common_result_frame.grid_columnconfigure(0, weight=1)
        ttk.Label(common_result_frame,
                  textvariable=self.freq_common_result_var,
                  justify=tk.LEFT
                  ).grid(row=0, column=0, padx=5, pady=2, sticky="ew")


    def _create_span_preset_buttons(self, parent_frame):
        # Creates buttons for predefined frequency spans and links them to the span variable.
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__)
        debug_log(message=f"Entering {current_function} with argument: parent_frame: {parent_frame}",
                  file=current_file,
                  version=current_version,
                  function=current_function)

        try:
            for i, (label, preset) in enumerate(PRESET_FREQUENCY_SPAN_MHZ.items()):
                # Use a format string with two decimal places for better display and rely on grid for sizing.
                button_text = f"{label}\n{preset['span_mhz']:.2f} MHz"
                button = ttk.Button(parent_frame,
                                    text=button_text,
                                    command=lambda p=preset: self._on_span_preset_button_click(preset=p))
                button.grid(row=0, column=i, sticky="ew", padx=2, pady=5)
                self.span_buttons[label] = button

            parent_frame.grid_rowconfigure(0, weight=1)
            for i in range(len(PRESET_FREQUENCY_SPAN_MHZ)):
                parent_frame.grid_columnconfigure(i, weight=1)

            console_log(message="✅ Span preset buttons created successfully.", function=current_function)
        except Exception as e:
            console_log(message=f"❌ Error in {current_function}: {e}")
            debug_log(message=f"Arrr, the code be capsized! The error be: {e}",
                      file=current_file,
                      version=current_version,
                      function=current_function)


    def _on_span_preset_button_click(self, preset):
        # Handles the click event for a span preset button.
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__)
        debug_log(message=f"Entering {current_function} with argument: preset: {preset}",
                  file=current_file,
                  version=current_version,
                  function=current_function)
        try:
            self.is_tracing = True
            self.freq_span_var.set(preset['span_mhz'])
            self.freq_center_var.set(preset['center_mhz']) # Also set center frequency
            self.is_tracing = False
            self._update_span_button_styles()
            self._on_freq_center_span_beg() # Trigger YakBeg after button click
            console_log(message=f"✅ Span set to {preset['span_mhz']} MHz).", function=current_function)
        except Exception as e:
            console_log(message=f"❌ Error in {current_function}: {e}")
            debug_log(message=f"Arrr, the code be capsized! The error be: {e}",
                      file=current_file,
                      version=current_version,
                      function=current_function)

    def _on_span_variable_change(self, *args):
        # A callback function for the span variable's trace.
        # It updates button styles when the variable changes.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering {current_function} with no arguments.",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        if not self.is_tracing:
            self._update_span_button_styles()
            console_log(message="✅ Span variable changed, button styles updated.", function=current_function)

    def _update_span_button_styles(self):
        # A brief, one-sentence description of the function's purpose.
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__)
        debug_log(message=f"Entering {current_function} with no arguments.",
                  file=current_file,
                  version=current_version,
                  function=current_function)
        try:
            current_span_mhz = self.freq_span_var.get()
            for label, preset in PRESET_FREQUENCY_SPAN_MHZ.items():
                button = self.span_buttons.get(label)
                if button:
                    if np.isclose(current_span_mhz, preset['span_mhz']):
                        button.configure(style='Orange.TButton')
                    else:
                        button.configure(style='Blue.TButton')
            console_log(message="✅ Span button styles updated.", function=current_function)
        except Exception as e:
            console_log(message=f"❌ Error in {current_function}: {e}")
            debug_log(message=f"Arrr, the code be capsized! The error be: {e}",
                      file=current_file,
                      version=current_version,
                      function=current_function)


    def _on_freq_start_stop_beg(self):
        """
        Handles the YakBeg for FREQUENCY/START-STOP.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering function: {current_function}. Arrr, a treasure map for frequencies! 🗺️",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        try:
            start_freq_mhz = self.freq_start_var.get()
            stop_freq_mhz = self.freq_stop_var.get()
            
            # UPDATED: Validation logic for Start/Stop frequencies
            if start_freq_mhz >= stop_freq_mhz:
                new_stop_mhz = start_freq_mhz + 10.0
                console_log(message=f"⚠️ Start frequency ({start_freq_mhz:.3f} MHz) is greater than or equal to stop frequency ({stop_freq_mhz:.3f} MHz). Automatically setting stop to {new_stop_mhz:.3f} MHz.")
                debug_log(message=f"The start frequency ({start_freq_mhz} MHz) is greater than or equal to the stop frequency ({stop_freq_mhz} MHz). The captain has corrected the course! 📈",
                          file=os.path.basename(__file__),
                          version=current_version,
                          function=current_function)
                self.freq_stop_var.set(value=new_stop_mhz)
                # Re-read the adjusted value for the YakBeg command
                stop_freq_mhz = self.freq_stop_var.get()
            elif stop_freq_mhz < start_freq_mhz:
                new_start_mhz = stop_freq_mhz - 10.0
                console_log(message=f"⚠️ Stop frequency ({stop_freq_mhz:.3f} MHz) is less than start frequency ({start_freq_mhz:.3f} MHz). Automatically setting start to {new_start_mhz:.3f} MHz.")
                debug_log(message=f"The stop frequency ({stop_freq_mhz} MHz) is less than the start frequency ({start_freq_mhz} MHz). The captain has corrected the course! 📉",
                          file=os.path.basename(__file__),
                          version=current_version,
                          function=current_function)
                self.freq_start_var.set(value=new_start_mhz)
                # Re-read the adjusted value for the YakBeg command
                start_freq_mhz = self.freq_start_var.get()


            # Get values in MHz and convert to Hz, ensuring no decimal points
            start_freq_hz = int(start_freq_mhz * 1e6)
            stop_freq_hz = int(stop_freq_mhz * 1e6)

            # Expect 4 values to be returned from the handler
            start_resp_hz, stop_resp_hz, span_resp_hz, center_resp_hz = handle_freq_start_stop_beg(
                app_instance=self.app_instance,
                start_freq=start_freq_hz,
                stop_freq=stop_freq_hz,
                console_print_func=self.console_print_func
            )

            if start_resp_hz is not None and stop_resp_hz is not None:
                # Convert response back to MHz for display
                start_resp_mhz = start_resp_hz / 1e6
                stop_resp_mhz = stop_resp_hz / 1e6
                span_resp_mhz = span_resp_hz / 1e6
                center_resp_mhz = center_resp_hz / 1e6
                
                # Update all variables
                self.freq_start_var.set(value=start_resp_mhz)
                self.freq_stop_var.set(value=stop_resp_mhz)
                self.freq_center_var.set(value=center_resp_mhz)
                self.freq_span_var.set(value=span_resp_mhz)
                
                # UPDATED: Format the result string to match the requested layout
                result_message = (
                    f"Center: {center_resp_mhz:.3f} MHz\n"
                    f"Span: {span_resp_mhz:.3f} MHz\n\n\n"
                    f"Start: {start_resp_mhz:.3f} MHz\n"
                    f"Stop: {stop_resp_mhz:.3f} MHz"
                )
                self.freq_common_result_var.set(value=result_message)
                self._save_settings_handler()
            else:
                self.freq_common_result_var.set(value="Result: FAILED")

        except Exception as e:
            console_log(message=f"❌ Error in {current_function}: {e}")
            debug_log(message=f"Arrr, the code be capsized! The error be: {e}",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)

    def _on_freq_center_span_beg(self):
        """
        Handles the YakBeg for FREQUENCY/CENTER-SPAN.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering function: {current_function}. Plotting a course to the center! 🧭",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        try:
            # Get values in MHz and convert to Hz, ensuring no decimal points
            center_freq_mhz = self.freq_center_var.get()
            span_freq_mhz = self.freq_span_var.get()

            center_freq_hz = int(center_freq_mhz * 1e6)
            span_freq_hz = int(span_freq_mhz * 1e6)

            # Expect 4 values to be returned from the handler
            center_resp_hz, span_resp_hz, start_resp_hz, stop_resp_hz = handle_freq_center_span_beg(
                app_instance=self.app_instance,
                center_freq=center_freq_hz,
                span_freq=span_freq_hz,
                console_print_func=self.console_print_func
            )

            if center_resp_hz is not None and span_resp_hz is not None:
                # Convert response back to MHz for display
                center_resp_mhz = center_resp_hz / 1e6
                span_resp_mhz = span_resp_hz / 1e6
                start_resp_mhz = start_resp_hz / 1e6
                stop_resp_mhz = stop_resp_hz / 1e6
                
                # Update all variables
                self.freq_center_var.set(value=center_resp_mhz)
                self.freq_span_var.set(value=span_resp_mhz)
                self.freq_start_var.set(value=start_resp_mhz)
                self.freq_stop_var.set(value=stop_resp_mhz)
                
                # UPDATED: Format the result string to match the requested layout
                result_message = (
                    f"Center: {center_resp_mhz:.3f} MHz\n"
                    f"Span: {span_resp_mhz:.3f} MHz\n\n\n"
                    f"Start: {start_resp_mhz:.3f} MHz\n"
                    f"Stop: {stop_resp_mhz:.3f} MHz"
                )
                self.freq_common_result_var.set(value=result_message)
                self._save_settings_handler()
            else:
                self.freq_common_result_var.set(value="Result: FAILED")

        except Exception as e:
            console_log(message=f"❌ Error in {current_function}: {e}")
            debug_log(message=f"Arrr, the code be capsized! The error be: {e}",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)

    def _save_settings_handler(self):
        """
        Handles saving the instrument frequency settings to the config file.
        This handler now directly loads and saves the configuration to resolve
        the AttributeError.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"⚙️ 💾 Entering {current_function}. Time to save the instrument frequency configuration! 🚀",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)
        
        try:
            # Load the configuration file
            config = load_program_config(config_file_path=CONFIG_FILE_PATH, default_config=DEFAULT_CONFIG)

            # Call the specific save function from the modular config manager
            _save_instrument_settings(
                config=config,
                app_instance=self.app_instance,
                console_print_func=self.console_print_func
            )
            # Call the main config save function to write the changes to the file
            save_program_config(
                app_instance=self.app_instance,
                config=config,
                config_file_path=CONFIG_FILE_PATH,
                console_print_func=self.console_print_func
            )
            debug_log("⚙️ ✅ Instrument frequency settings saved successfully. Mission accomplished!",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)
        except Exception as e:
            debug_log(f"❌ Error saving instrument frequency settings: {e}",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)
            self.console_print_func(f"❌ Error saving instrument frequency settings: {e}")

#####################################
### File: OPEN-AIR\Instrument\settings\tab_instrument_child_settings_markers.py
#####################################
# tabs/Instrument/tab_instrument_child_settings_markers.py
#
# This file defines the MarkerSettingsTab, a Tkinter Frame for controlling a spectrum
# analyzer's marker settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.141300.1
# UPDATED: Added a new handler to save marker settings to the configuration file
#          after a successful update from the GUI.

current_version = "20250821.141300.1"
current_version_hash = 20250821 * 141300 * 1

import tkinter as tk
from tkinter import ttk
import inspect
import os

from display.debug_logic import debug_log
from display.console_logic import console_log
from yak.utils_yakbeg_handler import handle_marker_place_all_beg

# ADDED: Imports for the configuration manager
from settings_and_config.config_manager_marker import _save_marker_tab_settings
from settings_and_config.config_manager_save import save_program_config


class MarkerSettingsTab(ttk.Frame):
    """
    A Tkinter Frame that provides a user interface for marker settings.
    """
    def __init__(self, master=None, app_instance=None, console_print_func=None):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Initializing MarkerSettingsTab. This should be a walk in the park! 🚶‍♀️",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        self.app_instance = app_instance
        self.console_print_func = console_print_func

        super().__init__(master)
        self.pack(fill="both", expand=True)
        self._set_default_variables()
        self._create_widgets()

    def _set_default_variables(self):
        """Initializes Tkinter variables for the widgets."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Setting default variables for MarkerSettingsTab. ⚙️",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        self.read_markers_all_data = tk.StringVar(self, value="N/A")
        # Set default values to match the experiment tab
        default_freqs = [111.0, 222.0, 333.0, 444.0, 555.0, 666.0]
        self.marker_freq_vars = [tk.DoubleVar(self, value=f) for f in default_freqs]
        
    def _create_widgets(self):
        """Creates the GUI widgets for the tab."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Creating widgets for MarkerSettingsTab. The puzzle pieces are coming together! 🧩",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)
        
        # Main container frame with padding
        main_container = ttk.Frame(self, padding="10")
        main_container.pack(fill="both", expand=True)
        main_container.grid_columnconfigure(0, weight=1)
        
        # --- Marker Input Frame (top row) ---
        marker_input_frame = ttk.Frame(main_container)
        marker_input_frame.grid(row=0, column=0, pady=(0, 5), sticky="ew")
        for i in range(6):
            marker_input_frame.grid_columnconfigure(i, weight=1)
            ttk.Label(marker_input_frame, text=f"M{i+1} Freq (MHz):").grid(row=0, column=i, padx=2, pady=2)
            ttk.Entry(marker_input_frame, textvariable=self.marker_freq_vars[i], width=8).grid(row=1, column=i, padx=2, pady=2)

        # --- Action Button ---
        ttk.Button(main_container, text="YakBeg - MARKER/PLACE/ALL", command=self._on_marker_place_all_beg, style='Blue.TButton').grid(row=1, column=0, pady=5, sticky="ew")

        # --- Results Table ---
        results_frame = ttk.Frame(main_container)
        results_frame.grid(row=2, column=0, pady=(5, 0), sticky="nsew")
        results_frame.grid_columnconfigure(0, weight=1)
        results_frame.grid_rowconfigure(0, weight=1)
        
        self.marker_result_table = ttk.Treeview(results_frame, columns=('Marker', 'Frequency', 'Amplitude'), show='headings', height=6)
        self.marker_result_table.heading('Marker', text='Marker')
        self.marker_result_table.heading('Frequency', text='Frequency (MHz)')
        self.marker_result_table.heading('Amplitude', text='Amplitude (dBm)')
        
        self.marker_result_table.column('Marker', width=80, stretch=tk.YES, anchor='center')
        self.marker_result_table.column('Frequency', width=120, stretch=tk.YES, anchor='center')
        self.marker_result_table.column('Amplitude', width=120, stretch=tk.YES, anchor='center')
        
        self.marker_result_table.grid(row=0, column=0, sticky="nsew")

        vsb = ttk.Scrollbar(results_frame, orient="vertical", command=self.marker_result_table.yview)
        vsb.grid(row=0, column=1, sticky="ns")
        self.marker_result_table.configure(yscrollcommand=vsb.set)
        
        debug_log(f"Widgets for Marker Settings Tab created. The controls are ready to go! 🗺️",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

    def _on_marker_place_all_beg(self):
        """
        Handles the YakBeg - MARKER/PLACE/ALL command.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering function: {current_function}. Arrr, let's get these markers placed! 🧭",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        try:
            marker_freqs = [v.get() for v in self.marker_freq_vars]
            
            result_string = handle_marker_place_all_beg(
                app_instance=self.app_instance, 
                marker_freqs_mhz=marker_freqs,
                console_print_func=self.console_print_func
            )
            
            self.marker_result_table.delete(*self.marker_result_table.get_children())

            if result_string and result_string != "FAILED":
                y_values = result_string.split(';')

                if len(y_values) == 6:
                    for i in range(6):
                        marker_label = f"M{i+1}"
                        input_freq_mhz = self.marker_freq_vars[i].get()
                        
                        try:
                            amplitude_dbm = float(y_values[i])
                            self.marker_result_table.insert('', 'end', values=(marker_label, f"{input_freq_mhz:.3f}", f"{amplitude_dbm:.2f}"))
                        except (ValueError, IndexError):
                            self.console_print_func(f"❌ Error parsing result for {marker_label}.")
                            self.marker_result_table.insert('', 'end', values=(marker_label, f"{input_freq_mhz:.3f}", 'FAILED'))
                    self.console_print_func("✅ Marker operation successful. Results displayed in table.")
                    self._save_settings_handler()
                else:
                    self.console_print_func(f"❌ Invalid response format. Expected 6 values, got {len(y_values)}.")
                    debug_log(f"Invalid response format from instrument. Expected 6 values, got {len(y_values)}. What a pain!",
                        file=os.path.basename(__file__),
                        version=current_version,
                        function=current_function)
                    self.marker_result_table.insert('', 'end', values=('M1-6', 'FAILED', 'FAILED'))
            else:
                self.console_print_func("❌ Marker operation failed.")
                self.marker_result_table.insert('', 'end', values=('M1-6', 'FAILED', 'FAILED'))
                
        except Exception as e:
            self.console_print_func(f"❌ Error in {current_function}: {e}")
            debug_log(f"Arrr, the code be capsized! The error be: {e}",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)

    def _save_settings_handler(self):
        """Handles saving the instrument marker settings to the config file."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"⚙️ 💾 Entering {current_function}. Time to save the instrument marker settings! 📍",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        try:
            # Call the specific save function from the modular config manager
            _save_marker_tab_settings(
                config=self.app_instance.program_config,
                showtime_tab=self,
                console_print_func=self.console_print_func
            )
            # Call the main config save function to write the changes to the file
            save_program_config(
                app_instance=self.app_instance,
                config=self.app_instance.program_config,
                config_file_path=self.app_instance.config_file_path,
                console_print_func=self.console_print_func
            )
            debug_log("⚙️ ✅ Instrument marker settings saved successfully. Mission accomplished!",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)
        except Exception as e:
            debug_log(f"❌ Error saving instrument marker settings: {e}",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)
            self.console_print_func(f"❌ Error saving instrument marker settings: {e}")

#####################################
### File: OPEN-AIR\Instrument\settings\tab_instrument_child_settings_traces.py
#####################################
# tabs/Instrument/tab_instrument_child_settings_traces.py
#
# This file defines the TraceSettingsTab, a Tkinter Frame for controlling a spectrum
# analyzer's trace settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.141200.1
# UPDATED: Added a new handler to save instrument trace settings to the configuration file
#          after a successful update from the GUI or an instrument query.

current_version = "20250821.141200.1"
current_version_hash = 20250821 * 141200 * 1

import tkinter as tk
from tkinter import ttk, scrolledtext
import inspect
import os
import pandas as pd # Import pandas for data manipulation

from display.debug_logic import debug_log
from display.console_logic import console_log
from yak.utils_yakbeg_handler import handle_trace_modes_beg, handle_trace_data_beg
from yak.utils_yaknab_handler import handle_all_traces_nab

from display.utils_display_monitor import update_top_plot, update_middle_plot, update_bottom_plot, clear_monitor_plots
from display.utils_scan_view import update_single_plot

# ADDED: Imports for the configuration manager
from settings_and_config.config_manager_instruments import _save_instrument_settings
from settings_and_config.config_manager_save import save_program_config

class TraceSettingsTab(ttk.Frame):
    """
    A Tkinter Frame that provides a user interface for trace settings.
    """
    def __init__(self, master=None, app_instance=None, console_print_func=None, **kwargs):
        """
        Initializes the TraceSettingsTab.
        """
        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func if console_print_func else console_log
        self.trace_modes = ["VIEW", "WRITE", "BLANK", "MAXHOLD", "MINHOLD"]

        # UPDATED: Set default values for the trace mode variables
        self.trace1_mode_var = tk.StringVar(value="WRITE")
        self.trace2_mode_var = tk.StringVar(value="MAXHOLD")
        self.trace3_mode_var = tk.StringVar(value="MINHOLD")
        self.trace4_mode_var = tk.StringVar(value="BLANK")

        self.trace_vars = [
            self.trace1_mode_var,
            self.trace2_mode_var,
            self.trace3_mode_var,
            self.trace4_mode_var
        ]

        # Tkinter variables for trace data
        self.trace_data_start_freq_var = tk.DoubleVar(value=500)
        self.trace_data_stop_freq_var = tk.DoubleVar(value=1000)
        self.trace_select_var = tk.StringVar(value="1")
        self.trace_data_count_var = tk.StringVar(value="0")

        self.trace_modes_result_var = tk.StringVar(value="Result: N/A")

        # Variables to store the last successful NAB response data for plotting
        self.last_nab_trace_data = None
        self.last_nab_start_freq = None
        self.last_nab_stop_freq = None
        self.last_nab_trace_modes = None
        
        # NEW: StringVars for displaying the modes and frequencies from the NAB handler response
        self.all_traces_start_freq_display_var = tk.StringVar(value="N/A")
        self.all_traces_stop_freq_display_var = tk.StringVar(value="N/A")
        self.all_traces_trace1_mode_display_var = tk.StringVar(value="N/A")
        self.all_traces_trace2_mode_display_var = tk.StringVar(value="N/A")
        self.all_traces_trace3_mode_display_var = tk.StringVar(value="N/A")
        self.all_traces_count_var = tk.StringVar(value="0")

        self._create_widgets()

    def _create_widgets(self):
        """
        Creates and arranges the widgets for the Trace Settings tab.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering _create_widgets. Creating widgets for the Trace Settings Tab. 📈",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)
        
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(2, weight=1)

        # --- TRACE/MODES Frame (from YakBegTab) ---
        trace_modes_frame = ttk.LabelFrame(self, text="YakBeg - TRACE/MODES", padding=10)
        trace_modes_frame.grid(row=0, column=0, padx=10, pady=5, sticky="ew")
        trace_modes_frame.grid_columnconfigure(0, weight=1)
        trace_modes_frame.grid_columnconfigure(1, weight=1)
        trace_modes_frame.grid_columnconfigure(2, weight=1)
        trace_modes_frame.grid_columnconfigure(3, weight=1)

        ttk.Label(trace_modes_frame, text="Trace 1 Mode:").grid(row=0, column=0, padx=5, pady=2, sticky="w")
        self.trace1_combo = ttk.Combobox(trace_modes_frame, textvariable=self.trace_vars[0], values=self.trace_modes, state="readonly")
        self.trace1_combo.grid(row=1, column=0, padx=5, pady=2, sticky="ew")
        ttk.Label(trace_modes_frame, text="Trace 2 Mode:").grid(row=0, column=1, padx=5, pady=2, sticky="w")
        self.trace2_combo = ttk.Combobox(trace_modes_frame, textvariable=self.trace_vars[1], values=self.trace_modes, state="readonly")
        self.trace2_combo.grid(row=1, column=1, padx=5, pady=2, sticky="ew")
        ttk.Label(trace_modes_frame, text="Trace 3 Mode:").grid(row=0, column=2, padx=5, pady=2, sticky="w")
        self.trace3_combo = ttk.Combobox(trace_modes_frame, textvariable=self.trace_vars[2], values=self.trace_modes, state="readonly")
        self.trace3_combo.grid(row=1, column=2, padx=5, pady=2, sticky="ew")
        ttk.Label(trace_modes_frame, text="Trace 4 Mode:").grid(row=0, column=3, padx=5, pady=2, sticky="w")
        self.trace4_combo = ttk.Combobox(trace_modes_frame, textvariable=self.trace_vars[3], values=self.trace_modes, state="readonly")
        self.trace4_combo.grid(row=1, column=3, padx=5, pady=2, sticky="ew")
        
        self.trace_modes_result_var = tk.StringVar(value="Result: N/A")
        ttk.Label(trace_modes_frame, textvariable=self.trace_modes_result_var, style="Dark.TLabel.Value").grid(row=2, column=0, columnspan=4, padx=5, pady=2, sticky="ew")
        
        ttk.Button(trace_modes_frame, text="YakBeg - TRACE/MODES", command=lambda: self._on_trace_modes_beg()).grid(row=3, column=0, columnspan=4, padx=5, pady=5, sticky="ew")


        # --- TRACE/DATA Frame (from YakBegTab) ---
        trace_data_frame = ttk.LabelFrame(self, text="YakBeg - TRACE/DATA", padding=10)
        trace_data_frame.grid(row=1, column=0, padx=10, pady=5, sticky="nsew")
        trace_data_frame.grid_columnconfigure(0, weight=1)
        trace_data_frame.grid_rowconfigure(2, weight=1)
        
        trace_data_controls_frame = ttk.Frame(trace_data_frame)
        trace_data_controls_frame.grid(row=0, column=0, sticky="ew")
        trace_data_controls_frame.grid_columnconfigure(0, weight=1)
        trace_data_controls_frame.grid_columnconfigure(1, weight=1)
        trace_data_controls_frame.grid_columnconfigure(2, weight=1)

        ttk.Label(trace_data_controls_frame, text="Trace #:", style="TLabel").grid(row=0, column=0, padx=5, pady=2, sticky="w")
        self.trace_select_combo = ttk.Combobox(trace_data_controls_frame, textvariable=self.trace_select_var, values=["1", "2", "3", "4"], state="readonly")
        self.trace_select_combo.grid(row=0, column=1, padx=5, pady=2, sticky="ew")
        self.trace_select_combo.set("1")

        ttk.Label(trace_data_controls_frame, text="# of points:", style="TLabel").grid(row=0, column=2, padx=5, pady=2, sticky="w")
        ttk.Label(trace_data_controls_frame, textvariable=self.trace_data_count_var, style="Dark.TLabel.Value").grid(row=0, column=3, padx=5, pady=2, sticky="ew")

        ttk.Label(trace_data_controls_frame, text="Start Freq (MHz):", style="TLabel").grid(row=1, column=0, padx=5, pady=2, sticky="w")
        ttk.Entry(trace_data_controls_frame, textvariable=self.trace_data_start_freq_var).grid(row=1, column=1, padx=5, pady=2, sticky="ew")

        ttk.Label(trace_data_controls_frame, text="Stop Freq (MHz):", style="TLabel").grid(row=1, column=2, padx=5, pady=2, sticky="w")
        ttk.Entry(trace_data_controls_frame, textvariable=self.trace_data_stop_freq_var).grid(row=1, column=3, padx=5, pady=2, sticky="ew")
        
        ttk.Button(trace_data_controls_frame, text="YakBeg - TRACE/DATA", command=lambda: self._on_trace_data_beg()).grid(row=2, column=0, columnspan=4, padx=5, pady=5, sticky="ew")

        # Table to display trace data
        columns = ("Frequency (MHz)", "Value (dBm)")
        self.trace_data_tree = ttk.Treeview(trace_data_frame, columns=columns, show="headings", style='Treeview')
        self.trace_data_tree.heading("Frequency (MHz)", text="Frequency (MHz)", anchor=tk.W)
        self.trace_data_tree.heading("Value (dBm)", text="Value (dBm)", anchor=tk.W)
        self.trace_data_tree.grid(row=1, column=0, sticky="nsew", padx=5, pady=5)
        
        vsb = ttk.Scrollbar(trace_data_frame, orient="vertical", command=self.trace_data_tree.yview)
        vsb.grid(row=1, column=1, sticky="ns")
        self.trace_data_tree.configure(yscrollcommand=vsb.set)
        
        # New button to push data to monitor
        ttk.Button(self, text="Push Trace Data to Monitor", command=lambda: self._on_push_to_monitor(), style="Green.TButton").grid(row=2, column=0, padx=10, pady=5, sticky="ew")

        # NEW: Frame for NAB All Traces functionality
        all_traces_nab_frame = ttk.LabelFrame(self, text="YakNab - TRACE/ALL/ONETWOTHREE", padding=10)
        all_traces_nab_frame.grid(row=3, column=0, padx=10, pady=5, sticky="nsew")
        all_traces_nab_frame.grid_columnconfigure(0, weight=1)
        all_traces_nab_frame.grid_columnconfigure(1, weight=1)

        ttk.Label(all_traces_nab_frame, text="Start Freq (MHz):", style="TLabel").grid(row=0, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(all_traces_nab_frame, textvariable=self.all_traces_start_freq_display_var, style="Dark.TLabel.Value").grid(row=0, column=1, padx=5, pady=2, sticky="ew")
        
        ttk.Label(all_traces_nab_frame, text="Stop Freq (MHz):", style="TLabel").grid(row=1, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(all_traces_nab_frame, textvariable=self.all_traces_stop_freq_display_var, style="Dark.TLabel.Value").grid(row=1, column=1, padx=5, pady=2, sticky="ew")
        
        ttk.Label(all_traces_nab_frame, text="Trace 1 Mode:", style="TLabel").grid(row=2, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(all_traces_nab_frame, textvariable=self.all_traces_trace1_mode_display_var, style="Dark.TLabel.Value").grid(row=2, column=1, padx=5, pady=2, sticky="ew")

        ttk.Label(all_traces_nab_frame, text="Trace 2 Mode:", style="TLabel").grid(row=3, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(all_traces_nab_frame, textvariable=self.all_traces_trace2_mode_display_var, style="Dark.TLabel.Value").grid(row=3, column=1, padx=5, pady=2, sticky="ew")
        
        ttk.Label(all_traces_nab_frame, text="Trace 3 Mode:", style="TLabel").grid(row=4, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(all_traces_nab_frame, textvariable=self.all_traces_trace3_mode_display_var, style="Dark.TLabel.Value").grid(row=4, column=1, padx=5, pady=2, sticky="ew")
        
        self.all_traces_count_label = ttk.Label(all_traces_nab_frame, text="# of points:", style="TLabel")
        self.all_traces_count_label.grid(row=5, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(all_traces_nab_frame, textvariable=self.all_traces_count_var, style="Dark.TLabel.Value").grid(row=5, column=1, padx=5, pady=2, sticky="ew")

        ttk.Button(all_traces_nab_frame, text="YakNab - TRACE/ALL/ONETWOTHREE", command=self._on_all_traces_nab).grid(row=6, column=0, columnspan=2, padx=5, pady=5, sticky="ew")

        columns_all = ("Frequency (MHz)", "Trace 1", "Trace 2", "Trace 3")
        self.all_traces_tree = ttk.Treeview(all_traces_nab_frame, columns=columns_all, show="headings", style='Treeview')
        self.all_traces_tree.heading("Frequency (MHz)", text="Frequency (MHz)", anchor=tk.W)
        self.all_traces_tree.heading("Trace 1", text="Trace 1 (dBm)", anchor=tk.W)
        self.all_traces_tree.heading("Trace 2", text="Trace 2 (dBm)", anchor=tk.W)
        self.all_traces_tree.heading("Trace 3", text="Trace 3 (dBm)", anchor=tk.W)
        self.all_traces_tree.grid(row=7, column=0, columnspan=2, sticky="nsew", padx=5, pady=5)
        
        vsb_all = ttk.Scrollbar(all_traces_nab_frame, orient="vertical", command=self.all_traces_tree.yview)
        vsb_all.grid(row=7, column=2, sticky="ns")
        self.all_traces_tree.configure(yscrollcommand=vsb_all.set)


        debug_log(f"Widgets for Trace Settings Tab created. The controls are ready to go! 🗺️",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)


    def _on_all_traces_nab(self):
        """
        Handles the YakNab command for all traces, displaying the results in the new table.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"YakNab for all traces triggered.",
                  file=f"{os.path.basename(__file__)}",
                  version=current_version,
                  function=current_function)
        
        # We call the handler function, which now returns a dictionary.
        all_trace_data = handle_all_traces_nab(self.app_instance, self.console_print_func)
        
        if all_trace_data:
            # Store the data for potential plotting later
            self.last_nab_trace_data = all_trace_data.get("TraceData", {})
            self.last_nab_start_freq = all_trace_data.get("StartFreq")
            self.last_nab_stop_freq = all_trace_data.get("StopFreq")
            self.last_nab_trace_modes = all_trace_data.get("TraceModes", {})

            # Extract the data and modes from the returned dictionary.
            trace_data_dict = self.last_nab_trace_data
            trace_modes = self.last_nab_trace_modes
            start_freq = self.last_nab_start_freq
            stop_freq = self.last_nab_stop_freq

            trace1_data = trace_data_dict.get("Trace1", [])
            trace2_data = trace_data_dict.get("Trace2", [])
            trace3_data = trace_data_dict.get("Trace3", [])

            # Update the display variables for the new UI labels.
            self.all_traces_start_freq_display_var.set(f"{start_freq / 1000000:.3f} MHz")
            self.all_traces_stop_freq_display_var.set(f"{stop_freq / 1000000:.3f} MHz")
            self.all_traces_trace1_mode_display_var.set(trace_modes.get("Trace1", "N/A"))
            self.all_traces_trace2_mode_display_var.set(trace_modes.get("Trace2", "N/A"))
            self.all_traces_trace3_mode_display_var.set(trace_modes.get("Trace3", "N/A"))
            self.all_traces_count_var.set(str(len(trace1_data)))

            # Clear and repopulate the Treeview table.
            self.all_traces_tree.delete(*self.all_traces_tree.get_children())
            
            for i in range(len(trace1_data)):
                freq = trace1_data[i][0]
                val1 = trace1_data[i][1] if i < len(trace1_data) else None
                val2 = trace2_data[i][1] if i < len(trace2_data) else None
                val3 = trace3_data[i][1] if i < len(trace3_data) else None
                
                self.all_traces_tree.insert("", "end", values=(f"{freq:.3f}", f"{val1:.2f}", f"{val2:.2f}", f"{val3:.2f}"))
            
            self.console_print_func(f"✅ Received and displayed data for 3 traces, with {len(trace1_data)} points each.")
            
            # Call the new function to plot the data
            self._plot_all_traces_to_monitor()
            
            # NEW: Switch to the Scan Monitor tab automatically
            self.app_instance.display_parent_tab.change_display_tab("Monitor")

            # ADDED: Call the save handler
            self._save_settings_handler()

        else:
            self.all_traces_start_freq_display_var.set("N/A")
            self.all_traces_stop_freq_display_var.set("N/A")
            self.all_traces_trace1_mode_display_var.set("N/A")
            self.all_traces_trace2_mode_display_var.set("N/A")
            self.all_traces_trace3_mode_display_var.set("N/A")
            self.all_traces_count_var.set("0")
            self.all_traces_tree.delete(*self.all_traces_tree.get_children())
            self.console_print_func("❌ Trace data retrieval failed.")


    def _on_trace_modes_beg(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"YakBeg for TRACE/MODES triggered.",
                    file=f"{os.path.basename(__file__)}",
                    version=current_version,
                    function=current_function)
        
        # FIXED: Get values from the local StringVar objects
        trace_modes = [
            self.trace1_mode_var.get(),
            self.trace2_mode_var.get(),
            self.trace3_mode_var.get(),
            self.trace4_mode_var.get()
        ]
        
        response = handle_trace_modes_beg(self.app_instance, trace_modes, self.console_print_func)
        self.trace_modes_result_var.set(f"Result: {response}")
        
        if response != "FAILED":
            # ADDED: Call the save handler
            self._save_settings_handler()

    def _on_trace_data_beg(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"YakBeg for TRACE/DATA triggered.",
                    file=f"{os.path.basename(__file__)}",
                    version=current_version,
                    function=current_function)
        
        trace_number = self.trace_select_var.get()
        start_freq_mhz = self.trace_data_start_freq_var.get()
        stop_freq_mhz = self.trace_data_stop_freq_var.get()
        
        processed_data = handle_trace_data_beg(self.app_instance, trace_number, start_freq_mhz, stop_freq_mhz, self.console_print_func)

        if processed_data:
            self.trace_data_count_var.set(str(len(processed_data)))
            self.trace_data_tree.delete(*self.trace_data_tree.get_children())
            
            for freq, value in processed_data:
                self.trace_data_tree.insert("", "end", values=(f"{freq:.3f}", f"{value:.2f}"))
            
            self.console_print_func(f"✅ Received and displayed {len(processed_data)} data points.")

            # NEW: Call update_plot to update the Scan View tab with the new data
            scan_view_tab = self.app_instance.display_parent_tab.bottom_pane.scan_view_tab
            df = pd.DataFrame(processed_data, columns=['Frequency_Hz', 'Power_dBm'])
            plot_title = f"Trace {trace_number} Data from YakBeg"
            update_single_plot(scan_view_tab, df, start_freq_mhz, stop_freq_mhz, plot_title)
            
            # NEW: Switch to the Scan View tab automatically
            self.app_instance.display_parent_tab.change_display_tab("View")

        else:
            self.trace_data_count_var.set("0")
            self.trace_data_tree.delete(*self.trace_data_tree.get_children())
            self.console_print_func("❌ Trace data retrieval failed.")

    def _on_tab_selected(self, event):
        """Called when this tab is selected."""
        pass # No specific actions needed on selection
        
    def _on_push_to_monitor(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Push to Monitor button clicked. Let's see if we can get this trace on screen! 🖥️",
                    file=f"{os.path.basename(__file__)}",
                    version=current_version,
                    function=current_function)
        
        trace_number = self.trace_select_var.get()
        data = []
        for item in self.trace_data_tree.get_children():
            values = self.trace_data_tree.item(item, 'values')
            data.append((float(values[0]), float(values[1])))
        
        # We need to know which plot to update. The original code only had one push function.
        # Let's assume we're pushing to the top plot for now.
        plot_title = f"Trace {trace_number} Data"
        if trace_number == "1":
            update_top_plot(self.app_instance.display_parent_tab.scan_monitor_tab, data, self.trace_data_start_freq_var.get(), self.trace_data_stop_freq_var.get(), plot_title)
        elif trace_number == "2":
            update_middle_plot(self.app_instance.display_parent_tab.scan_monitor_tab, data, self.trace_data_start_freq_var.get(), self.trace_data_stop_freq_var.get(), plot_title)
        elif trace_number == "3":
            update_bottom_plot(self.app_instance.display_parent_tab.scan_monitor_tab, data, self.trace_data_start_freq_var.get(), self.trace_data_stop_freq_var.get(), plot_title)
        else:
            self.console_print_func("⚠️ Invalid trace number selected. Cannot push to monitor.")
            debug_log("Invalid trace number selected. This is a fucking waste of time!",
                        file=f"{os.path.basename(__file__)}",
                        version=current_version,
                        function=current_function)

    def _plot_all_traces_to_monitor(self):
        """
        Function Description:
        This function takes the last successful response from handle_all_traces_nab,
        converts the data to a DataFrame, and pushes it to the three monitor plots.
        
        Inputs:
            None (uses self.last_nab_trace_data and other class attributes)

        Outputs:
            None. Renders the plots to the GUI.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}. Plotting all three NAB traces to the monitor. 📊",
                  file=f"{os.path.basename(__file__)}",
                  version=current_version,
                  function=current_function)

        if not self.last_nab_trace_data:
            self.console_print_func("❌ No NAB trace data available to plot. Press the NAB button first!")
            debug_log("No NAB trace data available. Aborting plot.",
                        file=f"{os.path.basename(__file__)}",
                        version=current_version,
                        function=current_function)
            return

        # Get the global plot instance
        monitor_tab = self.app_instance.display_parent_tab.bottom_pane.scan_monitor_tab
        if not monitor_tab:
            self.console_print_func("❌ Monitor tab not found. Cannot plot.")
            debug_log("Monitor tab instance not found. This is a critical failure!",
                        file=f"{os.path.basename(__file__)}",
                        version=current_version,
                        function=current_function)
            return

        start_freq_mhz = self.last_nab_start_freq / 1000000
        stop_freq_mhz = self.last_nab_stop_freq / 1000000

        # Plot Trace 1 (Live/View) on the top plot
        trace1_data = self.last_nab_trace_data.get("Trace1", [])
        trace1_mode = self.last_nab_trace_modes.get("Trace1", "N/A")
        if trace1_data and trace1_mode.upper() in ["VIEW", "WRIT"]:
            df1 = pd.DataFrame(trace1_data, columns=["Frequency_Hz", "Power_dBm"])
            update_top_plot(monitor_tab, df1, start_freq_mhz, stop_freq_mhz, f"Live/View ({trace1_mode})")
        else:
            # Clear the plot if the mode is 'BLANK' or no data is available
            df1 = pd.DataFrame(columns=["Frequency_Hz", "Power_dBm"])
            update_top_plot(monitor_tab, df1, start_freq_mhz, stop_freq_mhz, "Live/View (BLANK)")
            
        # Plot Trace 2 (Max Hold) on the middle plot
        trace2_data = self.last_nab_trace_data.get("Trace2", [])
        trace2_mode = self.last_nab_trace_modes.get("Trace2", "N/A")
        if trace2_data and trace2_mode.upper() == "MAXH":
            df2 = pd.DataFrame(trace2_data, columns=["Frequency_Hz", "Power_dBm"])
            update_middle_plot(monitor_tab, df2, start_freq_mhz, stop_freq_mhz, f"Max Hold ({trace2_mode})")
        else:
            df2 = pd.DataFrame(columns=["Frequency_Hz", "Power_dBm"])
            update_middle_plot(monitor_tab, df2, start_freq_mhz, stop_freq_mhz, "Max Hold (BLANK)")

        # Plot Trace 3 (Min Hold) on the bottom plot
        trace3_data = self.last_nab_trace_data.get("Trace3", [])
        trace3_mode = self.last_nab_trace_modes.get("Trace3", "N/A")
        if trace3_data and trace3_mode.upper() == "MINH":
            df3 = pd.DataFrame(trace3_data, columns=["Frequency_Hz", "Power_dBm"])
            update_bottom_plot(monitor_tab, df3, start_freq_mhz, stop_freq_mhz, f"Min Hold ({trace3_mode})")
        else:
            df3 = pd.DataFrame(columns=["Frequency_Hz", "Power_dBm"])
            update_bottom_plot(monitor_tab, df3, start_freq_mhz, stop_freq_mhz, "Min Hold (BLANK)")

        self.console_print_func("✅ Successfully plotted all traces to the monitor.")
        debug_log(f"All NAB traces plotted successfully. Mission accomplished! 🥳",
                  file=f"{os.path.basename(__file__)}",
                  version=current_version,
                  function=current_function)

    def _save_settings_handler(self):
        """Handles saving the instrument trace settings to the config file."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"⚙️ 💾 Entering {current_function}. Time to save the instrument trace settings! 📈",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)
        
        try:
            # Call the specific save function from the modular config manager
            _save_instrument_settings(
                config=self.app_instance.program_config,
                app_instance=self.app_instance,
                console_print_func=self.console_print_func
            )
            # Call the main config save function to write the changes to the file
            save_program_config(
                app_instance=self.app_instance,
                config=self.app_instance.program_config,
                config_file_path=self.app_instance.config_file_path,
                console_print_func=self.console_print_func
            )
            debug_log("⚙️ ✅ Instrument trace settings saved successfully. Mission accomplished!",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)
        except Exception as e:
            debug_log(f"❌ Error saving instrument trace settings: {e}",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)
            self.console_print_func(f"❌ Error saving instrument trace settings: {e}")

#####################################
### File: OPEN-AIR\Instrument\visa\ref_visa_commands.py
#####################################
# ref/ref_visa_commands.py
#
# This module provides a single, centralized list of default VISA commands
# for the application's interpreter. The data structure has been updated to
# include a 'Manufacturer' field to support the new column in the VISA Interpreter.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250812.215500.1 (FIXED: The get_default_commands function now correctly returns a list of tuples instead of a single tuple to properly populate the CSV file.)

current_version = "20250812.215500.1"
current_version_hash = 20250812 * 215500 * 1

def get_default_visa_commands():
    """
    Returns a list of default VISA commands.
    Each entry is a tuple: (Manufacturer, Model, Command Type, Action, VISA Command, Default Value for Variable, Validated).
    """
    # CORRECTED: The return value is now wrapped in a list.
    return [
        # System/Identification
        ("Keysight Technologies", "*", "SYSTEM/ID", "GET", "*IDN", "?", ""),
        ("Keysight Technologies", "*", "SYSTEM/RESET", "DO", "*RST", "", ""),
        ("Keysight Technologies", "*", "SYSTEM/ERRORS", "GET", ":SYSTem:ERRor", "?", ""),
        ("Keysight Technologies", "*", "SYSTEM/DISPLAY/UPDATE", "DO", ":SYSTem:DISPlay:UPDate", "", ""),
        ("Rohde & Schwarz", "*", "SYSTEM/ID", "GET", "*IDN", "?", ""),
        ("Rohde & Schwarz", "*", "SYSTEM/RESET", "DO", "*RST", "", ""),
        ("Rohde & Schwarz", "*", "SYSTEM/ERRORS", "GET", ":SYSTem:ERRor", "?", ""),
        ("Rohde & Schwarz", "*", "SYSTEM/DISPLAY/UPDATE", "DO", ":SYSTem:DISPlay:UPDate", "", ""),
        # Frequency/Span/Sweep
        ("Keysight Technologies", "*", "FREQUENCY/CENTER", "SET", ":SENSe:FREQuency:CENTer", "1000", ""),
        ("Keysight Technologies", "*", "FREQUENCY/CENTER", "GET", ":SENSe:FREQuency:CENTer", "?", ""),
        ("Keysight Technologies", "*", "FREQUENCY/SPAN", "SET", ":SENSe:FREQuency:SPAN", "1000", ""),
        ("Keysight Technologies", "*", "FREQUENCY/SPAN", "GET", ":SENSe:FREQuency:SPAN", "?", ""),

        ("Keysight Technologies", "*", "FREQUENCY/CENTER-SPAN", "RIG", ":SENSe:FREQuency:CENTer 111;:SENSe:FREQuency:SPAN 222; ", "2", ""),
        ("Keysight Technologies", "*", "FREQUENCY/CENTER-SPAN", "NAB", ":SENSe:FREQuency:SPAN?;:SENSe:FREQuency:CENTer? ", "2", ""),
        ("Keysight Technologies", "*", "FREQUENCY/CENTER-SPAN", "BEG", ":SENSe:FREQuency:CENTer 111;:SENSe:FREQuency:SPAN 222;:SENSe:FREQuency:SPAN?;:SENSe:FREQuency:CENTer?;:FREQuency:STARt?;:FREQuency:STOP?", "2", ""),
        



        ("Keysight Technologies", "*", "FREQUENCY/START", "GET", ":FREQuency:STARt", "?", ""),
        ("Keysight Technologies", "*", "FREQUENCY/START", "SET", ":FREQuency:STARt", "1000", ""),
        ("Keysight Technologies", "*", "FREQUENCY/STOP", "GET", ":FREQuency:STOP", "?", ""),
        ("Keysight Technologies", "*", "FREQUENCY/STOP", "SET", ":FREQuency:STOP", "2000", ""),
        
        ("Keysight Technologies", "*", "FREQUENCY/START-STOP", "RIG", ":FREQuency:STARt 111;:FREQuency:STOP 222 ", "2", ""),
        ("Keysight Technologies", "*", "FREQUENCY/START-STOP", "NAB", ":FREQuency:STARt?;:FREQuency:STOP? ", "2", ""),
        ("Keysight Technologies", "*", "FREQUENCY/START-STOP", "BEG", ":FREQuency:STARt 111;:FREQuency:STOP 222;:FREQuency:STARt?;:FREQuency:STOP?;:SENSe:FREQuency:SPAN?;:SENSe:FREQuency:CENTer?;", "2", ""),
        

        ("Keysight Technologies", "*", "FREQUENCY/SWEEP/POINTS", "GET", ":SENSe:SWEep:POINts", "?", ""),
        
        ("Keysight Technologies", "N9342CN", "FREQUENCY/SWEEP/TIME", "GET", ":SENSe:SWEep:TIME", "?", ""),
        ("Keysight Technologies", "N9342CN", "FREQUENCY/SWEEP/TIME/ON", "DO", ":SENSe:SWEep:TIME:AUTO", "ON", ""),
        ("Keysight Technologies", "N9342CN", "FREQUENCY/SWEEP/TIME", "GET", ":SENSe:SWEep:TIME", "?", ""),
        ("Keysight Technologies", "N9342CN", "FREQUENCY/SWEEP/TIME/OFF", "DO", ":SENSe:SWEep:TIME:AUTO", "OFF", ""),
        ("Keysight Technologies", "N9342CN", "FREQUENCY/SWEEP/TIME", "GET", ":SENSe:SWEep:TIME", "?", ""),

        ("Agilent Technologies", "N9340B", "FREQUENCY/SWEEP/TIME", "SET", ":SENSe:SWEep:TIME", "3", ""),
        ("Agilent Technologies", "N9340B", "FREQUENCY/SWEEP/TIME", "GET", ":SENSe:SWEep:TIME", "?", ""),

        ("Agilent Technologies", "N9340B", "FREQUENCY/SWEEP/TIME/AUTO", "GET", ":SENSe:SWEep:TIME:AUTO", "?", ""),
        ("Agilent Technologies", "N9340B", "FREQUENCY/SWEEP/TIME/AUTO/ON", "DO", ":SENSe:SWEep:TIME:AUTO", "ON", ""),
        ("Agilent Technologies", "N9340B", "FREQUENCY/SWEEP/TIME/AUTO", "GET", ":SENSe:SWEep:TIME:AUTO", "?", ""),
        ("Agilent Technologies", "N9340B", "FREQUENCY/SWEEP/TIME/AUTO/OFF", "DO", ":SENSe:SWEep:TIME:AUTO", "OFF", ""),

        ("Agilent Technologies", "N9340B", "FREQUENCY/SWEEP/TIME/AUTO", "GET", ":SENSe:SWEep:TIME:AUTO", "?", ""),
        ("Agilent Technologies", "N9340B", "FREQUENCY/SWEEP/MODE", "DO", ":SENSe:SWEep:TIME:AUTO:MODE", "NORMAL", ""),
        ("Agilent Technologies", "N9340B", "FREQUENCY/SWEEP/TIME/AUTO", "GET", ":SENSe:SWEep:TIME:AUTO", "?", ""),        
        ("Agilent Technologies", "N9340B", "FREQUENCY/SWEEP/MODE", "DO", ":SENSe:SWEep:TIME:AUTO:MODE", "FAST", ""),
        ("Agilent Technologies", "N9340B", "FREQUENCY/SWEEP/MODE", "GET", ":SENSe:SWEep:TIME:AUTO:MODE", "?", ""),
        ("Agilent Technologies", "N9340B", "FREQUENCY/SWEEP/TDMODE/ON", "DO", ":SENSe:SWEep:TDMode", "ON", ""),
        ("Agilent Technologies", "N9340B", "FREQUENCY/SWEEP/TDMODE/OFF", "DO", ":SENSe:SWEep:TDMode", "OFF", ""),
        ("Agilent Technologies", "N9340B", "FREQUENCY/SWEEP/TDMODE", "GET", ":SENSe:SWEep:TDMode", "?", ""),

        ("Keysight Technologies", "*", "FREQUENCY/SWEEP/SPACING/LINEAR", "DO", ":SENSe:X:SPACing LINear", "LINear", ""),
        
        ("Keysight Technologies", "N9342CN", "FREQUENCY/OFFSET", "GET", ":FREQuency:OFFSet", "?", ""),
        ("Keysight Technologies", "N9342CN", "FREQUENCY/SHIFT", "GET", ":INPut:RFSense:FREQuency:SHIFt", "?", ""),
        ("Keysight Technologies", "N9342CN", "FREQUENCY/SHIFT/0", "DO", ":INPut:RFSense:FREQuency:SHIFt", "0", ""),

        # Bandwidth (RBW/VBW)
        ("Keysight Technologies", "*", "BANDWIDTH/RESOLUTION", "GET", ":SENSe:BANDwidth:RESolution", "?", ""),
        ("Keysight Technologies", "*", "BANDWIDTH/RESOLUTION", "SET", ":SENSe:BANDwidth:RESolution", "1000000", ""),
        ("Keysight Technologies", "*", "BANDWIDTH/RESOLUTION", "GET", ":SENSe:BANDwidth:RESolution", "?", ""),

        ("Keysight Technologies", "*", "INITIATE/CONTINUOUS", "GET", ":INITiate:CONTinuous", "?", ""),
        ("Keysight Technologies", "*", "INITIATE/CONTINUOUS/ON", "DO", ":INITiate:CONTinuous", "ON", ""),
        ("Keysight Technologies", "*", "INITIATE/CONTINUOUS", "GET", ":INITiate:CONTinuous", "?", ""),
        ("Keysight Technologies", "*", "INITIATE/CONTINUOUS/OFF", "DO", ":INITiate:CONTinuous", "Off", ""),
        
        ("Keysight Technologies", "*", "BANDWIDTH/SETTINGS", "NAB", ":SENSe:BANDwidth:RESolution?;:SENSe:BANDwidth:VIDeo?;:SENSe:BANDwidth:VIDeo:AUTO?;:INITiate:CONTinuous?;:SENSe:SWEep:TIME?", "5", ""),
        
        
        ("Keysight Technologies", "*", "INITIATE/IMMEDIATE", "DO", ":INITiate:IMMediate", "", ""),

        ("Keysight Technologies", "*", "BANDWIDTH/VIDEO", "GET", ":SENSe:BANDwidth:VIDeo", "?", ""),
        ("Keysight Technologies", "*", "BANDWIDTH/VIDEO", "SET", ":SENSe:BANDwidth:VIDeo", "1000000", ""),
        ("Keysight Technologies", "*", "BANDWIDTH/VIDEO", "GET", ":SENSe:BANDwidth:VIDeo", "?", ""),

        ("Keysight Technologies", "*", "BANDWIDTH/VIDEO/AUTO/ON", "DO", ":SENSe:BANDwidth:VIDeo:AUTO", "ON", ""),
        ("Keysight Technologies", "*", "BANDWIDTH/VIDEO/AUTO", "GET", ":SENSe:BANDwidth:VIDeo:AUTO", "?", ""),
        ("Keysight Technologies", "*", "BANDWIDTH/VIDEO/AUTO/OFF", "DO", ":SENSe:BANDwidth:VIDeo:AUTO", "OFF", ""),
        ("Keysight Technologies", "*", "BANDWIDTH/VIDEO/AUTO", "GET", ":SENSe:BANDwidth:VIDeo:AUTO", "?", ""),

        ("Keysight Technologies", "*", "BANDWIDTH/RESOLUTION/AUTO/ON", "DO", ":SENSe:BANDwidth:RESolution:AUTO", "ON", ""),
        ("Keysight Technologies", "*", "BANDWIDTH/VIDEO/AUTO/ON", "DO", ":SENSe:BANDwidth:VIDeo:AUTO", "ON", ""),

        # Amplitude/Reference Level/Attenuation/Gain
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL", "GET", ":DISPlay:WINDow:TRACe:Y:RLEVel", "?", ""),
      # Updated commands for AMPLITUDE/REFERENCE LEVEL, with 5 dB increments from 0 to -120.

        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL", "GET", ":DISPlay:WINDow:TRACe:Y:RLEVel", "?", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/0", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "0", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-5", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-5", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-10", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-10", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-15", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-15", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-20", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-20", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-25", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-25", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-30", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-30", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-35", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-35", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-40", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-40", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-45", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-45", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-50", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-50", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-55", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-55", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-60", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-60", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-65", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-65", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-70", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-70", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-75", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-75", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-80", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-80", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-85", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-85", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-90", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-90", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-95", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-95", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-100", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-100", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-105", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-105", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-110", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-110", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-115", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-115", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-120", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-120", ""),

        ("Keysight Technologies", "*", "AMPLITUDE/ATTENUATION/AUTO/ON", "DO", ":INPut:ATTenuation:AUTO", "ON", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/ATTENUATION/AUTO", "GET", ":INPut:ATTenuation", "?", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/ATTENUATION/AUTO/OFF", "DO", ":INPut:ATTenuation:AUTO", "OFF", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/ATTENUATION/AUTO", "GET", ":INPut:ATTenuation", "?", ""),

        ("Keysight Technologies", "*", "AMPLITUDE/GAIN/STATE/ON", "DO", ":INPut:GAIN:STATe", "ON", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/GAIN/STATE", "GET", ":INPut:GAIN:STATe", "?", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/GAIN/STATE/OFF", "DO", ":INPut:GAIN:STATe", "OFF", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/GAIN/STATE", "GET", ":INPut:GAIN:STATe", "?", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION/AUTO/ON", "DO", ":POWer:ATTenuation:AUTO", "ON", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION/AUTO/OFF", "DO", ":POWer:ATTenuation:AUTO", "OFF", ""),

        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION", "GET", ":POWer:ATTenuation", "?", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION/0DB", "DO", ":POWer:ATTenuation", "0", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION", "GET", ":POWer:ATTenuation", "?", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION/10DB", "DO", ":POWer:ATTenuation", "10", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION", "GET", ":POWer:ATTenuation", "?", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION/20DB", "DO", ":POWer:ATTenuation", "20", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION", "GET", ":POWer:ATTenuation", "?", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION/30DB", "DO", ":POWer:ATTenuation", "30", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION", "GET", ":POWer:ATTenuation", "?", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION/40DB", "DO", ":POWer:ATTenuation", "40", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION", "GET", ":POWer:ATTenuation", "?", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION/50DB", "DO", ":POWer:ATTenuation", "50", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION", "GET", ":POWer:ATTenuation", "?", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION/60DB", "DO", ":POWer:ATTenuation", "60", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION", "GET", ":POWer:ATTenuation", "?", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION/70DB", "DO", ":POWer:ATTenuation", "70", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION", "GET", ":POWer:ATTenuation", "?", ""),

        ("Keysight Technologies", "*", "AMPLITUDE/POWER/GAIN/ON", "DO", ":POWer:GAIN", "ON", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/GAIN", "GET", ":POWer:GAIN", "?", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/GAIN/OFF", "DO", ":POWer:GAIN", "OFF", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/GAIN", "GET", ":POWer:GAIN", "?", ""),
        
        ("Keysight Technologies", "N9342CN", "AMPLITUDE/POWER/HIGH SENSITIVE/ON", "DO", ":POWer:HSENsitive", "ON", ""),
        ("Keysight Technologies", "N9342CN", "AMPLITUDE/POWER/HIGH SENSITIVE/OFF", "DO", ":POWer:HSENsitive", "OFF", ""),
        ("Keysight Technologies", "N9342CN", "AMPLITUDE/POWER/HIGH SENSITIVE", "NAB", ":DISPlay:WINDow:TRACe:Y:RLEVel?;:POWer:ATTenuation?;:POWer:GAIN?", "3", ""),

        ("Keysight Technologies", "N9340B", "AMPLITUDE/POWER/HIGH SENSITIVE/ON", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel -50; :POWer:ATTenuation 0; :POWer:GAIN ON", "", ""),
        ("Keysight Technologies", "N9340B", "AMPLITUDE/POWER/HIGH SENSITIVE/OFF", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel 0; :POWer:ATTenuation 20; :POWer:GAIN OFF", "", ""),
        ("Keysight Technologies", "N9340B", "AMPLITUDE/POWER/HIGH SENSITIVE", "NAB", ":DISPlay:WINDow:TRACe:Y:RLEVel?;:POWer:ATTenuation?;:POWer:GAIN?", "3", ""),

        ("Keysight Technologies", "*", "TRACE/MODES", "NAB", ":TRAC1:MODE?;:TRAC2:MODE?;:TRAC3:MODE?;:TRAC4:MODE?", "4", ""),
        ("Keysight Technologies", "*", "TRACE/MODES", "RIG", ":TRAC1:MODE 111;:TRAC2:MODE 222;:TRAC3:MODE 333;:TRAC4:MODE 444", "4", ""),
        ("Keysight Technologies", "*", "TRACE/MODES", "BEG", ":TRAC1:MODE 111;:TRAC2:MODE 222;:TRAC3:MODE 333;:TRAC4:MODE 444;:TRAC1:MODE?;:TRAC2:MODE?;:TRAC3:MODE?;:TRAC4:MODE?", "4", ""),

        # Trace Mode Write
        ("Keysight Technologies", "*", "TRACE/1/MODE/WRITE", "DO", ":TRAC1:MODE", "WRITe", ""),
        ("Keysight Technologies", "*", "TRACE/2/MODE/WRITE", "DO", ":TRAC2:MODE", "WRITe", ""),
        ("Keysight Technologies", "*", "TRACE/3/MODE/WRITE", "DO", ":TRAC3:MODE", "WRITe", ""),
        ("Keysight Technologies", "*", "TRACE/4/MODE/WRITE", "DO", ":TRAC4:MODE", "WRITe", ""),

        # Trace/Display - Expanded for 4 traces
        # Trace Data Query
        ("Keysight Technologies", "N9342CN", "TRACE/1/DATA", "GET", ":TRACe:DATA? TRACE1", "", ""),
        ("Keysight Technologies", "N9342CN", "TRACE/2/DATA", "GET", ":TRACe:DATA? TRACE2", "", ""),
        ("Keysight Technologies", "N9342CN", "TRACE/3/DATA", "GET", ":TRACe:DATA? TRACE3", "", ""),
        ("Keysight Technologies", "N9342CN", "TRACE/4/DATA", "GET", ":TRACe:DATA? TRACE4", "", ""),

        ("Keysight Technologies", "N9340B", "TRACE/1/DATA", "GET", ":TRACe1:DATA", "?", ""),
        ("Keysight Technologies", "N9340B", "TRACE/2/DATA", "GET", ":TRACe2:DATA", "?", ""),
        ("Keysight Technologies", "N9340B", "TRACE/3/DATA", "GET", ":TRACe3:DATA", "?", ""),
        ("Keysight Technologies", "N9340B", "TRACE/4/DATA", "GET", ":TRACe4:DATA", "?", ""),
        
        ("Keysight Technologies", "N9340B", "TRACE/ALL/ONETWOTHREE", "NAB", ":FREQuency:STARt?;:FREQuency:STOP?;:TRAC1:MODE?;:TRAC2:MODE?;:TRAC3:MODE?;:TRACe1:DATA?;:TRACe2:DATA?;:TRACe3:DATA?;", "8", ""),
        ("Keysight Technologies", "N9342CN", "TRACE/ALL/ONETWOTHREE", "NAB", ":FREQuency:STARt?;:FREQuency:STOP?;:TRAC1:MODE?;:TRAC2:MODE?;:TRAC3:MODE?;:TRACe:DATA? TRACE1;:TRACe:DATA? TRACE2;:TRACe:DATA? TRACE3;", "8", ""),

        # Trace/Display - Expanded for 4 traces
        # Trace Data Query
        ("Keysight Technologies", "N9342CN", "TRACE/1/DATA", "NAB", ":FREQuency:STARt?;:FREQuency:STOP?;:TRACe:DATA? TRACE1", "3", ""),
        ("Keysight Technologies", "N9342CN", "TRACE/2/DATA", "NAB", ":FREQuency:STARt?;:FREQuency:STOP?;:TRACe:DATA? TRACE2", "3", ""),
        ("Keysight Technologies", "N9342CN", "TRACE/3/DATA", "NAB", ":FREQuency:STARt?;:FREQuency:STOP?;:TRACe:DATA? TRACE3", "3", ""),
        ("Keysight Technologies", "N9342CN", "TRACE/4/DATA", "NAB", ":FREQuency:STARt?;:FREQuency:STOP?;:TRACe:DATA? TRACE4", "3", ""),

        ("Keysight Technologies", "N9342CN", "TRACE/1/DATA", "BEG", ":FREQuency:STARt 111;:FREQuency:STOP 222;:TRACe:DATA? TRACE1", "2", ""),
        ("Keysight Technologies", "N9342CN", "TRACE/2/DATA", "BEG", ":FREQuency:STARt 111;:FREQuency:STOP 222;:TRACe:DATA? TRACE2", "2", ""),
        ("Keysight Technologies", "N9342CN", "TRACE/3/DATA", "BEG", ":FREQuency:STARt 111;:FREQuency:STOP 222;:TRACe:DATA? TRACE3", "2", ""),
        ("Keysight Technologies", "N9342CN", "TRACE/4/DATA", "BEG", ":FREQuency:STARt 111;:FREQuency:STOP 222;:TRACe:DATA? TRACE4", "2", ""),



        ("Keysight Technologies", "N9340B", "TRACE/1/DATA", "NAB", ":FREQuency:STARt?;:FREQuency:STOP?;:TRACe1:DATA?", "3", ""),
        ("Keysight Technologies", "N9340B", "TRACE/2/DATA", "NAB", ":FREQuency:STARt?;:FREQuency:STOP?;:TRACe2:DATA?", "3", ""),
        ("Keysight Technologies", "N9340B", "TRACE/3/DATA", "NAB", ":FREQuency:STARt?;:FREQuency:STOP?;:TRACe3:DATA?", "3", ""),
        ("Keysight Technologies", "N9340B", "TRACE/4/DATA", "NAB", ":FREQuency:STARt?;:FREQuency:STOP?;:TRACe4:DATA?", "3", ""),


        ("Keysight Technologies", "N9340B", "TRACE/1/DATA", "BEG", ":FREQuency:STARt 111;:FREQuency:STOP 222;:TRACe1:DATA?", "2", ""),
        ("Keysight Technologies", "N9340B", "TRACE/2/DATA", "BEG", ":FREQuency:STARt 111;:FREQuency:STOP 222;:TRACe2:DATA?", "2", ""),
        ("Keysight Technologies", "N9340B", "TRACE/3/DATA", "BEG", ":FREQuency:STARt 111;:FREQuency:STOP 222;:TRACe3:DATA?", "2", ""),
        ("Keysight Technologies", "N9340B", "TRACE/4/DATA", "BEG", ":FREQuency:STARt 111;:FREQuency:STOP 222;:TRACe4:DATA?", "2", ""),





        # Trace Mode write
        ("Keysight Technologies", "*", "TRACE/1/MODE/WRITE", "DO", ":TRAC1:MODE", "WRITe", ""),
        ("Keysight Technologies", "*", "TRACE/2/MODE/WRITE", "DO", ":TRAC2:MODE", "WRITe", ""),
        ("Keysight Technologies", "*", "TRACE/3/MODE/WRITE", "DO", ":TRAC3:MODE", "WRITe", ""),
        ("Keysight Technologies", "*", "TRACE/4/MODE/WRITE", "DO", ":TRAC4:MODE", "WRITe", ""),
        
        ("Keysight Technologies", "*", "TRACE/MODES", "NAB", ":TRAC1:MODE?;:TRAC2:MODE?;:TRAC3:MODE?;:TRAC4:MODE?", "4", ""),
        
        ("Keysight Technologies", "*", "TRACE/1/MODE/WRITE", "DO", ":TRAC1:MODE", "WRITe", ""),
        ("Keysight Technologies", "*", "TRACE/1/MODE/BLANK", "DO", ":TRAC1:MODE", "BLANk", ""),
        ("Keysight Technologies", "*", "TRACE/2/MODE/WRITE", "DO", ":TRAC2:MODE", "WRITe", ""),
        ("Keysight Technologies", "*", "TRACE/2/MODE/BLANK", "DO", ":TRAC2:MODE", "BLANk", ""),
        ("Keysight Technologies", "*", "TRACE/3/MODE/WRITE", "DO", ":TRAC3:MODE", "WRITe", ""),
        ("Keysight Technologies", "*", "TRACE/3/MODE/BLANK", "DO", ":TRAC3:MODE", "BLANk", ""),
        ("Keysight Technologies", "*", "TRACE/4/MODE/WRITE", "DO", ":TRAC4:MODE", "WRITe", ""),
        ("Keysight Technologies", "*", "TRACE/4/MODE/BLANK", "DO", ":TRAC4:MODE", "BLANk", ""),
        
        ("Keysight Technologies", "*", "TRACE/1/MODE", "GET", ":TRAC1:MODE", "?", ""),
        ("Keysight Technologies", "*", "TRACE/2/MODE", "GET", ":TRAC2:MODE", "?", ""),
        ("Keysight Technologies", "*", "TRACE/3/MODE", "GET", ":TRAC3:MODE", "?", ""),
        ("Keysight Technologies", "*", "TRACE/4/MODE", "GET", ":TRAC4:MODE", "?", ""),

        # Trace Mode MaxHold
        ("Keysight Technologies", "*", "TRACE/1/MODE/MAXHOLD", "DO", ":TRAC1:MODE", "MAXHold", ""),
        ("Keysight Technologies", "*", "TRACE/2/MODE/MAXHOLD", "DO", ":TRAC2:MODE", "MAXHold", ""),
        ("Keysight Technologies", "*", "TRACE/3/MODE/MAXHOLD", "DO", ":TRAC3:MODE", "MAXHold", ""),
        ("Keysight Technologies", "*", "TRACE/4/MODE/MAXHOLD", "DO", ":TRAC4:MODE", "MAXHold", ""),

        ("Keysight Technologies", "*", "TRACE/1/MODE", "GET", ":TRAC1:MODE", "?", ""),
        ("Keysight Technologies", "*", "TRACE/2/MODE", "GET", ":TRAC2:MODE", "?", ""),
        ("Keysight Technologies", "*", "TRACE/3/MODE", "GET", ":TRAC3:MODE", "?", ""),
        ("Keysight Technologies", "*", "TRACE/4/MODE", "GET", ":TRAC4:MODE", "?", ""),

        # Trace Mode MinHold
        ("Keysight Technologies", "*", "TRACE/1/MODE/MINHOLD", "DO", ":TRAC1:MODE", "MINHold", ""),
        ("Keysight Technologies", "*", "TRACE/2/MODE/MINHOLD", "DO", ":TRAC2:MODE", "MINHold", ""),
        ("Keysight Technologies", "*", "TRACE/3/MODE/MINHOLD", "DO", ":TRAC3:MODE", "MINHold", ""),
        ("Keysight Technologies", "*", "TRACE/4/MODE/MINHOLD", "DO", ":TRAC4:MODE", "MINHold", ""),

        ("Keysight Technologies", "*", "TRACE/1/MODE", "GET", ":TRAC1:MODE", "?", ""),
        ("Keysight Technologies", "*", "TRACE/2/MODE", "GET", ":TRAC2:MODE", "?", ""),
        ("Keysight Technologies", "*", "TRACE/3/MODE", "GET", ":TRAC3:MODE", "?", ""),
        ("Keysight Technologies", "*", "TRACE/4/MODE", "GET", ":TRAC4:MODE", "?", ""),

        # Trace Mode VIEW
        ("Keysight Technologies", "*", "TRACE/1/MODE/VIEW", "DO", ":TRAC1:MODE", "VIEW", ""),
        ("Keysight Technologies", "*", "TRACE/2/MODE/VIEW", "DO", ":TRAC2:MODE", "VIEW", ""),
        ("Keysight Technologies", "*", "TRACE/3/MODE/VIEW", "DO", ":TRAC3:MODE", "VIEW", ""),
        ("Keysight Technologies", "*", "TRACE/4/MODE/VIEW", "DO", ":TRAC4:MODE", "VIEW", ""),

        ("Keysight Technologies", "*", "TRACE/1/MODE", "GET", ":TRAC1:MODE", "?", ""),
        ("Keysight Technologies", "*", "TRACE/2/MODE", "GET", ":TRAC2:MODE", "?", ""),
        ("Keysight Technologies", "*", "TRACE/3/MODE", "GET", ":TRAC3:MODE", "?", ""),
        ("Keysight Technologies", "*", "TRACE/4/MODE", "GET", ":TRAC4:MODE", "?", ""),

        # Averaging:


        
        # Averaging
        ("Keysight Technologies", "*", "AVERAGE/ON", "DO", ":AVER:TRAC1:STAT", "ON", ""),
        ("Keysight Technologies", "*", "AVERAGE/OFF", "DO", ":AVER:TRAC1:STAT", "OFF", ""),
        ("Keysight Technologies", "*", "AVERAGE", "SET", ":AVER:TRAC1:COUNT", "25", ""),
        ("Keysight Technologies", "*", "AVERAGE", "NAB", ":AVER:TRAC1:STAT?;:AVER:TRAC1:COUNT?", "2", ""),

        

        
        ("Keysight Technologies", "*", "TRACE/DISPLAY/TYPE", "GET", ":DISPlay:WINDow:TRACe:TYPE", "?", ""),
        ("Keysight Technologies", "*", "TRACE/DISPLAY/Y SCALE/SPACING", "SET", ":DISPlay:WINDow:TRACe:Y:SCALe:SPACing", "LOGarithmic", ""),
        ("Keysight Technologies", "N9342CN", "TRACE/FORMAT/DATA/ASCII", "DO", ":TRACe:FORMat:DATA", "ASCii", ""), # For *
        ("Keysight Technologies", "N9340B", "TRACE/FORMAT/DATA/ASCII", "DO", ":FORMat:DATA", "ASCii", ""), # General

        # Marker - Expanded for 6 markers
        # Marker Calculate Max
        ("Keysight Technologies", "*", "MARKER/1/CALCULATE/MAX", "DO", ":CALCulate:MARKer1:MAX", "", ""),
        ("Keysight Technologies", "*", "MARKER/2/CALCULATE/MAX", "DO", ":CALCulate:MARKer2:MAX", "", ""),
        ("Keysight Technologies", "*", "MARKER/3/CALCULATE/MAX", "DO", ":CALCulate:MARKer3:MAX", "", ""),
        ("Keysight Technologies", "*", "MARKER/4/CALCULATE/MAX", "DO", ":CALCulate:MARKer4:MAX", "", ""),
        ("Keysight Technologies", "*", "MARKER/5/CALCULATE/MAX", "DO", ":CALCulate:MARKer5:MAX", "", ""),
        ("Keysight Technologies", "*", "MARKER/6/CALCULATE/MAX", "DO", ":CALCulate:MARKer6:MAX", "", ""),


        ("Keysight Technologies", "*", "MARKER/1/CALCULATE/NEXT", "DO", ":CALCulate:MARKer1:NEXT", "", ""),
        ("Keysight Technologies", "*", "MARKER/2/CALCULATE/NEXT", "DO", ":CALCulate:MARKer2:NEXT", "", ""),
        ("Keysight Technologies", "*", "MARKER/3/CALCULATE/NEXT", "DO", ":CALCulate:MARKer3:NEXT", "", ""),
        ("Keysight Technologies", "*", "MARKER/4/CALCULATE/NEXT", "DO", ":CALCulate:MARKer4:NEXT", "", ""),
        ("Keysight Technologies", "*", "MARKER/5/CALCULATE/NEXT", "DO", ":CALCulate:MARKer5:NEXT", "", ""),
        ("Keysight Technologies", "*", "MARKER/6/CALCULATE/NEXT", "DO", ":CALCulate:MARKer6:NEXT", "", ""),

        ("Keysight Technologies", "*", "MARKER/PEAK/SEARCH", "DO", "CALCulate:MARKer1:MAXimum; :CALCulate:MARKer2:MAXimum:LEFT; :CALCulate:MARKer3:MAXimum:RIGHt; :CALCulate:MARKer4:MAXimum:LEFT; :CALCulate:MARKer5:MAXimum:RIGHt; :CALCulate:MARKer6:MAXimum:LEFT", "", ""),
        
        ("Keysight Technologies", "*", "MARKER/All/CALCULATE/STATE/ON", "DO", ":CALCulate:MARKer1:STATe ON; :CALCulate:MARKer2:STATe ON; :CALCulate:MARKer3:STATe ON; :CALCulate:MARKer4:STATe ON; :CALCulate:MARKer5:STATe ON; :CALCulate:MARKer6:STATe ON; ", "", ""),
        
        ("Keysight Technologies", "*", "MARKER/All/CALCULATE/STATE/OFF", "DO", ":CALCulate:MARKer1:STATe OFF; :CALCulate:MARKer2:STATe OFF; :CALCulate:MARKer3:STATe OFF; :CALCulate:MARKer4:STATe OFF; :CALCulate:MARKer5:STATe OFF; :CALCulate:MARKer6:STATe OFF; ", "", ""),
        
        ("Keysight Technologies", "*", "MARKER/NAB/ALL/Y", "NAB", ":CALCulate:MARKer1:Y?;:CALCulate:MARKer2:Y?;:CALCulate:MARKer3:Y?;:CALCulate:MARKer4:Y?;:CALCulate:MARKer5:Y?;:CALCulate:MARKer1:Y?", "6", ""),
        ("Keysight Technologies", "*", "MARKER/NAB/ALL/X", "NAB", ":CALCulate:MARKer1:X?;:CALCulate:MARKer2:X?;:CALCulate:MARKer3:X?;:CALCulate:MARKer4:X?;:CALCulate:MARKer5:X?;:CALCulate:MARKer1:X?", "6", ""),

        # Marker Calculate State
        ("Keysight Technologies", "*", "MARKER/1/CALCULATE/STATE/ON", "DO", ":CALCulate:MARKer1:STATe", "ON", ""),
        ("Keysight Technologies", "*", "MARKER/2/CALCULATE/STATE/ON", "DO", ":CALCulate:MARKer2:STATe", "ON", ""),
        ("Keysight Technologies", "*", "MARKER/3/CALCULATE/STATE/ON", "DO", ":CALCulate:MARKer3:STATe", "ON", ""),
        ("Keysight Technologies", "*", "MARKER/4/CALCULATE/STATE/ON", "DO", ":CALCulate:MARKer4:STATe", "ON", ""),
        ("Keysight Technologies", "*", "MARKER/5/CALCULATE/STATE/ON", "DO", ":CALCulate:MARKer5:STATe", "ON", ""),
        ("Keysight Technologies", "*", "MARKER/6/CALCULATE/STATE/ON", "DO", ":CALCulate:MARKer6:STATe", "ON", ""),

        # Marker Calculate State
        ("Keysight Technologies", "*", "MARKER/1/CALCULATE/STATE/OFF", "DO", ":CALCulate:MARKer1:STATe", "OFF", ""),
        ("Keysight Technologies", "*", "MARKER/2/CALCULATE/STATE/OFF", "DO", ":CALCulate:MARKer2:STATe", "OFF", ""),
        ("Keysight Technologies", "*", "MARKER/3/CALCULATE/STATE/OFF", "DO", ":CALCulate:MARKer3:STATe", "OFF", ""),
        ("Keysight Technologies", "*", "MARKER/4/CALCULATE/STATE/OFF", "DO", ":CALCulate:MARKer4:STATe", "OFF", ""),
        ("Keysight Technologies", "*", "MARKER/5/CALCULATE/STATE/OFF", "DO", ":CALCulate:MARKer5:STATe", "OFF", ""),
        ("Keysight Technologies", "*", "MARKER/6/CALCULATE/STATE/OFF", "DO", ":CALCulate:MARKer6:STATe", "OFF", ""),

                # Get Marker Calculate State
        ("Keysight Technologies", "*", "MARKER/1/CALCULATE/STATE", "GET", ":CALCulate:MARKer1:STATe", "?", ""),
        ("Keysight Technologies", "*", "MARKER/2/CALCULATE/STATE", "GET", ":CALCulate:MARKer2:STATe", "?", ""),
        ("Keysight Technologies", "*", "MARKER/3/CALCULATE/STATE", "GET", ":CALCulate:MARKer3:STATe", "?", ""),
        ("Keysight Technologies", "*", "MARKER/4/CALCULATE/STATE", "GET", ":CALCulate:MARKer4:STATe", "?", ""),
        ("Keysight Technologies", "*", "MARKER/5/CALCULATE/STATE", "GET", ":CALCulate:MARKer5:STATe", "?", ""),
        ("Keysight Technologies", "*", "MARKER/6/CALCULATE/STATE", "GET", ":CALCulate:MARKer6:STATe", "?", ""),


        # Marker Calculate X (Frequency)
        ("Keysight Technologies", "*", "MARKER/1/PLACE/X", "SET", ":CALCulate:MARKer1:X", "111111", ""),
        ("Keysight Technologies", "*", "MARKER/2/PLACE/X", "SET", ":CALCulate:MARKer2:X", "222222", ""),
        ("Keysight Technologies", "*", "MARKER/3/PLACE/X", "SET", ":CALCulate:MARKer3:X", "333333", ""),
        ("Keysight Technologies", "*", "MARKER/4/PLACE/X", "SET", ":CALCulate:MARKer4:X", "444444", ""),
        ("Keysight Technologies", "*", "MARKER/5/PLACE/X", "SET", ":CALCulate:MARKer5:X", "555555", ""),
        ("Keysight Technologies", "*", "MARKER/6/PLACE/X", "SET", ":CALCulate:MARKer6:X", "666666", ""),

        ("Keysight Technologies", "*", "MARKER/PLACE/ALL", "RIG", ":CALCulate:MARKer1:STATe ON;:CALCulate:MARKer2:STATe ON;:CALCulate:MARKer3:STATe ON;:CALCulate:MARKer4:STATe ON;:CALCulate:MARKer5:STATe ON;:CALCulate:MARKer6:STATe ON;:CALCulate:MARKer1:X 111,:CALCulate:MARKer2:X 222,:CALCulate:MARKer3:X 333;:CALCulate:MARKer4:X 444;:CALCulate:MARKer1:X 555;:CALCulate:MARKer6:X 666", "6", ""),
        ("Keysight Technologies", "*", "MARKER/PLACE/ALL", "BEG", ":CALCulate:MARKer1:STATe ON;:CALCulate:MARKer2:STATe ON;:CALCulate:MARKer3:STATe ON;:CALCulate:MARKer4:STATe ON;:CALCulate:MARKer5:STATe ON;:CALCulate:MARKer6:STATe ON;:CALCulate:MARKer1:X 111;:CALCulate:MARKer2:X 222;:CALCulate:MARKer3:X 333;:CALCulate:MARKer4:X 444;:CALCulate:MARKer5:X 555;:CALCulate:MARKer6:X 666;:CALCulate:MARKer1:Y?;:CALCulate:MARKer2:Y?;:CALCulate:MARKer3:Y?;:CALCulate:MARKer4:Y?;:CALCulate:MARKer5:Y?;:CALCulate:MARKer6:Y?", "6", ""),



        # Marker Calculate X (Frequency)
        ("Keysight Technologies", "*", "MARKER/1/CALCULATE/X", "GET", ":CALCulate:MARKer1:X", "?", ""),
        ("Keysight Technologies", "*", "MARKER/2/CALCULATE/X", "GET", ":CALCulate:MARKer2:X", "?", ""),
        ("Keysight Technologies", "*", "MARKER/3/CALCULATE/X", "GET", ":CALCulate:MARKer3:X", "?", ""),
        ("Keysight Technologies", "*", "MARKER/4/CALCULATE/X", "GET", ":CALCulate:MARKer4:X", "?", ""),
        ("Keysight Technologies", "*", "MARKER/5/CALCULATE/X", "GET", ":CALCulate:MARKer5:X", "?", ""),
        ("Keysight Technologies", "*", "MARKER/6/CALCULATE/X", "GET", ":CALCulate:MARKer6:X", "?", ""),


        


        # Marker Calculate Y (Amplitude)
        ("Keysight Technologies", "*", "MARKER/1/CALCULATE/Y", "GET", ":CALCulate:MARKer1:Y", "?", ""),
        ("Keysight Technologies", "*", "MARKER/2/CALCULATE/Y", "GET", ":CALCulate:MARKer2:Y", "?", ""),
        ("Keysight Technologies", "*", "MARKER/3/CALCULATE/Y", "GET", ":CALCulate:MARKer3:Y", "?", ""),
        ("Keysight Technologies", "*", "MARKER/4/CALCULATE/Y", "GET", ":CALCulate:MARKer4:Y", "?", ""),
        ("Keysight Technologies", "*", "MARKER/5/CALCULATE/Y", "GET", ":CALCulate:MARKer5:Y", "?", ""),
        ("Keysight Technologies", "*", "MARKER/6/CALCULATE/Y", "GET", ":CALCulate:MARKer6:Y", "?", ""),

        # Memory/Preset
        ("Keysight Technologies", "*", "MEMORY/PRESET/CATALOG", "GET", ":MMEMory:CATalog:STATe", "?", ""),
        ("Keysight Technologies", "*", "MEMORY/PRESET/LOAD", "SET", ":MMEMory:LOAD:STATe", "0", ""),
        ("Keysight Technologies", "*", "MEMORY/PRESET/STORE", "SET", ":MMEMory:STORe:STATe", "0", ""),
        
        ("Keysight Technologies", "*", "POWER/RESET", "DO", "SYSTem:POWer:RESet", "", ""),
    ]

#####################################
### File: OPEN-AIR\Instrument\visa\tab_instrument_child_visa_interpreter.py
#####################################
# tabs/Instrument/tab_instrument_child_visa_interpreter.py
#
# This file defines the VisaInterpreterTab, a Tkinter Frame that provides a user-editable
# cell editor for VISA commands. It displays model names, command types, actions, and the
# commands themselves, allowing users to modify, add, or remove entries, and execute
# selected commands directly on a connected instrument.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.175600.1
# FIXED: The Treeview now correctly displays all 7 columns of data from the updated file.
#        The cell editing functionality has also been updated to handle these new columns.

import tkinter as tk
from tkinter import ttk
import os
import inspect
from datetime import datetime
import threading
import time

from display.debug_logic import debug_log
from display.console_logic import console_log
from src.program_style import COLOR_PALETTE
from ref.ref_file_paths import VISA_COMMANDS_FILE_PATH
from .utils_visa_interpreter_files import initialize_data_file_and_load, save_visa_commands_data
from .utils_visa_interpreter_commands import VisaCommandExecutor

# --- Versioning ---
w = 20250821
x_str = '175600'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"{w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = f"{os.path.basename(__file__)}"


class VisaInterpreterTab(ttk.Frame):
    """
    VisaInterpreterTab provides a user-friendly interface for executing and managing
    VISA commands. It presents a treeview of commands, allowing for direct editing
    and execution on a connected instrument.
    """
    def __init__(self, parent, app_instance, console_print_func, *args, **kwargs):
        super().__init__(parent, *args, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func
        self.data = []
        self.sort_direction = {}
        self.last_selected_item = None
        
        # Instantiate the new command executor class
        self.command_executor = VisaCommandExecutor(app_instance, console_print_func)
        
        self.create_widgets()
        self.setup_layout()
        self.bind_events()
        
        # Call file utility to handle all file-related logic
        self.data = initialize_data_file_and_load()
        self.load_data_to_treeview()
        self._set_ui_initial_state()

        self.app_instance.bind("<<ConnectionStatusChanged>>", self._handle_connection_status_change_event)
        self._handle_connection_status_change_event()
        
        current_function = inspect.currentframe().f_code.co_name
        debug_log("VisaInterpreterTab initialized. Ready for battle! ⚔️",
                    file=current_file,
                    version=current_version,
                    function=current_function)

    def _set_ui_initial_state(self):
        self.status_label.configure(text="Status: Disconnected", foreground="red")
        self.command_entry.config(state=tk.DISABLED)
        self.execute_command_button.config(state=tk.DISABLED)
        self.query_button.config(state=tk.DISABLED)
        self.set_button.config(state=tk.DISABLED)
        self.do_button.config(state=tk.DISABLED)

    def _handle_connection_status_change_event(self, event=None):
        current_function = inspect.currentframe().f_code.co_name
        is_connected = self.app_instance.inst is not None
        instrument_model = self.app_instance.connected_instrument_model.get() if hasattr(self.app_instance, 'connected_instrument_model') else ""
        
        debug_log(f"Connection status changed event received: Connected={is_connected}, Model={instrument_model}. Updating UI state.",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        
        if is_connected:
            self.status_label.configure(text=f"Status: Connected to {instrument_model}", foreground="green")
            self.command_entry.config(state=tk.NORMAL)
            self.execute_command_button.config(state=tk.NORMAL)
            self.query_button.config(state=tk.NORMAL)
            self.set_button.config(state=tk.NORMAL)
            self.do_button.config(state=tk.NORMAL)
            self.console_print_func(f"✅ VISA Interpreter connected to instrument.")
        else:
            self.status_label.configure(text="Status: Disconnected", foreground="red")
            self.command_entry.config(state=tk.DISABLED)
            self.execute_command_button.config(state=tk.DISABLED)
            self.query_button.config(state=tk.DISABLED)
            self.set_button.config(state=tk.DISABLED)
            self.do_button.config(state=tk.DISABLED)
            self.console_print_func("❌ VISA Interpreter disconnected from instrument.")
    
    def load_data_to_treeview(self):
        """
        Loads data from the internal list into the Treeview widget.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log("Loading data from list to Treeview... 💾",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        
        for item in self.treeview.get_children():
            self.treeview.delete(item)
        
        for row in self.data:
            self.treeview.insert('', 'end', values=row)

        self.console_print_func(f"✅ Loaded {len(self.data)} entries into the table.")
        debug_log(f"Loaded {len(self.data)} entries into Treeview.",
                    file=current_file,
                    version=current_version,
                    function=current_function)

    def create_widgets(self):
        """
        Creates the UI widgets for the VisaInterpreterTab.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log("Creating widgets for VisaInterpreterTab...",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        self.columnconfigure(0, weight=1)
        self.rowconfigure(0, weight=1)
        self.rowconfigure(1, weight=0)

        main_frame = ttk.Frame(self)
        main_frame.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
        main_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(0, weight=1)

        tree_frame = ttk.Frame(main_frame)
        tree_frame.grid(row=0, column=0, sticky="nsew")
        tree_frame.rowconfigure(0, weight=1)
        tree_frame.columnconfigure(0, weight=1)

        # CORRECTED: Updated columns to display all 7 data fields
        columns = ("Manufacturer", "Model", "Command Type", "Action", "VISA Command", "Variable", "Validated")
        self.treeview = ttk.Treeview(tree_frame, columns=columns, show="headings")
        self.treeview.pack(side="left", fill="both", expand=True)

        for col in columns:
            self.treeview.heading(col, text=col, command=lambda c=col: self._sort_treeview(self.treeview, c))
            self.treeview.column(col, anchor="w", width=100)
            self.sort_direction[col] = 'asc'

        scrollbar = ttk.Scrollbar(tree_frame, orient="vertical", command=self.treeview.yview)
        self.treeview.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side="right", fill="y")
        
        control_frame = ttk.LabelFrame(self, text="Controls")
        control_frame.grid(row=1, column=0, sticky="ew", padx=10, pady=5)
        control_frame.columnconfigure(1, weight=1)

        self.status_label = ttk.Label(control_frame, text="Status: Disconnected", foreground="red")
        self.status_label.grid(row=0, column=0, columnspan=2, sticky="ew", padx=5, pady=2)

        ttk.Label(control_frame, text="Command:", style='TLabel').grid(row=1, column=0, sticky="w", padx=5, pady=2)
        self.command_entry = ttk.Entry(control_frame)
        self.command_entry.grid(row=1, column=1, sticky="ew", padx=5, pady=2)
        self.command_entry.bind('<Return>', lambda e: self.command_executor.on_execute_command(self.command_entry.get().strip()))

        button_frame = ttk.Frame(control_frame)
        button_frame.grid(row=2, column=0, columnspan=2, sticky="ew", padx=5, pady=5)
        button_frame.columnconfigure(0, weight=1)
        button_frame.columnconfigure(1, weight=1)
        button_frame.columnconfigure(2, weight=1)
        button_frame.columnconfigure(3, weight=1)

        self.execute_command_button = ttk.Button(button_frame, text="Execute", command=lambda: self.command_executor.on_execute_command(self.command_entry.get().strip()))
        self.execute_command_button.grid(row=0, column=0, sticky="ew", padx=2, pady=2)

        self.query_button = ttk.Button(button_frame, text="Query", command=lambda: self.command_executor.on_query_command(self.command_entry.get().strip()))
        self.query_button.grid(row=0, column=1, sticky="ew", padx=2, pady=2)
        
        self.set_button = ttk.Button(button_frame, text="Set", command=lambda: self.command_executor.on_set_command(self.command_entry.get().strip()))
        self.set_button.grid(row=0, column=2, sticky="ew", padx=2, pady=2)
        
        self.do_button = ttk.Button(button_frame, text="Do", command=lambda: self.command_executor.on_do_command(self.command_entry.get().strip()))
        self.do_button.grid(row=0, column=3, sticky="ew", padx=2, pady=2)

        action_frame = ttk.Frame(control_frame)
        action_frame.grid(row=3, column=0, columnspan=2, sticky="ew", padx=5, pady=5)
        action_frame.columnconfigure(0, weight=1)
        action_frame.columnconfigure(1, weight=1)
        action_frame.columnconfigure(2, weight=1)
        action_frame.columnconfigure(3, weight=1)

        ttk.Button(action_frame, text="Load Data", command=lambda: self._refresh_data()).grid(row=0, column=0, sticky="ew", padx=2, pady=2)
        ttk.Button(action_frame, text="Add New Row", command=self._add_new_row).grid(row=0, column=1, sticky="ew", padx=2, pady=2)
        ttk.Button(action_frame, text="Save Data", command=self._save_data_to_csv).grid(row=0, column=2, sticky="ew", padx=2, pady=2)
        ttk.Button(action_frame, text="Delete Row", command=self._delete_selected_row).grid(row=0, column=3, sticky="ew", padx=2, pady=2)
        
        debug_log("Widgets created successfully. All systems go! 🚀",
                    file=current_file,
                    version=current_version,
                    function=current_function)

    def setup_layout(self):
        self.grid_rowconfigure(0, weight=1)
        self.grid_columnconfigure(0, weight=1)

    def bind_events(self):
        self.treeview.bind("<Double-1>", self._on_double_click)
        self.treeview.bind("<<TreeviewSelect>>", self._on_treeview_select)
        self.treeview.bind("<FocusIn>", self._on_treeview_focus)

    def _on_treeview_focus(self, event):
        if not self.treeview.selection():
            if self.last_selected_item:
                self.treeview.selection_set(self.last_selected_item)
                self.treeview.focus(self.last_selected_item)

    def _on_treeview_select(self, event):
        selection = self.treeview.selection()
        if selection:
            self.last_selected_item = selection[0]
            values = self.treeview.item(self.last_selected_item, 'values')
            if values:
                self.command_entry.delete(0, tk.END)
                if len(values) > 4 and values[4] is not None:
                    self.command_entry.insert(0, values[4])

    def _on_double_click(self, event):
        item = self.treeview.identify_row(event.y)
        col = self.treeview.identify_column(event.x)
        if item and col:
            col_index = int(col.replace('#', '')) - 1
            column_name = self.treeview['columns'][col_index]

            # CORRECTED: Allow editing of VISA Command, Variable, and Validated columns
            editable_columns = ["VISA Command", "Variable", "Validated"]
            if column_name in editable_columns:
                self._edit_cell(item, col_index)

    def _edit_cell(self, item, col_index):
        x, y, width, height = self.treeview.bbox(item, col_index)
        
        values = self.treeview.item(item, 'values')
        original_text = values[col_index]

        entry = ttk.Entry(self.treeview)
        entry.place(x=x, y=y, width=width, height=height, anchor='nw')
        entry.insert(0, original_text)
        entry.focus_set()

        def on_entry_change(e):
            new_values = list(self.treeview.item(item, 'values'))
            new_values[col_index] = entry.get()
            self.treeview.item(item, values=new_values)
            entry.destroy()
            self.last_selected_item = item
            self._save_data_to_csv()

        def on_focus_out(e):
            entry.destroy()
            self._save_data_to_csv()

        entry.bind("<Return>", on_entry_change)
        entry.bind("<FocusOut>", on_focus_out)

    def _add_new_row(self):
        """
        Adds a new, empty row to the Treeview and the internal data list.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log("Adding a new empty row to the Treeview. A fresh start!",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        new_row = ["", "", "", "", "", "", ""]
        self.data.append(new_row)
        self.treeview.insert('', 'end', values=new_row)
        self.console_print_func("✅ New row added. Don't forget to save!")
        self._save_data_to_csv()
        debug_log("New row added and saved.",
                    file=current_file,
                    version=current_version,
                    function=current_function)

    def _delete_selected_row(self):
        """
        Deletes the currently selected row from the Treeview and the internal data list.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log("Attempting to delete the selected row. Goodbye, cruel data!",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        selected_item = self.treeview.selection()
        if not selected_item:
            self.console_print_func("❌ No row selected to delete. You must choose!")
            debug_log("Delete failed: No row selected.",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return

        for item in selected_item:
            values = self.treeview.item(item, 'values')
            self.treeview.delete(item)
            if list(values) in self.data:
                self.data.remove(list(values))
            self.console_print_func(f"✅ Row deleted: {values[2]} - {values[3]}")
        
        self._save_data_to_csv()
        debug_log("Row deleted and file saved.",
                    file=current_file,
                    version=current_version,
                    function=current_function)

    def _save_data_to_csv(self):
        """
        Saves the current data from the Treeview back to the CSV file.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log("Saving data to CSV file. Committing the changes to memory!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        
        current_data = [self.treeview.item(item, 'values') for item in self.treeview.get_children()]

        try:
            save_visa_commands_data(VISA_COMMANDS_FILE_PATH, current_data)
            self.console_print_func(f"✅ Saved data to {os.path.basename(VISA_COMMANDS_FILE_PATH)} successfully.")
            debug_log("Data saved successfully.",
                        file=current_file,
                        version=current_version,
                        function=current_function)
        except Exception as e:
            self.console_print_func(f"❌ Error saving data: {e}. Oh no, the data is lost!")
            debug_log(f"Error saving data to CSV: {e}.",
                        file=current_file,
                        version=current_version,
                        function=current_function)

    def _sort_treeview(self, tv, col):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Sorting Treeview by column '{col}'. Let's get this organized! 📚",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        items = list(tv.get_children(''))
        col_index = tv['columns'].index(col)

        is_numeric = False
        if items:
            try:
                float(tv.item(items[0], 'values')[col_index])
                is_numeric = True
            except (ValueError, IndexError):
                is_numeric = False

        direction = self.sort_direction.get(col, 'asc')
        reverse = (direction == 'desc')

        if is_numeric:
            def numeric_sort_key(x):
                try:
                    return float(tv.set(x, col))
                except (ValueError, IndexError):
                    return float('-inf')
            sorted_items = sorted(items, key=numeric_sort_key, reverse=reverse)
        else:
            sorted_items = sorted(items, key=lambda x: tv.set(x, col), reverse=reverse)

        for index, item in enumerate(sorted_items):
            tv.move(item, '', index)

        self.sort_direction[col] = 'asc' if reverse else 'desc'
        
        tv.heading(col, text=f"{col} ({'▲' if not reverse else '▼'})")
        debug_log(f"Treeview sorted by '{col}' in {'descending' if reverse else 'ascending'} order. All tidy now. ✅",
                    file=current_file,
                    version=current_version,
                    function=current_function)

    def _refresh_data(self):
        """Reloads data from the file and updates the treeview."""
        self.data = initialize_data_file_and_load()
        self.load_data_to_treeview()
        self.console_print_func("✅ Data reloaded from file.")
        debug_log("Data reloaded from file.",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)

#####################################
### File: OPEN-AIR\Instrument\visa\utils_visa_interpreter_commands.py
#####################################
# Instrument/utils_visa_interpreter_commands.py

# This file contains the core logic for executing and testing VISA commands via the
# VisaInterpreterTab. It abstracts all the low-level command execution, error handling,
# and console logging, allowing the GUI to remain a simple view layer. This module
# ensures the principle of separation of concerns is upheld.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.175300.1
# UPDATED: File created to house all VISA command execution and testing logic.

import inspect
import os
from datetime import datetime
import tkinter as tk

from yak.utils_yak_visa import query_safe, write_safe
from display.debug_logic import debug_log
from display.console_logic import console_log

# --- Versioning ---
w = 20250821
x_str = '175300'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"{w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = f"{os.path.basename(__file__)}"


class VisaCommandExecutor:
    """
    This class handles all execution and testing of VISA commands. It is instantiated
    by the VisaInterpreterTab and is responsible for all communication with the
    connected instrument.
    """
    def __init__(self, app_instance, console_print_func):
        self.app_instance = app_instance
        self.console_print_func = console_print_func

        current_function = inspect.currentframe().f_code.co_name
        debug_log("Initializing VisaCommandExecutor. The command-slinger is ready! 🤠",
                    file=current_file,
                    version=current_version,
                    function=current_function)

    def _get_instrument_status(self):
        """Checks if an instrument is connected and returns the status."""
        is_connected = self.app_instance.inst is not None
        if not is_connected:
            self.console_print_func("❌ No instrument connected. The command is a whisper to the wind!")
            debug_log("Command failed: No instrument connection.",
                        file=current_file,
                        version=current_version,
                        function=inspect.currentframe().f_code.co_name)
        return is_connected

    def on_execute_command(self, command):
        """Executes a command (query or write) based on its format."""
        if not self._get_instrument_status():
            return
        
        self.console_print_func(f"Executing: {command}...")
        
        if command.endswith('?'):
            response = query_safe(self.app_instance.inst, command, self.console_print_func)
            self.console_print_func(f"Response: {response}")
        else:
            write_safe(self.app_instance.inst, command, self.console_print_func)
            self.console_print_func("✅ Command sent.")
    
    def on_query_command(self, command):
        """Executes a query command and displays the response."""
        if not self._get_instrument_status():
            return
        
        if not command.endswith('?'):
            self.console_print_func(f"⚠️ Command '{command}' does not end with '?' for a query. Executing as a simple write.")
            self.on_execute_command(command)
            return

        self.console_print_func(f"Querying: {command}...")
        response = query_safe(self.app_instance.inst, command, self.console_print_func)
        self.console_print_func(f"Response: {response}")

    def on_set_command(self, command):
        """Executes a set command, which requires a value."""
        if not self._get_instrument_status():
            return

        parts = command.split(' ', 1)
        if len(parts) < 2:
            self.console_print_func("❌ SET command requires a value. Format: 'command value'.")
            debug_log("Set failed: Invalid command format.",
                        file=current_file,
                        version=current_version,
                        function=inspect.currentframe().f_code.co_name)
            return
            
        full_command = f"{parts[0]} {parts[1]}"
        self.console_print_func(f"Setting: {full_command}...")
        write_safe(self.app_instance.inst, full_command, self.console_print_func)
        self.console_print_func("✅ Set command sent.")
    
    def on_do_command(self, command):
        """Executes a 'do' command, which performs an action."""
        if not self._get_instrument_status():
            return

        self.console_print_func(f"Executing: {command}...")
        write_safe(self.app_instance.inst, command, self.console_print_func)
        self.console_print_func("✅ Do command sent.")

#####################################
### File: OPEN-AIR\Instrument\visa\utils_visa_interpreter_files.py
#####################################
# utils/utils_visa_interpreter_files.py
#
# This file contains all the core logic for handling file I/O operations related to the
# VISA Interpreter Tab. This includes creating the default data file if it doesn't exist,
# loading the data from the file, and saving the data back to it. This module ensures
# that the file handling is a separate, modular concern, as per project standards.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.175500.1
# UPDATED: This file now uses the definitive source of truth for default commands,
#          `ref_visa_commands.py`, and correctly handles the full 7-column data structure.

import os
import csv
import inspect
from datetime import datetime

from display.debug_logic import debug_log
from display.console_logic import console_log
from ref.ref_file_paths import VISA_COMMANDS_FILE_PATH, DATA_FOLDER_PATH
from .ref_visa_commands import get_default_visa_commands

# --- Versioning ---
w = 20250821
x_str = '175500'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"{w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = f"{os.path.basename(__file__)}"


def create_default_data_file(data_file):
    """
    Creates a new CSV file with default VISA command entries from the ref file.

    Inputs:
        data_file (str): The full path to the data file.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Creating default VISA commands CSV file at '{data_file}'. 📝",
                file=current_file,
                version=current_version,
                function=current_function)
    
    # Use the definitive source of truth for headers and data
    default_headers = ["Manufacturer", "Model", "Command Type", "Action", "VISA Command", "Variable", "Validated"]
    default_data = get_default_visa_commands()

    os.makedirs(os.path.dirname(data_file), exist_ok=True)
    with open(data_file, 'w', newline='', encoding='utf-8') as f:
        writer = csv.writer(f)
        writer.writerow(default_headers)
        writer.writerows(default_data)
    console_log(f"✅ Created new default file: {os.path.basename(data_file)}")
    debug_log("Default VISA commands CSV created.",
                file=current_file,
                version=current_version,
                function=current_function)

def load_visa_commands_data(data_file):
    """
    Loads data from the CSV file into a list of lists.
    This function is designed to handle the 7-column data from the `ref` file.

    Inputs:
        data_file (str): The full path to the data file.

    Outputs:
        list: A list of lists representing the CSV data.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log("Loading data from CSV... 💾",
                file=current_file,
                version=current_version,
                function=current_function)
    
    data = []
    try:
        with open(data_file, 'r', newline='', encoding='utf-8') as f:
            reader = csv.reader(f)
            headers = next(reader)
            for row in reader:
                # Ensure the data has the correct number of columns
                if len(row) == 7:
                    data.append(row)
                else:
                    debug_log(f"⚠️ Row has incorrect number of columns: {row}. Skipping.",
                                file=current_file,
                                version=current_version,
                                function=current_function)
        console_log(f"✅ Loaded {len(data)} entries from {os.path.basename(data_file)}.")
        debug_log(f"Loaded {len(data)} entries from CSV.",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return data
    except FileNotFoundError:
        console_log(f"❌ Error: {os.path.basename(data_file)} not found. This is a disaster!")
        debug_log("CSV file not found during load.",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return []
    except Exception as e:
        console_log(f"❌ Error loading data: {e}. This is a disaster!")
        debug_log(f"Error loading CSV data: {e}.",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return []

def save_visa_commands_data(data_file, data):
    """
    Saves the provided data to the CSV file.
    This function is designed to handle the 7-column data.

    Inputs:
        data_file (str): The full path to the data file.
        data (list): A list of lists containing the data to save.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log("Saving data to CSV file. Committing the changes to memory! 💾",
                file=current_file,
                version=current_version,
                function=current_function)
    
    headers = ["Manufacturer", "Model", "Command Type", "Action", "VISA Command", "Variable", "Validated"]
    try:
        with open(data_file, 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerow(headers)
            writer.writerows(data)
        console_log(f"✅ Saved data to {os.path.basename(data_file)} successfully.")
        debug_log("Data saved successfully.",
                    file=current_file,
                    version=current_version,
                    function=current_function)
    except Exception as e:
        console_log(f"❌ Error saving data: {e}. Oh no, the data is lost!")
        debug_log(f"Error saving data to CSV: {e}.",
                    file=current_file,
                    version=current_version,
                    function=current_function)

def initialize_data_file_and_load():
    """
    Ensures the VISA commands CSV file exists, populates it if it doesn't,
    and then loads its content.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log("Initializing data file and loading content... 💾",
                file=current_file,
                version=current_version,
                function=current_function)
    
    data_file_path = VISA_COMMANDS_FILE_PATH
    
    if not os.path.exists(data_file_path):
        console_log(f"ℹ️ {os.path.basename(data_file_path)} not found. Creating a new file with default entries.")
        debug_log(f"File '{os.path.basename(data_file_path)}' not found. Creating new file with defaults.",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        create_default_data_file(data_file_path)
    
    data = load_visa_commands_data(data_file_path)
    debug_log("Data file check and load completed. Ready to go! ✅",
                file=current_file,
                version=current_version,
                function=current_function)
    return data

#####################################
### File: OPEN-AIR\Markers\TAB_MARKERS_PARENT.py
#####################################
# FolderName/TAB_MARKERS_PARENT.py
#
# This file defines the TAB_MARKERS_PARENT class, which serves as a container
# for the 'Showtime' and 'Import & Edit' child tabs.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.140800.1
# FIXED: The AttributeError was fixed by adding `console_print_func` as a positional
#        argument and assigning it directly, resolving the race condition.
# FIXED: Added custom styling for the child notebook tabs to match the Markers' color palette.
# FIXED: Added missing versioning variables to resolve NameError in debug logging.

import tkinter as tk
from tkinter import ttk
import typing
import os
import inspect
from datetime import datetime
from display.debug_logic import debug_log
from display.console_logic import console_log
from src.program_style import COLOR_PALETTE, COLOR_PALETTE_TABS, _get_dark_color

# --- Versioning ---
w = 20250821
x = 140800
y = 1
current_version = f"Version {w}.{x}.{y}"
current_version_hash = (w * x * y)
current_file = f"{os.path.basename(__file__)}"

# Import the specific child tab classes
from .showtime.tab_markers_parent_showtime import ShowtimeParentTab
from .files.tab_markers_child_import_and_edit import ReportConverterTab

class TAB_MARKERS_PARENT(ttk.Frame):
    def __init__(self, parent_notebook, app_instance, console_print_func, *args, **kwargs):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                  file=f"{os.path.basename(__file__)}",
                  version=current_version,
                  function=current_function)

        try:
            super().__init__(parent_notebook, **kwargs)
            self.app_instance = app_instance
            self.parent_notebook = parent_notebook
            self.console_print_func = console_print_func
            
            # --- NEW: Apply custom styling for the child notebook tabs ---
            style = ttk.Style(self)
            active_color = COLOR_PALETTE_TABS['Markers']['active']
            inactive_color = _get_dark_color(active_color)
            
            style.configure('Markers.Child.TNotebook', background=COLOR_PALETTE['background'])
            style.map('Markers.Child.TNotebook.Tab',
                    background=[('selected', active_color),
                                ('!selected', inactive_color)],
                    foreground=[('selected', COLOR_PALETTE_TABS['Markers']['fg']),
                                ('!selected', 'white')])

            self.child_notebook = ttk.Notebook(self, style='Markers.Child.TNotebook')
            self.child_notebook.pack(expand=True, fill="both")

            self.showtime_tab = ShowtimeParentTab(self.child_notebook, self.app_instance, self.console_print_func)
            self.child_notebook.add(self.showtime_tab, text="Showtime")

            self.import_edit_tab = ReportConverterTab(self.child_notebook, self.app_instance)
            self.child_notebook.add(self.import_edit_tab, text="Import & Edit")

            # Bind the tab-change event to our handler
            self.child_notebook.bind("<<NotebookTabChanged>>", self._on_child_tab_selected)
            
            debug_log("Exiting __init__. Child tabs added.",
                      file=f"{os.path.basename(__file__)}",
                      version=current_version,
                      function=current_function)
        except Exception as e:
            console_log(f"❌ Error in TAB_MARKERS_PARENT initialization: {e}", "ERROR")
            debug_log(f"Arrr, the code be capsized! The error be: {e}",
                      file=f"{os.path.basename(__file__)}",
                      version=current_version,
                      function=current_function)
            raise

    def _on_child_tab_selected(self, event):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}", file=f"{os.path.basename(__file__)}", version=current_version, function=current_function)

        selected_child_tab_id = self.child_notebook.select()
        if selected_child_tab_id:
            selected_child_tab_widget = self.child_notebook.nametowidget(selected_child_tab_id)
            if hasattr(selected_child_tab_widget, '_on_tab_selected'):
                selected_child_tab_widget._on_tab_selected(event)

        debug_log(f"Exiting {current_function}", file=f"{os.path.basename(__file__)}", version=current_version, function=current_function)


    def _on_parent_tab_selected(self, event):
        # Handles the event when this parent tab is selected. It now also switches the display
        # pane to the "Monitor" tab automatically.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}", file=f"{os.path.basename(__file__)}", version=current_version, function=current_function)

        if hasattr(self.app_instance, 'display_parent_tab'):
            self.app_instance.display_parent_tab.change_display_tab("Monitor")

        # Delegate to the currently active child tab to ensure it is properly refreshed
        selected_child_tab_id = self.child_notebook.select()
        if selected_child_tab_id:
            selected_child_tab_widget = self.child_notebook.nametowidget(selected_child_tab_id)
            if hasattr(selected_child_tab_widget, '_on_tab_selected'):
                selected_child_tab_widget._on_tab_selected(event)
        debug_log(f"Exiting {current_function}", file=f"{os.path.basename(__file__)}", version=current_version, function=current_function)


#####################################
### File: OPEN-AIR\Markers\files\tab_markers_child_import_and_edit.py
#####################################
# tabs/Markers/tab_markers_child_import_and_edit.py
#
# This file manages the Report Converter tab in the GUI, handling
# It provides functionality to convert spectrum analyzer report files (HTML, SHW, or Soundbase PDF)
# into CSV format. Crucially, it now displays the converted data in an editable, sortable table
# (Treeview) and allows users to load, save, and save as MARKERS.CSV files directly.
# The previous text-based conversion log has been replaced by this data table.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
#
#
# Version 20250802.0055.1 (Fixed TclError: expected integer but got "" for Treeview rowheight.)
# Version 20250804.000014.0 (FIXED: Ensured MarkersDisplayTab reloads from file when updated by ReportConverterTab.)
# Version 20250804.000015.0 (FIXED: ReportConverterTab now explicitly tells MarkersDisplayTab to load_markers_from_file.)

current_version = "20250804.000015.0" # Incremented version
# current_version_hash = 20250802 * 55 * 1 # Example hash, needs adjustment based on new versioning format

import tkinter as tk
from tkinter import filedialog, ttk
import os
import csv
import xml.etree.ElementTree as ET
import sys
import inspect
import threading
import json 
import datetime 
import re 

# Import the new report converter utility functions
from ..files.utils_marker_report_converter import convert_html_report_to_csv, generate_csv_from_shw, convert_pdf_report_to_csv
from src.gui_elements import TextRedirector 
from display.debug_logic import debug_log 
from display.console_logic import console_log 
# Removed: from tabs.Markers.tab_markers_child_display import load_markers_from_file
# The load_markers_from_file from display tab will be called via the instance.


class ReportConverterTab(ttk.Frame):
    """
    A Tkinter Frame that provides functionality to convert spectrum analyzer
    report files (HTML, SHW, or Soundbase PDF) into CSV format.
    It now also displays the converted data in an editable, sortable table
    and allows loading/saving of MARKERS.CSV files.
    """
    def __init__(self, master=None, app_instance=None, console_print_func=None, **kwargs): # console_print_func will be removed later
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__) 
        debug_log(f"[{current_file} - {current_function}] Initializing ReportConverterTab...",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        # self.console_print_func is removed, using console_log directly

        self.output_csv_path = None # To store the path of the last generated/loaded CSV

        self.tree_headers = [] # Stores current headers of the Treeview
        self.tree_data = []    # Stores current data of the Treeview (list of dicts)
        self.sort_column = None # To keep track of the last sorted column
        self.sort_direction = False # True for ascending, False for descending

        self._create_widgets()


    def _create_widgets(self):
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__) 
        debug_log(f"[{current_file} - {current_function}] Creating ReportConverterTab widgets.",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(0, weight=0) 
        self.grid_rowconfigure(1, weight=1) 
        self.grid_rowconfigure(2, weight=0) 


        load_markers_frame = ttk.LabelFrame(self, text="Load Markers", padding=(5,5,5,5), style='Dark.TLabelframe')
        load_markers_frame.grid(row=0, column=0, padx=5, pady=5, sticky="ew")
        load_markers_frame.grid_columnconfigure(0, weight=1)
        load_markers_frame.grid_columnconfigure(1, weight=1)
        load_markers_frame.grid_columnconfigure(2, weight=1)
        load_markers_frame.grid_columnconfigure(3, weight=1) 

        self.load_csv_button = ttk.Button(load_markers_frame, text="Load CSV Marker Set", command=self._load_markers_file, style='Green.TButton')
        self.load_csv_button.grid(row=0, column=0, padx=2, pady=2, sticky="ew")

        self.load_ias_html_button = ttk.Button(load_markers_frame, text="Load IAS HTML", command=lambda: self._initiate_conversion("HTML"), style='Blue.TButton')
        self.load_ias_html_button.grid(row=0, column=1, padx=2, pady=2, sticky="ew")

        self.load_wwb_shw_button = ttk.Button(load_markers_frame, text="Load WWB.shw", command=lambda: self._initiate_conversion("SHW"), style='Blue.TButton')
        self.load_wwb_shw_button.grid(row=0, column=2, padx=2, pady=2, sticky="ew")

        self.load_sb_pdf_button = ttk.Button(load_markers_frame, text="Load SB PDF", command=lambda: self._initiate_conversion("PDF"), style='Blue.TButton')
        self.load_sb_pdf_button.grid(row=0, column=3, padx=2, pady=2, sticky="ew")


        marker_table_frame = ttk.LabelFrame(self, text="Marker Editor", padding=(5,5,5,5), style='Dark.TLabelframe')
        marker_table_frame.grid(row=1, column=0, padx=5, pady=5, sticky="nsew")
        marker_table_frame.grid_columnconfigure(0, weight=1)
        marker_table_frame.grid_rowconfigure(0, weight=1)

        self.marker_tree = ttk.Treeview(marker_table_frame, show="headings", style="Treeview")
        self.marker_tree.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)

        tree_yscroll = ttk.Scrollbar(marker_table_frame, orient="vertical", command=self.marker_tree.yview)
        tree_yscroll.grid(row=0, column=1, sticky="ns")
        self.marker_tree.configure(yscrollcommand=tree_yscroll.set)

        tree_xscroll = ttk.Scrollbar(marker_table_frame, orient="horizontal", command=self.marker_tree.xview)
        tree_xscroll.grid(row=1, column=0, sticky="ew")
        self.marker_tree.configure(xscrollcommand=tree_xscroll.set)

        self.marker_tree.bind("<Double-1>", self._on_tree_double_click) 
        self.marker_tree.bind("<ButtonRelease-1>", self._on_tree_header_click) 


        self.save_open_air_button = ttk.Button(self, text="Save Markers as Open Air.csv", command=self._save_open_air_csv, style='Orange.TButton')
        self.save_open_air_button.grid(row=2, column=0, padx=5, pady=5, sticky="ew")


    def _populate_marker_tree(self):
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__) 
        debug_log(f"[{current_file} - {current_function}] Populating marker treeview.",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        self.marker_tree.delete(*self.marker_tree.get_children())

        if not self.tree_headers:
            console_log("ℹ️ No headers available to display in Marker Editor table.", function=current_function)
            self.marker_tree["columns"] = ()
            return

        self.marker_tree["columns"] = self.tree_headers
        
        try:
            row_height_str = ttk.Style().lookup("Treeview", "rowheight")
            row_height = int(row_height_str) if row_height_str else 25 
        except (TclError, ValueError):
            row_height = 25 

        for col_name in self.tree_headers:
            self.marker_tree.heading(col_name, text=col_name, anchor="w")
            self.marker_tree.column(col_name, width=row_height * 5, stretch=tk.YES) 

        for i, row_data in enumerate(self.tree_data):
            values = [row_data.get(header, "") for header in self.tree_headers]
            self.marker_tree.insert("", "end", iid=str(i), values=values, tags=('editable',))

        console_log(f"✅ Displayed {len(self.tree_data)} rows in Marker Editor table.", function=current_function)
        debug_log(f"[{current_file} - {current_function}] Marker treeview populated with {len(self.tree_data)} rows.",
                    file=current_file,
                    version=current_version,
                    function=current_function)


    def _on_tree_double_click(self, event):
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__) 
        debug_log(f"[{current_file} - {current_function}] Treeview double-clicked for editing.",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        if not self.marker_tree.identify_region(event.x, event.y) == "cell":
            return 

        column_id = self.marker_tree.identify_column(event.x)
        item_id = self.marker_tree.identify_row(event.y)

        if not item_id or not column_id:
            return

        col_index = int(column_id[1:]) - 1
        if col_index < 0 or col_index >= len(self.tree_headers):
            debug_log(f"[{current_file} - {current_function}] Invalid column index {col_index} for editing.",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return

        current_value = self.marker_tree.item(item_id, 'values')[col_index]

        self._start_editing_cell(item_id, col_index, initial_value=current_value)


    def _start_editing_cell(self, item, col_index, initial_value=""):
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__) 

        for widget in self.marker_tree.winfo_children():
            if isinstance(widget, ttk.Entry) and widget.winfo_name() == "cell_editor":
                widget.destroy()

        entry_editor = ttk.Entry(self.marker_tree, style="Markers.TEntry", name="cell_editor")
        entry_editor.insert(0, initial_value)
        entry_editor.focus_force()

        x, y, width, height = self.marker_tree.bbox(item, self.marker_tree["columns"][col_index])
        entry_editor.place(x=x, y=y, width=width, height=height)

        entry_editor.current_item = item
        entry_editor.current_col_index = col_index

        def on_edit_complete_and_navigate(event, navigate_direction=None):
            new_value = entry_editor.get()
            entry_editor.destroy()

            current_values = list(self.marker_tree.item(item, 'values'))
            current_values[col_index] = new_value
            self.marker_tree.item(item, values=current_values)

            row_idx = int(item) 
            if row_idx < len(self.tree_data):
                self.tree_data[row_idx][self.tree_headers[col_index]] = new_value
                console_log(f"Updated cell: Row {row_idx+1}, Column '{self.tree_headers[col_index]}' to '{new_value}'", function=current_function)
                debug_log(f"[{current_file} - {current_function}] Updated tree_data[{row_idx}]['{self.tree_headers[col_index]}'] to '{new_value}'.",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                
                # Inform MarkersDisplayTab about the change and save
                self._update_markers_display_tab_data()
                self._save_markers_file_internally() 

            else:
                debug_log(f"[{current_file} - {current_function}] Error: Row index {row_idx} out of bounds for self.tree_data.",
                            file=current_file,
                            version=current_version,
                            function=current_function)

            if navigate_direction:
                self._navigate_cells(item, col_index, navigate_direction)

        entry_editor.bind("<Return>", lambda e: on_edit_complete_and_navigate(e, "down"))
        entry_editor.bind("<Tab>", lambda e: on_edit_complete_and_navigate(e, "right"))
        entry_editor.bind("<Shift-Tab>", lambda e: on_edit_complete_and_navigate(e, "left"))
        entry_editor.bind("<Control-Return>", lambda e: on_edit_complete_and_navigate(e, "ctrl_down"))
        entry_editor.bind("<FocusOut>", lambda e: on_edit_complete_and_navigate(e, None)) 
        entry_editor.bind("<Up>", lambda e: on_edit_complete_and_navigate(e, "up"))
        entry_editor.bind("<Down>", lambda e: on_edit_complete_and_navigate(e, "down"))
        entry_editor.bind("<Left>", lambda e: on_edit_complete_and_navigate(e, "left"))
        entry_editor.bind("<Right>", lambda e: on_edit_complete_and_navigate(e, "right"))


    def _navigate_cells(self, current_item, current_col_index, direction):
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__) 
        debug_log(f"[{current_file} - {current_function}] Navigating cells.",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        items = self.marker_tree.get_children()
        num_rows = len(items)
        num_cols = len(self.tree_headers)

        current_row_idx = items.index(current_item) if current_item in items else -1
        
        next_item = None
        next_col_index = -1
        initial_value_for_next_cell = "" 

        if current_row_idx == -1:
            debug_log(f"[{current_file} - {current_function}] Current item not found in tree for navigation.",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return

        if direction == "down":
            next_row_idx = current_row_idx + 1
            next_col_index = current_col_index
            if next_row_idx < num_rows:
                next_item = items[next_row_idx]
        elif direction == "up": 
            next_row_idx = current_row_idx - 1
            next_col_index = current_col_index
            if next_row_idx >= 0:
                next_item = items[next_row_idx]
        elif direction == "right":
            next_col_index = current_col_index + 1
            if next_col_index < num_cols:
                next_item = current_item
            else: 
                next_row_idx = current_row_idx + 1
                if next_row_idx < num_rows:
                    next_item = items[next_row_idx]
                    next_col_index = 0 
        elif direction == "left":
            next_col_index = current_col_index - 1
            if next_col_index >= 0:
                next_item = current_item
            else: 
                next_row_idx = current_row_idx - 1
                if next_row_idx >= 0:
                    next_item = items[next_row_idx]
                    next_col_index = num_cols - 1 
        elif direction == "ctrl_down":
            next_row_idx = current_row_idx + 1
            next_col_index = current_col_index
            if next_row_idx < num_rows:
                next_item = items[next_row_idx]
                prev_cell_value = self.marker_tree.item(current_item, 'values')[current_col_index]
                initial_value_for_next_cell = self._increment_string_with_trailing_digits(prev_cell_value)
            else:
                debug_log(f"[{current_file} - {current_function}] Cannot Ctrl+Enter: No row below.",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return

        if next_item is not None and next_col_index != -1:
            if direction != "ctrl_down":
                try:
                    next_item_values = self.marker_tree.item(next_item, 'values')
                    if 0 <= next_col_index < len(next_item_values):
                        initial_value_for_next_cell = next_item_values[next_col_index]
                    else:
                        debug_log(f"[{current_file} - {current_function}] Next column index {next_col_index} out of bounds for next item values. Setting empty.",
                                    file=current_file,
                                    version=current_version,
                                    function=current_function)
                        initial_value_for_next_cell = "" 
                except Exception as e:
                    debug_log(f"[{current_file} - {current_function}] Error getting initial value for next cell: {e}. Setting empty.",
                                file=current_file,
                                version=current_version,
                                function=current_function)
                    initial_value_for_next_cell = "" 

            self.marker_tree.focus(next_item)
            self.marker_tree.selection_set(next_item)
            self.app_instance.after(10, lambda: self._start_editing_cell(next_item, next_col_index, initial_value_for_next_cell))
        else:
            debug_log(f"[{current_file} - {current_function}] No cell to navigate to in direction: {direction}",
                        file=current_file,
                        version=current_version,
                        function=current_function)


    def _increment_string_with_trailing_digits(self, text):
        match = re.search(r'(\d+)$', text)
        if match:
            num_str = match.group(1)
            num_int = int(num_str)
            incremented_num = num_int + 1
            new_num_str = str(incremented_num).zfill(len(num_str))
            return text[:-len(num_str)] + new_num_str
        return text


    def _on_tree_header_click(self, event):
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__) 
        debug_log(f"[{current_file} - {current_function}] Treeview header clicked for sorting.",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        region = self.marker_tree.identify_region(event.x, event.y)
        if region == "heading":
            column_id = self.marker_tree.identify_column(event.x)
            col_index = int(column_id[1:]) - 1
            if col_index < 0 or col_index >= len(self.tree_headers):
                debug_log(f"[{current_file} - {current_function}] Invalid column index {col_index} for sorting.",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return

            column_name = self.tree_headers[col_index]

            if self.sort_column == column_name:
                self.sort_direction = not self.sort_direction 
            else:
                self.sort_column = column_name
                self.sort_direction = True 

            self._sort_treeview(column_name, self.sort_direction)


    def _sort_treeview(self, column_name, ascending):
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__) 
        debug_log(f"[{current_file} - {current_function}] Sorting treeview by '{column_name}', ascending: {ascending}.",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        def get_sort_key(item):
            value = item.get(column_name, "")
            try:
                return float(value)
            except ValueError:
                return str(value)

        self.tree_data.sort(key=get_sort_key, reverse=not ascending)

        self._populate_marker_tree()
        console_log(f"Sorted by '{column_name}' {'Ascending' if ascending else 'Descending'}.", function=current_function)


    def _load_markers_file(self):
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__) 
        debug_log(f"[{current_file} - {current_function}] Loading MARKERS.CSV file (Load Marker Set button)...",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        initial_dir = os.path.dirname(self.app_instance.MARKERS_FILE_PATH) if self.app_instance and hasattr(self.app_instance, 'MARKERS_FILE_PATH') else os.getcwd()

        file_path = filedialog.askopenfilename(
            title="Load MARKERS.CSV File",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
            initialdir=initial_dir
        )
        if not file_path:
            console_log("ℹ️ Info: Load Marker Set cancelled.", function=current_function)
            return

        self._disable_buttons() 
        try:
            headers = []
            rows = []
            with open(file_path, mode='r', newline='', encoding='utf-8') as csvfile:
                reader = csv.DictReader(csvfile)
                headers = reader.fieldnames
                for row_data in reader:
                    rows.append(row_data)

            if headers and rows:
                self.tree_headers = headers
                self.tree_data = rows
                self.app_instance.after(0, self._populate_marker_tree) 
                self.output_csv_path = file_path 
                console_log(f"✅ Successfully loaded {len(rows)} markers from '{os.path.basename(file_path)}'.", function=current_function)
                debug_log(f"[{current_file} - {current_function}] Loaded {len(rows)} markers from '{file_path}'.",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                
                self._update_markers_display_tab_data()
                self._save_markers_file_internally()
            else:
                console_log("ℹ️ Info: Selected CSV file is empty or has no data.", function=current_function)
                debug_log(f"[{current_file} - {current_function}] Selected CSV file '{file_path}' is empty.",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                self.tree_headers = []
                self.tree_data = []
                self.app_instance.after(0, self._populate_marker_tree) 
        except Exception as e:
            console_log(f"❌ Error loading CSV: {e}", function=current_function)
            debug_log(f"[{current_file} - {current_function}] Error loading CSV from '{file_path}': {e}",
                        file=current_file,
                        version=current_version,
                        function=current_function)
        finally:
            self.app_instance.after(0, self._enable_buttons) 


    def _save_markers_file_internally(self): 
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__) 
        debug_log(f"[{current_file} - {current_function}] Saving current marker data to internal MARKERS.CSV...",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        if not self.tree_data:
            debug_log(f"[{current_file} - {current_function}] No data to save to internal MARKERS.CSV. Creating empty file if headers exist.",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            if self.tree_headers:
                markers_file_path = self.app_instance.MARKERS_FILE_PATH
                output_dir = os.path.dirname(markers_file_path)
                try:
                    os.makedirs(output_dir, exist_ok=True)
                    with open(markers_file_path, 'w', newline='', encoding='utf-8') as csvfile:
                        writer = csv.DictWriter(csvfile, fieldnames=self.tree_headers)
                        writer.writeheader()
                    self.output_csv_path = markers_file_path
                    console_log(f"✅ Auto-saved empty MARKERS.CSV with headers to '{os.path.basename(markers_file_path)}'.", function=current_function)
                    debug_log(f"[{current_file} - {current_function}] Auto-saved empty MARKERS.CSV with headers to '{markers_file_path}'.",
                                file=current_file,
                                version=current_version,
                                function=current_function)
                except Exception as e:
                    console_log(f"❌ Error creating empty internal MARKERS.CSV: {e}", function=current_function)
                    debug_log(f"[{current_file} - {current_function}] Error creating empty internal MARKERS.CSV at '{markers_file_path}': {e}",
                                file=current_file,
                                version=current_version,
                                function=current_function)
            return

        markers_file_path = self.app_instance.MARKERS_FILE_PATH
        output_dir = os.path.dirname(markers_file_path) 

        if not markers_file_path:
            console_log("⚠️ Warning: Internal MARKERS.CSV path not configured. Cannot save automatically.", function=current_function)
            debug_log(f"[{current_file} - {current_function}] Internal MARKERS.CSV path not configured. Cannot save.",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return

        try:
            os.makedirs(output_dir, exist_ok=True) 
            with open(markers_file_path, 'w', newline='', encoding='utf-8') as csvfile:
                writer = csv.DictWriter(csvfile, fieldnames=self.tree_headers)
                writer.writeheader()
                writer.writerows(self.tree_data)
            self.output_csv_path = markers_file_path 
            console_log(f"✅ Auto-saved MARKERS.CSV to '{os.path.basename(markers_file_path)}'.", function=current_function)
            debug_log(f"[{current_file} - {current_function}] Auto-saved MARKERS.CSV to '{markers_file_path}'.",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            
            # --- NEW: Explicitly trigger reload in MarkersDisplayTab after saving ---
            self._update_markers_display_tab_data() # This will now call load_markers_from_file on the display tab
            # --- END NEW ---

        except Exception as e:
            console_log(f"❌ Error auto-saving internal MARKERS.CSV: {e}", function=current_function)
            debug_log(f"[{current_file} - {current_function}] Error auto-saving internal MARKERS.CSV to '{markers_file_path}': {e}",
                        file=current_file,
                        version=current_version,
                        function=current_function)


    def _save_open_air_csv(self):
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__) 
        debug_log(f"[{current_file} - {current_function}] Saving Markers as Open_Air_Markers.csv...",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        if not self.tree_data:
            console_log("ℹ️ Info: No data to save.", function=current_function)
            return

        scan_name = ""
        if self.app_instance and hasattr(self.app_instance, 'scan_name_var'):
            scan_name = self.app_instance.scan_name_var.get().strip()
            if scan_name:
                scan_name = f" - {scan_name}" 

        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M")

        default_filename = f"Open_Air_Markers{scan_name} - {timestamp}.csv"

        initial_dir = os.path.dirname(self.app_instance.MARKERS_FILE_PATH) if self.app_instance and hasattr(self.app_instance, 'MARKERS_FILE_PATH') else os.getcwd()

        file_path = filedialog.asksaveasfilename(
            title="Save Markers as Open Air CSV",
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
            initialdir=initial_dir, 
            initialfile=default_filename
        )
        if not file_path:
            console_log("ℹ️ Info: Save As cancelled.", function=current_function)
            return

        self._disable_buttons() 
        try:
            with open(file_path, 'w', newline='', encoding='utf-8') as csvfile:
                writer = csv.DictWriter(csvfile, fieldnames=self.tree_headers)
                writer.writeheader()
                writer.writerows(self.tree_data)
            console_log(f"✅ Successfully saved markers to '{os.path.basename(file_path)}'.", function=current_function)
            debug_log(f"[{current_file} - {current_function}] Saved markers to '{file_path}'.",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            
            # --- NEW: Explicitly trigger reload in MarkersDisplayTab after saving to a *new* file ---
            # This is important if "Save As" changes the primary MARKERS.CSV
            # If the user saves to a *different* file, the MarkersDisplayTab should still reflect the main MARKERS.CSV
            # So, we should trigger a reload of the *main* MARKERS.CSV.
            self._update_markers_display_tab_data() # This will call load_markers_from_file on the display tab
            # --- END NEW ---

        except Exception as e:
            console_log(f"❌ Error saving markers: {e}", function=current_function)
            debug_log(f"[{current_file} - {current_function}] Error saving markers to '{file_path}': {e}",
                        file=current_file,
                        version=current_version,
                        function=current_function)
        finally:
            self.app_instance.after(0, self._enable_buttons) 


    def _disable_buttons(self):
        self.load_csv_button.config(state=tk.DISABLED)
        self.load_ias_html_button.config(state=tk.DISABLED)
        self.load_wwb_shw_button.config(state=tk.DISABLED)
        self.load_sb_pdf_button.config(state=tk.DISABLED)
        self.save_open_air_button.config(state=tk.DISABLED)


    def _enable_buttons(self):
        self.load_csv_button.config(state=tk.NORMAL)
        self.load_ias_html_button.config(state=tk.NORMAL)
        self.load_wwb_shw_button.config(state=tk.NORMAL)
        self.load_sb_pdf_button.config(state=tk.NORMAL)
        self.save_open_air_button.config(state=tk.NORMAL)


    def _initiate_conversion(self, file_type):
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__) 
        debug_log(f"[{current_file} - {current_function}] Initiating conversion for type: {file_type}.",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        file_types_map = {
            "HTML": [("HTML files", "*.html"), ("All files", "*.*")],
            "SHW": [("SHW files", "*.shw"), ("XML files", "*.xml"), ("All files", "*.*")],
            "PDF": [("PDF files", "*.pdf"), ("All files", "*.*")]
        }
        title_map = {
            "HTML": "Select IAS HTML Report File",
            "SHW": "Select WWB.shw Report File",
            "PDF": "Select Soundbase PDF Report File"
        }

        file_path = filedialog.askopenfilename(
            title=title_map.get(file_type, "Select Report File"),
            filetypes=file_types_map.get(file_type, [("All files", "*.*")])
        )
        if not file_path:
            console_log(f"ℹ️ Info: {file_type} conversion cancelled.", function=current_function)
            return

        self._disable_buttons()
        conversion_thread = threading.Thread(target=self._perform_conversion, args=(file_path, file_type))
        conversion_thread.daemon = True
        conversion_thread.start()


    def _perform_conversion(self, file_path, file_type):
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__) 
        console_log(f"Processing '{os.path.basename(file_path)}'...", function=current_function)
        debug_log(f"[{current_file} - {current_function}] Performing conversion for {file_path} (type: {file_type}) in thread.",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        headers = []
        rows = []
        error_message = None
        # output_csv_path is now handled by _save_markers_file_internally

        try:
            file_name = os.path.basename(file_path)
            # No longer using output_dir from app_instance for MARKERS.CSV operations
            # Instead, ensure the directory for MARKERS_FILE_PATH exists
            markers_dir = os.path.dirname(self.app_instance.MARKERS_FILE_PATH)
            os.makedirs(markers_dir, exist_ok=True)

            if file_type == 'HTML':
                console_log("Detected HTML file. Converting...", function=current_function)
                with open(file_path, 'r', encoding='utf-8') as f:
                    html_content = f.read()
                headers, rows = convert_html_report_to_csv(html_content, console_print_func=console_log) 
            elif file_type == 'SHW':
                console_log("Detected SHW file. Converting...", function=current_function)
                headers, rows = generate_csv_from_shw(file_path, console_print_func=console_log) 
            elif file_type == 'PDF':
                console_log("Detected PDF file. Converting...", function=current_function)
                headers, rows = convert_pdf_report_to_csv(file_path, console_print_func=console_log) 
            else:
                error_message = f"Unsupported file type: {file_type}. This should not happen."
                console_log(f"❌ {error_message}", function=current_function)
                debug_log(f"Unsupported file type: {file_type}",
                            file=current_file,
                            version=current_version,
                            function=current_function)

            if not error_message and headers and rows:
                # Update the Treeview with the new data
                self.tree_headers = headers
                self.tree_data = rows
                self.app_instance.after(0, self._populate_marker_tree) # Update GUI on main thread

                # Call the method on the main App instance to update the Markers Display tab
                self._update_markers_display_tab_data()
                # NEW: Save the converted data to MARKERS.CSV immediately
                self._save_markers_file_internally() 

                console_log(f"\n✅ Successfully converted '{file_name}' and saved to MARKERS.CSV.", function=current_function)
            else:
                error_message = f"No relevant data could be extracted from '{file_name}'. CSV file was not created."
                console_log(f"🚫 {error_message}", function=current_function)

        except FileNotFoundError as e:
            error_message = f"File not found: {e}"
            console_log(f"❌ {error_message}", function=current_function)
        except ET.ParseError as e:
            error_message = f"Error parsing XML (SHW) file: {e}"
            console_log(f"❌ {error_message}", function=current_function)
        except Exception as e:
            error_message = f"An unexpected error occurred during conversion: {e}"
            console_log(f"❌ {error_message}", function=current_function)
        
        finally:
            if error_message:
                debug_log(f"Conversion failed for {file_name}: {error_message}",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                self.app_instance.after(0, lambda: console_log(f"❌ Conversion failed for {file_name}. See Report Converter Log for details.", function=current_function))
            self.app_instance.after(0, self._enable_buttons)


    def _update_markers_display_tab_data(self):
        """
        Function Description:
        This method is called to propagate the current marker data
        from the Report Converter Tab (marker editor) to the Markers Display Tab.
        It finds the MarkersDisplayTab instance and calls its `load_markers_from_file` method.
        This ensures the display tab always reloads from the saved MARKERS.CSV.

        Inputs to this function:
        - None
        """
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__) 
        debug_log(f"[{current_file} - {current_function}] Attempting to tell Markers Display Tab to reload its data from file...",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        if self.app_instance and hasattr(self.app_instance, 'markers_parent_tab') and \
           hasattr(self.app_instance.markers_parent_tab, 'markers_display_tab') and \
           self.app_instance.markers_parent_tab.markers_display_tab is not None:
            try:
                # NEW: Call MarkersDisplayTab's load_markers_from_file() to make it read from disk
                self.app_instance.markers_parent_tab.markers_display_tab.load_markers_from_file()
                console_log("✅ Markers Display Tab signaled to reload data.", function=current_function)
                debug_log(f"[{current_file} - {current_function}] Signaled MarkersDisplayTab to reload its data from file. 🎉",
                            file=current_file,
                            version=current_version,
                            function=current_function)
            except Exception as e:
                console_log(f"❌ Error signaling Markers Display Tab to reload: {e}", function=current_function)
                debug_log(f"[{current_file} - {current_function}] Error signaling MarkersDisplayTab to reload: {e}. Fucking hell, what went wrong now?!",
                            file=current_file,
                            version=current_version,
                            function=current_function)
        else:
            console_log("⚠️ Warning: Markers Display Tab instance not found or accessible in app_instance. Cannot signal reload.", function=current_function)
            debug_log(f"[{current_file} - {current_function}] MarkersDisplayTab instance not found in app_instance. Current app_instance attributes: {dir(self.app_instance)}. This is a goddamn mess!",
                        file=current_file,
                        version=current_version,
                        function=current_function)

    def _on_tab_selected(self, event):
        """
        Callback when this tab is selected. Ensures the marker tree is populated
        if MARKERS.CSV exists in the designated internal data folder.
        """
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__) 
        console_log("ReportConverterTab selected. Checking for MARKERS.CSV in internal data folder...", function=current_function)
        debug_log(f"[{current_file} - {current_function}] ReportConverterTab selected. Checking for MARKERS.CSV in internal data folder...",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        markers_file_path = None
        if self.app_instance and hasattr(self.app_instance, 'MARKERS_FILE_PATH'):
            markers_file_path = self.app_instance.MARKERS_FILE_PATH
            debug_log(f"[{current_file} - {current_function}] Attempting to load MARKERS.CSV from configured internal path: {markers_file_path}",
                        file=current_file,
                        version=current_version,
                        function=current_function)
        else:
            console_log("⚠️ Warning: App instance or MARKERS_FILE_PATH not available. Cannot check for MARKERS.CSV.", function=current_function)
            debug_log(f"[{current_file} - {current_function}] App instance or MARKERS_FILE_PATH not available. Cannot check for MARKERS.CSV.",
                        file=current_file,
                        version=current_version,
                        function=current_function)

        if markers_file_path and os.path.exists(markers_file_path):
            debug_log(f"[{current_file} - {current_function}] MARKERS.CSV found at: {markers_file_path}",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            try:
                headers = []
                rows = []
                with open(markers_file_path, mode='r', newline='', encoding='utf-8') as csvfile:
                    reader = csv.DictReader(csvfile)
                    headers = reader.fieldnames
                    for row_data in reader:
                        rows.append(row_data)

                if headers and rows:
                    self.tree_headers = headers
                    self.tree_data = rows
                    self._populate_marker_tree()
                    self.output_csv_path = markers_file_path 
                    console_log(f"✅ Displayed {len(rows)} markers from MARKERS.CSV.", function=current_function)
                else:
                    console_log("ℹ️ Info: The MARKERS.CSV file was found but contains no data.", function=current_function)
                    self.tree_headers = []
                    self.tree_data = []
                    self._populate_marker_tree() 
            except Exception as e:
                console_log(f"❌ Error loading MARKERS.CSV for display: {e}", function=current_function)
                debug_log(f"[{current_file} - {current_function}] Error loading MARKERS.CSV for display: {e}",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                self.tree_headers = []
                self.tree_data = []
                self._populate_marker_tree() 
        else:
            console_log("ℹ️ Info: MARKERS.CSV not found in internal data folder. Table is empty.", function=current_function)
            self.tree_headers = []
            self.tree_data = []
            self._populate_marker_tree()

#####################################
### File: OPEN-AIR\Markers\files\utils_file_markers_handling.py
#####################################
# tabs/Markers/utils_markers_file_handling.py
#
# This file contains functions for handling file-related operations, specifically
# for the MARKERS.CSV file. It centralizes the logic for loading, saving, and
# processing marker data.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250814.153000.1

current_version = "20250814.153000.1"
current_version_hash = (20250814 * 153000 * 1)

import os
import inspect
import pandas as pd
import numpy as np

from display.debug_logic import debug_log

def load_and_process_markers(app_instance, console_print_func):
    # [A brief, one-sentence description of the function's purpose.]
    # This is the main orchestrator function that loads the CSV and processes it
    # into the two data structures required by the Showtime tab.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Entering {current_function}. Orchestrating the loading and processing of MARKERS.CSV.",
              file=f"{os.path.basename(__file__)} - {current_version}",
              version=current_version,
              function=current_function)

    df, success, message = load_markers_data(app_instance, console_print_func)
    console_print_func(message)

    if not success or df.empty:
        return {}, {} # Return empty dicts on failure

    # 1. Create the markers_data dictionary (keyed by unique name)
    markers_data_dict = {}
    df['NAME'] = df['NAME'].fillna(pd.Series([f"Unnamed_{i}" for i in range(len(df))]))

    for index, row in df.iterrows():
        unique_name = row['NAME']
        try:
            freq_mhz = float(row.get('FREQ', 0))
        except (ValueError, TypeError):
            freq_mhz = 0
        
        markers_data_dict[unique_name] = {
            'frequency_mhz': freq_mhz,
            'zone': row.get('ZONE', 'Unknown'),
            'group': row.get('GROUP', 'Ungrouped'),
            'device': row.get('DEVICE', ''),
            'peak': row.get('Peak', None)
        }

    # 2. Create the zones dictionary using the helper function
    zones_dict = _group_by_zone_and_group(df)

    debug_log(f"✅ Successfully parsed CSV into {len(markers_data_dict)} devices and {len(zones_dict)} zones.",
              file=f"{os.path.basename(__file__)} - {current_version}",
              version=current_version,
              function=current_function)
              
    return markers_data_dict, zones_dict


def load_markers_data(app_instance, console_print_func):
    # [A brief, one-sentence description of the function's purpose.]
    # Loads marker data from the internal MARKERS.CSV file.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Entering {current_function}. Loading markers data from CSV. Let's see what we've got!",
              file=f"{os.path.basename(__file__)} & {current_version}",
              version=current_version,
              function=current_function)

    markers_data = pd.DataFrame()
    
    if app_instance and hasattr(app_instance, 'MARKERS_FILE_PATH'):
        path = app_instance.MARKERS_FILE_PATH
        debug_log(f"Attempting to load markers from path: {path}",
                  file=f"{os.path.basename(__file__)} & {current_version}",
                  version=current_version,
                  function=current_function)
        if os.path.exists(path):
            try:
                markers_data = pd.read_csv(path)
                return markers_data, True, f"✅ Loaded {len(markers_data)} markers from MARKERS.CSV."
            except pd.errors.EmptyDataError:
                return pd.DataFrame(), False, "⚠️ MARKERS.CSV is empty. No marker data to display."
            except Exception as e:
                return pd.DataFrame(), False, f"❌ Error loading MARKERS.CSV: {e}"
        else:
            return pd.DataFrame(), False, "ℹ️ MARKERS.CSV not found. Please create one."
    
    return pd.DataFrame(), False, "❌ Application instance or file path not available."


def _group_by_zone_and_group(data):
    # [A brief, one-sentence description of the function's purpose.]
    # Groups marker data by zone and then by group.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Entering {current_function}. Grouping marker data by zone and group.",
              file=f"{os.path.basename(__file__)} & {current_version}",
              version=current_version,
              function=current_function)

    if data.empty:
        return {}

    data['GROUP'] = data['GROUP'].fillna('No Group')
    data['ZONE'] = data['ZONE'].fillna('No Zone')

    zones = {}
    for zone, zone_data in data.groupby('ZONE'):
        groups = {group: group_data['NAME'].tolist() for group, group_data in zone_data.groupby('GROUP')}
        
        min_freq = zone_data['FREQ'].min()
        max_freq = zone_data['FREQ'].max()
        if pd.notna(min_freq) and pd.notna(max_freq) and max_freq > min_freq:
            span_hz = (max_freq - min_freq) * 1_000_000 
        else:
            span_hz = 1_000_000 # Default span
        
        groups['span_hz'] = span_hz
        zones[zone] = groups
    
    debug_log(f"✅ Successfully grouped data into {len(zones)} zones.",
              file=f"{os.path.basename(__file__)} & {current_version}",
              version=current_version,
              function=current_function)

    return zones

#####################################
### File: OPEN-AIR\Markers\files\utils_marker_report_converter.py
#####################################
# tabs/Markers/report_converter_utils.py
#
# This file contains utility functions for converting various spectrum analyzer
# report formats (HTML, SHW, Soundbase PDF) into a standardized CSV format.
# This version specifically restores the logic from the previously provided
# 'old_report_converter_utils.py' and adapts it to the new logging system.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
# Version 20250815.200000.3 (FIXED: The headers for CSV conversions now include a "Peak" column with a placeholder value to prevent data loss.)

import csv
import subprocess
import sys
import xml.etree.ElementTree as ET
import os
import re
from bs4 import BeautifulSoup
import pdfplumber
import inspect
import numpy as np

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log


def convert_html_report_to_csv(html_content, console_print_func=None):
    """
    Converts the HTML frequency coordination report into a list of dictionaries
    suitable for CSV output, handling multiple zones. This version is based on
    the IAS HTML to CSV.py prototype for accurate extraction.
    All frequencies are converted to MHz for consistency.

    Inputs:
        html_content (str): The full HTML content of the report.
        console_print_func (function, optional): A function to use for printing messages
                                                 to the console. If None, uses standard print.

    Returns:
        tuple: A tuple containing:
               - list: A list of strings representing the CSV headers.
               - list: A list of dictionaries, where each dictionary represents a row
                       in the CSV and keys are column headers.
    """
    _print = console_print_func if console_print_func else print
    current_function = inspect.currentframe().f_code.co_name
    current_file = os.path.basename(__file__) # Get current file name for debug_log

    _print("Starting HTML report conversion...")
    debug_log("Starting HTML report conversion.", file=current_file, function=current_function)

    soup = BeautifulSoup(html_content, 'html.parser')
    
    csv_headers = [
        "ZONE",
        "GROUP",
        "DEVICE",
        "NAME",
        "FREQ",
        "Peak" # NEW: Added Peak header
    ]
    
    data_rows = []

    # Find the main content area within the HTML, based on the IAS prototype.
    main_content_container = None
    
    first_zone_p = soup.find('p', style=lambda value: value and 'font-size: large' in value and 'text-decoration: underline' in value)

    if first_zone_p:
        main_content_container = first_zone_p.find_parent('span')
        _print(f"Found main content container based on first zone paragraph.")
        debug_log(f"Found main content container based on first zone paragraph.", file=current_file, function=current_function)
    
    if not main_content_container:
        main_table = soup.find('table', class_='MainTable')
        if main_table:
            main_table_trs = main_table.find_all('tr')
            if len(main_table_trs) > 1:
                second_tr_td = main_table_trs[1].find('td')
                if second_tr_td:
                    potential_span_wrapper = second_tr_td.find('span')
                    if potential_span_wrapper:
                        main_content_container = potential_span_wrapper
                    else:
                        main_content_container = second_tr_td
                    _print(f"Found main content container based on MainTable structure.")
                    debug_log(f"Found main content container based on MainTable structure.", file=current_file, function=current_function)
    
    if not main_content_container:
        _print("Warning: Could not find the main content container. No data will be extracted.")
        debug_log("Warning: Could not find the main content container. No data will be extracted.", file=current_file, function=current_function)
        return csv_headers, data_rows

    current_zone_type = ""
    # Iterate through the children of the identified main content container
    for element in main_content_container.children:
        if element.name == 'p' and element.get('style') and \
           'font-size: large' in element.get('style') and \
           'text-decoration: underline' in element.get('style'):
            zone_text = element.get_text(strip=True)
            if zone_text.startswith("Zone:"):
                current_zone_type = zone_text.replace("Zone:", "").strip()
                _print(f"Processing Zone: {current_zone_type}")
                debug_log(f"Processing Zone: {current_zone_type}", file=current_file, function=current_function)
        
        elif element.name == 'table' and 'Assignment' in element.get('class', []):
            table = element
            
            device_name_tag = table.find('th')
            current_group_name = device_name_tag.get_text(strip=True) if device_name_tag else ""
            _print(f"  Processing Group: {current_group_name}")
            debug_log(f"Processing Group: {current_group_name}", file=current_file, function=current_function)

            rows_in_table = table.find_all('tr')[1:] # Skip the first row as it contains the <th> (device_name)
            debug_log(f"Found {len(rows_in_table)} rows in current table.", file=current_file, function=current_function)

            for row in rows_in_table:
                data_spans = row.find_all('span')
                
                if data_spans:
                    for data_span in data_spans:
                        cells = data_span.find_all('td')
                        if len(cells) >= 4:
                            band_type = cells[0].get_text(strip=True)
                            
                            channel_frequency_tag = cells[3].find('b')
                            channel_frequency_str = channel_frequency_tag.get_text(strip=True) if channel_frequency_tag else ""

                            channel_name = cells[1].get_text(strip=True)
                            if not channel_name:
                                channel_name = cells[2].get_text(strip=True)
                            
                            # Convert frequency string to MHz
                            freq_mhz = "N/A"
                            try:
                                freq_match = re.search(r'(\d+(\.\d+)?)\s*(kHz|MHz|GHz)', channel_frequency_str, re.IGNORECASE)
                                if freq_match:
                                    value = float(freq_match.group(1))
                                    unit = freq_match.group(3).lower()
                                    if unit == 'mhz':
                                        freq_mhz = value
                                    elif unit == 'ghz':
                                        freq_mhz = value * 1000 # GHz to MHz
                                    elif unit == 'khz':
                                        freq_mhz = value / 1000 # kHz to MHz
                                    debug_log(f"HTML Freq conversion: '{channel_frequency_str}' -> {freq_mhz} MHz", file=current_file, function=current_function)
                                else:
                                    # Fallback if regex doesn't match, assume MHz
                                    freq_mhz = float(channel_frequency_str) # Assume it's already in MHz
                                    _print(f"WARNING (HTML): No unit found for '{channel_frequency_str}'. Assuming MHz.")
                                    debug_log(f"HTML Freq conversion (fallback): '{channel_frequency_str}' -> {freq_mhz} MHz", file=current_file, function=current_function)
                            except ValueError:
                                _print(f"WARNING (HTML): Could not convert frequency '{channel_frequency_str}' to float. Setting to 'Invalid Frequency'.")
                                debug_log(f"HTML Freq conversion error: '{channel_frequency_str}'", file=current_file, function=current_function)
                                freq_mhz = "Invalid Frequency"

                            row_data = {
                                "ZONE": current_zone_type,
                                "GROUP": current_group_name,
                                "DEVICE": band_type,
                                "NAME": channel_name,
                                "FREQ": freq_mhz, # Store in MHz
                                "Peak": np.nan # NEW: Added Peak column
                            }
                            if band_type or channel_frequency_str or channel_name:
                                data_rows.append(row_data)
                                debug_log(f"Added HTML row: {row_data}", file=current_file, function=current_function)
                else:
                    # Process rows that have <td>s directly (e.g., blank rows or specific structures without inner spans)
                    cells = row.find_all('td')
                    if len(cells) >= 4: 
                        band_type = cells[0].get_text(strip=True)
                        channel_frequency_tag = cells[3].find('b')
                        channel_frequency_str = channel_frequency_tag.get_text(strip=True) if channel_frequency_tag else ""
                        
                        channel_name = cells[1].get_text(strip=True)
                        if not channel_name:
                            channel_name = cells[2].get_text(strip=True)

                        # Convert frequency string to MHz
                        freq_mhz = "N/A"
                        try:
                            freq_match = re.search(r'(\d+(?:\.\d+)?)\s*(?:(k|m|g)?hz)?', channel_frequency_str, re.IGNORECASE)
                            if freq_match:
                                value = float(freq_match.group(1))
                                unit_group = freq_match.group(3)
                                if unit_group:
                                    unit = unit_group.lower()
                                    if unit == 'm': # MHz
                                        freq_mhz = value
                                    elif unit == 'g': # GHz
                                        freq_mhz = value * 1000
                                    elif unit == 'k': # kHz
                                        freq_mhz = value / 1000
                                else: # No unit specified, assume MHz
                                    freq_mhz = value
                                debug_log(f"HTML Freq conversion (direct td): '{channel_frequency_str}' -> {freq_mhz} MHz", file=current_file, function=current_function)
                            else:
                                # Fallback if regex doesn't match, assume MHz
                                freq_mhz = float(channel_frequency_str) # Assume it's already in MHz
                                _print(f"WARNING (HTML): No unit found for '{channel_frequency_str}'. Assuming MHz.")
                                debug_log(f"HTML Freq conversion (direct td, fallback): '{channel_frequency_str}' -> {freq_mhz} MHz", file=current_file, function=current_function)
                        except ValueError:
                            _print(f"WARNING (HTML): Could not convert frequency '{channel_frequency_str}' to float. Setting to 'Invalid Frequency'.")
                            debug_log(f"HTML Freq conversion error (direct td): '{channel_frequency_str}'", file=current_file, function=current_function)
                            freq_mhz = "Invalid Frequency"

                        row_data = {
                            "ZONE": current_zone_type,
                            "GROUP": current_group_name,
                            "DEVICE": band_type,
                            "NAME": channel_name,
                            "FREQ": freq_mhz, # Store in MHz
                            "Peak": np.nan # NEW: Added Peak column
                        }
                        if band_type or channel_frequency_str or channel_name:
                            data_rows.append(row_data)
                            debug_log(f"Added HTML row (direct td): {row_data}", file=current_file, function=current_function)
    _print(f"Finished HTML report conversion. Extracted {len(data_rows)} rows.")
    debug_log(f"Finished HTML report conversion. Extracted {len(data_rows)} rows.", file=current_file, function=current_function)
    return csv_headers, data_rows


def generate_csv_from_shw(xml_file_path, console_print_func=None):
    """
    Parses an SHW (XML) file and extracts frequency data, converting it
    into a standardized CSV format. This version is based on the SHOW to CSV.py
    prototype for accurate extraction of ZONE and GROUP.
    All frequencies are converted to MHz for consistency.

    Inputs:
        xml_file_path (str): The full path to the SHW (XML) file.
        console_print_func (function, optional): A function to use for printing messages
                                                 to the console. If None, uses standard print.
    Outputs:
        tuple: A tuple containing:
               - headers (list): A list of strings representing the CSV header row.
               - csv_data (list): A list of dictionaries, where each dictionary
                                  represents a row of data with keys matching the headers.
    Raises:
        FileNotFoundError: If the specified XML file does not exist.
        xml.etree.ElementTree.ParseError: If the XML file is malformed.
        Exception: For other parsing or data extraction errors.
    """
    _print = console_print_func if console_print_func else print
    current_function = inspect.currentframe().f_code.co_name
    current_file = os.path.basename(__file__)

    _print(f"Starting SHW report conversion for '{os.path.basename(xml_file_path)}'...")
    debug_log(f"Starting SHW report conversion for '{os.path.basename(xml_file_path)}'.", file=current_file, function=current_function)

    headers = ["ZONE", "GROUP", "DEVICE", "NAME", "FREQ", "Peak"] # NEW: Added Peak header
    csv_data = []

    try:
        with open(xml_file_path, 'r', encoding='utf-8') as f:
            tree = ET.parse(f)
        root = tree.getroot()
        _print("XML file parsed successfully.")
        debug_log("XML file parsed successfully.", file=current_file, function=current_function)

        # Iterate through 'freq_entry' elements
        for i, freq_entry in enumerate(root.findall('.//freq_entry')):
            if i % 100 == 0: # Print progress every 100 entries
                _print(f"  Processing SHW entry {i}...")
                debug_log(f"Processing SHW entry {i}...", file=current_file, function=current_function)

            # Reverting ZONE and GROUP extraction to match SHOW to CSV.py prototype
            zone_element = freq_entry.find('compat_key/zone')
            zone = zone_element.text if zone_element is not None else "N/A"

            group = freq_entry.get('tag', "N/A") # Extract GROUP from the 'tag' attribute of freq_entry
            
            # Extract DEVICE (manufacturer, model, band)
            manufacturer = freq_entry.find('manufacturer').text if freq_entry.find('manufacturer') is not None else "N/A"
            model = freq_entry.find('model').text if freq_entry.find('model') is not None else "N/A"
            band_element = freq_entry.find('compat_key/band') 
            band = band_element.text if band_element is not None else "N/A"
            device = f"{manufacturer} - {model} - {band}"

            # Extract NAME
            name_element = freq_entry.find('source_name')
            name = name_element.text if name_element is not None else "N/A"

            # Extract FREQ from value. User states SHW files contain markers in KHZ.
            freq_element = freq_entry.find('value')
            freq_mhz = "N/A"
            if freq_element is not None and freq_element.text is not None:
                freq_str = freq_element.text 
                
                debug_log(f"DEBUG (SHW): Processing freq_str: '{freq_str}' for device '{name}'", file=current_file, function=current_function)

                try:
                    # Convert kHz to MHz as per user's clarification
                    freq_mhz = float(freq_str) / 1000.0 
                    debug_log(f"SHW Freq conversion: '{freq_str}' kHz -> {freq_mhz} MHz", file=current_file, function=current_function)
                except ValueError:
                    _print(f"WARNING (SHW): Could not convert SHW frequency value '{freq_str}' to float. Setting to 'Invalid Frequency'.")
                    debug_log(f"SHW Freq conversion error: '{freq_str}'", file=current_file, function=current_function)
                    freq_mhz = "Invalid Frequency"

            csv_data.append({
                "ZONE": zone,
                "GROUP": group,
                "DEVICE": device,
                "NAME": name,
                "FREQ": freq_mhz, # Store in MHz
                "Peak": np.nan # NEW: Added Peak column
            })
        _print(f"Finished SHW report conversion. Extracted {len(csv_data)} rows.")
        debug_log(f"Finished SHW report conversion. Extracted {len(csv_data)} rows.", file=current_file, function=current_function)
        return headers, csv_data

    except FileNotFoundError:
        _print(f"Error: The file '{xml_file_path}' was not found.")
        debug_log(f"Error: The file '{xml_file_path}' was not found.", file=current_file, function=current_function)
        raise FileNotFoundError(f"The file '{xml_file_path}' was not found.")
    except ET.ParseError as e:
        _print(f"Error: Malformed XML (SHW) file '{xml_file_path}': {e}")
        debug_log(f"Error: Malformed XML (SHW) file '{xml_file_path}': {e}", file=current_file, function=current_function)
        raise ET.ParseError(f"Error parsing XML (SHW) file '{xml_file_path}': {e}")
    except Exception as e:
        _print(f"Error during SHW conversion data extraction: {e}")
        debug_log(f"Error during SHW conversion data extraction: {e}", file=current_file, function=current_function)
        raise

def convert_pdf_report_to_csv(pdf_file_path, console_print_func=None):
    """
    Parses a PDF file (Sound Base format) and extracts frequency data, converting it
    into a standardized CSV format. This function maps PDF fields to the MARKERS.CSV
    structure as follows:
    - PDF 'Group' -> CSV 'ZONE'
    - PDF 'Model' -> CSV 'GROUP'
    - PDF 'Name' -> CSV 'NAME'
    - PDF 'Frequency' -> CSV 'FREQ' (in MHz)
    - CSV 'DEVICE' is constructed from PDF 'Model', 'Band', and 'Preset'.

    Inputs:
        pdf_file_path (str): The full path to the PDF file.
        console_print_func (function, optional): A function to use for printing messages
                                                 to the console. If None, uses standard print.
    Outputs:
        tuple: A tuple containing:
               - headers (list): A list of strings representing the CSV header row.
               - csv_data (list): A list of dictionaries, where each dictionary
                                  represents a row of data with keys matching the headers.
    Raises:
        FileNotFoundError: If the specified PDF file does not exist.
        Exception: For other parsing or data extraction errors.
    """
    _print = console_print_func if console_print_func else print
    current_function = inspect.currentframe().f_code.co_name
    current_file = os.path.basename(__file__)

    _print(f"Starting PDF report conversion for '{os.path.basename(pdf_file_path)}'...")
    debug_log(f"Starting PDF report conversion for '{os.path.basename(pdf_file_path)}'.", file=current_file, function=current_function)

    headers = ["ZONE", "GROUP", "DEVICE", "NAME", "FREQ", "Peak"] # NEW: Added Peak header
    csv_data = []

    try:
        with pdfplumber.open(pdf_file_path) as pdf:
            last_known_group = "Uncategorized" # Default group if not found
            _print(f"Opened PDF with {len(pdf.pages)} pages.")
            debug_log(f"Opened PDF with {len(pdf.pages)} pages.", file=current_file, function=current_function)

            for page_num, page in enumerate(pdf.pages):
                _print(f"  Processing Page {page_num + 1}...")
                debug_log(f"Processing Page {page_num + 1}...", file=current_file, function=current_function)
                # Extract text for group headers
                lines = page.extract_text().splitlines()
                lines = [line.strip() for line in lines if line.strip()]

                group_headers = [(i, line) for i, line in enumerate(lines)
                                 if re.match(r".+\(\d+ frequencies\)", line)]

                tables = page.extract_tables()
                debug_log(f"Found {len(tables)} tables on Page {page_num + 1}.", file=current_file, function=current_function)

                group_index = 0
                for table_num, table in enumerate(tables):
                    if group_index < len(group_headers):
                        last_known_group = group_headers[group_index][1]
                        group_index += 1

                    current_zone = last_known_group # PDF Group -> CSV ZONE
                    _print(f"      Processing Table {table_num + 1} for Zone: {current_zone}")
                    debug_log(f"Processing Table {table_num + 1} for Zone: {current_zone}", file=current_file, function=current_function)

                    for row_num, row in enumerate(table):
                        if not row or all(cell is None or cell.strip() == "" for cell in row):
                            continue

                        if "Model" in row[0] and "Frequency" in row[-1]: # Skip header rows
                            debug_log(f"Skipping header row: {row}", file=current_file, function=current_function)
                            continue

                        clean_row = [cell.replace("\n", " ").strip() if cell else "" for cell in row]
                        # Ensure row has at least 6 elements to unpack safely
                        while len(clean_row) < 6:
                            clean_row.append("")

                        model_pdf, band_pdf, name_pdf, preset_pdf, spacing_pdf, frequency_pdf_str = clean_row

                        if model_pdf.strip() == current_zone.strip(): # Skip rows that mistakenly repeat the group name
                            debug_log(f"Skipping duplicate group name row: {row}", file=current_file, function=current_function)
                            continue

                        # Map PDF fields to CSV fields
                        zone_csv = current_zone
                        group_csv = model_pdf # PDF Model -> CSV GROUP

                        # Construct DEVICE from PDF Model, Band, Preset
                        device_csv = f"{model_pdf}"
                        if band_pdf:
                            device_csv += f" - {band_pdf}"
                        if preset_pdf:
                            device_csv += f" - {preset_pdf}"
                        
                        name_csv = name_pdf # PDF Name -> CSV NAME

                        freq_mhz_csv = "N/A"
                        try:
                            # The frequency is already in MHz, so no conversion needed
                            freq_mhz_csv = float(frequency_pdf_str)
                            debug_log(f"PDF Freq conversion: '{frequency_pdf_str}' -> {freq_mhz_csv} MHz", file=current_file, function=current_function)
                        except ValueError:
                            _print(f"WARNING (PDF): Could not convert PDF frequency value '{frequency_pdf_str}' to float (MHz). Setting to 'Invalid Frequency'.")
                            debug_log(f"PDF Freq conversion error: '{frequency_pdf_str}'", file=current_file, function=current_function)
                            freq_mhz_csv = "Invalid Frequency"

                        csv_data.append({
                            "ZONE": zone_csv,
                            "GROUP": group_csv,
                            "DEVICE": device_csv,
                            "NAME": name_csv,
                            "FREQ": freq_mhz_csv,
                            "Peak": np.nan # NEW: Added Peak column
                        })
                        debug_log(f"Added PDF row: {csv_data[-1]}", file=current_file, function=current_function)
        _print(f"Finished PDF report conversion. Extracted {len(csv_data)} rows.")
        debug_log(f"Finished PDF report conversion. Extracted {len(csv_data)} rows.", file=current_file, function=current_function)
        return headers, csv_data

    except FileNotFoundError:
        _print(f"Error: The file '{pdf_file_path}' was not found.")
        debug_log(f"Error: The file '{pdf_file_path}' was not found.", file=current_file, function=current_function)
        raise FileNotFoundError(f"The file '{pdf_file_path}' was not found.")
    except Exception as e:
        _print(f"Error during PDF conversion data extraction: {e}")
        debug_log(f"Error during PDF conversion data extraction: {e}", file=current_file, function=current_function)
        raise


#####################################
### File: OPEN-AIR\Markers\showtime\tab_markers_parent_showtime.py
#####################################
# tabs/Markers/showtime/tab_markers_parent_showtime.py
#
# This file defines the Showtime tab. It assembles the main UI components
# by combining the ZoneGroupsDevicesFrame and the ControlsFrame.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250823.235500.1
# REFACTORED: The ControlsFrame constructor call no longer passes a `shared_state`
#             parameter, resolving a `TypeError` and aligning with the new architecture.

import tkinter as tk
from tkinter import ttk
import os
import inspect
from datetime import datetime

from display.debug_logic import debug_log
from display.console_logic import console_log


from ..showtime.zones_groups_devices.tab_markers_child_zone_groups_devices import ZoneGroupsDevicesFrame
from ..showtime.controls.tab_markers_parent_bottom_controls import ControlsFrame

# --- Versioning ---
w = 20250823
x_str = '235500'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"

class ShowtimeParentTab(ttk.Frame):
    def __init__(self, parent_notebook, app_instance, console_print_func):
        # [Initializes the Showtime tab, setting up the main frames and shared state.]
        super().__init__(parent_notebook)
        self.app_instance = app_instance
        self.console_print_func = console_print_func
        
        # --- UI Element References ---
        self.span_buttons = {}
        self.rbw_buttons = {}
        self.trace_buttons = {}
        self.device_buttons = {}
        self.zone_zoom_buttons = {}

        # --- Tkinter State Variables ---
        self.span_var = tk.StringVar(value="1M")
        self.rbw_var = tk.StringVar(value="300k")
        self.poke_freq_var = tk.StringVar(value="")
        self.follow_zone_span_var = tk.BooleanVar(value=False)
        
        # Labels for the Zone Zoom functionality
        self.zone_zoom_label_left_var = tk.StringVar(value="Select Zone/Group/Device")
        self.zone_zoom_label_center_var = tk.StringVar(value="N/A")
        self.zone_zoom_label_right_var = tk.StringVar(value="N/A")

        # Toggles for trace modes
        self.toggle_get_all_traces = tk.BooleanVar(value=False)
        self.toggle_get_live_trace = tk.BooleanVar(value=True)
        self.toggle_get_max_traces = tk.BooleanVar(value=False)
        
        self.trace_modes = {
            'live': self.toggle_get_live_trace,
            'max': self.toggle_get_max_traces,
            'all': self.toggle_get_all_traces
        }

        # --- Selection State ---
        self.selected_zone = None
        self.selected_group = None
        self.selected_device_info = None
        self.last_selected_button = None
        self.active_device_button = None
        self.last_selected_type = None

        # NEW: Variables to store information about the selected zone/group
        self.selected_zone_info = {
            'min_freq': 0.0,
            'max_freq': 0.0,
            'device_count': 0
        }

        self.selected_group_info = {
            'min_freq': 0.0,
            'max_freq': 0.0,
            'device_count': 0
        }
        
        # NEW: Variables for the window buffer
        self.buffer_var = tk.StringVar(value="3")
        self.buffered_start_var = tk.DoubleVar(value=0.0)
        self.buffered_stop_var = tk.DoubleVar(value=0.0)

        self._create_widgets()
        self.bind("<<NotebookTabChanged>>", self._on_tab_selected)

    def _create_widgets(self):
        # [Creates and packs the main UI components for the Showtime tab.]
        content_frame = ttk.Frame(self, style='Main.TFrame')
        content_frame.pack(expand=True, fill='both')

        # NEW: Configure the content_frame's grid to allow the top row to expand
        content_frame.grid_rowconfigure(0, weight=1)
        content_frame.grid_columnconfigure(0, weight=1)

        self.zgd_frame = ZoneGroupsDevicesFrame(
            parent_frame=content_frame,
            showtime_tab_instance=self,
        )
        self.zgd_frame.grid(row=0, column=0, sticky="nsew")

        # FIXED: Removed the now-defunct 'shared_state' argument from the constructor.
        self.controls_frame = ControlsFrame(
            parent_frame=content_frame,
            showtime_tab_instance=self
        )
        self.controls_frame.grid(row=1, column=0, sticky="ew")

        # The parent grid configuration is no longer needed here as content_frame handles its own layout
        # self.grid_rowconfigure(0, weight=1)
        # self.grid_columnconfigure(0, weight=1)

    def _on_tab_selected(self, event):
        # [Handles the event when this tab is selected.]
        try:
            self.zgd_frame.load_and_display_data()
            console_log("✅ Showtime tab refreshed.")
        except Exception as e:
            console_log(f"❌ Error during Showtime tab selection: {e}")
            raise


#####################################
### File: OPEN-AIR\Markers\showtime\controls\tab_markers_child_control_poke.py
#####################################
# tabs/Markers/showtime/controls/tab_markers_child_control_poke.py
#
# This file defines the Poke tab for the ControlsFrame.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.000100.1
# REFACTORED: Removed dependency on `shared_state` object. State is now accessed from the `showtime_tab_instance`.

import os
import inspect
import tkinter as tk
from tkinter import ttk
from datetime import datetime

from display.debug_logic import debug_log
from .utils_showtime_poke import on_poke_action

# --- Versioning ---
w = 20250824
x_str = '000100'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"

class PokeTab(ttk.Frame):
    def __init__(self, parent_notebook, showtime_tab_instance):
        # [Initializes the Poke control tab.]
        debug_log(f"🖥️ 🟢 Entering __init__",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        
        super().__init__(parent_notebook)
        self.showtime_tab_instance = showtime_tab_instance
        self._create_widgets()
        
        debug_log(f"🖥️ 🟢 Exiting __init__",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)

    def _create_widgets(self):
        # [Creates the UI elements for the Poke tab.]
        debug_log(f"🖥️ 🟢 Creating widgets for PokeTab.",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        
        self.poke_entry = ttk.Entry(self, textvariable=self.showtime_tab_instance.poke_freq_var, style='TEntry')
        self.poke_button = ttk.Button(
            self, text="Poke", style='ControlButton.TButton',
            command=lambda: on_poke_action(self.showtime_tab_instance)
        )
        self.poke_entry.pack(side='left', fill='x', expand=True, padx=(0, 5))
        self.poke_button.pack(side='left')
        
        debug_log(f"🖥️ ✅ Widgets created successfully.",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)


#####################################
### File: OPEN-AIR\Markers\showtime\controls\tab_markers_child_control_rbw.py
#####################################
# tabs/Markers/showtime/controls/tab_markers_child_control_rbw.py
#
# Author: Anthony Peter Kuzub
# ... (Full header included)
#
# Version 20250824.000100.1
# REFACTORED: Removed dependency on `shared_state` object. State is now accessed from the `showtime_tab_instance`.

import tkinter as tk
import os
from tkinter import ttk
# Moved import inside method to fix circular import error
# from .utils_showtime_rbw import on_rbw_button_click
from ref.ref_scanner_setting_lists import PRESET_BANDWIDTH_RBW
from display.debug_logic import debug_log
from display.console_logic import console_log
import inspect
from datetime import datetime

# --- Versioning ---
w = 20250824
x = 100
y = 1
current_version = f"Version {w}.{x}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"

# --- Constants for formatting ---
KHZ_TO_HZ = 1_000
MHZ_TO_HZ = 1_000_000

class RBWTab(ttk.Frame):
    def __init__(self, parent_notebook, showtime_tab_instance):
        debug_log(f"🖥️ 🟢 Entering __init__",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        
        super().__init__(parent_notebook)
        self.showtime_tab_instance = showtime_tab_instance

        self._create_widgets()
        
        debug_log(f"🖥️ 🟢 Exiting __init__",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)

    def _create_widgets(self):
        # FIXED: Moved import here to resolve circular import.
        from .utils_showtime_rbw import on_rbw_button_click

        debug_log(f"🖥️ 🟢 Creating widgets for RBWTab.",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        
        self.showtime_tab_instance.rbw_buttons.clear()
        for i, rbw_data in enumerate(PRESET_BANDWIDTH_RBW):
            label = rbw_data.get("label", "N/A")
            value = rbw_data.get("value", 0)

            # Format the button text to show the label and the value
            if value >= MHZ_TO_HZ:
                value_text = f"{value / MHZ_TO_HZ:.3f} MHz"
            elif value >= KHZ_TO_HZ:
                value_text = f"{value / KHZ_TO_HZ:.0f} kHz"
            else:
                value_text = f"{value} Hz"
                
            button_text = f"{label}\n{value_text}"

            btn = ttk.Button(
                self, text=button_text, style='ControlButton.TButton',
                # FIXED: Pass the main showtime_tab_instance, not self
                command=lambda v=value: on_rbw_button_click(self.showtime_tab_instance, v)
            )
            btn.grid(row=0, column=i, sticky='ew', padx=2, pady=2)
            self.showtime_tab_instance.rbw_buttons[str(value)] = btn
        self.grid_columnconfigure(list(range(len(PRESET_BANDWIDTH_RBW))), weight=1)
        
        debug_log(f"🖥️ ✅ Widgets created successfully.",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)


#####################################
### File: OPEN-AIR\Markers\showtime\controls\tab_markers_child_control_span.py
#####################################
# tabs/Markers/showtime/controls/tab_markers_child_control_span.py
#
# This file defines the Span tab for the ControlsFrame.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: [https://like.audio/category/software/spectrum-scanner/](https://like.audio/category/software/spectrum-scanner/)
# Source Code: [https://github.com/APKaudio/](https://github.com/APKaudio/)
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.001000.1
# REFACTORED: Removed dependency on `shared_state` object. State is now accessed from the `showtime_tab_instance`.

import os
import inspect
import tkinter as tk
from tkinter import ttk
from datetime import datetime

from display.debug_logic import debug_log
from ref.ref_scanner_setting_lists import PRESET_FREQUENCY_SPAN
from .utils_showtime_span import on_span_button_click

# --- Versioning ---
w = 20250824
x = 1000
y = 1
current_version = f"Version {w}.{x}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"

# --- Constants for formatting ---
MHZ_TO_HZ = 1_000_000

class SpanTab(ttk.Frame):
    def __init__(self, parent_notebook, showtime_tab_instance):
        # [Initializes the Span control tab.]
        debug_log(f"🖥️ 🟢 Entering __init__",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        
        super().__init__(parent_notebook)
        self.showtime_tab_instance = showtime_tab_instance
        self._create_widgets()
        
        debug_log(f"🖥️ 🟢 Exiting __init__",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        
    def _create_widgets(self):
        # [Creates the UI elements for the Span tab.]
        debug_log(f"🖥️ 🟢 Creating widgets for SpanTab.",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        
        self.showtime_tab_instance.span_buttons.clear()

        for i, span_data in enumerate(PRESET_FREQUENCY_SPAN):
            label = span_data.get("label", "N/A")
            value = span_data.get("value", 0)
            
            # Format the button text to show the label and the value in MHz
            button_text = f"{label}\n{value / MHZ_TO_HZ:.3f} MHz"

            btn = ttk.Button(
                self, text=button_text, style='ControlButton.TButton',
                command=lambda v=value: on_span_button_click(self.showtime_tab_instance, v)
            )
            btn.grid(row=0, column=i, sticky='ew', padx=2, pady=2)
            self.showtime_tab_instance.span_buttons[str(value)] = btn

        self.grid_columnconfigure(list(range(len(PRESET_FREQUENCY_SPAN))), weight=1)

        debug_log(f"🖥️ ✅ Widgets created successfully.",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)


#####################################
### File: OPEN-AIR\Markers\showtime\controls\tab_markers_child_control_traces.py
#####################################
# tabs/Markers/showtime/controls/tab_markers_child_control_traces.py
#
# This file defines the Trace tab for the ControlsFrame.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: [https://like.audio/category/software/spectrum-scanner/](https://like.audio/category/software/spectrum-scanner/)
# Source Code: [https://github.com/APKaudio/](https://github.com/APKaudio/)
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.001000.1
# REFACTORED: Removed dependency on `shared_state` object. State is now accessed from the `showtime_tab_instance`.

import os
import inspect
import tkinter as tk
from tkinter import ttk
from datetime import datetime

from display.debug_logic import debug_log
# FIXED: Defer import to avoid circular dependency
# from .utils_showtime_trace import execute_trace_action

# --- Versioning ---
w = 20250824
x = 1000
y = 1
current_version = f"Version {w}.{x}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"

class TracesTab(ttk.Frame):
    def __init__(self, parent_notebook, showtime_tab_instance):
        # [Initializes the Traces control tab.]
        debug_log(f"🖥️ 🟢 Entering __init__",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        
        super().__init__(parent_notebook)
        self.showtime_tab_instance = showtime_tab_instance
        self._create_widgets()
        
        debug_log(f"🖥️ 🟢 Exiting __init__",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)

    def _create_widgets(self):
        # FIXED: Move import here to resolve circular import.
        from .utils_showtime_trace import execute_trace_action

        # [Creates the UI elements for the Traces tab.]
        debug_log(f"🖥️ 🟢 Creating widgets for TracesTab.",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        
        self.showtime_tab_instance.trace_buttons.clear()
        
        # UPDATED: Added the "Min" button to the configuration list
        buttons_config = [
            ("All", lambda: self._toggle_and_execute('all')),
            ("Live", lambda: self._toggle_and_execute('live')),
            ("Max", lambda: self._toggle_and_execute('max')),
            ("Min", lambda: self._toggle_and_execute('min'))
        ]

        for i, (text, command) in enumerate(buttons_config):
            # FIXED: Added a fixed width to ensure all buttons are the same size.
            btn = ttk.Button(self, text=text, style='ControlButton.TButton', command=command, width=12)
            btn.grid(row=0, column=i, sticky='ew', padx=2, pady=2)
            self.showtime_tab_instance.trace_buttons[text.lower()] = btn

        self.grid_columnconfigure(list(range(len(buttons_config))), weight=1)
        self._update_button_styles()
        
        debug_log(f"🖥️ ✅ Widgets created successfully.",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)

    def _toggle_and_execute(self, button_type):
        # [Toggles the state of a trace mode and executes the trace action.]
        debug_log(f"🖥️ 🟢 Entering _toggle_and_execute for button: {button_type}",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        
        from .utils_showtime_trace import execute_trace_action

        target_var = self.showtime_tab_instance.trace_modes.get(button_type)
        if not target_var: return

        # NEW LOGIC: This implements a true exclusive selection
        current_state = target_var.get()
        if not current_state: # Only proceed if the button is not already active
            for mode, var in self.showtime_tab_instance.trace_modes.items():
                if mode == button_type:
                    var.set(True) # Set the clicked button to active
                    debug_log(f"🖥️ 📝 Setting shared state trace mode '{mode}' to active.",
                                file=current_file,
                                version=current_version,
                                function=inspect.currentframe().f_code.co_name)
                else:
                    var.set(False) # Set all other buttons to inactive
                    debug_log(f"🖥️ 📝 Setting shared state trace mode '{mode}' to inactive.",
                                file=current_file,
                                version=current_version,
                                function=inspect.currentframe().f_code.co_name)
            
            self._update_button_styles()
            execute_trace_action(traces_tab_instance=self, action_type=button_type)
        
        # If the button is already active, do nothing.
        debug_log(f"🖥️ 🟢 Exiting _toggle_and_execute",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)


    def _update_button_styles(self):
        # [Updates button styles based on the state of trace mode variables.]
        debug_log(f"🖥️ 🟢 Entering _update_button_styles",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        
        for mode, var in self.showtime_tab_instance.trace_modes.items():
            button = self.showtime_tab_instance.trace_buttons.get(mode)
            if button:
                style = 'ControlButton.Active.TButton' if var.get() else 'ControlButton.Inactive.TButton'
                button.config(style=style)
                
        debug_log(f"🖥️ ✅ Button styles updated successfully.",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)


#####################################
### File: OPEN-AIR\Markers\showtime\controls\tab_markers_child_control_zone_zoom.py
#####################################
# tabs/Markers/showtime/controls/tab_markers_child_control_zone_zoom.py
#
# This file defines the Zone Zoom tab for the ControlsFrame.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: [https://like.audio/category/software/spectrum-scanner/](https://like.audio/category/software/spectrum-scanner/)
# Source Code: [https://github.com/APKaudio/](https://github.com/APKaudio/)
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.001000.1
# REFACTORED: Removed dependency on `shared_state` object. State is now accessed from the `showtime_tab_instance`.

import os
import inspect
import tkinter as tk
from tkinter import ttk
from datetime import datetime

from display.debug_logic import debug_log

# --- Versioning ---
w = 20250824
x_str = '001000'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"

class ZoneZoomTab(ttk.Frame):
    def __init__(self, parent_notebook, showtime_tab_instance):
        # [Initializes the Zone Zoom control tab.]
        debug_log(f"🖥️ 🟢 Entering __init__",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        
        super().__init__(parent_notebook)
        self.showtime_tab_instance = showtime_tab_instance
        self._create_widgets()
        
        debug_log(f"🖥️ 🟢 Exiting __init__",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        
    def _create_widgets(self):
        # FIXED: Moved imports inside this method to resolve the ImportError.
        from .utils_showtime_zone_zoom import set_span_to_all_markers, set_span_to_device, set_span_to_group, set_span_to_zone
        
        # [Creates the UI elements for the Zone Zoom tab.]
        debug_log(f"🖥️ 🟢 Creating widgets for the Zone Zoom tab.",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        
        # Main container uses a two-column grid
        self.grid_columnconfigure(0, weight=1)
        self.grid_columnconfigure(1, weight=1)

        # Left side frame for buttons and buffer dropdown
        left_frame = ttk.Frame(self, style='TFrame')
        left_frame.grid(row=0, column=0, sticky="nsew")
        left_frame.grid_columnconfigure(0, weight=1)

        # Button Frame for Zone/Group/Device/All Markers buttons
        button_frame = ttk.Frame(left_frame, style='TFrame')
        button_frame.grid(row=0, column=0, sticky="ew")

        buttons_config = [
            ("Zone", lambda: set_span_to_zone(self.showtime_tab_instance, self)),
            ("Group", lambda: set_span_to_group(self.showtime_tab_instance, self)),
            ("Device", lambda: set_span_to_device(self.showtime_tab_instance, self)),
            ("All Markers", lambda: set_span_to_all_markers(self.showtime_tab_instance, self))
        ]

        self.showtime_tab_instance.zone_zoom_buttons.clear()
        for i, (text, command) in enumerate(buttons_config):
            btn = ttk.Button(button_frame, text=text, style='ControlButton.TButton', command=command, width=12)
            btn.grid(row=0, column=i, sticky='ew', padx=2, pady=2)
            self.showtime_tab_instance.zone_zoom_buttons[text.lower()] = btn
        button_frame.grid_columnconfigure(list(range(len(buttons_config))), weight=1)

        # Frame for the new "Window Buffer" dropdown
        buffer_frame = ttk.Frame(left_frame, style='TFrame')
        buffer_frame.grid(row=1, column=0, sticky="ew")
        buffer_frame.grid_columnconfigure(1, weight=1)
        
        ttk.Label(buffer_frame, text="Window Buffer (MHz):").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        buffer_options = ["1", "3", "10", "30"]
        self.buffer_dropdown = ttk.Combobox(buffer_frame, textvariable=self.showtime_tab_instance.buffer_var, values=buffer_options, state="readonly")
        self.buffer_dropdown.grid(row=0, column=1, sticky="ew", padx=5, pady=2)
        self.buffer_dropdown.set(self.showtime_tab_instance.buffer_var.get())

        # Right side frame for labels, allowing it to expand
        right_frame = ttk.Frame(self, style='TFrame')
        right_frame.grid(row=0, column=1, sticky="nsew")
        right_frame.grid_rowconfigure(0, weight=1) # The row for labels should expand
        right_frame.grid_columnconfigure(0, weight=1)

        label_frame = ttk.Frame(right_frame, style='TFrame')
        label_frame.grid(row=0, column=0, sticky="nsew")

        # The labels now have a vertical layout
        self.label_left = ttk.Label(label_frame, textvariable=self.showtime_tab_instance.zone_zoom_label_left_var, style='TLabel')
        self.label_center = ttk.Label(label_frame, textvariable=self.showtime_tab_instance.zone_zoom_label_center_var, style='TLabel')
        self.label_right = ttk.Label(label_frame, textvariable=self.showtime_tab_instance.zone_zoom_label_right_var, style='TLabel')

        self.label_left.pack(anchor="w", padx=5)
        self.label_center.pack(anchor="w", padx=5)
        self.label_right.pack(anchor="w", padx=5)
        
        debug_log(f"🖥️ ✅ Widgets created successfully.",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        
    def _sync_ui_from_state(self):
        # [Updates button styles and labels based on the current selection in shared state.]
        debug_log(f"🖥️ 🔄 Syncing UI from shared state.",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        
        # Reset all buttons to inactive first
        for btn in self.showtime_tab_instance.zone_zoom_buttons.values():
            btn.config(style='ControlButton.Inactive.TButton')
            
        # Set the active button based on the last selected type
        if self.showtime_tab_instance.last_selected_type:
            active_btn = self.showtime_tab_instance.zone_zoom_buttons.get(self.showtime_tab_instance.last_selected_type.lower())
            if active_btn:
                active_btn.config(style='ControlButton.Active.TButton')
        else: # Default to "All Markers" if nothing is selected
            all_markers_btn = self.showtime_tab_instance.zone_zoom_buttons.get('all markers')
            if all_markers_btn:
                all_markers_btn.config(style='ControlButton.Active.TButton')

        # Update the labels from the values stored in the shared state
        buffered_start = self.showtime_tab_instance.buffered_start_var.get()
        buffered_stop = self.showtime_tab_instance.buffered_stop_var.get()

        if self.showtime_tab_instance.last_selected_type == 'zone':
            zone_info = self.showtime_tab_instance.selected_zone_info
            count = zone_info.get('device_count', 0)
            self.showtime_tab_instance.zone_zoom_label_left_var.set(f"Zone ({count} Devices)")
            self.showtime_tab_instance.zone_zoom_label_center_var.set(f"Name: {self.showtime_tab_instance.selected_zone}")
            self.showtime_tab_instance.zone_zoom_label_right_var.set(f"Start: {buffered_start:.3f} MHz\nStop: {buffered_stop:.3f} MHz")
        elif self.showtime_tab_instance.last_selected_type == 'group':
            group_info = self.showtime_tab_instance.selected_group_info
            count = group_info.get('device_count', 0)
            self.showtime_tab_instance.zone_zoom_label_left_var.set(f"Group ({count} Devices)")
            self.showtime_tab_instance.zone_zoom_label_center_var.set(f"Name: {self.showtime_tab_instance.selected_group}")
            self.showtime_tab_instance.zone_zoom_label_right_var.set(f"Start: {buffered_start:.3f} MHz\nStop: {buffered_stop:.3f} MHz")
        elif self.showtime_tab_instance.last_selected_type == 'device':
            device_info = self.showtime_tab_instance.selected_device_info
            self.showtime_tab_instance.zone_zoom_label_left_var.set(f"Device: {device_info.get('NAME')}")
            self.showtime_tab_instance.zone_zoom_label_center_var.set(f"Name: {device_info.get('NAME')}")
            self.showtime_tab_instance.zone_zoom_label_right_var.set(f"Center: {device_info.get('CENTER'):.3f} MHz\nStart: {buffered_start:.3f} MHz\nStop: {buffered_stop:.3f} MHz")
        else: # All markers
            all_devices = self.showtime_tab_instance.zgd_frame._get_all_devices_in_zone(self.showtime_tab_instance.zgd_frame.structured_data, None)
            count = len(all_devices) if all_devices else 0
            self.showtime_tab_instance.zone_zoom_label_left_var.set("All Markers")
            self.showtime_tab_instance.zone_zoom_label_center_var.set(f"({count} Devices)")
            self.showtime_tab_instance.zone_zoom_label_right_var.set(f"Start: {buffered_start:.3f} MHz\nStop: {buffered_stop:.3f} MHz")

        debug_log(f"🖥️ ✅ UI synced successfully.",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)

    def _on_tab_selected(self, event):
        # [Handles the event when this tab is selected.]
        debug_log(f"🖥️ 🟢 Entering _on_tab_selected",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        self._sync_ui_from_state()
        debug_log(f"🖥️ 🟢 Exiting _on_tab_selected",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)


#####################################
### File: OPEN-AIR\Markers\showtime\controls\tab_markers_parent_bottom_controls.py
#####################################
# tabs/Markers/showtime/controls/tab_markers_parent_bottom_controls.py
#
# This file defines the ControlsFrame, which contains a notebook of child tabs
# for controlling various instrument settings related to markers.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250823.235500.2
# REFACTORED: The ControlsFrame now instantiates its child tabs without the
#             `shared_state` parameter, resolving the `TypeError`.

import tkinter as tk
from tkinter import ttk
import inspect
import os
from datetime import datetime

from display.debug_logic import debug_log
from display.console_logic import console_log
from src.program_style import COLOR_PALETTE, COLOR_PALETTE_TABS, _get_dark_color

# Import the child tab classes
from .tab_markers_child_control_span import SpanTab
from .tab_markers_child_control_rbw import RBWTab
from .tab_markers_child_control_traces import TracesTab
from .tab_markers_child_control_poke import PokeTab
from .tab_markers_child_control_zone_zoom import ZoneZoomTab

# --- Versioning ---
w = 20250823
x_str = '235500'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 2
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"


class ControlsFrame(ttk.LabelFrame):
    def __init__(self, parent_frame, showtime_tab_instance, *args, **kwargs):
        # [Initializes the controls frame, setting up the notebook and tabs.]
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"🖥️ 🟢 Entering __init__",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        super().__init__(parent_frame, text="Controls", style='TLabelframe', **kwargs)
        self.showtime_tab_instance = showtime_tab_instance
        self._create_widgets()
        
        debug_log(f"🖥️ 🟢 Exiting __init__",
                    file=current_file,
                    version=current_version,
                    function=current_function)
    
    def _create_widgets(self):
        # [Creates the notebook and adds all the control tabs to it.]
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"🖥️ 🟢 Creating widgets for ControlsFrame. Building a new control panel! 🛠️",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        
        # --- NEW: Apply custom styling for the control notebook tabs ---
        style = ttk.Style(self)
        active_color = COLOR_PALETTE_TABS['Markers']['active']
        inactive_color = _get_dark_color(active_color)
        
        style.configure('Controls.TNotebook', background=COLOR_PALETTE['background'])
        style.map('Controls.TNotebook.Tab',
                background=[('selected', active_color),
                            ('!selected', inactive_color)],
                foreground=[('selected', COLOR_PALETTE_TABS['Markers']['fg']),
                            ('!selected', 'white')])

        self.child_notebook = ttk.Notebook(self, style='Controls.TNotebook')
        self.child_notebook.pack(expand=True, fill="both")
        
        # Pass the parent instance to all child tabs so they can access the state
        self.span_tab = SpanTab(self.child_notebook, self.showtime_tab_instance)
        self.child_notebook.add(self.span_tab, text="Span")
        
        self.rbw_tab = RBWTab(self.child_notebook, self.showtime_tab_instance)
        self.child_notebook.add(self.rbw_tab, text="RBW")
        
        self.traces_tab = TracesTab(self.child_notebook, self.showtime_tab_instance)
        self.child_notebook.add(self.traces_tab, text="Traces")
        
        self.poke_tab = PokeTab(self.child_notebook, self.showtime_tab_instance)
        self.child_notebook.add(self.poke_tab, text="Poke")
        
        self.zone_zoom_tab = ZoneZoomTab(self.child_notebook, self.showtime_tab_instance)
        self.child_notebook.add(self.zone_zoom_tab, text="Zone Zoom")
        
        self.child_notebook.bind("<<NotebookTabChanged>>", self._on_tab_selected)

        debug_log(f"🖥️ ✅ Widgets created successfully. Child tabs are now present. 🗂️",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        
    def _on_tab_selected(self, event):
        # [Handles the event when a tab is selected in the notebook.]
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"🖥️ 🟢 Entering {current_function}",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        selected_child_tab_id = self.child_notebook.select()
        if selected_child_tab_id:
            selected_child_tab_widget = self.child_notebook.nametowidget(selected_child_tab_id)
            if hasattr(selected_child_tab_widget, '_on_tab_selected'):
                selected_child_tab_widget._on_tab_selected(event)

        debug_log(f"🖥️ 🟢 Exiting {current_function}",
                    file=current_file,
                    version=current_version,
                    function=current_function)
    
    def switch_to_tab(self, tab_name):
        # [Switches the currently displayed tab in the notebook.]
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"🖥️ 🟢 Entering {current_function} with argument: {tab_name}",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        
        try:
            tab_id = -1
            # Iterate through all tabs to find the one with the matching name
            for i, name in enumerate(self.child_notebook.tabs()):
                if self.child_notebook.tab(name, 'text') == tab_name:
                    tab_id = i
                    break
            
            if tab_id != -1:
                self.child_notebook.select(tab_id)
                debug_log(f"🖥️ ✅ Switched to tab: {tab_name}",
                            file=current_file,
                            version=current_version,
                            function=current_function)
            else:
                debug_log(f"🖥️ ❌ Error switching to tab '{tab_name}': Tab not found.",
                            file=current_file,
                            version=current_version,
                            function=current_function)

        except Exception as e:
            debug_log(f"🖥️ ❌ Error switching to tab '{tab_name}': {e}",
                        file=current_file,
                        version=current_version,
                        function=current_function)

        debug_log(f"🖥️ 🟢 Exiting {current_function}",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        
    def _update_control_buttons(self):
        # This function updates the state and style of all control buttons.
        # It's called when a variable changes to ensure the UI is in sync.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"🖥️ 🔄 Updating control button styles.",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        try:
            # Span buttons
            current_span_hz = self.showtime_tab_instance.span_var.get()
            for value_str, btn in self.showtime_tab_instance.span_buttons.items():
                if value_str == current_span_hz:
                    btn.config(style='ControlButton.Active.TButton')
                else:
                    btn.config(style='ControlButton.Inactive.TButton')
                    
            # RBW buttons
            current_rbw_hz = self.showtime_tab_instance.rbw_var.get()
            for value_str, btn in self.showtime_tab_instance.rbw_buttons.items():
                if value_str == current_rbw_hz:
                    btn.config(style='ControlButton.Active.TButton')
                else:
                    btn.config(style='ControlButton.Inactive.TButton')
            
            # Trace buttons
            for mode_name, mode_var in self.showtime_tab_instance.trace_modes.items():
                button = self.showtime_tab_instance.trace_buttons.get(mode_name)
                if button:
                    if mode_var.get():
                        button.config(style='ControlButton.Active.TButton')
                    else:
                        button.config(style='ControlButton.Inactive.TButton')

            debug_log(f"🖥️ ✅ Control button styles updated successfully.",
                        file=current_file,
                        version=current_version,
                        function=current_function)
        except Exception as e:
            debug_log(f"🖥️ ❌ Error updating control buttons: {e}",
                        file=current_file,
                        version=current_version,
                        function=current_function)



#####################################
### File: OPEN-AIR\Markers\showtime\controls\utils_showtime_plot.py
#####################################
# tabs/Markers/showtime/controls/utils_showtime_plot.py
#
# This utility file centralizes all logic for fetching and plotting trace data
# from the instrument. It is designed to be called by the UI and acts as a
# high-level API for triggering trace actions and updating the display.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.003000.1
# FIXED: The plotting functions are now correctly imported from `utils_display_monitor.py`
#        and `utils_scan_view.py` instead of being defined here, resolving the issue
#        of displaying plots on the monitor tab.
# FIXED: Corrected the `plot_all_traces` function to correctly access attributes from the `showtime_tab_instance`.
# FIXED: Corrected versioning to adhere to project standards.

import os
import inspect
import pandas as pd
import tkinter as tk
from ref.ref_frequency_bands import MHZ_TO_HZ
from display.debug_logic import debug_log
from display.console_logic import console_log

# Import plotting functions from the display utilities
from display.utils_display_monitor import update_top_plot, update_middle_plot, update_bottom_plot

# --- Versioning ---
w = 20250824
x = 3000
y = 1
current_version = f"Version {w}.{x}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"


def plot_all_traces(showtime_tab_instance, trace_data_dict, view_name, start_freq_mhz, stop_freq_mhz):
    # [Updates the display plots with trace data from the instrument.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Entering {current_function} with view_name: {view_name}",
              file=f"{os.path.basename(__file__)}",
              version=current_version,
              function=current_function)
    
    if trace_data_dict:
        monitor_tab = showtime_tab_instance.app_instance.display_parent_tab.bottom_pane.scan_monitor_tab
        if monitor_tab:
            df1 = pd.DataFrame(trace_data_dict["TraceData"]["Trace1"], columns=['Frequency_Hz', 'Power_dBm'])
            update_top_plot(monitor_tab, df1, start_freq_mhz, stop_freq_mhz, f"Live Trace - {view_name}")
            
            df2 = pd.DataFrame(trace_data_dict["TraceData"]["Trace2"], columns=['Frequency_Hz', 'Power_dBm'])
            update_middle_plot(monitor_tab, df2, start_freq_mhz, stop_freq_mhz, f"Max Hold - {view_name}")

            df3 = pd.DataFrame(trace_data_dict["TraceData"]["Trace3"], columns=['Frequency_Hz', 'Power_dBm'])
            update_bottom_plot(monitor_tab, df3, start_freq_mhz, stop_freq_mhz, f"Min Hold - {view_name}")
            
            showtime_tab_instance.console_print_func("✅ Successfully updated monitor with all three traces.")
            
            # This is a bit of a hack to ensure the monitor tab is visible
            showtime_tab_instance.app_instance.display_parent_tab.change_display_tab('Monitor')
        else:
            showtime_tab_instance.console_print_func("❌ Scan Monitor tab not found.")
    else:
        showtime_tab_instance.console_print_func("❌ Failed to retrieve trace data.")
        debug_log(f"Shiver me timbers, the trace data be lost at sea!",
                  file=f"{os.path.basename(__file__)}",
                  version=current_version,
                  function=current_function)


#####################################
### File: OPEN-AIR\Markers\showtime\controls\utils_showtime_poke.py
#####################################
# tabs/Markers/showtime/controls/utils_showtime_poke.py
#
# This utility file provides the backend logic for the PokeTab. It contains
# functions that handle button clicks for Poking and then communicates with
# the instrument control layer.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.002500.1
# REFACTORED: Removed dependency on `shared_state` object. State is now accessed
#             from the `showtime_tab_instance`.

import os
import inspect
import pandas as pd
from ref.ref_frequency_bands import MHZ_TO_HZ
from display.debug_logic import debug_log
from display.console_logic import console_log
from yak.Yakety_Yak import YakSet
from settings_and_config.config_manager_save import save_program_config 

# Import dedicated utility functions from their respective modules
from .utils_showtime_span import format_hz
from yak.utils_yakbeg_handler import handle_freq_center_span_beg

# --- Versioning ---
w = 20250824
x = 2500
y = 1
current_version = f"Version {w}.{x}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"

def on_poke_action(showtime_tab_instance):
    # [Sets center frequency and span simultaneously using the YakBeg handler.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"Entering {current_function}", file=f"{os.path.basename(__file__)}", version=current_version, function=current_function)
    
    try:
        # 📖 Read Data: Retrieve poke and span values.
        center_freq_mhz = float(showtime_tab_instance.poke_freq_var.get())
        span_hz = int(showtime_tab_instance.span_var.get())
        debug_log(message=f"📖 Reading state: poke_freq_var = {center_freq_mhz} MHz, span_var = {span_hz} Hz", file=f"{os.path.basename(__file__)}", version=current_version, function=current_function)
        
        center_freq_hz = int(center_freq_mhz * MHZ_TO_HZ)
        
        showtime_tab_instance.console_print_func(f"Poking instrument: Center={center_freq_mhz} MHz, Span={format_hz(span_hz)}...")
        
        response = handle_freq_center_span_beg(
            app_instance=showtime_tab_instance.app_instance, 
            center_freq=center_freq_hz, 
            span_freq=span_hz,
            console_print_func=showtime_tab_instance.console_print_func
        )
        
        if response and len(response) >= 2:
            returned_center, returned_span, _, _ = response
            showtime_tab_instance.console_print_func(
                f"✅ Instrument Confirmed: Center={returned_center / MHZ_TO_HZ:.3f} MHz, Span={format_hz(returned_span)}"
            )
            # FIXED: Save config after a successful poke action
            save_program_config (config=showtime_tab_instance.app_instance.config,
                        file_path=showtime_tab_instance.app_instance.CONFIG_FILE_PATH,
                        console_print_func=showtime_tab_instance.console_print_func,
                        app_instance=showtime_tab_instance.app_instance)

        else:
            showtime_tab_instance.console_print_func("❌ Poke command failed. Instrument did not confirm settings.")
            
    except ValueError:
        showtime_tab_instance.console_print_func("⚠️ Poke frequency must be a valid number.")
    except Exception as e:
        showtime_tab_instance.console_print_func(f"❌ Error during poke action: {e}")
        debug_log(message=f"Shiver me timbers, the poke be capsized! The error be: {e}",
                  file=f"{os.path.basename(__file__)}",
                  version=current_version,
                  function=current_function)


#####################################
### File: OPEN-AIR\Markers\showtime\controls\utils_showtime_rbw.py
#####################################
# tabs/Markers/showtime/controls/utils_showtime_rbw.py
#
# This utility file centralizes the backend logic for controlling the instrument's
# Resolution Bandwidth (RBW) settings. It contains functions that handle
# button clicks from the GUI and translate them into instrument commands.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.010200.1
# REFACTORED: The logic has been streamlined to ensure that UI updates,
#             instrument commands, and configuration saving are consistently
#             handled by the on_rbw_button_click function.

import os
import inspect
import tkinter as tk
from tkinter import ttk

from display.debug_logic import debug_log
from display.console_logic import console_log
from yak.Yakety_Yak import YakSet
from yak.utils_yak_setting_handler import set_resolution_bandwidth
from settings_and_config.config_manager_save import save_program_config 

from process_math.math_frequency_translation import format_hz

# --- Versioning ---
w = 20250824
x_str = '010200'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = f"{os.path.basename(__file__)}"

def set_rbw_logic(app_instance, rbw_hz, console_print_func):
    # [Sets the resolution bandwidth of the instrument and reports back.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"Entering {current_function} with rbw_hz: {rbw_hz}", file=f"{os.path.basename(__file__)}", version=current_version, function=current_function)
    
    status = YakSet(app_instance=app_instance, command_type="BANDWIDTH/RESOLUTION", variable_value=str(rbw_hz), console_print_func=console_print_func)
    
    if status != "PASSED":
        console_print_func("❌ Failed to set RBW.")

def on_rbw_button_click(showtime_tab, rbw_hz):
    # [Handles the event when an RBW button is clicked.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"Entering {current_function} with rbw_hz: {rbw_hz}",
              file=f"{os.path.basename(__file__)}",
              version=current_version,
              function=current_function)
    
    try:
        # 📝 Write Data: Update the RBW variable on the parent instance.
        showtime_tab.rbw_var.set(str(rbw_hz))
        debug_log(message=f"📝 Writing state: rbw_var = {rbw_hz} Hz", file=f"{os.path.basename(__file__)}", version=current_version, function=current_function)
        
        # Re-sync the RBW button styles
        for value_str, btn in showtime_tab.rbw_buttons.items():
            if value_str == showtime_tab.rbw_var.get():
                btn.config(style='ControlButton.Active.TButton')
            else:
                btn.config(style='ControlButton.Inactive.TButton')
        
        showtime_tab.console_print_func(f"✅ RBW set to {format_hz(rbw_hz)}.")
        
        # Trigger the handler to send the new RBW to the instrument
        set_resolution_bandwidth(app_instance=showtime_tab.app_instance, value=int(rbw_hz), console_print_func=showtime_tab.console_print_func)
        
        # FIXED: Save config after a successful RBW change
        save_program_config (config=showtime_tab.app_instance.config,
                    file_path=showtime_tab.app_instance.CONFIG_FILE_PATH,
                    console_print_func=showtime_tab.console_print_func,
                    app_instance=showtime_tab.app_instance)

    except Exception as e:
        showtime_tab.console_print_func(f"❌ Error setting RBW: {e}")
        debug_log(message=f"Shiver me timbers, the RBW has gone rogue! The error be: {e}",
                  file=f"{os.path.basename(__file__)}",
                  version=current_version,
                  function=current_function)

#####################################
### File: OPEN-AIR\Markers\showtime\controls\utils_showtime_span.py
#####################################
# tabs/Markers/showtime/controls/utils_showtime_span.py
#
# This utility file centralizes the backend logic for controlling the instrument's
# Span settings. It contains functions that handle button clicks from the GUI
# and translate them into instrument commands.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.010500.1
# UPDATED: File header and versioning adhere to new standards.
# FIXED: The `on_span_button_click` function now correctly captures the RBW value
#        from the device response and updates the UI and config accordingly.

import os
import inspect

from display.debug_logic import debug_log
from display.console_logic import console_log
from yak.utils_yakbeg_handler import handle_freq_center_span_beg
from yak.utils_yak_setting_handler import set_span_frequency
from yak.utils_yaknab_handler import handle_bandwidth_settings_nab
from settings_and_config.config_manager_save import save_program_config 
from process_math.math_frequency_translation import format_hz

# --- Versioning ---
w = 20250824
x = 10500
y = 1
current_version = f"Version {w}.{x}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"


def on_span_button_click(showtime_tab_instance, span_hz):
    # [Handles the event when a Span button is clicked.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"Entering {current_function} with span_hz: {span_hz}",
              file=f"{os.path.basename(__file__)}",
              version=current_version,
              function=current_function)
    
    try:
        # Check if the user wants to follow the zone span
        showtime_tab_instance.follow_zone_span_var.set(False)

        # 📝 Write Data: Update the span variable on the parent instance.
        showtime_tab_instance.span_var.set(str(span_hz))
        debug_log(message=f"📝 Writing state: span_var = {span_hz} Hz", file=f"{os.path.basename(__file__)}", version=current_version, function=current_function)

        # Re-sync all the control buttons
        showtime_tab_instance.controls_frame._update_control_buttons()
        
        showtime_tab_instance.console_print_func(f"✅ Span set to {format_hz(span_hz)}.")

        # Trigger the handler to send the new span to the instrument.
        # It should use the current center frequency and the new span.
        
        # CORRECTED: Capture the response from the device
        set_span_frequency(app_instance=showtime_tab_instance.app_instance,
                                    value=span_hz / 1_000_000,
                                    console_print_func=showtime_tab_instance.console_print_func)
        
        # NEW LOGIC: Get the current bandwidth settings from the device and update the state.
        device_bandwidth_settings = handle_bandwidth_settings_nab(app_instance=showtime_tab_instance.app_instance,
                                                                    console_print_func=showtime_tab_instance.console_print_func)
        
        if device_bandwidth_settings and device_bandwidth_settings.get('RBW_Hz') is not None:
            rbw_from_device = device_bandwidth_settings['RBW_Hz']
            showtime_tab_instance.rbw_var.set(str(rbw_from_device))
            showtime_tab_instance.console_print_func(f"✅ RBW automatically updated to {format_hz(rbw_from_device)}.")
            debug_log(message=f"📝 Writing state: rbw_var updated from device response to {rbw_from_device} Hz.", file=current_file, version=current_version, function=current_function)
        
        # FIXED: Save config after a successful span change
        save_program_config (config=showtime_tab_instance.app_instance.config,
                    file_path=showtime_tab_instance.app_instance.CONFIG_FILE_PATH,
                    console_print_func=showtime_tab_instance.console_print_func,
                    app_instance=showtime_tab_instance.app_instance)

    except Exception as e:
        showtime_tab_instance.console_print_func(f"❌ Error setting span: {e}")
        debug_log(message=f"Arrr, a kraken be attacking the span settings! The error be: {e}",
                  file=f"{os.path.basename(__file__)}",
                  version=current_version,
                  function=current_function)


#####################################
### File: OPEN-AIR\Markers\showtime\controls\utils_showtime_trace.py
#####################################
# tabs/Markers/showtime/controls/utils_showtime_trace.py
#
# This utility file centralizes all logic for fetching trace data from the instrument,
# handling trace mode configurations, and updating the corresponding display plots.
# It acts as a high-level API for the UI to trigger trace actions.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.010400.1
# UPDATED: The execute_trace_action function now correctly calls handle_trace_modes_beg to set the new mode on the instrument before fetching data.
# UPDATED: The trace mode mapping now correctly uses the mode strings defined in the new MarkerTab config.
# FIXED: The execute_trace_action function now saves the config after changing trace modes.
# FIXED: Corrected the AttributeErrors in `_get_and_plot_traces` by retrieving
#        frequency and span values from the `app_instance.config` object.

import os
import inspect
import pandas as pd
import tkinter as tk
import numpy as np

from display.debug_logic import debug_log
from display.console_logic import console_log

from yak.utils_yaknab_handler import handle_all_traces_nab
from yak.utils_yakbeg_handler import handle_trace_modes_beg
from settings_and_config.config_manager_save import save_program_config 

from .utils_showtime_plot import plot_all_traces
from process_math.math_frequency_translation import MHZ_TO_HZ

# --- Versioning ---
w = 20250824
x_str = '010400'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = f"{os.path.basename(__file__)}"

def sync_trace_modes(traces_tab_instance):
    # [Synchronizes the trace mode buttons with the instrument's current state.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Entering {current_function}", file=f"{os.path.basename(__file__)}", version=current_version, function="sync_trace_modes")
    
    showtime_tab = traces_tab_instance.showtime_tab_instance
    app_instance = showtime_tab.app_instance
    console_print_func = showtime_tab.console_print_func

    # Placeholder for getting current trace modes from instrument
    current_modes = ['Live', 'Max Hold', 'Min Hold']
    
    for button_name in traces_tab_instance.trace_buttons.keys():
        if button_name in current_modes:
            traces_tab_instance.trace_buttons[button_name].config(style='ControlButton.Active.TButton')
        else:
            traces_tab_instance.trace_buttons[button_name].config(style='ControlButton.Inactive.TButton')
            
    debug_log(f"Exiting {current_function}", file=f"{os.path.basename(__file__)}", version=current_version, function="sync_trace_modes")

def execute_trace_action(traces_tab_instance, action_type):
    # [Orchestrates the process of fetching and plotting traces based on user action.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Entering {current_function} with action_type: {action_type}", file=f"{os.path.basename(__file__)}", version=current_version, function="execute_trace_action")
    
    # FIXED: Access the parent ShowtimeParentTab instance directly from the child tab
    showtime_tab = traces_tab_instance.showtime_tab_instance

    # Set the instrument's trace mode based on the button clicked
    trace_mode_map = {
        'all': ['WRITE', 'MAXHold', 'MINHold'],
        'live': ['WRITE', 'BLANK', 'BLANK', 'BLANK'],
        'max': ['BLANK', 'MAXHold', 'BLANK', 'BLANK'],
        'min': ['BLANK', 'BLANK', 'MINHold', 'BLANK']
    }
    
    selected_modes = trace_mode_map.get(action_type, [])
    
    # NEW: Call handle_trace_modes_beg to set the modes on the instrument
    debug_log(f"Calling YakBeg to set trace modes on the instrument. ⚡",
                file=f"{os.path.basename(__file__)}",
                version=current_version,
                function=current_function)
    handle_trace_modes_beg(showtime_tab.app_instance, selected_modes, showtime_tab.console_print_func)
    
    # FIXED: Pass the action_type to _get_and_plot_traces
    _get_and_plot_traces(traces_tab_instance, action_type)
    
    # FIXED: Save config after a successful trace action
    save_program_config (config=showtime_tab.app_instance.config,
                file_path=showtime_tab.app_instance.CONFIG_FILE_PATH,
                console_print_func=showtime_tab.console_print_func,
                app_instance=showtime_tab.app_instance)

    debug_log(f"Exiting {current_function}", file=f"{os.path.basename(__file__)}", version=current_version, function="execute_trace_action")

def _get_and_plot_traces(traces_tab_instance, view_name):
    # [Fetches trace data from the instrument and passes it to the plotting utility.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Entering {current_function}", file=f"{os.path.basename(__file__)}", version=current_version, function="_get_and_plot_traces")
    
    # FIXED: Access the parent ShowtimeParentTab instance directly from the child tab
    showtime_tab = traces_tab_instance.showtime_tab_instance
    app_instance = showtime_tab.app_instance
    console_print_func = showtime_tab.console_print_func
    
    # CORRECTED: Retrieve center and span values from the config file, which is the correct source of truth.
    # The previous code was trying to access attributes on orchestrator_logic that do not exist.
    center_freq_mhz = float(app_instance.config.get('InstrumentSettings', 'center_freq_mhz', fallback='1500'))
    span_freq_mhz = float(app_instance.config.get('InstrumentSettings', 'span_freq_mhz', fallback='3000'))
    
    start_freq_mhz = (center_freq_mhz - span_freq_mhz / 2)
    stop_freq_mhz = (center_freq_mhz + span_freq_mhz / 2)
    
    try:
        # 📖 Read Data: Fetch the data from the instrument.
        debug_log(message=f"📖 Reading Data: Fetching all traces from the instrument via NAB handler.", file=f"{os.path.basename(__file__)}", version=current_version, function=current_function)
        trace_data = handle_all_traces_nab(app_instance, console_print_func)
        
        # If data is successfully retrieved, pass it to the plotter
        if trace_data:
            plot_all_traces(showtime_tab_instance=showtime_tab, trace_data_dict=trace_data, view_name=view_name, start_freq_mhz=start_freq_mhz, stop_freq_mhz=stop_freq_mhz)
        
    except Exception as e:
        console_print_func(f"❌ Error getting trace data: {e}")
        debug_log(message=f"Shiver me timbers, the trace data be lost at sea! The error be: {e}",
                  file=f"{os.path.basename(__file__)}",
                  version=current_version,
                  function="execute_trace_action")

#####################################
### File: OPEN-AIR\Markers\showtime\controls\utils_showtime_zone_zoom.py
#####################################
# tabs/Markers/showtime/controls/utils_showtime_zone_zoom.py
#
# This utility file provides the backend logic for the Zone Zoom tab in the ControlsFrame.
# It contains functions to calculate and set the instrument's span based on
# selected zones, groups, devices, or all markers by calling YakBeg handlers.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.001500.2
# UPDATED: set_span_to_zone and set_span_to_group now read min/max frequencies and device count
#          from the shared state, ensuring consistency between the UI state and calculations.
# UPDATED: All debug logs now include the correct emoji prefixes.
# UPDATED: Versioning and file header adhere to new standards.
# FIXED: Added `save_program_config` calls to all functions that modify state.
# FIXED: Corrected the AttributeErrors in all functions by retrieving state
#        variables directly from the `showtime_tab_instance` object.

import inspect
import os
from display.debug_logic import debug_log
from display.console_logic import console_log
from ref.ref_frequency_bands import MHZ_TO_HZ
from process_math.math_frequency_translation import format_hz
from settings_and_config.config_manager_save import save_program_config

# Import the YakBeg handlers for direct instrument control
from yak.utils_yakbeg_handler import handle_freq_start_stop_beg, handle_freq_center_span_beg

# --- Versioning ---
w = 20250824
x_str = '001500'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 2
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"


def _buffer_start_stop_frequencies(start_freq_mhz, stop_freq_mhz, buffer_mhz):
    # [Calculates the buffered start and stop frequencies based on a given buffer value.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"🛠️ 🟢 Entering {current_function} with start: {start_freq_mhz}, stop: {stop_freq_mhz}, buffer: {buffer_mhz}", file=current_file, version=current_version, function=current_function)
    
    buffered_start_freq_mhz = start_freq_mhz - buffer_mhz
    buffered_stop_freq_mhz = stop_freq_mhz + buffer_mhz
    
    debug_log(message=f"🛠️ 🟢 Exiting {current_function} with buffered start: {buffered_start_freq_mhz}, buffered stop: {buffered_stop_freq_mhz}", file=current_file, version=current_version, function=current_function)
    
    return buffered_start_freq_mhz, buffered_stop_freq_mhz

def set_span_to_all_markers(showtime_tab_instance, zone_zoom_tab):
    # [Calculates the required span to view all markers and sets the instrument using a start-stop command.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"🛠️ 🟢 Entering {current_function}", file=current_file, version=current_version, function="set_span_to_all_markers")
    
    # Get necessary info from the state and zgd_frame
    all_devices = showtime_tab_instance.zgd_frame._get_all_devices_in_zone(showtime_tab_instance.zgd_frame.structured_data, None)
    
    if not all_devices:
        showtime_tab_instance.console_print_func("⚠️ No markers loaded. Cannot set span to all markers.")
        debug_log(message=f"🛠️ 🚫 No markers found.", file=current_file, version=current_version, function=current_function)
        return
        
    freqs = [float(d['CENTER']) for d in all_devices if d.get('CENTER') and isinstance(d.get('CENTER'), (int, float))]
    if not freqs:
        showtime_tab_instance.console_print_func("⚠️ No valid frequencies found in markers. Cannot set span.")
        debug_log(message=f"🛠️ 🚫 No valid frequencies found in markers.", file=current_file, version=current_version, function=current_function)
        return
    
    start_freq_mhz = min(freqs)
    stop_freq_mhz = max(freqs)
    number_of_markers = len(freqs)

    try:
        # 📖 Read Data: Retrieve buffer value.
        buffer_mhz = float(showtime_tab_instance.buffer_var.get())
        debug_log(message=f"📖 Reading state: buffer_var = {buffer_mhz} MHz", file=current_file, version=current_version, function=current_function)

        buffered_start_freq_mhz, buffered_stop_freq_mhz = _buffer_start_stop_frequencies(start_freq_mhz, stop_freq_mhz, buffer_mhz)
        
        # 📝 Write Data: Store the buffered frequencies in the state.
        debug_log(message=f"📝 Writing state: buffered_start_var = {buffered_start_freq_mhz}, buffered_stop_var = {buffered_stop_freq_mhz}", file=current_file, version=current_version, function=current_function)
        showtime_tab_instance.buffered_start_var.set(buffered_start_freq_mhz)
        showtime_tab_instance.buffered_stop_var.set(buffered_stop_freq_mhz)

        start_freq_hz = int(buffered_start_freq_mhz * MHZ_TO_HZ)
        stop_freq_hz = int(buffered_stop_freq_mhz * MHZ_TO_HZ)
        
        showtime_tab_instance.console_print_func(f"✅ Setting span to all markers: {buffered_start_freq_mhz:.3f} MHz to {buffered_stop_freq_mhz:.3f} MHz.")
        
        # FIXED: Calling the handler here after the values are calculated
        handle_freq_start_stop_beg(app_instance=showtime_tab_instance.app_instance, start_freq=start_freq_hz, stop_freq=stop_freq_hz, console_print_func=showtime_tab_instance.console_print_func)

        showtime_tab_instance.follow_zone_span_var.set(True)

        showtime_tab_instance.zone_zoom_label_left_var.set("All Markers")
        showtime_tab_instance.zone_zoom_label_center_var.set(f"({number_of_markers} Devices)")
        showtime_tab_instance.zone_zoom_label_right_var.set(f"Start: {buffered_start_freq_mhz:.3f} MHz\nStop: {buffered_stop_freq_mhz:.3f} MHz")
        
        # Trigger UI sync on ZoneZoomTab
        zone_zoom_tab._sync_ui_from_state()
        debug_log(message=f"🛠️ ✅ Successfully updated all markers span and UI.", file=current_file, version=current_version, function=current_function)
        
        # FIXED: Add save_program_config call
        save_program_config(config=showtime_tab_instance.app_instance.config,
                    file_path=showtime_tab_instance.app_instance.CONFIG_FILE_PATH,
                    console_print_func=showtime_tab_instance.console_print_func,
                    app_instance=showtime_tab_instance.app_instance)

    except Exception as e:
        showtime_tab_instance.console_print_func(f"❌ Error in set_span_to_all_markers: {e}")
        debug_log(message=f"🛠️ 🧨 Shiver me timbers, setting span to all markers has failed! The error be: {e}", file=current_file, version=current_version, function="set_span_to_all_markers")

def set_span_to_zone(showtime_tab_instance, zone_zoom_tab):
    # [Calculates the required span for a zone and sets the instrument using a start-stop command.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"🛠️ 🟢 Entering {current_function}", file=current_file, version=current_version, function=current_function)

    zone_info = showtime_tab_instance.selected_zone_info
    zone_name = showtime_tab_instance.selected_zone

    if not zone_name:
        showtime_tab_instance.console_print_func("⚠️ No zone selected. Cannot set span to zone.")
        debug_log(message=f"🛠️ 🚫 No zone selected.", file=current_file, version=current_version, function=current_function)
        return
    
    start_freq_mhz = zone_info.get('min_freq')
    stop_freq_mhz = zone_info.get('max_freq')
    number_of_markers = zone_info.get('device_count')
    
    if number_of_markers == 0:
        showtime_tab_instance.console_print_func(f"⚠️ No valid frequencies found in zone '{zone_name}'. Cannot set span.")
        debug_log(message=f"🛠️ 🚫 No valid frequencies found in zone '{zone_name}'.", file=current_file, version=current_version, function=current_function)
        return
    
    debug_log(message=f"🛠️ 🔍 Reading state: zone_info = {zone_info}", file=current_file, version=current_version, function=current_function)
    
    try:
        # 📖 Read Data: Retrieve buffer value.
        buffer_mhz = float(showtime_tab_instance.buffer_var.get())
        debug_log(message=f"📖 Reading state: buffer_var = {buffer_mhz} MHz", file=current_file, version=current_version, function=current_function)

        buffered_start_freq_mhz, buffered_stop_freq_mhz = _buffer_start_stop_frequencies(start_freq_mhz, stop_freq_mhz, buffer_mhz)

        # 📝 Write Data: Store the buffered frequencies in the state.
        debug_log(message=f"📝 Writing state: buffered_start_var = {buffered_start_freq_mhz}, buffered_stop_var = {buffered_stop_freq_mhz}", file=current_file, version=current_version, function=current_function)
        showtime_tab_instance.buffered_start_var.set(buffered_start_freq_mhz)
        showtime_tab_instance.buffered_stop_var.set(buffered_stop_freq_mhz)

        start_freq_hz = int(buffered_start_freq_mhz * MHZ_TO_HZ)
        stop_freq_hz = int(buffered_stop_freq_mhz * MHZ_TO_HZ)
        
        showtime_tab_instance.console_print_func(f"✅ Setting span to zone '{zone_name}': {buffered_start_freq_mhz:.3f} MHz to {buffered_stop_freq_mhz:.3f} MHz.")
        
        handle_freq_start_stop_beg(app_instance=showtime_tab_instance.app_instance, start_freq=start_freq_hz, stop_freq=stop_freq_hz, console_print_func=showtime_tab_instance.console_print_func)
        
        showtime_tab_instance.follow_zone_span_var.set(True)

        showtime_tab_instance.zone_zoom_label_left_var.set(f"Zone ({number_of_markers} Devices)")
        showtime_tab_instance.zone_zoom_label_center_var.set(f"Name: {zone_name}")
        showtime_tab_instance.zone_zoom_label_right_var.set(f"Start: {buffered_start_freq_mhz:.3f} MHz\nStop: {buffered_stop_freq_mhz:.3f} MHz")
        
        zone_zoom_tab._sync_ui_from_state()
        debug_log(message=f"🛠️ ✅ Successfully updated zone span and UI.", file=current_file, version=current_version, function=current_function)
        
        # FIXED: Add save_program_config call
        save_program_config(config=showtime_tab_instance.app_instance.config,
                    file_path=showtime_tab_instance.app_instance.CONFIG_FILE_PATH,
                    console_print_func=showtime_tab_instance.console_print_func,
                    app_instance=showtime_tab_instance.app_instance)


    except Exception as e:
        showtime_tab_instance.console_print_func(f"❌ Error in set_span_to_zone: {e}")
        debug_log(message=f"🛠️ 🧨 Arrr, the code be capsized! The error be: {e}", file=current_file, version=current_version, function="set_span_to_zone")

def set_span_to_group(showtime_tab_instance, zone_zoom_tab):
    # [Calculates the required span for a group and sets the instrument using a start-stop command.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"🛠️ 🟢 Entering {current_function}", file=current_file, version=current_version, function=current_function)
    
    group_info = showtime_tab_instance.selected_group_info
    group_name = showtime_tab_instance.selected_group
    
    if not group_name:
        showtime_tab_instance.console_print_func("⚠️ No group selected. Cannot set span to group.")
        debug_log(message=f"🛠️ 🚫 No group selected.", file=current_file, version=current_version, function=current_function)
        return
        
    start_freq_mhz = group_info.get('min_freq')
    stop_freq_mhz = group_info.get('max_freq')
    number_of_markers = group_info.get('device_count')

    if number_of_markers == 0:
        showtime_tab_instance.console_print_func(f"⚠️ No valid frequencies found in group '{group_name}'. Cannot set span.")
        debug_log(message=f"🛠️ 🚫 No valid frequencies found in group '{group_name}'.", file=current_file, version=current_version, function=current_function)
        return

    debug_log(message=f"🛠️ 🔍 Reading state: group_info = {group_info}", file=current_file, version=current_version, function=current_function)
    
    try:
        # 📖 Read Data: Retrieve buffer value.
        buffer_mhz = float(showtime_tab_instance.buffer_var.get())
        debug_log(message=f"📖 Reading state: buffer_var = {buffer_mhz} MHz", file=current_file, version=current_version, function=current_function)

        buffered_start_freq_mhz, buffered_stop_freq_mhz = _buffer_start_stop_frequencies(start_freq_mhz, stop_freq_mhz, buffer_mhz)

        # 📝 Write Data: Store the buffered frequencies in the state.
        debug_log(message=f"📝 Writing state: buffered_start_var = {buffered_start_freq_mhz}, buffered_stop_var = {buffered_stop_freq_mhz}", file=current_file, version=current_version, function=current_function)
        showtime_tab_instance.buffered_start_var.set(buffered_start_freq_mhz)
        showtime_tab_instance.buffered_stop_var.set(buffered_stop_freq_mhz)
        
        start_freq_hz = int(buffered_start_freq_mhz * MHZ_TO_HZ)
        stop_freq_hz = int(buffered_stop_freq_mhz * MHZ_TO_HZ)
        
        showtime_tab_instance.console_print_func(f"✅ Setting span to group '{group_name}': {buffered_start_freq_mhz:.3f} MHz to {buffered_stop_freq_mhz:.3f} MHz.")

        handle_freq_start_stop_beg(app_instance=showtime_tab_instance.app_instance, start_freq=start_freq_hz, stop_freq=stop_freq_hz, console_print_func=showtime_tab_instance.console_print_func)
        
        showtime_tab_instance.follow_zone_span_var.set(True)

        showtime_tab_instance.zone_zoom_label_left_var.set(f"Group ({number_of_markers} Devices)")
        showtime_tab_instance.zone_zoom_label_center_var.set(f"Name: {group_name}")
        showtime_tab_instance.zone_zoom_label_right_var.set(f"Start: {buffered_start_freq_mhz:.3f} MHz\nStop: {buffered_stop_freq_mhz:.3f} MHz")
        
        zone_zoom_tab._sync_ui_from_state()
        debug_log(message=f"🛠️ ✅ Successfully updated group span and UI.", file=current_file, version=current_version, function=current_function)
        
        # FIXED: Add save_program_config call
        save_program_config(config=showtime_tab_instance.app_instance.config,
                    file_path=showtime_tab_instance.app_instance.CONFIG_FILE_PATH,
                    console_print_func=showtime_tab_instance.console_print_func,
                    app_instance=showtime_tab_instance.app_instance)

    except Exception as e:
        showtime_tab_instance.console_print_func(f"❌ Error in set_span_to_group: {e}")
        debug_log(message=f"🛠️ 🧨 Great Scott! The group span calculation has failed! The error is: {e}", file=current_file, version=current_version, function="set_span_to_group")
        
def set_span_to_device(showtime_tab_instance, zone_zoom_tab):
    # [Sets the instrument's span to focus on a single device using a center-span command.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"🛠️ 🟢 Entering {current_function}", file=current_file, version=current_version, function=current_function)
    
    device_info = showtime_tab_instance.selected_device_info
    
    if not device_info:
        showtime_tab_instance.console_print_func("⚠️ No device selected. Cannot set span to device.")
        debug_log(message=f"🛠️ 🚫 No device selected.", file=current_file, version=current_version, function=current_function)
        return

    device_name = device_info.get('NAME')
    center_freq_mhz = device_info.get('CENTER')
    
    debug_log(message=f"🛠️ 🔍 Reading state: device_name={device_name}, center_freq_mhz={center_freq_mhz}", file=current_file, version=current_version, function=current_function)
    
    try:
        # 📖 Read Data: Retrieve buffer value.
        buffer_mhz = float(showtime_tab_instance.buffer_var.get())
        debug_log(message=f"📖 Reading state: buffer_var = {buffer_mhz} MHz", file=current_file, version=current_version, function=current_function)

        center_freq_hz = int(center_freq_mhz * MHZ_TO_HZ)
        
        # FIXED: Check if the value contains 'M' and convert it to a float.
        span_str = showtime_tab_instance.span_var.get()
        if 'M' in span_str:
            span_mhz = float(span_str.replace('M', ''))
        else:
            span_mhz = float(span_str)
            
        span_hz = int(span_mhz * MHZ_TO_HZ)
        
        # Calculate start and stop with the buffer for display purposes
        buffered_span = span_mhz + (2 * buffer_mhz)
        buffered_start_freq_mhz = center_freq_mhz - (buffered_span / 2)
        buffered_stop_freq_mhz = center_freq_mhz + (buffered_span / 2)
        
        # 📝 Write Data: Store the buffered frequencies in the state.
        debug_log(message=f"📝 Writing state: buffered_start_var = {buffered_start_freq_mhz}, buffered_stop_var = {buffered_stop_freq_mhz}", file=current_file, version=current_version, function=current_function)
        showtime_tab_instance.buffered_start_var.set(buffered_start_freq_mhz)
        showtime_tab_instance.buffered_stop_var.set(buffered_stop_freq_mhz)
        
        showtime_tab_instance.console_print_func(f"✅ Setting span to device '{device_name}': Center={center_freq_mhz:.3f} MHz, Span={format_hz(span_hz)}.")

        handle_freq_center_span_beg(app_instance=showtime_tab_instance.app_instance, center_freq=center_freq_hz, span_freq=span_hz, console_print_func=showtime_tab_instance.console_print_func)
        
        showtime_tab_instance.follow_zone_span_var.set(False)

        showtime_tab_instance.zone_zoom_label_left_var.set(f"Device: {device_name}")
        showtime_tab_instance.zone_zoom_label_center_var.set(f"Name: {device_name}")
        showtime_tab_instance.zone_zoom_label_right_var.set(f"Center: {center_freq_mhz:.3f} MHz\nSpan: {span_mhz:.3f} MHz\nStart: {buffered_start_freq_mhz:.3f} MHz\nStop: {buffered_stop_freq_mhz:.3f} MHz")
        
        zone_zoom_tab._sync_ui_from_state()
        debug_log(message=f"🛠️ ✅ Successfully updated device span and UI.", file=current_file, version=current_version, function=current_function)
        
        # FIXED: Add save_program_config call
        save_program_config(config=showtime_tab_instance.app_instance.config,
                    file_path=showtime_tab_instance.app_instance.CONFIG_FILE_PATH,
                    console_print_func=showtime_tab_instance.console_print_func,
                    app_instance=showtime_tab_instance.app_instance)

    except Exception as e:
        showtime_tab_instance.console_print_func(f"❌ Error in set_span_to_device: {e}")
        debug_log(message=f"🛠️ 🧨 It's madness! The device span function has gone haywire! The error is: {e}", file=current_file, version=current_version, function="set_span_to_device")


#####################################
### File: OPEN-AIR\Markers\showtime\zones_groups_devices\tab_markers_child_zone_groups_devices.py
#####################################
# tabs/Markers/showtime/zones_groups_devices/tab_markers_child_zone_groups_devices.py
#
# [This file defines the ZoneGroupsDevicesFrame, which dynamically loads
# and displays data from the MARKERS.CSV file.]
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.110500.1
# REFACTORED: This file has been refactored to serve exclusively as a UI component.
#             The event handler functions have been moved to their own dedicated
#             utility files, thereby eliminating circular dependencies.
# UPDATED: The class now correctly uses `partial` to call the external handler functions.

import tkinter as tk
from tkinter import ttk
from functools import partial
import os
import inspect
from datetime import datetime

# Import utility functions from their dedicated files
from .utils_files_markers_zone_groups_devices import load_and_structure_markers_data
from .utils_button_volume_level import create_signal_level_indicator

# Import the specific selection handlers for each button type
from .utils_display_showtime_zones import on_zone_selected
from .utils_display_showtime_groups import on_group_selected
from .utils_display_showtime_devices import on_device_selected
from .utils_display_showtime_all import on_all_markers_selected

from display.debug_logic import debug_log
from display.console_logic import console_log
from src.program_style import COLOR_PALETTE


# --- Versioning ---
w = 20250824
x_str = '110500'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"


class ZoneGroupsDevicesFrame(ttk.Frame):
    def __init__(self, parent_frame, showtime_tab_instance):
        # [Initializes the frame, restoring the original grid layout and scrollable device list.]
        super().__init__(parent_frame, style='TFrame')
        self.showtime_tab_instance = showtime_tab_instance
        self.structured_data = None
        self.grid(row=0, column=0, sticky="nsew")

        # Widget references for active selections, now correctly on the Frame instance
        self.active_zone_button = None
        self.active_group_button = None

        self._create_layout()

    def _create_layout(self):
        # [Creates the main layout with zones, groups, and the scrollable device frame.]
        self.columnconfigure(0, weight=1)
        self.rowconfigure(2, weight=1) # Allow device frame to expand
        
        self.zones_frame = ttk.LabelFrame(self, text="Zones", style='TLabelframe')
        self.zones_frame.grid(row=0, column=0, sticky="ew", padx=10, pady=5)
        
        self.groups_frame = ttk.LabelFrame(self, text="Groups", style='TLabelframe')
        self.groups_frame.grid(row=1, column=0, sticky="ew", padx=10, pady=5)
        
        self._create_device_frame(self)

    def _create_device_frame(self, parent):
        # [Creates the scrollable canvas for the device buttons.]
        self.devices_outer_frame = ttk.LabelFrame(parent, text="Devices", style='TLabelframe')
        self.devices_outer_frame.grid(row=2, column=0, sticky="nsew", padx=10, pady=5)
        self.devices_outer_frame.grid_rowconfigure(0, weight=1)
        self.devices_outer_frame.grid_columnconfigure(0, weight=1)
        
        self.canvas = tk.Canvas(self.devices_outer_frame, borderwidth=0, highlightthickness=0, bg=COLOR_PALETTE['background'])
        scrollbar = ttk.Scrollbar(self.devices_outer_frame, orient="vertical", command=self.canvas.yview)
        self.devices_scrollable_frame = ttk.Frame(self.canvas, style='Dark.TFrame')
        self.devices_scrollable_frame.bind("<Configure>", lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all")))
        
        self.canvas.create_window((0, 0), window=self.devices_scrollable_frame, anchor="nw")
        self.canvas.configure(yscrollcommand=scrollbar.set)
        
        self.canvas.grid(row=0, column=0, sticky="nsew")
        scrollbar.grid(row=0, column=1, sticky="ns")

    def load_and_display_data(self):
        # [Main entry point to load data and fully rebuild the UI.]
        self.structured_data = load_and_structure_markers_data()
        self._make_zone_buttons()
        self._make_group_buttons()
        self._make_device_buttons()
        
        all_devices = self._get_all_devices_in_zone(self.structured_data, None)
        self._get_min_max_freq_and_update_title(frame_widget=self.zones_frame, devices=all_devices, title_prefix="ALL DEVICES")
        self.groups_frame.config(text="Groups")
        self.devices_outer_frame.config(text="Devices")

    def _make_zone_buttons(self):
        # [Creates the zone selection buttons in a grid.]
        for widget in self.zones_frame.winfo_children():
            widget.destroy()
        if not self.structured_data:
            ttk.Label(self.zones_frame, text="Could not load MARKERS.CSV").pack(padx=5, pady=5)
            return

        max_columns = 6
        for i, zone_name in enumerate(self.structured_data.keys()):
            row, col = divmod(i, max_columns)
            # Calls the external function from utils_display_showtime_zones.py
            btn = ttk.Button(self.zones_frame, text=zone_name, style='ControlButton.Inactive.TButton', command=partial(on_zone_selected, self, zone_name))
            btn.grid(row=row, column=col, padx=2, pady=2, sticky="ew")
            self.zones_frame.columnconfigure(col, weight=1)

    def _make_group_buttons(self):
        # [Creates group buttons, dynamically showing/hiding the frame.]
        for widget in self.groups_frame.winfo_children():
            widget.destroy()
        self.groups_frame.grid_remove() # Hide by default

        if not self.showtime_tab_instance.selected_zone or not self.structured_data:
            return

        groups = self.structured_data.get(self.showtime_tab_instance.selected_zone, {})
        # Show frame only if there are meaningful groups to select
        if len(groups) > 1 or (len(groups) == 1 and next(iter(groups)) not in ['Ungrouped', 'No Group']):
            self.groups_frame.grid()
        else:
            return

        max_columns = 6
        for i, group_name in enumerate(groups.keys()):
            row, col = divmod(i, max_columns)
            # Calls the external function from utils_display_showtime_groups.py
            btn = ttk.Button(self.groups_frame, text=group_name, style='ControlButton.Inactive.TButton', command=partial(on_group_selected, self, group_name))
            btn.grid(row=row, column=col, padx=2, pady=2, sticky="ew")
            self.groups_frame.columnconfigure(col, weight=1)

    def _make_device_buttons(self):
        # [Creates the detailed, multi-line device buttons in the scrollable frame.]
        for widget in self.devices_scrollable_frame.winfo_children():
            widget.destroy()
        self.showtime_tab_instance.device_buttons.clear()

        devices_to_display = self._get_devices_to_display()
        self.devices_outer_frame.config(text=f"Devices ({len(devices_to_display)})")

        max_cols = 4
        for col in range(max_cols):
            self.devices_scrollable_frame.grid_columnconfigure(col, weight=1)
            
        for i, device in enumerate(devices_to_display):
            name = device.get('NAME', 'N/A')
            device_type = device.get('DEVICE', 'N/A')
            center = device.get('CENTER', 'N/A')
            peak = device.get('PEAK', -120.0)
            
            progress_bar = create_signal_level_indicator(peak)
            btn_text = f"{name}\n{device_type}\n{center} MHz\n{peak} dBm\n{progress_bar}"
            
            # Calls the external function from utils_display_showtime_devices.py
            btn = ttk.Button(self.devices_scrollable_frame, text=btn_text, style='DeviceButton.Inactive.TButton', command=partial(on_device_selected, self, device))
            self.showtime_tab_instance.device_buttons[id(device)] = btn
            
            row, col = divmod(i, max_cols)
            btn.grid(row=row, column=col, padx=5, pady=2, sticky="ew")

    def _get_devices_to_display(self):
        # [Helper to determine which list of devices to show based on selection.]
        if self.showtime_tab_instance.selected_zone:
            zone_data = self.structured_data.get(self.showtime_tab_instance.selected_zone, {})
            if self.showtime_tab_instance.selected_group:
                return zone_data.get(self.showtime_tab_instance.selected_group, [])
            else:
                return self._get_all_devices_in_zone(self.structured_data, self.showtime_tab_instance.selected_zone)
        return self._get_all_devices_in_zone(self.structured_data, None)

    def _get_min_max_freq_and_update_title(self, frame_widget, devices, title_prefix):
        # [Calculates min/max frequency and updates a frame's title.]
        freqs = [float(d['CENTER']) for d in devices if isinstance(d.get('CENTER'), (int, float))]
        if freqs:
            min_freq, max_freq = min(freqs), max(freqs)
            new_title = f"{title_prefix} ({len(devices)}) - MIN: {min_freq:.3f} MHz - MAX: {max_freq:.3f} MHz"
        else:
            new_title = f"{title_prefix} ({len(devices)})"
        frame_widget.config(text=new_title)
        
    def _get_all_devices_in_zone(self, structured_data, zone_name):
        # [Helper to flatten all devices from all groups within a zone, or all zones.]
        devices = []
        if structured_data and zone_name: # A specific zone
            for group_devices in structured_data.get(zone_name, {}).values():
                devices.extend(group_devices)
        elif structured_data: # All zones
            for zone in structured_data.values():
                for group_devices in zone.values():
                    devices.extend(group_devices)
        return devices

#####################################
### File: OPEN-AIR\Markers\showtime\zones_groups_devices\utils_button_volume_level.py
#####################################
# tabs/Markers/showtime/util_button_volume_level.py
#
# This file provides a standalone utility function to generate a Unicode text-based
# progress bar for a given value within a specified range.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
#
#
# Version 20250822.103000.1
# UPDATED: The function now handles NaN values gracefully by returning an empty bar.
# UPDATED: File header and versioning adhere to new standards.
# UPDATED: All debug messages now include the correct emoji prefixes.

import inspect
import os
from datetime import datetime
import math # Import the math module to check for NaN

from display.debug_logic import debug_log

# --- Versioning ---
w = 20250822
x_str = '103000'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"

def create_signal_level_indicator(value, min_val=-120, max_val=0, width=24):
    """
    Generates a Unicode text-based progress bar for a given peak value.

    Args:
        value (float): The current value to represent in the progress bar.
        min_val (int): The minimum value of the range (e.g., -120 dBm).
        max_val (int): The maximum value of the range (e.g., 0 dBm).
        width (int): The width of the progress bar in characters.

    Returns:
        str: A string representing the Unicode progress bar, e.g., '[█████████        ]'.
    """
    current_function = inspect.currentframe().f_code.co_name
 #   debug_log(f"🛠️ 🟢 Entering {current_function} with value: {value}", file=current_file, version=current_version, function=current_function)
    try:
        # Check if the value is NaN or None and handle it gracefully
        if value is None or (isinstance(value, float) and math.isnan(value)):
            debug_log(f"🛠️ 🟡 Value is NaN or None. Returning empty bar.", file=current_file, version=current_version, function=current_function)
            return f"[{' ' * width}]"

        value = float(value)
        if value < min_val:
            value = min_val
        if value > max_val:
            value = max_val
        
        percentage = (value - min_val) / (max_val - min_val)
        filled_length = int(width * percentage)
        
        bar = '█' * filled_length
        empty = ' ' * (width - filled_length)
#        debug_log(f"🛠️ 🟢 Exiting {current_function}. Generated bar: [{bar}{empty}]", file=current_file, version=current_version, function=current_function)
        return f"[{bar}{empty}]"
    except (ValueError, TypeError) as e:
        debug_log(f"🛠️ ❌ Error in {current_function}: {e}. Returning empty bar. Fucking useless!", file=current_file, version=current_version, function=current_function)
        return f"[{' ' * width}]"


#####################################
### File: OPEN-AIR\Markers\showtime\zones_groups_devices\utils_display_showtime_all.py
#####################################
# tabs/Markers/showtime/zones_groups_devices/utils_display_showtime_all.py
#
# This module provides the backend logic for handling the "All Markers" view.
# It manages the selection of all markers and delegates to shared utility
# functions for updating the display and instrument's span.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.110500.6
# REFACTORED: Created a new file for the "All Markers" view to improve modularity.
# UPDATED: Imports now point to the new shared utility file.
# FIXED: The function now correctly gets all devices and calls the appropriate
#        span utility function.

import os
import inspect
from tkinter import ttk
import pandas as pd
import numpy as np

from display.debug_logic import debug_log
from display.console_logic import console_log

# Import shared utility functions
from Markers.showtime.controls.utils_showtime_zone_zoom import set_span_to_all_markers, set_span_to_group

from .utils_display_showtime_shared import _update_zone_zoom_tab, _save_showtime_state_to_config


# --- Versioning ---
w = 20250824
x_str = '110500'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 6
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"


def on_all_markers_selected(zgd_frame_instance):
    # [Handles the logic for selecting and viewing all markers.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"🛠️🟢 Entering {current_function}", file=current_file, version=current_version, function=current_function)

    showtime_tab = zgd_frame_instance.showtime_tab_instance
    
    console_log(f"EVENT: All markers selected. Displaying all devices...", "INFO")
    
    # Reset all active selections
    if zgd_frame_instance.active_zone_button and zgd_frame_instance.active_zone_button.winfo_exists():
        zgd_frame_instance.active_zone_button.config(style='ControlButton.Inactive.TButton')
        zgd_frame_instance.active_zone_button = None
    if zgd_frame_instance.active_group_button and zgd_frame_instance.active_group_button.winfo_exists():
        zgd_frame_instance.active_group_button.config(style='ControlButton.Inactive.TButton')
        zgd_frame_instance.active_group_button = None
    if showtime_tab.active_device_button and showtime_tab.active_device_button.winfo_exists():
        showtime_tab.active_device_button.config(style='DeviceButton.Inactive.TButton')
    showtime_tab.active_device_button = None
    
    # 📝 Write Data: Update selected state variables.
    debug_log(message=f"🛠️📝 Writing to state: Setting selection to all markers.", file=current_file, version=current_version, function=current_function)
    showtime_tab.selected_zone = None
    showtime_tab.selected_group = None
    showtime_tab.selected_device_info = None
    showtime_tab.last_selected_type = 'all markers'
    
    all_devices = zgd_frame_instance._get_all_devices_in_zone(zgd_frame_instance.structured_data, None)
    
    if all_devices:
        freqs = [float(d['CENTER']) for d in all_devices if isinstance(d.get('CENTER'), (int, float))]
        min_freq = min(freqs) if freqs else 0.0
        max_freq = max(freqs) if freqs else 0.0
        device_count = len(all_devices)

        showtime_tab.selected_zone_info = {
            'min_freq': min_freq,
            'max_freq': max_freq,
            'device_count': device_count
        }
        showtime_tab.selected_group_info = {}
        
        zgd_frame_instance._get_min_max_freq_and_update_title(frame_widget=zgd_frame_instance.zones_frame, devices=all_devices, title_prefix="All Devices")
        zgd_frame_instance._make_group_buttons()
        zgd_frame_instance._make_device_buttons()
        
    # Call the set_span_to_all_markers utility function to trigger the update
    from Markers.showtime.controls.utils_showtime_zone_zoom import set_span_to_all_markers
    set_span_to_all_markers(showtime_tab_instance=showtime_tab, zone_zoom_tab=showtime_tab.controls_frame.zone_zoom_tab)

    _save_showtime_state_to_config(showtime_tab)

    debug_log(message=f"🛠️🟢 Exiting {current_function}", file=current_file, version=current_version, function=current_function)



  


    
def no_zone_grou_device_selected(zgd_frame_instance):
    # [Handles the logic for when no zone, group, or device is selected.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"🛠️🟢 Entering {current_function}", file=current_file, version=current_version, function=current_function)
    
    console_log(f"EVENT: No zone, group, or device selected. Displaying all devices. ")
    
    # Access and update parent's state variables directly
    showtime_tab = zgd_frame_instance.showtime_tab_instance
    # 📝 Write Data: Reset selected state variables.
    debug_log(message=f"🛠️📝 Writing to state: Resetting selected state variables.", file=current_file, version=current_version, function=current_function)
    showtime_tab.selected_zone = None
    showtime_tab.selected_group = None
    showtime_tab.selected_device_info = None
    showtime_tab.last_selected_type = None

    if zgd_frame_instance.active_zone_button and zgd_frame_instance.active_zone_button.winfo_exists():
        zgd_frame_instance.active_zone_button.config(style='ControlButton.Inactive.TButton')
        zgd_frame_instance.active_zone_button = None
        
    if zgd_frame_instance.active_group_button and zgd_frame_instance.active_group_button.winfo_exists():
        zgd_frame_instance.active_group_button.config(style='ControlButton.Inactive.TButton')
        zgd_frame_instance.active_group_button = None
        
    if showtime_tab.active_device_button and showtime_tab.active_device_button.winfo_exists():
        showtime_tab.active_device_button.config(style='DeviceButton.Inactive.TButton')
    showtime_tab.active_device_button = None
    
    # FIXED: Revert the view to the parent group when a device is deselected.
    set_span_to_group(showtime_tab_instance=showtime_tab, zone_zoom_tab=showtime_tab.controls_frame.zone_zoom_tab)
    _update_zone_zoom_tab(zgd_frame_instance)
    _save_showtime_state_to_config(showtime_tab)
    
    if hasattr(showtime_tab.controls_frame, 'switch_to_tab'):
        showtime_tab.controls_frame.switch_to_tab("Zone Zoom")
        
    debug_log(message=f"🛠️🟢 Exiting {current_function}", file=current_file, version=current_version, function=current_function)
  

#####################################
### File: OPEN-AIR\Markers\showtime\zones_groups_devices\utils_display_showtime_devices.py
#####################################
# tabs/Markers/showtime/zones_groups_devices/utils_display_showtime_devices.py
#
# This module provides the backend logic for handling Device-level button clicks.
# It manages the selection and deselection of devices, updates the UI to reflect
# the current state, and communicates directly with the instrument to set the
# center frequency and span. It delegates to shared utility functions for saving
# the state and updating the instrument's view.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.110500.6
# REFACTORED: Extracted device-specific logic from the main utility file.
# UPDATED: Corrected imports to resolve circular dependencies.
# FIXED: The logic for selecting a device now correctly sets the instrument's
#        center frequency and span based on the device's frequency.

import os
import inspect
import pandas as pd
import numpy as np
import math

from display.debug_logic import debug_log
from display.console_logic import console_log

# Import shared utility functions
from Markers.showtime.controls.utils_showtime_zone_zoom import set_span_to_group
from .utils_display_showtime_shared import _update_zone_zoom_tab, _save_showtime_state_to_config
from yak.utils_yakbeg_handler import handle_freq_center_span_beg


# --- Versioning ---
w = 20250824
x_str = '110500'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 6
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"


def on_device_deselected(zgd_frame_instance):
    # [Handles the logic for when a device is deselected.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"🛠️🟢 Entering {current_function}", file=current_file, version=current_version, function=current_function)
    
    showtime_tab = zgd_frame_instance.showtime_tab_instance
    # 📝 Write Data: Reset selected state variables.
    debug_log(message=f"🛠️📝 Writing to state: Resetting selected device.", file=current_file, version=current_version, function=current_function)
    showtime_tab.selected_device_info = None
    showtime_tab.last_selected_type = 'group'

    if showtime_tab.active_device_button and showtime_tab.active_device_button.winfo_exists():
        showtime_tab.active_device_button.config(style='DeviceButton.Inactive.TButton')
    showtime_tab.active_device_button = None
    
    # FIXED: Revert the view to the parent group when a device is deselected.
    set_span_to_group(showtime_tab_instance=showtime_tab, zone_zoom_tab=showtime_tab.controls_frame.zone_zoom_tab)
    _update_zone_zoom_tab(zgd_frame_instance)
    _save_showtime_state_to_config(showtime_tab)
    
    if hasattr(showtime_tab.controls_frame, 'switch_to_tab'):
        showtime_tab.controls_frame.switch_to_tab("Zone Zoom")
        
    debug_log(message=f"🛠️🟢 Exiting {current_function}", file=current_file, version=current_version, function=current_function)


def on_device_selected(zgd_frame_instance, device_info):
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"🛠️🟢 Entering {current_function} for device object: {device_info}", file=current_file, version=current_version, function=current_function)

    showtime_tab = zgd_frame_instance.showtime_tab_instance
    device_name = device_info.get('NAME', 'N/A')

    if isinstance(device_name, float) and np.isnan(device_name):
        device_name = 'nan'
    
    if showtime_tab.selected_device_info and id(showtime_tab.selected_device_info) == id(device_info):
        console_log(f"EVENT: Device '{device_name}' deselected.")
        from .utils_display_showtime_groups import on_group_deselected # Correctly moved here
        on_device_deselected(zgd_frame_instance)
        debug_log(message=f"🛠️🟢 Exiting {current_function} after deselecting device.", file=current_file, version=current_version, function=current_function)
        return

    # 📝 Write Data: Update selected state variables.
    debug_log(message=f"🛠️📝 Writing to state: Storing selected device info.", file=current_file, version=current_version, function=current_function)
    showtime_tab.selected_device_info = device_info
    showtime_tab.last_selected_type = 'device'

    selected_button = showtime_tab.device_buttons.get(id(device_info))
    
    if showtime_tab.active_device_button and showtime_tab.active_device_button.winfo_exists():
        showtime_tab.active_device_button.config(style='DeviceButton.Inactive.TButton')

    if selected_button:
        selected_button.config(style='DeviceButton.Active.TButton')
        showtime_tab.active_device_button = selected_button
        console_log(f"✅ EVENT: Device '{device_name}' selected. 🎵")
    
    if device_info:
        freq = device_info.get('CENTER', 'N/A')
        if freq != 'N/A':
            zgd_frame_instance.devices_outer_frame.config(text=f"Devices - {device_name} - {freq:.3f} MHz")
            console_log(f"✅ Displaying device '{device_name}' at frequency {freq:.3f} MHz.")
            if hasattr(showtime_tab.controls_frame, 'switch_to_tab'):
                showtime_tab.controls_frame.switch_to_tab("Span")
        else:
            zgd_frame_instance.devices_outer_frame.config(text=f"Devices - {device_name} - N/A")
            console_log(f"⚠️ Device '{device_name}' has no valid frequency.")
    else:
        zgd_frame_instance.devices_outer_frame.config(text="Devices")
        console_log(f"❌ Device info not found. The device has vanished into thin air!")

    _update_zone_zoom_tab(zgd_frame_instance)
    
    # NEW: Set the instrument's center frequency and span based on the state.
    center_freq_mhz = device_info.get('CENTER')
    # 📖 Read Data: Get the current span from the state.
    span_str = showtime_tab.span_var.get()
    if 'M' in span_str:
        span_mhz = float(span_str.replace('M', ''))
    else:
        span_mhz = float(span_str)

    if center_freq_mhz is not None and isinstance(center_freq_mhz, (float, int)):
        debug_log(message=f"🛠️📤 Outbound: Setting instrument center frequency to {center_freq_mhz} MHz and span to {span_mhz} MHz.", file=current_file, version=current_version, function=current_function)
        
        # Convert to Hz for the handler function
        center_freq_hz = int(center_freq_mhz * 1_000_000)
        span_hz = int(span_mhz * 1_000_000)
        
        handle_freq_center_span_beg(app_instance=showtime_tab.app_instance, 
                                 center_freq=center_freq_hz, 
                                 span_freq=span_hz,
                                 console_print_func=showtime_tab.console_print_func)
    else:
        console_log("❌ Cannot set instrument center frequency. Invalid device center frequency.")
        debug_log(message=f"🛠️❌ Invalid center frequency for device: {center_freq_mhz}. Cannot set instrument.", 
                  file=current_file, 
                  version=current_version, 
                  function=current_function)

    _save_showtime_state_to_config(showtime_tab)

    debug_log(message=f"🛠️🟢 Exiting {current_function}", file=current_file, version=current_version, function=current_function)

#####################################
### File: OPEN-AIR\Markers\showtime\zones_groups_devices\utils_display_showtime_groups.py
#####################################
# tabs/Markers/showtime/zones_groups_devices/utils_display_showtime_groups.py
#
# This module provides the backend logic for handling Group-level button clicks.
# It manages the selection and deselection of groups, handles single-device
# auto-selection, and delegates to shared utility functions for saving
# the state and updating the instrument's view.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.110500.6
# REFACTORED: Extracted group-specific logic from the main utility file.
# UPDATED: Corrected imports to resolve circular dependencies.
# FIXED: The logic for selecting a group now correctly checks for single devices and auto-selects them.
# FIXED: Moved `on_group_deselected` to the shared utility file to break a circular import.

import os
import inspect
import math
from tkinter import ttk
import pandas as pd
import numpy as np

from display.debug_logic import debug_log
from display.console_logic import console_log

# Import shared utility functions
from Markers.showtime.controls.utils_showtime_zone_zoom import set_span_to_group
from .utils_display_showtime_shared import _update_zone_zoom_tab, _save_showtime_state_to_config


# --- Versioning ---
w = 20250824
x_str = '110500'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 6
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"


def on_group_selected(zgd_frame_instance, group_name):
    
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"🛠️🟢 Entering {current_function} for group: {group_name}", file=current_file, version=current_version, function=current_function)

    showtime_tab = zgd_frame_instance.showtime_tab_instance
    devices_in_group = zgd_frame_instance.structured_data.get(showtime_tab.selected_zone, {}).get(group_name, [])

    if len(devices_in_group) == 1:
        console_log(f"EVENT: Group '{group_name}' contains one device. Auto-selecting device...", "INFO")
        # 📝 Write Data: Update selected state variables.
        debug_log(message=f"🛠️📝 Writing to state: Updating selected group and resetting device.", file=current_file, version=current_version, function=current_function)
        showtime_tab.selected_group = group_name
        zgd_frame_instance._make_device_buttons()
        # Lazily import on_device_selected to break circular import
        from .utils_display_showtime_devices import on_device_selected 
        on_device_selected(zgd_frame_instance, devices_in_group[0])
        
        for widget in zgd_frame_instance.groups_frame.winfo_children():
            if widget.cget("text") == group_name:
                if zgd_frame_instance.active_group_button and zgd_frame_instance.active_group_button.winfo_exists():
                    zgd_frame_instance.active_group_button.config(style='ControlButton.Inactive.TButton')
                widget.config(style='ControlButton.Active.TButton')
                zgd_frame_instance.active_group_button = widget
                break
        return

    if showtime_tab.selected_group == group_name:
        console_log(f"EVENT: Group '{group_name}' deselected. Reverting to show all devices in Zone '{showtime_tab.selected_zone}'.", "INFO")
        on_group_deselected(zgd_frame_instance)
        return

    for widget in zgd_frame_instance.groups_frame.winfo_children():
        if widget.cget("text") == group_name:
            selected_button = widget
            break
    else:
        selected_button = None

    console_log(f"EVENT: Group '{group_name}' selected in Zone '{showtime_tab.selected_zone}'. Loading devices... ⚙️")
    if zgd_frame_instance.active_group_button and zgd_frame_instance.active_group_button.winfo_exists():
        zgd_frame_instance.active_group_button.config(style='ControlButton.Inactive.TButton')

    # 📝 Write Data: Update selected state variables.
    debug_log(message=f"🛠️📝 Writing to state: Updating selected group and resetting device.", file=current_file, version=current_version, function=current_function)
    showtime_tab.active_device_button = None
    showtime_tab.selected_device_info = None
    showtime_tab.selected_group = group_name
    showtime_tab.last_selected_type = 'group'

    # NEW: Calculate and store group information in state
    freqs = [float(d['CENTER']) for d in devices_in_group if isinstance(d.get('CENTER'), (int, float))]
    
    # FIXED: Check if freqs is not empty before calling min/max
    if freqs:
        min_freq = min(freqs)
        max_freq = max(freqs)
    else:
        min_freq = 0.0
        max_freq = 0.0
        
    showtime_tab.selected_group_info = {
        'min_freq': min_freq,
        'max_freq': max_freq,
        'device_count': len(devices_in_group)
    }
    
    debug_log(message=f"🛠️📦 Stored group info in state: {showtime_tab.selected_group_info}", file=current_file, version=current_version, function=current_function)

    if selected_button:
        selected_button.config(style='ControlButton.Active.TButton')
        zgd_frame_instance.active_group_button = selected_button
    
    devices_in_group_list = zgd_frame_instance.structured_data.get(showtime_tab.selected_zone, {}).get(group_name, [])
    zgd_frame_instance._get_min_max_freq_and_update_title(frame_widget=zgd_frame_instance.groups_frame, devices=devices_in_group_list, title_prefix=f"Group '{group_name}'")

    zgd_frame_instance._make_device_buttons()
    zgd_frame_instance.canvas.yview_moveto(0)
    
    # FIXED: Call the set_span_to_group utility function here to trigger the update
    from Markers.showtime.controls.utils_showtime_zone_zoom import set_span_to_group
    set_span_to_group(showtime_tab_instance=showtime_tab, zone_zoom_tab=showtime_tab.controls_frame.zone_zoom_tab)
    _save_showtime_state_to_config(showtime_tab)

    debug_log(message=f"🛠️🟢 Exiting {current_function}", file=current_file, version=current_version, function=current_function)

def on_group_deselected(zgd_frame_instance):
    # [Handles the logic for when a group is deselected.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"🛠️🟢 Entering {current_function}", file=current_file, version=current_version, function=current_function)
    
    showtime_tab = zgd_frame_instance.showtime_tab_instance

    if zgd_frame_instance.active_group_button and zgd_frame_instance.active_group_button.winfo_exists():
        zgd_frame_instance.active_group_button.config(style='ControlButton.Inactive.TButton')
        zgd_frame_instance.active_group_button = None
        
    # 📝 Write Data: Reset selected state variables.
    debug_log(message=f"🛠️📝 Writing to state: Resetting selected group and related info.", file=current_file, version=current_version, function=current_function)
    showtime_tab.selected_group = None
    showtime_tab.last_selected_type = 'zone'
    showtime_tab.selected_group_info = {
        'min_freq': 0.0,
        'max_freq': 0.0,
        'device_count': 0
    }
    zgd_frame_instance._make_device_buttons()
    
    _update_zone_zoom_tab(zgd_frame_instance)
    _save_showtime_state_to_config(showtime_tab)
    
    if hasattr(showtime_tab.controls_frame, 'switch_to_tab'):
        showtime_tab.controls_frame.switch_to_tab("Zone Zoom")
        
    debug_log(message=f"🛠️🟢 Exiting {current_function}", file=current_file, version=current_version, function=current_function)

def no_zone_grou_device_selected(zgd_frame_instance):
    # [Handles the logic for when no zone, group, or device is selected.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"🛠️🟢 Entering {current_function}", file=current_file, version=current_version, function=current_function)
    
    console_log(f"EVENT: No zone, group, or device selected. Displaying all devices. ")
    
    # Access and update parent's state variables directly
    showtime_tab = zgd_frame_instance.showtime_tab_instance
    # 📝 Write Data: Reset selected state variables.
    debug_log(message=f"🛠️📝 Writing to state: Resetting selected state variables.", file=current_file, version=current_version, function=current_function)
    showtime_tab.selected_zone = None
    showtime_tab.selected_group = None
    showtime_tab.selected_device_info = None
    showtime_tab.last_selected_type = None

    if zgd_frame_instance.active_zone_button and zgd_frame_instance.active_zone_button.winfo_exists():
        zgd_frame_instance.active_zone_button.config(style='ControlButton.Inactive.TButton')
        zgd_frame_instance.active_zone_button = None
        
    if zgd_frame_instance.active_group_button and zgd_frame_instance.active_group_button.winfo_exists():
        zgd_frame_instance.active_group_button.config(style='ControlButton.Inactive.TButton')
        zgd_frame_instance.active_group_button = None
        
    if showtime_tab.active_device_button and showtime_tab.active_device_button.winfo_exists():
        showtime_tab.active_device_button.config(style='DeviceButton.Inactive.TButton')
    showtime_tab.active_device_button = None
    
    # FIXED: Revert the view to the parent group when a device is deselected.
    set_span_to_group(showtime_tab_instance=showtime_tab, zone_zoom_tab=showtime_tab.controls_frame.zone_zoom_tab)
    _update_zone_zoom_tab(zgd_frame_instance)
    _save_showtime_state_to_config(showtime_tab)
    
    if hasattr(showtime_tab.controls_frame, 'switch_to_tab'):
        showtime_tab.controls_frame.switch_to_tab("Zone Zoom")
        
    debug_log(message=f"🛠️🟢 Exiting {current_function}", file=current_file, version=current_version, function=current_function)

#####################################
### File: OPEN-AIR\Markers\showtime\zones_groups_devices\utils_display_showtime_shared.py
#####################################
# tabs/Markers/showtime/zones_groups_devices/utils_display_showtime_shared.py
#
# This file provides shared utility functions for the Showtime tab's UI and state management.
# It contains logic that is common to handling selections at the zone, group, and device level,
# including saving the entire Showtime state to the config file and updating the zone-zoom display.
# By centralizing this code, it prevents duplication and ensures consistent behavior across
# all selection handlers.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.110500.6
# REFACTORED: Consolidated all truly shared functions into this single file.
# FIXED: The save function has been made more robust with checks for None values.
# FIXED: All references to shared state variables are now robustly handled.
# FIXED: Moved `on_group_deselected` to this file to break a circular import.

import os
import inspect
import math
from tkinter import ttk
import pandas as pd
import numpy as np
import threading

from display.debug_logic import debug_log
from display.console_logic import console_log
from settings_and_config.config_manager_save import save_program_config

# Import shared utility functions
from Markers.showtime.controls.utils_showtime_zone_zoom import _buffer_start_stop_frequencies, set_span_to_group


# --- Versioning ---
w = 20250824
x_str = '110500'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 6
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"


def _save_showtime_state_to_config(showtime_tab):
    # [Internal function to save all Showtime state variables to the config.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"🛠️📝 Writing Showtime state to configuration.", file=current_file, version=current_version, function=current_function)
    
    # Check if the parent tab exists before trying to save its state
    if not hasattr(showtime_tab, 'app_instance'):
        debug_log("❌ Cannot save config. ShowtimeParentTab instance does not have 'app_instance' attribute.", file=current_file, version=current_version, function=current_function)
        return
        
    try:
        config = showtime_tab.app_instance.config
        
        if not config.has_section('MarkerTab'):
            config.add_section('MarkerTab')
            
        # Save all the state variables to the config file
        config.set('MarkerTab', 'span_hz', str(showtime_tab.span_var.get()))
        config.set('MarkerTab', 'rbw_hz', str(showtime_tab.rbw_var.get()))
        config.set('MarkerTab', 'trace_live', str(showtime_tab.trace_modes['live'].get()))
        config.set('MarkerTab', 'trace_max_hold', str(showtime_tab.trace_modes['max'].get()))
        config.set('MarkerTab', 'trace_min_hold', str(showtime_tab.trace_modes['min'].get()))
        config.set('MarkerTab', 'buffer_mhz', str(showtime_tab.buffer_var.get()))
        config.set('MarkerTab', 'poke_mhz', str(showtime_tab.poke_freq_var.get()))
        
        config.set('MarkerTab', 'buffered_start_var', str(showtime_tab.buffered_start_var.get()))
        config.set('MarkerTab', 'buffered_stop_var', str(showtime_tab.buffered_stop_var.get()))
        
        # Save selection state with robust checks
        config.set('MarkerTab', 'zone_selected', 'true' if showtime_tab.selected_zone else 'false')
        config.set('MarkerTab', 'zone_zoom_button_selected_name', showtime_tab.selected_zone if showtime_tab.selected_zone else '')
        
        config.set('MarkerTab', 'group_selected', 'true' if showtime_tab.selected_group else 'false')
        config.set('MarkerTab', 'group_zoom_button_selected', 'true' if showtime_tab.selected_group else 'false')

        # We need to save device info as a string or a set of strings, not a dictionary directly
        if showtime_tab.selected_device_info:
            config.set('MarkerTab', 'device_selected_name', str(showtime_tab.selected_device_info.get('NAME', '')))
            config.set('MarkerTab', 'device_selected_device_type', str(showtime_tab.selected_device_info.get('DEVICE', '')))
            config.set('MarkerTab', 'device_selected_center', str(showtime_tab.selected_device_info.get('CENTER', '')))
        else:
            config.set('MarkerTab', 'device_selected_name', '')
            config.set('MarkerTab', 'device_selected_device_type', '')
            config.set('MarkerTab', 'device_selected_center', '')
            
        # The info dictionaries need to be saved as strings.
        config.set('MarkerTab', 'zone_zoom_label_left_var', showtime_tab.zone_zoom_label_left_var.get())
        config.set('MarkerTab', 'zone_zoom_label_center_var', showtime_tab.zone_zoom_label_center_var.get())
        config.set('MarkerTab', 'zone_zoom_label_right_var', showtime_tab.zone_zoom_label_right_var.get())

        config.set('MarkerTab', 'zone_zoom_start', str(showtime_tab.buffered_start_var.get()))
        config.set('MarkerTab', 'zone_zoom_stop', str(showtime_tab.buffered_stop_var.get()))
        config.set('MarkerTab', 'group_zoom_start', str(showtime_tab.buffered_start_var.get()))
        config.set('MarkerTab', 'group_zoom_stop', str(showtime_tab.buffered_stop_var.get()))
        
        # FIXED: Corrected the way device counts are retrieved with safe defaults, preventing crashes if state is None
        zone_info = showtime_tab.selected_zone_info if hasattr(showtime_tab, 'selected_zone_info') and showtime_tab.selected_zone_info else {}
        group_info = showtime_tab.selected_group_info if hasattr(showtime_tab, 'selected_group_info') and showtime_tab.selected_group_info else {}
        
        config.set('MarkerTab', 'zone_device_count', str(zone_info.get('device_count', 0)))
        
        # FIXED: The previous line was incorrect, trying to get `keys()` from a potentially empty dict
        zone_groups = showtime_tab.structured_data.get(showtime_tab.selected_zone, {}) if showtime_tab.structured_data and showtime_tab.selected_zone else {}
        config.set('MarkerTab', 'zone_group_count', str(len(zone_groups.keys()) if showtime_tab.selected_zone else 0))

        config.set('MarkerTab', 'group_device_count', str(group_info.get('device_count', 0)))
        
        
        save_program_config(config=config,
                    file_path=showtime_tab.app_instance.CONFIG_FILE_PATH,
                    console_print_func=showtime_tab.console_print_func,
                    app_instance=showtime_tab.app_instance)
        
        debug_log(message=f"🛠️ ✅ Showtime state successfully written to config.", file=current_file, version=current_version, function=current_function)

    except Exception as e:
        console_log(f"❌ Error saving Showtime state to config: {e}. Fucking useless!", "ERROR")
        debug_log(message=f"🛠️❌ Failed to save Showtime state. Error: {e}", file=current_file, version=current_version, function=current_function)


def _update_zone_zoom_tab(zgd_frame_instance):
    # [A helper function to update the ZoneZoomTab with the current selection details.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"🛠️🟢 Entering {current_function}", file=current_file, version=current_version, function=current_function)
    
    showtime_tab = zgd_frame_instance.showtime_tab_instance
    try:
        # --- NEW LOGIC: Calculate buffered frequencies based on current selection state ---
        current_type = showtime_tab.last_selected_type
        buffer_mhz = float(showtime_tab.buffer_var.get())
        
        start_freq_mhz = 0.0
        stop_freq_mhz = 0.0
        
        if current_type == 'zone':
            zone_info = showtime_tab.selected_zone_info
            start_freq_mhz = zone_info.get('min_freq', 0.0)
            stop_freq_mhz = zone_info.get('max_freq', 0.0)
        elif current_type == 'group':
            group_info = showtime_tab.selected_group_info
            start_freq_mhz = group_info.get('min_freq', 0.0)
            stop_freq_mhz = group_info.get('max_freq', 0.0)
        elif current_type == 'device':
            device_info = showtime_tab.selected_device_info
            if device_info:
                center_freq = device_info.get('CENTER', 0.0)
                span_str = showtime_tab.span_var.get()
                if 'M' in span_str:
                    span_mhz = float(span_str.replace('M', ''))
                else:
                    span_mhz = float(span_str)
                # FIXED: Calculate start/stop correctly for a device without buffer
                start_freq_mhz = center_freq - (span_mhz / 2)
                stop_freq_mhz = center_freq + (span_mhz / 2)
        else: # All markers
            all_devices = zgd_frame_instance._get_all_devices_in_zone(zgd_frame_instance.structured_data, None)
            freqs = [float(d['CENTER']) for d in all_devices if isinstance(d.get('CENTER'), (int, float))]
            if freqs:
                start_freq_mhz = min(freqs)
                stop_freq_mhz = max(freqs)

        # Calculate and write buffered frequencies to state. This fixes the main bug.
        buffered_start_freq_mhz, buffered_stop_freq_mhz = _buffer_start_stop_frequencies(start_freq_mhz, stop_freq_mhz, buffer_mhz)
        debug_log(message=f"🛠️📝 Writing state: buffered_start_var = {buffered_start_freq_mhz}, buffered_stop_var = {buffered_stop_freq_mhz}", file=current_file, version=current_version, function=current_function)
        showtime_tab.buffered_start_var.set(buffered_start_freq_mhz)
        showtime_tab.buffered_stop_var.set(buffered_stop_freq_mhz)

        # --- Update Labels based on the correct values from state ---
        buffered_start_freq = showtime_tab.buffered_start_var.get()
        buffered_stop_freq = showtime_tab.buffered_stop_var.get()

        if current_type == 'zone':
            zone_info = showtime_tab.selected_zone_info
            count = zone_info.get('device_count', 0)
            
            debug_log(message=f"🛠️📝 Writing to state: Updating zone_zoom labels.", file=current_file, version=current_version, function=current_function)
            showtime_tab.zone_zoom_label_left_var.set(f"Zone ({count} Devices)")
            showtime_tab.zone_zoom_label_center_var.set(f"Name: {showtime_tab.selected_zone}")
            showtime_tab.zone_zoom_label_right_var.set(f"Start: {buffered_start_freq:.3f} MHz\nStop: {buffered_stop_freq:.3f} MHz")
        elif current_type == 'group':
            group_info = showtime_tab.selected_group_info
            count = group_info.get('device_count', 0)
            
            debug_log(message=f"🛠️📝 Writing to state: Updating zone_zoom labels.", file=current_file, version=current_version, function=current_function)
            showtime_tab.zone_zoom_label_left_var.set(f"Group ({count} Devices)")
            showtime_tab.zone_zoom_label_center_var.set(f"Name: {showtime_tab.selected_group}")
            showtime_tab.zone_zoom_label_right_var.set(f"Start: {buffered_start_freq:.3f} MHz\nStop: {buffered_stop_freq:.3f} MHz")
        elif current_type == 'device':
            device_info = showtime_tab.selected_device_info
            if device_info:
                debug_log(message=f"🛠️📝 Writing to state: Updating zone_zoom labels.", file=current_file, version=current_version, function=current_function)
                showtime_tab.zone_zoom_label_left_var.set(f"Device: {device_info.get('NAME')}")
                showtime_tab.zone_zoom_label_center_var.set(f"Name: {device_info.get('NAME')}")
                showtime_tab.zone_zoom_label_right_var.set(f"Center: {device_info.get('CENTER'):.3f} MHz\nStart: {buffered_start_freq:.3f} MHz\nStop: {buffered_stop_freq:.3f} MHz")
            else:
                debug_log(message=f"🛠️📝 Writing to state: No device info available, clearing labels.", file=current_file, version=current_version, function=current_function)
                showtime_tab.zone_zoom_label_left_var.set("No Device Selected")
                showtime_tab.zone_zoom_label_center_var.set("N/A")
                showtime_tab.zone_zoom_label_right_var.set("N/A")
        else: # All markers
            all_devices = zgd_frame_instance._get_all_devices_in_zone(zgd_frame_instance.structured_data, None)
            count = len(all_devices) if all_devices else 0
            
            debug_log(message=f"🛠️📝 Writing to state: Updating zone_zoom labels.", file=current_file, version=current_version, function=current_function)
            showtime_tab.zone_zoom_label_left_var.set("All Markers")
            showtime_tab.zone_zoom_label_center_var.set(f"({count} Devices)")
            showtime_tab.zone_zoom_label_right_var.set(f"Start: {buffered_start_freq:.3f} MHz\nStop: {buffered_stop_freq:.3f} MHz")

        showtime_tab.controls_frame.zone_zoom_tab._sync_ui_from_state()
        
        _save_showtime_state_to_config(showtime_tab)

    except Exception as e:
        debug_log(message=f"🛠️❌ Error in _update_zone_zoom_tab: {e}", file=current_file, version=current_version, function=current_function)
    
    debug_log(message=f"🛠️🟢 Exiting {current_function}", file=current_file, version=current_version, function=current_function)

def get_current_view_details(zgd_frame_instance):
    # [Returns a dictionary with the start, stop, center, and span frequencies for the current view.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"🛠️🟢 Entering {current_function}", file=current_file, version=current_version, function=current_function)

    start_freq = None
    stop_freq = None
    
    # Access state from the parent ShowtimeTab instance
    showtime_tab = zgd_frame_instance.showtime_tab_instance

    if showtime_tab.selected_device_info:
        center_freq = showtime_tab.selected_device_info.get('CENTER')
        if center_freq:
            # Check for 'M' in span_var and convert appropriately
            span_str = showtime_tab.span_var.get()
            if 'M' in span_str:
                span = float(span_str.replace('M', ''))
            else:
                span = float(span_str)
            start_freq = center_freq - (span / 2)
            stop_freq = center_freq + (span / 2)
    
    elif showtime_tab.selected_zone or showtime_tab.selected_group:
        devices = []
        if showtime_tab.selected_group:
            devices = zgd_frame_instance.structured_data.get(showtime_tab.selected_zone, {}).get(showtime_tab.selected_group, [])
        elif showtime_tab.selected_zone:
            for group_name in showtime_tab.structured_data.get(showtime_tab.selected_zone, {}).keys():
                devices.extend(showtime_tab.structured_data.get(showtime_tab.selected_zone, {}).get(group_name, []))
        
        freqs = [float(d.get('CENTER')) for d in devices if d.get('CENTER') and isinstance(d.get('CENTER'), (int, float))]
        if freqs:
            start_freq = min(freqs)
            stop_freq = max(freqs)
    
    else:
        all_devices = zgd_frame_instance._get_all_devices_in_zone(zgd_frame_instance.structured_data, None)
        freqs = [float(d.get('CENTER')) for d in all_devices if isinstance(d.get('CENTER'), (int, float))]
        if freqs:
            start_freq = min(freqs)
            stop_freq = max(freqs)
            
    if start_freq is not None and stop_freq is not None:
        center = (start_freq + stop_freq) / 2
        span = stop_freq - start_freq
        return {"start": start_freq, "stop": stop_freq, "center": center, "span": span}
    
    debug_log(message=f"🛠️🟢 Exiting {current_function}", file=current_file, version=current_version, function=current_function)
    return None

#####################################
### File: OPEN-AIR\Markers\showtime\zones_groups_devices\utils_display_showtime_zones.py
#####################################
# tabs/Markers/showtime/zones_groups_devices/utils_display_showtime_zones.py
#
# This module provides the backend logic for handling Zone-level button clicks.
# It manages the selection and deselection of zones, updates the UI to reflect
# the current state, and delegates to shared utility functions for saving
# the state and updating the instrument's view.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.110500.6
# REFACTORED: Extracted zone-specific logic from the main utility file.
# FIXED: The logic for selecting and deselecting a zone is now self-contained.
# UPDATED: Corrected import statements to resolve circular dependencies.
# FIXED: Moved `on_group_deselected` to the shared utility file to break a circular import.

import os
import inspect
import math
from tkinter import ttk
import pandas as pd
import numpy as np

from display.debug_logic import debug_log
from display.console_logic import console_log

# Import shared utility functions
from Markers.showtime.controls.utils_showtime_zone_zoom import set_span_to_zone
# FIXED: Updated the import statement to reflect the new location of no_zone_grou_device_selected.
from .utils_display_showtime_shared import _update_zone_zoom_tab, _save_showtime_state_to_config
from .utils_display_showtime_all import no_zone_grou_device_selected


# --- Versioning ---
w = 20250824
x_str = '110500'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 6
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"


def on_zone_selected(zgd_frame_instance, zone_name):
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"🛠️🟢 Entering {current_function} for zone: {zone_name}", file=current_file, version=current_version, function=current_function)

    showtime_tab = zgd_frame_instance.showtime_tab_instance

    for widget in zgd_frame_instance.zones_frame.winfo_children():
        if widget.cget("text") == zone_name:
            selected_button = widget
            break
    else:
        selected_button = None

    if showtime_tab.selected_zone == zone_name:
        no_zone_grou_device_selected(zgd_frame_instance)
    else:
        console_log(f"EVENT: Zone '{zone_name}' selected. Loading groups and devices... 🚀")
        if zgd_frame_instance.active_zone_button and zgd_frame_instance.active_zone_button.winfo_exists():
            zgd_frame_instance.active_zone_button.config(style='ControlButton.Inactive.TButton')
        if zgd_frame_instance.active_group_button and zgd_frame_instance.active_group_button.winfo_exists():
            zgd_frame_instance.active_group_button.config(style='ControlButton.Inactive.TButton')
            zgd_frame_instance.active_group_button = None
        
        # 📝 Write Data: Update selected state variables.
        debug_log(message=f"🛠️📝 Writing to state: Updating selected zone and resetting group/device.", file=current_file, version=current_version, function=current_function)
        showtime_tab.active_device_button = None
        showtime_tab.selected_device_info = None
        showtime_tab.selected_zone = zone_name
        showtime_tab.selected_group = None
        showtime_tab.last_selected_type = 'zone'

        # NEW: Calculate and store zone information in state
        all_devices_in_zone = zgd_frame_instance._get_all_devices_in_zone(zgd_frame_instance.structured_data, showtime_tab.selected_zone)
        freqs = [float(d['CENTER']) for d in all_devices_in_zone if isinstance(d.get('CENTER'), (int, float))]
        
        # FIXED: Check if freqs is not empty before calling min/max
        if freqs:
            min_freq = min(freqs)
            max_freq = max(freqs)
        else:
            min_freq = 0.0
            max_freq = 0.0

        showtime_tab.selected_zone_info = {
            'min_freq': min_freq,
            'max_freq': max_freq,
            'device_count': len(all_devices_in_zone)
        }
        
        debug_log(message=f"🛠️📦 Stored zone info in state: {showtime_tab.selected_zone_info}", file=current_file, version=current_version, function=current_function)

        if selected_button:
            selected_button.config(style='ControlButton.Active.TButton')
            zgd_frame_instance.active_zone_button = selected_button
        
        zgd_frame_instance._get_min_max_freq_and_update_title(frame_widget=zgd_frame_instance.zones_frame, devices=all_devices_in_zone, title_prefix=f"Zone '{zone_name}'")

        zgd_frame_instance._get_min_max_freq_and_update_title(frame_widget=zgd_frame_instance.groups_frame, devices=[], title_prefix=f"Groups in Zone '{showtime_tab.selected_zone}'" if showtime_tab.selected_zone else "Groups")

        zgd_frame_instance._make_group_buttons()
        zgd_frame_instance.canvas.yview_moveto(0)
        
        # FIXED: Call the set_span_to_zone utility function here to trigger the update
        set_span_to_zone(showtime_tab_instance=showtime_tab, zone_zoom_tab=showtime_tab.controls_frame.zone_zoom_tab)
        _save_showtime_state_to_config(showtime_tab)

    debug_log(message=f"🛠️🟢 Exiting {current_function}", file=current_file, version=current_version, function=current_function)

#####################################
### File: OPEN-AIR\Markers\showtime\zones_groups_devices\utils_files_markers_zone_groups_devices.py
#####################################
# tabs.Markers/showtime/utils_markers_files_zone_groups_devices.py
#
# This new utility file centralizes all logic for parsing the MARKERS.CSV file,
# structuring the data into zones, groups, and devices, and providing helper
# functions for the UI, like the progress bar.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.210000.1
# FIXED: Replaced inplace operations on DataFrame slices to remove FutureWarning messages.
# NEW: Added debug logging for reads and writes of file data.

import os
import inspect
import pandas as pd
import numpy as np

from display.debug_logic import debug_log
from display.console_logic import console_log
from ref.ref_file_paths import MARKERS_FILE_PATH



def load_and_structure_markers_data():
    # The main function to load, parse, and structure data from MARKERS.CSV.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"Entering {current_function}. Time to wrangle that CSV data! 📂", file=f"{os.path.basename(__file__)}", version="20250821.210000.1", function=current_function)

    if not os.path.exists(MARKERS_FILE_PATH):
        console_log(f"❌ MARKERS.CSV not found at path: {MARKERS_FILE_PATH}", "ERROR")
        debug_log(message=f"Marker CSV not found. What a disaster!", file=f"{os.path.basename(__file__)}", version="20250821.210000.1", function=current_function)
        return None
    try:
        # 📂 Read File: Reading the marker CSV data.
        debug_log(message=f"📂 Read File: Reading marker data from {MARKERS_FILE_PATH}", file=f"{os.path.basename(__file__)}", version="20250821.210000.1", function=current_function)
        df = pd.read_csv(MARKERS_FILE_PATH)
        
        # --- Data Cleaning and Structuring ---
        df.columns = [col.upper().strip() for col in df.columns]
        
        # Define potential column names and map them to our desired names
        column_mapping = {
            'ZONE': 'ZONE',
            'GROUP': 'GROUP',
            'NAME': 'NAME',
            'DEVICE': 'DEVICE',
            'FREQ CENTER (MHZ)': 'CENTER',
            'FREQ': 'CENTER', # Alternate name for center frequency
            'PEAK (DBM)': 'PEAK',
            'PEAK': 'PEAK' # Alternate name for peak
        }
        
        # Rename columns based on the mapping
        df.rename(columns=column_mapping, inplace=True)

        # Ensure essential columns exist, fill missing with defaults
        for col in ['ZONE', 'GROUP', 'NAME', 'DEVICE', 'CENTER', 'PEAK']:
            if col not in df.columns:
                df[col] = 'N/A' if col != 'PEAK' else -120

        # FIXED: Corrected the fillna operations to avoid FutureWarning in pandas 3.0
        # Replaces df['GROUP'].fillna('Ungrouped', inplace=True)
        df.loc[:, 'GROUP'] = df['GROUP'].fillna('Ungrouped')
        # Replaces df['ZONE'].fillna('Unzoned', inplace=True)
        df.loc[:, 'ZONE'] = df['ZONE'].fillna('Unzoned')

        # --- Hierarchical Structuring ---
        structured_data = {}
        for zone_name, zone_df in df.groupby('ZONE'):
            zone_dict = {}
            for group_name, group_df in zone_df.groupby('GROUP'):
                device_list = []
                for index, row in group_df.iterrows():
                    device_list.append({
                        'NAME': row['NAME'],
                        'DEVICE': row['DEVICE'],
                        'CENTER': row['CENTER'],
                        'PEAK': row['PEAK']
                    })
                zone_dict[group_name] = device_list
            structured_data[zone_name] = zone_dict
        
        # 📊 Processed Data: Log the result of the data transformation.
        console_log(f"✅ Successfully loaded and structured {len(df)} devices into {len(structured_data)} zones.", "SUCCESS")
        debug_log(message=f"📊 Processed Data: Successfully loaded and structured {len(df)} devices into {len(structured_data)} zones. We got the data! 🎣", file=f"{os.path.basename(__file__)}", version="20250821.210000.1", function=current_function)
        return structured_data

    except Exception as e:
        console_log(f"❌ Failed to parse MARKERS.CSV. Error: {e}", "ERROR")
        debug_log(message=f"Full traceback for CSV parsing error: {e}. This bugger is being problematic!", file=f"{os.path.basename(__file__)}", version="20250821.210000.1", function=current_function)
        return None

#####################################
### File: OPEN-AIR\orchestrator\display_child_orchestrator_tasks.py
#####################################
# display/display_child_orchestrator_tasks.py
#
# This file defines the Orchestrator Tasks tab, a GUI component that displays the
# real-time status of the main application orchestrator and logs check-in events from
# various modules.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250814.113500.1

current_version = "20250814.113500.1"
current_version_hash = (20250814 * 113500 * 1)

import tkinter as tk
from tkinter import ttk
from datetime import datetime
import os
import inspect

from display.debug_logic import debug_log
from display.console_logic import console_log
# REMOVED: Unnecessary import that caused a circular dependency.
# from src.program_style import ProgramStyle

class OrchestratorTasksTab(ttk.Frame):
    def __init__(self, parent, app_instance, *args, **kwargs):
        # Initializes the Orchestrator Tasks tab GUI elements.
        super().__init__(parent, *args, **kwargs)
        self.app_instance = app_instance
        self.parent = parent
        
        self.grid(row=0, column=0, sticky="nsew")
        self.grid_rowconfigure(1, weight=1)
        self.grid_columnconfigure(0, weight=1)

        self._create_widgets()

    def _create_widgets(self):
        # Creates and arranges the widgets within the tab frame.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function_name}", file=f"{__name__}", version=current_version, function=current_function_name)

        try:
            # --- Status Display Frame ---
            status_frame = ttk.Frame(self, style='Dark.TFrame')
            status_frame.grid(row=0, column=0, sticky="ew", padx=10, pady=5)
            status_frame.grid_columnconfigure(1, weight=1)

            ttk.Label(status_frame, text="Orchestrator Status:", style='Header3.TLabel').grid(row=0, column=0, sticky="w")
            
            self.status_var = tk.StringVar(value="STOPPED")
            self.status_label = ttk.Label(status_frame, textvariable=self.status_var, style='Status.Stopped.TLabel')
            self.status_label.grid(row=0, column=1, sticky="w", padx=5)

            # --- Log Table Frame ---
            log_frame = ttk.Frame(self)
            log_frame.grid(row=1, column=0, sticky="nsew", padx=10, pady=(0, 10))
            log_frame.grid_rowconfigure(0, weight=1)
            log_frame.grid_columnconfigure(0, weight=1)

            # --- Treeview for Logging ---
            columns = ("timestamp", "source", "event")
            self.log_tree = ttk.Treeview(log_frame, columns=columns, show="headings", style="Custom.Treeview")
            
            self.log_tree.heading("timestamp", text="Timestamp")
            self.log_tree.heading("source", text="Source Module")
            self.log_tree.heading("event", text="Event")

            self.log_tree.column("timestamp", width=160, anchor='w')
            self.log_tree.column("source", width=250, anchor='w')
            self.log_tree.column("event", width=300, anchor='w')

            # --- Scrollbar ---
            scrollbar = ttk.Scrollbar(log_frame, orient="vertical", command=self.log_tree.yview)
            self.log_tree.configure(yscrollcommand=scrollbar.set)

            self.log_tree.grid(row=0, column=0, sticky="nsew")
            scrollbar.grid(row=0, column=1, sticky="ns")

            console_log("✅ Celebration of success! Orchestrator Tasks tab created.")

        except Exception as e:
            console_log(f"❌ Error in _create_widgets for orchestrator tab: {e}")
            debug_log(f"The orchestrator display tab has imploded! The error be: {e}",
                      file=f"{__name__}", version=current_version, function=current_function_name)

    def log_event(self, source="Unknown", event="Status Checked"):
        # Adds a new entry to the log table.
        try:
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
            values = (timestamp, os.path.basename(source).replace('.py', ''), event)
            
            self.log_tree.insert("", tk.END, values=values)
            self.log_tree.yview_moveto(1)

        except Exception as e:
            print(f"ERROR: Failed to log event to orchestrator tasks tab: {e}")

    def update_status_display(self, is_running, is_paused):
        # Updates the status label based on the orchestrator's state.
        try:
            if is_running and not is_paused:
                self.status_var.set("RUNNING")
                self.status_label.config(style='Status.Running.TLabel')
            elif is_running and is_paused:
                self.status_var.set("PAUSED")
                self.status_label.config(style='Status.Paused.TLabel')
            else:
                self.status_var.set("STOPPED")
                self.status_label.config(style='Status.Stopped.TLabel')
        
        except Exception as e:
            console_log(f"❌ Error in update_status_display for orchestrator tab: {e}")

#####################################
### File: OPEN-AIR\orchestrator\orchestrator_gui.py
#####################################
# orchestrator/orchestrator_gui.py
#
# This file defines the GUI for the main application orchestrator,
# providing the user with Start, Stop, and Pause controls.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250814.095000.2
# FIX: Restructured the layout to use a proportional grid for buttons.
# FIX: The button styling now correctly references predefined styles from program_style.py.

current_version = "20250814.095000.2"
current_version_hash = (20250814 * 95000 * 2)

import tkinter as tk
from tkinter import ttk
import inspect
import os

from display.console_logic import console_log
from display.debug_logic import debug_log
# REMOVED incorrect import: from orchestrator.orchestrator_logic import toggle_pause_resume, stop_logic

class OrchestratorGUI(ttk.Frame):
    def __init__(self, parent, app_instance, orchestrator_logic, *args, **kwargs):
        super().__init__(parent, *args, **kwargs)
        self.app_instance = app_instance
        self.orchestrator = orchestrator_logic
        self.grid(row=0, column=0, sticky="ew")
        self._create_widgets()

    def _create_widgets(self):
        # Creates and arranges the widgets for the orchestrator control bar.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function_name}", file=f"{__name__}", version=current_version, function=current_function_name)
        try:
            self.grid_columnconfigure(0, weight=1) # Spacer column to the left
            self.grid_columnconfigure(1, weight=1)
            self.grid_columnconfigure(2, weight=1)
            self.grid_columnconfigure(3, weight=1)
            self.grid_columnconfigure(4, weight=1) # Spacer column to the right
            self.grid_columnconfigure(5, weight=1)
            
            # --- Button Definitions ---
            self.start_button = ttk.Button(self, text="Start", command=self.orchestrator.start_orchestrator, style='Start.TButton')
            self.pause_button = ttk.Button(self, text="Pause", command=self.orchestrator.toggle_pause, style='PauseScan.TButton', state=tk.DISABLED)
            self.stop_button = ttk.Button(self, text="Stop", command=self.orchestrator.stop_orchestrator, style='StopScan.TButton', state=tk.DISABLED)

            # --- Grid Layout ---
            self.start_button.grid(row=0, column=1, padx=(10, 2), pady=10, sticky="ew")
            self.pause_button.grid(row=0, column=2, padx=2, pady=10, sticky="ew")
            self.stop_button.grid(row=0, column=3, padx=(2, 10), pady=10, sticky="ew")

            console_log("✅ Celebration of success! Orchestrator GUI created.")
        except Exception as e:
            console_log(f"❌ Error in _create_widgets for orchestrator GUI: {e}")
            debug_log(f"The GUI has gone rogue! The error be: {e}", file=f"{__name__}", version=current_version, function=current_function_name)

    def update_button_states(self):
        # Updates the enabled/disabled state of the control buttons based on the orchestrator's status.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function_name} with state is_running={self.orchestrator.is_running}, is_paused={self.orchestrator.is_paused}",
                  file=f"{__name__}", version=current_version, function=current_function_name)
        try:
            if self.orchestrator.is_running:
                self.start_button.config(state=tk.DISABLED, style='Disabled.TButton')
                self.pause_button.config(state=tk.NORMAL)
                self.stop_button.config(state=tk.NORMAL, style='StopScan.TButton')
                
                # Use a different style for Resume
                if self.orchestrator.is_paused:
                    self.pause_button.config(text="Resume", style='ResumeScan.Blink.TButton')
                else:
                    self.pause_button.config(text="Pause", style='PauseScan.TButton')

            else:
                self.start_button.config(state=tk.NORMAL, style='StartScan.TButton')
                self.pause_button.config(state=tk.DISABLED, text="Pause", style='Disabled.TButton')
                self.stop_button.config(state=tk.DISABLED, style='Disabled.TButton')

            console_log("✅ Orchestrator button states updated.")
        except Exception as e:
            console_log(f"❌ Error in update_button_states: {e}")
            debug_log(f"The buttons are rebelling! A mutiny! The error be: {e}",
                      file=f"{__name__}", version=current_version, function=current_function_name)

#####################################
### File: OPEN-AIR\orchestrator\orchestrator_logic.py
#####################################
# FolderName/orchestrator_logic.py
#
# This file contains the core logic for the application's orchestrator,
# managing the main operational state (running, paused, stopped).
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250814.121000.2

current_version = "20250814.121000.2"
current_version_hash = (20250814 * 121000 * 2)

import inspect
import os
from display.console_logic import console_log
from display.debug_logic import debug_log

class OrchestratorLogic:
    def __init__(self, app_instance, gui):
        self.app_instance = app_instance
        self.gui = gui
        self.is_running = False
        self.is_paused = False

    def get_status(self):
        # A brief, one-sentence description of the function's purpose.
        # Returns the current status of the orchestrator.
        return {
            "is_running": self.is_running,
            "is_paused": self.is_paused
        }

    def start_orchestrator(self):
        # Starts the main application orchestrator.
        if self.is_running:
            console_log("✅ Orchestrator is already running.")
            return

        self.is_running = True
        self.is_paused = False
        self.gui.update_button_states()
        console_log("✅ Orchestrator started. The symphony begins! 🎶")
        
        if self.app_instance.orchestrator_tasks_tab:
            self.app_instance.orchestrator_tasks_tab.update_status_display(self.is_running, self.is_paused)
            self.log_task_event(source_file=__file__, event="Orchestrator Started")

    def stop_orchestrator(self):
        # Stops the main application orchestrator.
        if not self.is_running:
            console_log("✅ Orchestrator is already stopped.")
            return

        self.is_running = False
        self.gui.update_button_states()
        console_log("✅ Orchestrator stopped. The music fades... 🤫")
        
        if self.app_instance.orchestrator_tasks_tab:
            self.app_instance.orchestrator_tasks_tab.update_status_display(self.is_running, self.is_paused)
            self.log_task_event(source_file=__file__, event="Orchestrator Stopped")

    def toggle_pause(self):
        # Toggles the paused state of the orchestrator.
        if not self.is_running:
            console_log("ℹ️ Cannot pause, orchestrator is not running.")
            return

        self.is_paused = not self.is_paused
        self.gui.update_button_states()
        state = "paused" if self.is_paused else "resumed"
        console_log(f"✅ Orchestrator {state}. A brief intermission. ⏸️")

        if self.app_instance.orchestrator_tasks_tab:
            self.app_instance.orchestrator_tasks_tab.update_status_display(self.is_running, self.is_paused)
            self.log_task_event(source_file=__file__, event=f"Orchestrator {state.capitalize()}")

    def log_check_in(self, source_file):
        # Allows other modules to log that they have checked the orchestrator status.
        self.log_task_event(source_file=source_file, event="Checked In")

    def log_task_event(self, source_file, event):
        # [A brief, one-sentence description of the function's purpose.]
        # Logs a specific event from a source module to the orchestrator tasks tab.
        try:
            if self.app_instance.orchestrator_tasks_tab:
                self.app_instance.orchestrator_tasks_tab.log_event(source=source_file, event=event)
        except Exception as e:
            # Avoid a logging loop by printing directly
            print(f"ERROR: Could not log task event from {source_file}: {e}")

#####################################
### File: OPEN-AIR\Plotting\TAB_PLOTTING_PARENT.py
#####################################
# tabs/Plotting/TAB_PLOTTING_PARENT.py
#
# This file defines the parent tab for Plotting-related functionalities.
# It acts as a container for child tabs such as "Single Scan Plotting",
# "Averaging from Folder", and "3D Scans Over Time".
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250803.2300.4 (REFACTORED: Applied color-coded child notebook style.)
# Version 20250803.2210.4 (REFACTORED: Removed ASCII art logic to break circular import.)

current_version = "20250803.2300.4"

import tkinter as tk
from tkinter import ttk
import inspect

# Import the child tabs
from .tab_plotting_child_Single import PlottingTab
from .tab_plotting_child_average import AveragingTab
from .tab_plotting_child_3D import Plotting3DTab

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log

class TAB_PLOTTING_PARENT(ttk.Frame):
    """
    A parent tab for Plotting-related functionalities.
    """
    def __init__(self, parent, app_instance, console_print_func):
        super().__init__(parent)
        self.app_instance = app_instance
        self.console_print_func = console_print_func

        # Use the specific, color-coded style for this child notebook
        self.child_notebook = ttk.Notebook(self, style='Plotting.Child.TNotebook')
        self.child_notebook.pack(expand=True, fill="both", padx=5, pady=5)

        self.single_scan_plotting_tab = PlottingTab(self.child_notebook, self.app_instance, self.console_print_func)
        self.child_notebook.add(self.single_scan_plotting_tab, text="Single Scan Plotting")

        self.averaging_tab = AveragingTab(self.child_notebook, self.app_instance, self.console_print_func)
        self.child_notebook.add(self.averaging_tab, text="Averaging from Folder")

        self.three_d_plotting_tab = Plotting3DTab(self.child_notebook, self.app_instance, self.console_print_func)
        self.child_notebook.add(self.three_d_plotting_tab, text="3D Scans Over Time")

        self.child_notebook.bind("<<NotebookTabChanged>>", self._on_child_tab_selected)

    def _on_child_tab_selected(self, event):
        """Handles tab change events within this parent's child notebook."""
        selected_child_tab_id = self.child_notebook.select()
        if selected_child_tab_id:
            selected_child_tab_widget = self.child_notebook.nametowidget(selected_child_tab_id)
            if hasattr(selected_child_tab_widget, '_on_tab_selected'):
                selected_child_tab_widget._on_tab_selected(event)

    def _on_parent_tab_selected(self, event):
        """
        Handles the event when this parent tab is selected.
        """
        self._on_child_tab_selected(event)

#####################################
### File: OPEN-AIR\Plotting\tab_plotting_child_3D.py
#####################################
# tabs/Plotting/tab_plotting_child_3D.py
#
# This file defines a Tkinter Frame for generating 3D plots of scans over time.
# It includes functionality for selecting a folder, identifying series of scans,
# and generating the interactive 3D plot.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250801.2250.1 (Refactored debug_print to use debug_log and console_log.)

current_version = "20250801.2250.1" # this variable should always be defined below the header to make the debugging better
current_version_hash = 20250801 * 2250 * 1 # Example hash, adjust as needed

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import os
import pandas as pd
import inspect
import webbrowser # For opening HTML plot in browser
import re # Added for regex in file grouping
import platform # For opening folder cross-platform
import glob # For finding files with specific patterns
from datetime import datetime # Import datetime for timestamping plots
import numpy as np # Added for PSD calculation

# CORRECTED: Import plotting functions and _open_plot_in_browser directly from utils.plotting_utils
from .utils_plotting_scans_over_time import plot_Scans_over_time

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log


class Plotting3DTab(ttk.Frame):
    """
    A Tkinter Frame that provides functionality for generating 3D plots of scans over time.
    """
    def __init__(self, master=None, app_instance=None, console_print_func=None, **kwargs):
        """
        Initializes the Plotting3DTab.

        Inputs:
            master (tk.Widget): The parent widget.
            app_instance (App): The main application instance, used for accessing
                                shared state like collected_scans_dataframes and output directory.
            console_print_func (function): Function to print messages to the GUI console.
            **kwargs: Arbitrary keyword arguments for Tkinter Frame.
        """
        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func if console_print_func else console_log # Use provided func or console_log
        self.last_opened_folder = None # To remember the last opened folder for 3D plotting
        self.grouped_csv_files = {} # Dictionary to store grouped CSV files for 3D plotting
        self.selected_group_prefix = None # Stores the prefix of the currently selected group for 3D plotting

        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        self._create_widgets()
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

    def _create_widgets(self):
        """
        Function Description:
        Creates and arranges all the widgets for the Plotting3DTab.

        Inputs to this function:
            None.

        Process of this function:
            1. Creates the main LabelFrame for "3D Scans Over Time Plotting".
            2. Adds a button to open a folder for 3D plotting.
            3. Creates a LabelFrame to display discovered series of scans with dynamic buttons.
            4. Adds an entry and label for Amplitude Threshold.
            5. Adds a button for generating the 3D plot.
            6. Configures grid weights for responsive layout.

        Outputs of this function:
            None. Populates the tab with GUI elements.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        # --- 3D Scans Over Time Plotting Section ---
        self.plot_3d_frame = ttk.LabelFrame(self, text="3D Scans Over Time Plotting", padding="10")
        self.plot_3d_frame.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")

        # Open Folder for 3D Plotting Button
        self.open_folder_3d_button = ttk.Button(self.plot_3d_frame, text="Open Folder for 3D Plotting", command=self._open_folder_for_3d_plotting)
        self.open_folder_3d_button.grid(row=0, column=0, columnspan=2, padx=5, pady=5, sticky="ew")

        # Discovered Series of Scans Frame for 3D plots
        self.discovered_series_3d_frame = ttk.LabelFrame(self.plot_3d_frame, text="Discovered Series of Scans (for 3D)", padding="10")
        self.discovered_series_3d_frame.grid(row=1, column=0, columnspan=2, padx=5, pady=5, sticky="nsew")
        self.dynamic_3d_buttons_frame = ttk.Frame(self.discovered_series_3d_frame) # This frame will hold dynamically created buttons.
        self.dynamic_3d_buttons_frame.pack(fill="both", expand=True) # Use pack for dynamic buttons within this frame

        # Amplitude Threshold
        amplitude_threshold_frame = ttk.Frame(self.plot_3d_frame)
        amplitude_threshold_frame.grid(row=2, column=0, columnspan=2, padx=5, pady=5, sticky="ew")
        amplitude_threshold_frame.grid_columnconfigure(1, weight=1) # Make entry expand

        ttk.Label(amplitude_threshold_frame, text="Amplitude Threshold (dBm):", style='TLabel').grid(row=0, column=0, padx=5, pady=2, sticky="w")
        self.amplitude_threshold_var = tk.DoubleVar(self, value=-80.0) # Default threshold
        ttk.Entry(amplitude_threshold_frame, textvariable=self.amplitude_threshold_var, style='TEntry').grid(row=0, column=1, padx=5, pady=2, sticky="ew")

        # Generate 3D Plot Button
        self.generate_plot_scans_over_time_button = ttk.Button(self.plot_3d_frame, text="Generate 3D Plot of Scans Over Time", command=self._generate_plot_scans_over_time)
        self.generate_plot_scans_over_time_button.grid(row=3, column=0, columnspan=2, padx=5, pady=5, sticky="ew")
        self.generate_plot_scans_over_time_button.config(state=tk.DISABLED) # Disable until group is selected


        # Configure column weights for resizing
        self.grid_columnconfigure(0, weight=1)
        self.plot_3d_frame.grid_columnconfigure(0, weight=1)
        self.plot_3d_frame.grid_columnconfigure(1, weight=1)
        self.discovered_series_3d_frame.grid_columnconfigure(0, weight=1)
        self.dynamic_3d_buttons_frame.grid_columnconfigure(0, weight=1) # Ensure dynamic buttons expand

        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

    def _open_folder_for_3d_plotting(self):
        """
        Function Description:
        Opens a file dialog to allow the user to select a folder containing CSV files for 3D plotting.
        Upon selection, it calls `_find_and_group_csv_files_3d` and enables relevant buttons.

        Inputs to this function:
            None.

        Process of this function:
            1. Opens a directory selection dialog, defaulting to the last opened folder.
            2. If a folder is selected, stores it as `self.last_opened_folder`.
            3. Calls `_find_and_group_csv_files_3d` to process the CSVs in the selected folder.
            4. Enables the 3D plotting button if groups are found.
            5. If no folder is selected, disables the button.

        Outputs of this function:
            None. Updates GUI state and initiates file grouping.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        folder_path = filedialog.askdirectory(initialdir=self.last_opened_folder)
        debug_log(f"Selected folder_path for 3D plotting: {folder_path}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        if folder_path:
            self.last_opened_folder = folder_path
            self.console_print_func(f"Selected folder for 3D plotting: {folder_path}")
            self._find_and_group_csv_files_3d(folder_path)
            # Enable 3D plotting button if groups are found
            if self.grouped_csv_files: # Only enable if groups were successfully found
                self.generate_plot_scans_over_time_button.config(state=tk.NORMAL)
                debug_log("3D plotting button enabled (folder selected and groups found).",
                            file=__file__,
                            version=current_version,
                            function=current_function)
            else:
                self.generate_plot_scans_over_time_button.config(state=tk.DISABLED)
                debug_log("3D plotting button disabled (no groups found in folder).",
                            file=__file__,
                            version=current_version,
                            function=current_function)
        else:
            self.console_print_func("Folder selection cancelled for 3D plotting.")
            self.generate_plot_scans_over_time_button.config(state=tk.DISABLED)
            debug_log("Folder selection cancelled. 3D plotting button disabled.",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    def _find_and_group_csv_files_3d(self, folder_path):
        """
        Function Description:
        Scans the selected folder for CSV files and groups them based on a common naming prefix
        for 3D plotting. It then creates dynamic buttons for each identified group.

        Inputs to this function:
            folder_path (str): The path to the folder containing CSV files.

        Process of this function:
            1. Lists all CSV files in the given `folder_path`.
            2. If no CSVs are found, clears dynamic buttons and returns.
            3. Iterates through each CSV, attempting to extract a common prefix using regex.
               The regex is designed to be flexible, looking for a pattern before RBW/HOLD/timestamp.
            4. Stores files in `file_groups` dictionary, where keys are prefixes and values are lists of file paths.
            5. Clears any existing dynamic group selection buttons.
            6. Creates a new `ttk.Button` for each identified group, allowing the user to select it.
            7. Configures button styles.

        Outputs of this function:
            None. Populates `self.grouped_csv_files` and updates the GUI with group selection buttons.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function} with folder_path: {folder_path}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        csv_files = [f for f in os.listdir(folder_path) if f.endswith('.csv')]
        debug_log(f"Found CSV files for 3D plotting: {csv_files}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        if not csv_files:
            self.console_print_func("No CSV files found in the selected folder for 3D plotting. FUCK! Where did they go?!")
            self._clear_dynamic_3d_buttons()
            self.grouped_csv_files = {} # Clear groups if no files
            debug_log(f"Exiting {current_function} (no CSVs)",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        file_groups = {}
        for filename in csv_files:
            base_name = os.path.splitext(filename)[0]
            # Updated regex for grouping: be more flexible with the ending part before date/time
            # It tries to capture the main prefix before any RBW/HOLD/timestamp.
            match = re.match(r"([^\d_ -]+(?:[_ -][^\d_ -]+)*?)_RBW\d+K?_HOLD\d+.*", base_name)
            prefix = base_name # Default to full base name if no clear pattern
            if match:
                prefix = match.group(1).strip() # Get the part before RBW/HOLD
                # Refine prefix: remove trailing underscores/hyphens if they were part of the non-digit group
                prefix = re.sub(r"[_ -]+$", "", prefix)
            else:
                # Fallback if the more specific pattern doesn't match (e.g., for INTERMOD.csv or simpler names)
                # Try to split by common delimiters if no complex pattern is found
                if '_' in base_name:
                    prefix = base_name.split('_')[0]
                elif '-' in base_name:
                    prefix = base_name.split('-')[0]
                else:
                    prefix = base_name # Use full name if no common delimiters

            if not prefix: # Ensure prefix is not empty
                prefix = base_name # Fallback to full base name

            if prefix not in file_groups:
                file_groups[prefix] = []
            file_groups[prefix].append(os.path.join(folder_path, filename))
        debug_log(f"Grouped CSV files for 3D plotting: {file_groups}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        self._clear_dynamic_3d_buttons() # Clear any previous buttons

        if not file_groups:
            self.console_print_func("No identifiable groups of CSV files found for 3D plotting. This is a bloody mess!")
            self.grouped_csv_files = {} # Clear groups if no files
            debug_log(f"Exiting {current_function} (no file groups)",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        self.console_print_func(f"Found {len(file_groups)} groups of similar CSV files for 3D plotting. Let's get this show on the road!")

        self.grouped_csv_files = file_groups
        self.selected_group_prefix = None

        row_start = 0
        for i, (prefix, files) in enumerate(file_groups.items()):
            group_text = f"Group '{prefix}' ({len(files)} files)"
            btn = ttk.Button(self.dynamic_3d_buttons_frame, text=group_text,
                             command=lambda p=prefix: self._select_group_for_3d_plotting(p))
            btn.grid(row=row_start + i, column=0, padx=5, pady=2, sticky="ew")
            btn.config(style='Orange.TButton') # Use a distinct style if desired

        try:
            style = ttk.Style()
            style.configure('Orange.TButton', background='orange', foreground='black')
        except Exception as e:
            debug_log(f"Could not apply orange style for 3D plotting buttons: {e}. Damn you, Tkinter styles!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

    def _select_group_for_3d_plotting(self, prefix):
        """
        Function Description:
        Sets the `selected_group_prefix` for 3D plotting and visually highlights the selected group button.

        Inputs to this function:
            prefix (str): The prefix of the selected group of files.

        Process of this function:
            1. Stores the `prefix` in `self.selected_group_prefix`.
            2. Updates the console with the selected group.
            3. Iterates through all dynamic group buttons:
               a. If the button's text matches the selected prefix, sets its relief to "sunken" and applies a "SelectedOrange.TButton" style.
               b. Otherwise, resets its relief to "raised" and applies the default "Orange.TButton" style.
            4. Attempts to configure the "SelectedOrange.TButton" style.

        Outputs of this function:
            None. Updates `self.selected_group_prefix` and GUI button appearance.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function} with prefix: {prefix}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        self.selected_group_prefix = prefix
        self.console_print_func(f"Selected group for 3D plotting: '{prefix}'")
        debug_log(f"Selected group for 3D plotting: '{prefix}'",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        for widget in self.dynamic_3d_buttons_frame.winfo_children():
            if isinstance(widget, ttk.Button):
                if widget.cget("text").startswith(f"Group '{prefix}'"):
                    widget.config(relief="sunken", style='SelectedOrange.TButton')
                    debug_log(f"Highlighted button for group: {prefix}",
                                file=__file__,
                                version=current_version,
                                function=current_function)
                else:
                    widget.config(relief="raised", style='Orange.TButton')
        try:
            style = ttk.Style()
            style.configure('SelectedOrange.TButton', background='darkorange', foreground='white')
        except Exception as e:
            debug_log(f"Could not apply selected orange style for 3D plotting buttons: {e}. This style system is a real pain in the ass!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

    def _clear_dynamic_3d_buttons(self):
        """
        Function Description:
        Destroys all dynamically created group selection buttons for 3D plotting from the GUI.

        Inputs to this function:
            None.

        Process of this function:
            1. Iterates through all child widgets in `self.dynamic_3d_buttons_frame`.
            2. Calls `destroy()` on each widget.

        Outputs of this function:
            None. Clears the dynamic button area in the GUI.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        for widget in self.dynamic_3d_buttons_frame.winfo_children():
            widget.destroy()
        debug_log(f"Cleared dynamic 3D plotting buttons.",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

    def _generate_plot_scans_over_time(self):
        """
        Function Description:
        Generates and opens the 3D Plotly HTML plot for scans over time.
        It utilizes the `plot_Scans_over_time` utility function.

        Inputs to this function:
            None.

        Process of this function:
            1. Checks if `grouped_csv_files` and `selected_group_prefix` are set.
            2. Retrieves the amplitude threshold from the Tkinter variable.
            3. Determines the output folder for the plot.
            4. Calls `plot_Scans_over_time` with the collected parameters.
            5. If the plot is generated successfully, logs success and optionally opens it in a browser.
            6. Logs failure messages to the console.

        Outputs of this function:
            None. Generates an HTML plot file.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        if not hasattr(self, 'grouped_csv_files') or not self.grouped_csv_files:
            self.console_print_func("Warning: No data. Please select a folder and identify CSV file groups for 3D plotting first. What the hell are you trying to plot?")
            debug_log(f"Exiting {current_function} (no grouped_csv_files)",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        if not self.selected_group_prefix:
            self.console_print_func("Warning: No group selected. Please click on one of the group buttons to select files for 3D plotting. Pick one, for crying out loud!")
            debug_log(f"Exiting {current_function} (no selected_group_prefix)",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        amplitude_threshold = self.amplitude_threshold_var.get()
        output_dir = self.app_instance.output_folder_var.get() # Use the main app's output folder

        self.console_print_func(f"Generating 3D plot for group '{self.selected_group_prefix}' with threshold {amplitude_threshold} dBm. This may take some time. Don't go anywhere!")
        debug_log(f"Calling plot_Scans_over_time for group '{self.selected_group_prefix}'",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        try:
            fig, plot_html_path = plot_Scans_over_time(
                self.grouped_csv_files,
                self.selected_group_prefix,
                output_dir,
                amplitude_threshold,
                self.console_print_func
            )

            if fig:
                self.console_print_func(f"✅ 3D plot generated and saved to: {plot_html_path}. BOOM! Nailed it!")
                debug_log(f"3D plot generated and saved to: {plot_html_path}",
                            file=__file__,
                            version=current_version,
                            function=current_function)
                if self.app_instance.open_html_after_complete_var.get():
                    self.console_print_func(f"Opening 3D plot in browser: {plot_html_path}")
                    webbrowser.open_new_tab(plot_html_path)
                    debug_log(f"3D plot opened in browser: {plot_html_path}",
                                file=__file__,
                                version=current_version,
                                function=current_function)
            else:
                self.console_print_func("🚫 3D Plotly figure was not generated. Fucking hell, not again!")
                debug_log("3D Plotly figure not generated.",
                            file=__file__,
                            version=current_version,
                            function=current_function)
        except Exception as e:
            self.console_print_func(f"❌ Error generating 3D plot: {e}. This is a nightmare!")
            debug_log(f"Error generating 3D plot: {e}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    def _on_tab_selected(self, event):
        """
        Function Description:
        Callback for when this tab is selected.
        This can be used to refresh data or update UI elements specific to this tab.

        Inputs to this function:
            event (tkinter.Event): The event object that triggered the tab selection.

        Process of this function:
            1. Logs a debug message indicating the tab selection.
            2. Enables/Disables the "Generate 3D Plot of Scans Over Time" button
               based on whether a folder has been opened and groups of CSV files have been identified.

        Outputs of this function:
            None. Updates the state of various GUI buttons.

        (2025-07-31) Change: Initial implementation for Plotting3DTab.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        debug_log("3D Plotting Tab selected.",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        # Enable/Disable 3D plotting button based on last_opened_folder and grouped_csv_files
        if hasattr(self, 'last_opened_folder') and self.last_opened_folder and \
           hasattr(self, 'grouped_csv_files') and self.grouped_csv_files:
            self.generate_plot_scans_over_time_button.config(state=tk.NORMAL)
            debug_log("3D plotting button enabled (folder and groups exist).",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        else:
            self.generate_plot_scans_over_time_button.config(state=tk.DISABLED)
            debug_log("3D plotting button disabled (no folder or groups).",
                        file=__file__,
                        version=current_version,
                        function=current_function)

        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


#####################################
### File: OPEN-AIR\Plotting\tab_plotting_child_Single.py
#####################################
# tabs/Plotting/tab_plotting_child_Single.py
#
# This file defines a Tkinter Frame that provides functionality for plotting single scan data
# and current cycle averaged data. It handles file selection, plotting options,
# and opening generated HTML plots.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250801.2230.1 (Refactored debug_print to use debug_log and console_log.)

current_version = "20250801.2230.1" # this variable should always be defined below the header to make the debugging better
current_version_hash = 20250801 * 2230 * 1 # Example hash, adjust as needed

import tkinter as tk
from tkinter import ttk, filedialog, scrolledtext, messagebox
import os
import pandas as pd
import inspect
import webbrowser # For opening HTML plot in browser
from datetime import datetime # Import datetime for timestamping plots
import numpy as np # Added for PSD calculation in _plot_current_cycle_average

# CORRECTED: Import plotting functions and _open_plot_in_browser directly from utils.utils_plotting
from .utils_plotting import plot_single_scan_data, plot_multi_trace_data, _open_plot_in_browser

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log

# Removed: from process_math.averaging_utils import average_scan
# Removed: from utils.plot_scans_over_time import plot_Scans_over_time


class PlottingTab(ttk.Frame):
    """
    A Tkinter Frame that provides functionality for plotting single scan data and current cycle averages.
    """
    def __init__(self, master=None, app_instance=None, console_print_func=None, **kwargs):
        """
        Initializes the PlottingTab.

        Inputs:
            master (tk.Widget): The parent widget.
            app_instance (App): The main application instance, used for accessing
                                shared state like collected_scans_dataframes and output directory.
            console_print_func (function): Function to print messages to the GUI console.
            **kwargs: Arbitrary keyword arguments for Tkinter Frame.
        """
        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func if console_print_func else console_log # Use provided func or console_log
        self.current_plot_file = None # To store the path of the last generated plot HTML
        # Removed: self.last_opened_folder = None # No longer needed here
        # Removed: self.last_applied_math_folder = None # No longer needed here

        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        self._create_widgets()
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

    def _create_widgets(self):
        """
        Function Description:
        Creates and arranges all the widgets for the PlottingTab.

        Inputs to this function:
            None.

        Process of this function:
            1. Creates the main LabelFrame for "SCAN Plotting Options".
            2. Adds HTML Output Options (checkboxes for creating and opening HTML).
            3. Adds Scan Markers to Plot options (checkboxes for various markers).
            4. Adds buttons for plotting a single scan, plotting current cycle average,
               and opening the last generated plot.
            5. Configures grid weights for responsive layout.

        Outputs of this function:
            None. Populates the tab with GUI elements.

        (2025-07-31) Change: Removed "Plotting Averages from Folder" section.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        # SCAN Plotting Options Frame (for single scan and current cycle average)
        plotting_options_frame = ttk.LabelFrame(self, text="SCAN Plotting Options", padding="10")
        plotting_options_frame.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")

        # Inner frame for 50/50 split
        scan_options_inner_frame = ttk.Frame(plotting_options_frame)
        scan_options_inner_frame.grid(row=0, column=0, padx=5, pady=5, sticky="nsew", columnspan=2)
        scan_options_inner_frame.grid_columnconfigure(0, weight=1)
        scan_options_inner_frame.grid_columnconfigure(1, weight=1)

        # Left 50% - HTML Output Options
        html_output_options_frame = ttk.LabelFrame(scan_options_inner_frame, text="HTML Output Options", padding="10")
        html_output_options_frame.grid(row=0, column=0, padx=5, pady=5, sticky="nsew")
        html_output_options_frame.grid_columnconfigure(0, weight=1)

        # Link to app_instance variables
        ttk.Checkbutton(html_output_options_frame, text="Plot the HTML after every scan", variable=self.app_instance.open_html_after_complete_var).grid(row=0, column=0, padx=5, pady=2, sticky="w")
        ttk.Checkbutton(html_output_options_frame, text="Create HTML", variable=self.app_instance.create_html_report_var,
                        command=self._on_create_html_checkbox_changed).grid(row=1, column=0, padx=5, pady=2, sticky="w")


        # Right 50% - Scan Markers to Plot
        scan_markers_to_plot_frame = ttk.LabelFrame(scan_options_inner_frame, text="Scan Markers to Plot", padding="10")
        scan_markers_to_plot_frame.grid(row=0, column=1, padx=5, pady=5, sticky="nsew")
        scan_markers_to_plot_frame.grid_columnconfigure(0, weight=1)

        # Link to app_instance variables
        ttk.Checkbutton(scan_markers_to_plot_frame, text="Include TV Band Markers", variable=self.app_instance.include_tv_markers_var,
                        command=self._on_scan_marker_checkbox_changed).grid(row=0, column=0, padx=5, pady=2, sticky="w")
        ttk.Checkbutton(scan_markers_to_plot_frame, text="Include Government Band Markers", variable=self.app_instance.include_gov_markers_var,
                        command=self._on_scan_marker_checkbox_changed).grid(row=1, column=0, padx=5, pady=2, sticky="w")
        ttk.Checkbutton(scan_markers_to_plot_frame, text="Include Markers", variable=self.app_instance.include_markers_var,
                        command=self._on_scan_marker_checkbox_changed).grid(row=2, column=0, padx=5, pady=2, sticky="w")
        ttk.Checkbutton(scan_markers_to_plot_frame, text="Include Intermodulations", variable=self.app_instance.include_scan_intermod_markers_var,
                        command=self._on_scan_marker_checkbox_changed).grid(row=3, column=0, padx=5, pady=2, sticky="w")


        # Plotting Buttons below the split frames
        self.plot_button = ttk.Button(plotting_options_frame, text="Plot Single Scan", command=self._plot_single_scan)
        self.plot_button.grid(row=1, column=0, padx=5, pady=5, sticky="ew") # Adjusted row
        # self.plot_button.config(state=tk.DISABLED) # This line is commented out, so it's not disabled here.

        self.plot_average_button = ttk.Button(plotting_options_frame, text="Plot Current Cycle Average (All Traces)", command=self._plot_current_cycle_average)
        self.plot_average_button.grid(row=2, column=0, padx=5, pady=5, sticky="ew") # Adjusted row
        self.plot_average_button.config(state=tk.DISABLED) # Disable until data is available

        self.open_last_plot_button = ttk.Button(plotting_options_frame, text="Open Last Plot", command=self._open_last_plot)
        self.open_last_plot_button.grid(row=3, column=0, padx=5, pady=5, sticky="ew")

        # Configure column weights for resizing
        self.grid_columnconfigure(0, weight=1)
        plotting_options_frame.grid_columnconfigure(0, weight=1)

        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

    # Removed: _on_avg_type_checkbox_changed - moved to tab_plotting_child_Average.py

    def _on_create_html_checkbox_changed(self):
        """
        Function Description:
        Callback function for when the "Create HTML" checkbox is changed.
        It logs the current state of the checkbox to the console.

        Inputs to this function:
            None.

        Process of this function:
            1. Retrieves the boolean state of `self.app_instance.create_html_var`.
            2. Logs the state to the debug log and the GUI console.

        Outputs of this function:
            None. Updates console output.

        (2025-07-31) Change: Maintained in tab_plotting_child_Single.py.
        (2025-08-01) Change: Updated debug_print to debug_log.
        """
        current_function = inspect.currentframe().f_code.co_name
        state = "Enabled" if self.app_instance.create_html_var.get() else "Disabled"
        debug_log(f"Create HTML checkbox changed. State: {state}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        self.console_print_func(f"Create HTML: {state}")


    def _on_scan_marker_checkbox_changed(self):
        """
        Function Description:
        Callback function for when a "Scan Markers to Plot" checkbox is changed.
        It logs the currently selected marker types for single scan plots to the console.

        Inputs to this function:
            None.

        Process of this function:
            1. Retrieves the state of all `include_..._markers_var` Tkinter variables from `app_instance`.
            2. Builds a list of selected marker types.
            3. Logs the selected types to the debug log and the GUI console.

        Outputs of this function:
            None. Updates console output.

        (2025-07-31) Change: Maintained in tab_plotting_child_Single.py.
        (2025-08-01) Change: Updated debug_print to debug_log.
        """
        current_function = inspect.currentframe().f_code.co_name
        selected_markers = []
        if self.app_instance.include_tv_markers_var.get():
            selected_markers.append("TV Band Markers")
        if self.app_instance.include_gov_markers_var.get():
            selected_markers.append("Government Band Markers")
        if self.app_instance.include_markers_var.get():
            selected_markers.append("General Markers")
        if self.app_instance.include_scan_intermod_markers_var.get(): # NEW variable
            selected_markers.append("Intermodulations")

        debug_log(f"SCAN Plotting Options - Selected markers: {selected_markers}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        self.console_print_func(f"SCAN Plotting Options - Markers: {', '.join(selected_markers) if selected_markers else 'None'}")

    # Removed: _on_multi_file_marker_checkbox_changed - moved to tab_plotting_child_Average.py


    def _plot_single_scan(self):
        """
        Function Description:
        Prompts the user to select a single CSV file and then plots its scan data.

        Inputs to this function:
            None.

        Process of this function:
            1. Opens a file dialog to select a CSV file.
            2. If a file is selected, reads it into a Pandas DataFrame.
            3. Determines the output directory and HTML filename for the plot.
            4. Calls `plot_single_scan_data` from `utils.plotting_utils` to generate the plot.
            5. Stores the path of the generated HTML plot in `self.current_plot_file`.
            6. Logs success or failure messages to the console and optionally opens the plot in a browser.

        Outputs of this function:
            None. Generates an HTML plot file and updates `self.current_plot_file`.

        (2025-07-31) Change: Maintained in tab_plotting_child_Single.py.
        (2025-08-01) Change: Updated debug_print to debug_log.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        file_path = filedialog.askopenfilename(
            title="Select a CSV file to plot",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")]
        )
        if not file_path:
            self.console_print_func("File selection cancelled. No single scan plot generated. Damn it!")
            debug_log("File selection cancelled for single plot.",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        try:
            df = pd.read_csv(file_path, header=None, names=['Frequency (Hz)', 'Power (dBm)']) # Ensure column names match plot_logic
            scan_name = os.path.splitext(os.path.basename(file_path))[0]
            self.console_print_func(f"Plotting single scan from: {scan_name}")
            debug_log(f"Plotting single scan for: {scan_name}",
                        file=__file__,
                        version=current_version,
                        function=current_function)

            # Use app_instance.output_folder_var for output directory
            output_dir = self.app_instance.output_folder_var.get()
            if not os.path.exists(output_dir):
                os.makedirs(output_dir)
                debug_log(f"Created output directory: {output_dir}",
                            file=__file__,
                            version=current_version,
                            function=current_function)

            html_filename = os.path.join(output_dir, f"{scan_name.replace(' ', '_')}_single_scan_plot.html")
            debug_log(f"Output HTML filename: {html_filename}",
                        file=__file__,
                        version=current_version,
                        function=current_function)

            fig, plot_html_path_return = plot_single_scan_data(
                df,
                f"Single Scan: {scan_name}",
                include_tv_markers=self.app_instance.include_tv_markers_var.get(),
                include_gov_markers=self.app_instance.include_gov_markers_var.get(),
                include_markers=self.app_instance.include_markers_var.get(), # Pass general markers
                include_intermod_markers=self.app_instance.include_scan_intermod_markers_var.get(), # NEW
                output_html_path=html_filename if self.app_instance.create_html_var.get() else None, # Only create HTML if checkbox is checked
                console_print_func=self.console_print_func,
                scan_data_folder=os.path.dirname(file_path) # Pass the folder of the selected scan
            )

            if fig:
                self.current_plot_file = plot_html_path_return
                if self.app_instance.create_html_var.get():
                    self.console_print_func(f"✅ Single scan plot saved to: {self.current_plot_file}")
                    debug_log(f"Plot saved successfully to: {self.current_plot_file}",
                                file=__file__,
                                version=current_version,
                                function=current_function)
                else:
                    self.console_print_func("✅ Single scan plot data processed (HTML not saved as per setting).")
                    debug_log("Plot data processed, HTML not saved.",
                                file=__file__,
                                version=current_version,
                                function=current_function)

                if self.app_instance.open_html_after_complete_var.get() and self.app_instance.create_html_var.get() and plot_html_path_return:
                    self.console_print_func(f"Opening plot in browser: {self.current_plot_file}")
                    webbrowser.open_new_tab(self.current_plot_file)
                    debug_log(f"Plot opened in browser: {self.current_plot_file}",
                                file=__file__,
                                version=current_version,
                                function=current_function)
                elif self.app_instance.open_html_after_complete_var.get() and not self.app_instance.create_html_var.get():
                    self.console_print_func("HTML plot not opened because 'Create HTML' is unchecked. What a waste of a click!")
                    debug_log("HTML not opened as 'Create HTML' is unchecked.",
                                file=__file__,
                                version=current_version,
                                function=current_function)
            else:
                self.console_print_func("🚫 Plotly figure was not generated for single scan. Fucking useless!")
                debug_log("Plotly figure not generated for single scan.",
                            file=__file__,
                            version=current_version,
                            function=current_function)
        except Exception as e:
            self.console_print_func(f"❌ Error plotting single scan: {e}. This is a goddamn disaster!")
            debug_log(f"Error plotting single scan: {e}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    def _plot_current_cycle_average(self):
        """
        Function Description:
        Generates a plot of the current cycle's collected scan data, applying selected average types.

        Inputs to this function:
            None.

        Process of this function:
            1. Checks if `self.app_instance.collected_scans_dataframes` contains any data.
            2. Determines the output directory for the plot.
            3. Retrieves the currently selected average types from `app_instance` variables.
            4. If no average types are selected, logs a warning and returns.
            5. Aggregates and aligns all collected scan dataframes to a common frequency reference.
            6. Calculates the selected average types (Average, Median, Range, Std Dev, Variance, PSD)
               across the aligned scan data.
            7. Determines the plot title and output HTML filename.
            8. Dynamically sets the y-axis range override based on the selected average types.
            9. Calls `plot_multi_trace_data` from `utils.plotting_utils` to generate the plot.
            10. Stores the path of the generated HTML plot in `self.current_plot_file`.
            11. Logs success or failure messages to the console and optionally opens the plot in a browser.

        Outputs of this function:
            None. Generates an HTML plot file and updates `self.current_plot_file`.

        (2025-07-31) Change: Maintained in tab_plotting_child_Single.py.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        if not self.app_instance.collected_scans_dataframes:
            self.console_print_func("No collected scan dataframes to average. What the hell am I supposed to plot?!")
            debug_log("No collected scan dataframes for current cycle average.",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            debug_log(f"Exiting {current_function} (no data)",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        # Use app_instance.output_folder_var for output directory
        output_dir = self.app_instance.output_folder_var.get()
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
            debug_log(f"Created output directory: {output_dir}",
                        file=__file__,
                        version=current_version,
                        function=current_function)

        # Get selected average types for current cycle plot from app_instance variables
        selected_avg_types = [
            "Average" if self.app_instance.math_average_var.get() else None,
            "Median" if self.app_instance.math_median_var.get() else None,
            "Range" if self.app_instance.math_range_var.get() else None,
            "Standard Deviation" if self.app_instance.math_standard_deviation_var.get() else None,
            "Variance" if self.app_instance.math_variance_var.get() else None,
            "Power Spectral Density (PSD)" if self.app_instance.math_psd_var.get() else None
        ]
        selected_avg_types = [t for t in selected_avg_types if t is not None]

        if not selected_avg_types:
            self.console_print_func("Warning: No average type selected for current cycle plot. Please select at least one type. Come on, pick something!")
            debug_log(f"Exiting {current_function} (no selected_avg_types for current cycle)",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        self.console_print_func("Processing current cycle average plot. This may take a moment depending on the number of scans. Don't touch that dial!")
        debug_log(f"Calling generate_current_cycle_average_csv_and_plot with {len(self.app_instance.collected_scans_dataframes)} dataframes and selected types: {selected_avg_types}.",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        # Aggregate the current cycle scans into a single DataFrame for plotting
        all_frequencies_current_cycle = pd.Series(dtype=float)
        power_levels_current_cycle_list = []
        rbw_values_current_cycle = [] # Collect RBW for PSD calculation

        for df_scan in self.app_instance.collected_scans_dataframes:
            if 'Frequency (Hz)' in df_scan.columns and 'Power (dBm)' in df_scan.columns:
                all_frequencies_current_cycle = pd.concat([all_frequencies_current_cycle, df_scan['Frequency (Hz)']])
                power_levels_current_cycle_list.append(df_scan.set_index('Frequency (Hz)')['Power (dBm)'])
                # Use the app_instance.scan_rbw_hz_var for RBW
                rbw_value = float(self.app_instance.scan_rbw_hz_var.get())
                rbw_values_current_cycle.append(rbw_value)
            else:
                self.console_print_func("Warning: Collected scan missing 'Frequency (Hz)' or 'Power (dBm)'. Skipping for current cycle average. What a mess!")
                debug_log("Collected scan missing freq/power columns.",
                            file=__file__,
                            version=current_version,
                            function=current_function)

        if not power_levels_current_cycle_list:
            self.console_print_func("No valid collected scans to average for current cycle. This is pointless!")
            debug_log("No valid collected scans for current cycle average.",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        # Create a master reference frequency for current cycle
        reference_freq_current_cycle = all_frequencies_current_cycle.sort_values().drop_duplicates().reset_index(drop=True)

        # Reindex and interpolate all power series to the master frequency
        aligned_power_series_current_cycle = []
        for series in power_levels_current_cycle_list:
            aligned_series = series.reindex(reference_freq_current_cycle).interpolate(method='linear', limit_direction='both')
            aligned_power_series_current_cycle.append(aligned_series)

        power_levels_df_current_cycle = pd.concat(aligned_power_series_current_cycle, axis=1)
        power_levels_df_current_cycle.columns = [f"Scan_{i+1}" for i in range(len(aligned_power_series_current_cycle))]

        # Calculate selected average types for current cycle
        aggregated_df_current_cycle = pd.DataFrame({'Frequency (Hz)': reference_freq_current_cycle})

        # Define calculation functions locally or import them if they are in averaging_utils
        # For simplicity, defining them here for now, but ideally they'd be shared.
        def _local_calculate_average(df): return df.mean(axis=1)
        def _local_calculate_median(df): return df.median(axis=1)
        def _local_calculate_range(df): return df.max(axis=1) - df.min(axis=1)
        def _local_calculate_std_dev(df): return df.std(axis=1)
        def _local_calculate_variance(df): return df.var(axis=1)
        def _local_calculate_psd(df, rbw_values_list):
            if rbw_values_list and any(r is not None and r > 0 for r in rbw_values_list):
                # Use the average RBW for the PSD calculation across multiple scans
                avg_rbw = sum([r for r in rbw_values_list if r is not None and r > 0]) / len([r for r in rbw_values_list if r is not None and r > 0])
                linear_power_mW = 10**(df / 10).mean(axis=1) # Average linear power
                return 10 * np.log10(linear_power_mW / avg_rbw)
            else:
                return pd.Series([np.nan]*len(df.index))

        calculation_functions = {
            "Average": _local_calculate_average,
            "Median": _local_calculate_median,
            "Range": _local_calculate_range,
            "Standard Deviation": _local_calculate_std_dev, # Updated key
            "Variance": _local_calculate_variance,
            "Power Spectral Density (PSD)": _local_calculate_psd # Updated key
        }

        for avg_type in selected_avg_types:
            if avg_type in calculation_functions:
                if avg_type == "Power Spectral Density (PSD)": # Updated key
                    # Pass rbw_values_current_cycle to PSD calculation
                    aggregated_df_current_cycle[avg_type] = calculation_functions[avg_type](power_levels_df_current_cycle, rbw_values_current_cycle)
                else:
                    aggregated_df_current_cycle[avg_type] = calculation_functions[avg_type](power_levels_df_current_cycle)
            else:
                self.console_print_func(f"Warning: Unknown average type '{avg_type}' requested for current cycle. Skipping. What the hell is this type?!")

        plot_title_current_cycle = f"Current Cycle Average - {', '.join(selected_avg_types)}"
        html_filename_current_cycle = os.path.join(output_dir, f"CurrentCycleAverage_Plot_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html")

        # Determine y_range_max_override for current cycle plot
        y_range_max_override_val = 0 # Default for power plots
        if any(avg_type in selected_avg_types for avg_type in ["Range", "Standard Deviation", "Variance", "Power Spectral Density (PSD)"]):
            y_range_max_override_val = 30 # Set to 30 for these statistical plots

        fig, plot_html_path_return = plot_multi_trace_data(
            aggregated_df_current_cycle,
            plot_title_current_cycle,
            include_tv_markers=self.app_instance.include_tv_markers_var.get(), # Use app_instance var
            include_gov_markers=self.app_instance.include_gov_markers_var.get(), # Use app_instance var
            include_markers=self.app_instance.include_markers_var.get(), # Use app_instance var
            include_intermod_markers=self.app_instance.include_scan_intermod_markers_var.get(), # NEW
            historical_dfs_with_names=None,
            individual_scan_dfs_with_names=[(df, f"Scan {i+1}") for i, df in enumerate(self.app_instance.collected_scans_dataframes)], # Pass individual scans
            output_html_path=html_filename_current_cycle if self.app_instance.create_html_var.get() else None, # Use app_instance var
            y_range_min_override=None, # Let the plotting function determine min
            y_range_max_override=y_range_max_override_val, # Pass the dynamically set override
            console_print_func=self.console_print_func,
            scan_data_folder=output_dir # Pass the output directory as the scan_data_folder for markers
        )

        if fig:
            self.current_plot_file = plot_html_path_return
            if self.app_instance.create_html_var.get():
                self.console_print_func(f"✅ Current cycle averaged plot saved to: {self.current_plot_file}")
                debug_log(f"Current cycle averaged plot saved to: {self.current_plot_file}",
                            file=__file__,
                            version=current_version,
                            function=current_function)
            else:
                self.console_print_func("✅ Current cycle averaged plot data processed (HTML not saved as per setting).")
                debug_log("Plot data processed, HTML not saved.",
                            file=__file__,
                            version=current_version,
                            function=current_function)

            if self.app_instance.open_html_after_complete_var.get() and self.app_instance.create_html_var.get() and plot_html_path_return:
                _open_plot_in_browser(plot_html_path_return, self.console_print_func)
        else:
            self.console_print_func("🚫 Plotly figure was not generated for current cycle averaged data. Are you even trying?!")
            debug_log("Plotly figure not generated for current cycle averaged data.",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    def _open_last_plot(self):
        """
        Function Description:
        Opens the last generated HTML plot in the default web browser.

        Inputs to this function:
            None.

        Process of this function:
            1. Checks if `self.current_plot_file` is set and the file exists.
            2. If so, opens the file in a new browser tab using `_open_plot_in_browser`.
            3. Otherwise, logs an error message to the console.

        Outputs of this function:
            None. Opens a web browser tab.

        (2025-07-31) Change: Maintained in tab_plotting_child_Single.py.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        if self.current_plot_file and os.path.exists(self.current_plot_file):
            self.console_print_func(f"Opening last plot: {self.current_plot_file}")
            _open_plot_in_browser(self.current_plot_file, self.console_print_func) # Pass console_print_func
            debug_log(f"Opened last plot: {self.current_plot_file}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        else:
            self.console_print_func("Error: No plot available or file not found. Please generate a plot first. What's the point of this button then?!")
            debug_log("No plot available or file not found.",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

    # Removed: _open_folder_for_averaging - moved to tab_plotting_child_Average.py
    # Removed: _find_and_group_csv_files - moved to tab_plotting_child_Average.py
    # Removed: _select_group_for_plotting - moved to tab_plotting_child_Average.py
    # Removed: _clear_dynamic_buttons - moved to tab_plotting_child_Average.py
    # Removed: _generate_csv_selected_series - moved to tab_plotting_child_Average.py
    # Removed: _open_applied_math_folder - moved to tab_plotting_child_Average.py
    # Removed: _generate_multi_average_plot - moved to tab_plotting_child_Average.py
    # Removed: _generate_plot_scans_over_time - moved to tab_plotting_child_Average.py


    def _on_tab_selected(self, event):
        """
        Function Description:
        Callback for when this tab is selected.
        This can be used to refresh data or update UI elements specific to this tab.

        Inputs to this function:
            event (tkinter.Event): The event object that triggered the tab selection.

        Process of this function:
            1. Logs a debug message indicating the tab selection.
            2. Ensures the "Plot Single Scan" button is enabled.
            3. Enables/Disables the "Plot Current Cycle Average" button based on whether
               `collected_scans_dataframes` contains any data.

        Outputs of this function:
            None. Updates the state of relevant GUI buttons.

        (2025-07-31) Change: Updated to reflect removal of folder averaging functionality.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        debug_log("Plotting Tab selected.",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        # The 'Plot Single Scan' button should always be enabled as it opens a file dialog.
        self.plot_button.config(state=tk.NORMAL)
        debug_log("Plot Single Scan button enabled.",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        # Enable/Disable 'Plot Current Cycle Average' button based on collected_scans_dataframes
        if self.app_instance.collected_scans_dataframes:
            self.plot_average_button.config(state=tk.NORMAL)
            debug_log("Plot Current Cycle Average button enabled (data available).",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        else:
            self.plot_average_button.config(state=tk.DISABLED)
            debug_log("Plot Current Cycle Average button disabled (no data available).",
                        file=__file__,
                        version=current_version,
                        function=current_function)

        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


#####################################
### File: OPEN-AIR\Plotting\tab_plotting_child_average.py
#####################################
# tabs/Plotting/tab_plotting_child_average.py
#
# This file defines a Tkinter Frame for plotting averaged scan data from folders.
# It handles selecting folders, grouping CSV files, generating averaged CSVs,
# and plotting various statistical analyses (Average, Median, Range, Std Dev, Variance, PSD).
# The 3D plotting functionality has been moved to tab_plotting_child_3D.py.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250801.2225.1 (Refactored debug_print to use debug_log and console_log.)

current_version = "20250801.2225.1" # this variable should always be defined below the header to make the debugging better
current_version_hash = 20250801 * 2225 * 1 # Example hash, adjust as needed

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import os
import pandas as pd
import inspect
import webbrowser # For opening HTML plot in browser
import re # Added for regex in file grouping
import platform # For opening folder cross-platform
import glob # For finding files with specific patterns
from datetime import datetime # Import datetime for timestamping plots
import numpy as np # Added for PSD calculation

# CORRECTED: Import plotting functions and _open_plot_in_browser directly from utils.plotting_utils
from .utils_plotting import plot_multi_trace_data, _open_plot_in_browser

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log

from process_math.averaging_utils import average_scan # NEW import
# Removed: from utils.plot_scans_over_time import plot_Scans_over_time # Moved to tab_plotting_child_3D.py


class AveragingTab(ttk.Frame):
    """
    A Tkinter Frame that provides functionality for plotting averaged scan data from folders.
    """
    def __init__(self, master=None, app_instance=None, console_print_func=None, **kwargs):
        """
        Initializes the AveragingTab.

        Inputs:
            master (tk.Widget): The parent widget.
            app_instance (App): The main application instance, used for accessing
                                shared state like collected_scans_dataframes and output directory.
            console_print_func (function): Function to print messages to the GUI console.
            **kwargs: Arbitrary keyword arguments for Tkinter Frame.
        """
        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func if console_print_func else console_log # Use provided func or console_log
        self.current_plot_file = None # To store the path of the last generated plot HTML
        self.last_opened_folder = None # To remember the last opened folder for averaging
        self.last_applied_math_folder = None # To store the path of the last folder created by applied math
        self.grouped_csv_files = {} # Dictionary to store grouped CSV files
        self.selected_group_prefix = None # Stores the prefix of the currently selected group

        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        self._create_widgets()
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

    def _create_widgets(self):
        """
        Function Description:
        Creates and arranges all the widgets for the AveragingTab.

        Inputs to this function:
            None.

        Process of this function:
            1. Creates the main LabelFrame for "Plotting Averages from Folder".
            2. Adds a button to open a folder for averaging.
            3. Creates a LabelFrame to display discovered series of scans with dynamic buttons.
            4. Creates a frame for "Apply Math" checkboxes (Average, Median, etc.).
            5. Creates a frame for "Markers to Plot" checkboxes specific to averaged plots.
            6. Adds buttons for generating CSVs, opening the applied math folder,
               and generating plots of averages (with/without scans).
            7. Configures grid weights for responsive layout.

        Outputs of this function:
            None. Populates the tab with GUI elements.

        (2025-07-31) Change: Removed "Generate Plot of Scans Over Time" button.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        # --- Plotting Averages from Folder Section ---
        self.averaging_folder_frame = ttk.LabelFrame(self, text="Plotting Averages from Folder", padding="10")
        self.averaging_folder_frame.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")

        # Open Folder to Average Button (Top of this section)
        self.open_folder_button = ttk.Button(self.averaging_folder_frame, text="Open Folder to Average", command=self._open_folder_for_averaging)
        self.open_folder_button.grid(row=0, column=0, columnspan=2, padx=5, pady=5, sticky="ew")

        # Discovered Series of Scans Frame
        self.discovered_series_frame = ttk.LabelFrame(self.averaging_folder_frame, text="Discovered Series of Scans", padding="10")
        self.discovered_series_frame.grid(row=1, column=0, columnspan=2, padx=5, pady=5, sticky="nsew")
        self.dynamic_avg_buttons_frame = ttk.Frame(self.discovered_series_frame) # This frame will hold dynamically created buttons.
        self.dynamic_avg_buttons_frame.pack(fill="both", expand=True) # Use pack for dynamic buttons within this frame

        # Math and Markers Container Frame (for 50/50 split)
        math_and_markers_frame = ttk.Frame(self.averaging_folder_frame)
        math_and_markers_frame.grid(row=2, column=0, columnspan=2, padx=5, pady=5, sticky="nsew")
        math_and_markers_frame.grid_columnconfigure(0, weight=1) # Make columns expandable
        math_and_markers_frame.grid_columnconfigure(1, weight=1)

        # Apply Math Frame
        apply_math_frame = ttk.LabelFrame(math_and_markers_frame, text="Apply Math", padding="10")
        apply_math_frame.grid(row=0, column=0, padx=5, pady=5, sticky="nsew")
        apply_math_frame.grid_columnconfigure(0, weight=1) # Make column expandable

        # Link to app_instance variables
        self.avg_type_vars = {
            "Average": self.app_instance.math_average_var,
            "Median": self.app_instance.math_median_var,
            "Range": self.app_instance.math_range_var,
            "Standard Deviation": self.app_instance.math_standard_deviation_var,
            "Variance": self.app_instance.math_variance_var,
            "Power Spectral Density (PSD)": self.app_instance.math_psd_var
        }

        # Tooltip definitions (example, you'd integrate a proper tooltip class)
        tooltip_texts = {
            "Average": "Calculates the arithmetic mean of power levels across all scans.",
            "Median": "Calculates the median (middle value) of power levels across all scans.",
            "Range": "Calculates the difference between the maximum and minimum power levels for each frequency point.",
            "Standard Deviation": "Measures the dispersion of power levels around the mean for each frequency point.",
            "Variance": "Measures the squared deviation from the mean, indicating the spread of power levels.",
            "Power Spectral Density (PSD)": "Normalizes power to a 1 Hz bandwidth, useful for comparing noise floors."
        }

        for i, (text, var) in enumerate(self.avg_type_vars.items()):
            chk = ttk.Checkbutton(apply_math_frame, text=text, variable=var,
                                  command=self._on_avg_type_checkbox_changed)
            chk.grid(row=i, column=0, padx=5, pady=2, sticky="w")

            # --- Tooltip Integration Suggestion ---
            # To add tooltips, you would typically use a custom Tooltip class
            # or bind to <Enter> and <Leave> events to show/hide a Label.
            # Example (conceptual, requires Tooltip class definition):
            # Tooltip(chk, text=tooltip_texts.get(text, "No description available."))
            # ------------------------------------

        # Markers to Plot Frame (Includes TV, Government, General, and Intermodulations)
        markers_to_plot_frame = ttk.LabelFrame(math_and_markers_frame, text="Markers to Plot", padding="10")
        markers_to_plot_frame.grid(row=0, column=1, padx=5, pady=5, sticky="nsew")
        markers_to_plot_frame.grid_columnconfigure(0, weight=1) # Make column expandable

        # Link to app_instance variables for average markers
        ttk.Checkbutton(markers_to_plot_frame, text="Include TV Band Markers", variable=self.app_instance.include_tv_markers_var,
                        command=self._on_multi_file_marker_checkbox_changed).grid(row=0, column=0, padx=5, pady=2, sticky="w")
        ttk.Checkbutton(markers_to_plot_frame, text="Include Government Band Markers", variable=self.app_instance.include_gov_markers_var,
                        command=self._on_multi_file_marker_checkbox_changed).grid(row=1, column=0, padx=5, pady=2, sticky="w")
        ttk.Checkbutton(markers_to_plot_frame, text="Include Markers", variable=self.app_instance.include_markers_var,
                        command=self._on_multi_file_marker_checkbox_changed).grid(row=2, column=0, padx=5, pady=2, sticky="w")
        ttk.Checkbutton(markers_to_plot_frame, text="Include Intermodulations", variable=self.app_instance.include_scan_intermod_markers_var,
                        command=self._on_multi_file_marker_checkbox_changed).grid(row=3, column=0, padx=5, pady=2, sticky="w")


        # Make Averages Frame
        make_averages_frame = ttk.LabelFrame(self.averaging_folder_frame, text="Make Averages", padding="10")
        make_averages_frame.grid(row=3, column=0, columnspan=2, padx=5, pady=5, sticky="nsew")
        make_averages_frame.grid_columnconfigure(0, weight=1) # Make column expandable

        self.generate_csv_button = ttk.Button(make_averages_frame, text="Generate CSV of Selected Series of Scan", command=self._generate_csv_selected_series)
        self.generate_csv_button.grid(row=0, column=0, padx=5, pady=5, sticky="ew")
        self.generate_csv_button.config(state=tk.DISABLED) # Disable until group is selected

        self.open_applied_math_folder_button = ttk.Button(make_averages_frame, text="Open Folder of Applied Math", command=self._open_applied_math_folder)
        self.open_applied_math_folder_button.grid(row=1, column=0, padx=5, pady=5, sticky="ew")
        self.open_applied_math_folder_button.config(state=tk.DISABLED) # Disable until a folder is created

        self.generate_plot_averages_button = ttk.Button(make_averages_frame, text="Generate Plot of Averages", command=lambda: self._generate_multi_average_plot(include_scans=False))
        self.generate_plot_averages_button.grid(row=2, column=0, padx=5, pady=5, sticky="ew")
        self.generate_plot_averages_button.config(state=tk.DISABLED) # Disable until group is selected

        self.generate_plot_averages_with_scan_button = ttk.Button(make_averages_frame, text="Generate Plot of Averages with Scan", command=lambda: self._generate_multi_average_plot(include_scans=True))
        self.generate_plot_averages_with_scan_button.grid(row=3, column=0, padx=5, pady=5, sticky="ew")
        self.generate_plot_averages_with_scan_button.config(state=tk.DISABLED) # Disable until group is selected

        # Removed: self.generate_plot_scans_over_time_button = ttk.Button(make_averages_frame, text="Generate Plot of Scans Over Time", command=self._generate_plot_scans_over_time)
        # Removed: self.generate_plot_scans_over_time_button.grid(row=4, column=0, padx=5, pady=5, sticky="ew")
        # Removed: self.generate_plot_scans_over_time_button.config(state=tk.DISABLED) # Disable until group is selected


        # Configure column weights for resizing
        self.grid_columnconfigure(0, weight=1)
        self.averaging_folder_frame.grid_columnconfigure(0, weight=1)
        self.averaging_folder_frame.grid_columnconfigure(1, weight=1) # For the two columns inside
        self.discovered_series_frame.grid_columnconfigure(0, weight=1)
        self.dynamic_avg_buttons_frame.grid_columnconfigure(0, weight=1) # Ensure dynamic buttons expand
        make_averages_frame.grid_columnconfigure(0, weight=1)


        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

    def _on_avg_type_checkbox_changed(self):
        """
        Function Description:
        Callback function for when an "Apply Math" checkbox is changed.
        It logs the currently selected average types to the console.

        Inputs to this function:
            None.

        Process of this function:
            1. Retrieves the state of all "math_average_var" Tkinter variables from app_instance.
            2. Filters out unselected types.
            3. Logs the selected types to the debug log and the GUI console.

        Outputs of this function:
            None. Updates console output.

        (2025-07-31) Change: Moved from tab_plotting_child_Single.py.
        (2025-08-01) Change: Updated debug_print to debug_log.
        """
        current_function = inspect.currentframe().f_code.co_name
        # Now directly use app_instance variables as they are linked
        selected_types = [
            "Average" if self.app_instance.math_average_var.get() else None,
            "Median" if self.app_instance.math_median_var.get() else None,
            "Range" if self.app_instance.math_range_var.get() else None,
            "Standard Deviation" if self.app_instance.math_standard_deviation_var.get() else None,
            "Variance" if self.app_instance.math_variance_var.get() else None,
            "Power Spectral Density (PSD)" if self.app_instance.math_psd_var.get() else None
        ]
        selected_types = [t for t in selected_types if t is not None]
        debug_log(f"Checkbox changed. Currently selected average types: {selected_types}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        self.console_print_func(f"Selected average types: {', '.join(selected_types) if selected_types else 'None'}")

    def _on_multi_file_marker_checkbox_changed(self):
        """
        Function Description:
        Callback function for when a "Markers to Plot" checkbox (for multi-file plots) is changed.
        It logs the currently selected marker types to the console.

        Inputs to this function:
            None.

        Process of this function:
            1. Retrieves the state of all "avg_include_..." Tkinter variables from app_instance.
            2. Builds a list of selected marker types.
            3. Logs the selected types to the debug log and the GUI console.

        Outputs of this function:
            None. Updates console output.

        (2025-07-31) Change: Moved from tab_plotting_child_Single.py.
        (2025-08-01) Change: Updated debug_print to debug_log.
        """
        current_function = inspect.currentframe().f_code.co_name
        selected_markers = []
        if self.app_instance.avg_include_tv_markers_var.get(): # NEW variable
            selected_markers.append("TV Band Markers")
        if self.app_instance.avg_include_gov_markers_var.get(): # NEW variable
            selected_markers.append("Government Band Markers")
        if self.app_instance.avg_include_markers_var.get(): # NEW variable
            selected_markers.append("General Markers")
        if self.app_instance.avg_include_intermod_markers_var.get(): # NEW variable
            selected_markers.append("Intermodulations")

        debug_log(f"Multi-File Plotting - Selected markers: {selected_markers}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        self.console_print_func(f"Multi-File Plotting - Markers: {', '.join(selected_markers) if selected_markers else 'None'}")

    def _open_folder_for_averaging(self):
        """
        Function Description:
        Opens a file dialog to allow the user to select a folder containing CSV files for averaging.
        Upon selection, it calls `_find_and_group_csv_files` and enables relevant buttons.

        Inputs to this function:
            None.

        Process of this function:
            1. Opens a directory selection dialog, defaulting to the last opened folder.
            2. If a folder is selected, stores it as `self.last_opened_folder`.
            3. Calls `_find_and_group_csv_files` to process the CSVs in the selected folder.
            4. Enables the CSV generation and plotting buttons.
            5. If no folder is selected, disables the buttons.

        Outputs of this function:
            None. Updates GUI state and initiates file grouping.

        (2025-07-31) Change: Moved from tab_plotting_child_Single.py.
        (2025-08-01) Change: Updated debug_print to debug_log.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        folder_path = filedialog.askdirectory(initialdir=self.last_opened_folder)
        debug_log(f"Selected folder_path: {folder_path}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        if folder_path:
            self.last_opened_folder = folder_path
            self.console_print_func(f"Selected folder for averaging: {folder_path}")
            self._find_and_group_csv_files(folder_path)
            # Enable relevant buttons after a folder is selected and groups are found
            self.generate_csv_button.config(state=tk.NORMAL)
            self.generate_plot_averages_button.config(state=tk.NORMAL)
            self.generate_plot_averages_with_scan_button.config(state=tk.NORMAL)
            # Removed: self.generate_plot_scans_over_time_button.config(state=tk.NORMAL)
            debug_log("Averaging buttons enabled (folder selected).",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        else:
            self.console_print_func("Folder selection cancelled.")
            # Disable buttons if folder selection is cancelled
            self.generate_csv_button.config(state=tk.DISABLED)
            self.generate_plot_averages_button.config(state=tk.DISABLED)
            self.generate_plot_averages_with_scan_button.config(state=tk.DISABLED)
            # Removed: self.generate_plot_scans_over_time_button.config(state=tk.DISABLED)
            debug_log("Folder selection cancelled. Averaging buttons disabled.",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    def _find_and_group_csv_files(self, folder_path):
        """
        Function Description:
        Scans the selected folder for CSV files and groups them based on a common naming prefix.
        It then creates dynamic buttons for each identified group.

        Inputs to this function:
            folder_path (str): The path to the folder containing CSV files.

        Process of this function:
            1. Lists all CSV files in the given `folder_path`.
            2. If no CSVs are found, clears dynamic buttons and returns.
            3. Iterates through each CSV, attempting to extract a common prefix using regex.
               The regex is designed to be flexible, looking for a pattern before RBW/HOLD/timestamp.
            4. Stores files in `file_groups` dictionary, where keys are prefixes and values are lists of file paths.
            5. Clears any existing dynamic group selection buttons.
            6. Creates a new `ttk.Button` for each identified group, allowing the user to select it.
            7. Configures button styles.

        Outputs of this function:
            None. Populates `self.grouped_csv_files` and updates the GUI with group selection buttons.

        (2025-07-31) Change: Moved from tab_plotting_child_Single.py.
        (2025-08-01) Change: Updated debug_print to debug_log.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function} with folder_path: {folder_path}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        csv_files = [f for f in os.listdir(folder_path) if f.endswith('.csv')]
        debug_log(f"Found CSV files: {csv_files}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        if not csv_files:
            self.console_print_func("No CSV files found in the selected folder. FUCK! Where did they go?!")
            self._clear_dynamic_buttons()
            debug_log(f"Exiting {current_function} (no CSVs)",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        file_groups = {}
        for filename in csv_files:
            base_name = os.path.splitext(filename)[0]
            # Updated regex for grouping: be more flexible with the ending part before date/time
            # It tries to capture the main prefix before any RBW/HOLD/Offset/timestamp.
            match = re.match(r"([^\d_ -]+(?:[_ -][^\d_ -]+)*?)_RBW\d+K?_HOLD\d+.*", base_name)
            prefix = base_name # Default to full base name if no clear pattern
            if match:
                prefix = match.group(1).strip() # Get the part before RBW/HOLD
                # Refine prefix: remove trailing underscores/hyphens if they were part of the non-digit group
                prefix = re.sub(r"[_ -]+$", "", prefix)
            else:
                # Fallback if the more specific pattern doesn't match (e.g., for INTERMOD.csv or simpler names)
                # Try to split by common delimiters if no complex pattern is found
                if '_' in base_name:
                    prefix = base_name.split('_')[0]
                elif '-' in base_name:
                    prefix = base_name.split('-')[0]
                else:
                    prefix = base_name # Use full name if no common delimiters

            if not prefix: # Ensure prefix is not empty
                prefix = base_name # Fallback to full base name

            if prefix not in file_groups:
                file_groups[prefix] = []
            file_groups[prefix].append(os.path.join(folder_path, filename))
        debug_log(f"Grouped CSV files: {file_groups}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        self._clear_dynamic_buttons() # Clear any previous buttons

        if not file_groups:
            self.console_print_func("No identifiable groups of CSV files found. This is a bloody mess!")
            debug_log(f"Exiting {current_function} (no file groups)",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        self.console_print_func(f"Found {len(file_groups)} groups of similar CSV files. Let's get this show on the road!")

        self.grouped_csv_files = file_groups
        self.selected_group_prefix = None

        row_start = 0
        for i, (prefix, files) in enumerate(file_groups.items()):
            group_text = f"Group '{prefix}' ({len(files)} files)"
            btn = ttk.Button(self.dynamic_avg_buttons_frame, text=group_text,
                             command=lambda p=prefix: self._select_group_for_plotting(p))
            btn.grid(row=row_start + i, column=0, padx=5, pady=2, sticky="ew")
            btn.config(style='Orange.TButton')

        try:
            style = ttk.Style()
            style.configure('Orange.TButton', background='orange', foreground='black')
        except Exception as e:
            debug_log(f"Could not apply orange style: {e}. Damn you, Tkinter styles!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    def _select_group_for_plotting(self, prefix):
        """
        Function Description:
        Sets the `selected_group_prefix` and visually highlights the selected group button.

        Inputs to this function:
            prefix (str): The prefix of the selected group of files.

        Process of this function:
            1. Stores the `prefix` in `self.selected_group_prefix`.
            2. Updates the console with the selected group.
            3. Iterates through all dynamic group buttons:
               a. If the button's text matches the selected prefix, sets its relief to "sunken" and applies a "SelectedOrange.TButton" style.
               b. Otherwise, resets its relief to "raised" and applies the default "Orange.TButton" style.
            4. Attempts to configure the "SelectedOrange.TButton" style.

        Outputs of this function:
            None. Updates `self.selected_group_prefix` and GUI button appearance.

        (2025-07-31) Change: Moved from tab_plotting_child_Single.py.
        (2025-08-01) Change: Updated debug_print to debug_log.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function} with prefix: {prefix}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        self.selected_group_prefix = prefix
        self.console_print_func(f"Selected group for plotting: '{prefix}'")
        debug_log(f"Selected group for plotting: '{prefix}'",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        for widget in self.dynamic_avg_buttons_frame.winfo_children():
            if isinstance(widget, ttk.Button):
                if widget.cget("text").startswith(f"Group '{prefix}'"):
                    widget.config(relief="sunken", style='SelectedOrange.TButton')
                    debug_log(f"Highlighted button for group: {prefix}",
                                file=__file__,
                                version=current_version,
                                function=current_function)
                else:
                    widget.config(relief="raised", style='Orange.TButton')
        try:
            style = ttk.Style()
            style.configure('SelectedOrange.TButton', background='darkorange', foreground='white')
        except Exception as e:
            debug_log(f"Could not apply selected orange style: {e}. This style system is a real pain in the ass!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    def _clear_dynamic_buttons(self):
        """
        Function Description:
        Destroys all dynamically created group selection buttons from the GUI.

        Inputs to this function:
            None.

        Process of this function:
            1. Iterates through all child widgets in `self.dynamic_avg_buttons_frame`.
            2. Calls `destroy()` on each widget.

        Outputs of this function:
            None. Clears the dynamic button area in the GUI.

        (2025-07-31) Change: Moved from tab_plotting_child_Single.py.
        (2025-08-01) Change: Updated debug_print to debug_log.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        for widget in self.dynamic_avg_buttons_frame.winfo_children():
            widget.destroy()
        debug_log(f"Cleared dynamic buttons.",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    def _generate_csv_selected_series(self):
        """
        Function Description:
        Generates CSV files containing the selected average types for the currently selected group of scans.
        It utilizes the `average_scan` utility function.

        Inputs to this function:
            None.

        Process of this function:
            1. Checks if `grouped_csv_files` and `selected_group_prefix` are set. If not, logs a warning and returns.
            2. Retrieves the list of files to average for the selected group.
            3. Retrieves the currently selected average types from `app_instance` variables.
            4. If no average types are selected, logs a warning and returns.
            5. Calls the `average_scan` function with the collected parameters.
            6. If CSV generation is successful, stores the `output_folder_path` in `self.last_applied_math_folder`
               and enables the "Open Folder of Applied Math" button. Otherwise, disables it.

        Outputs of this function:
            None. Creates CSV files and updates GUI button state.

        (2025-07-31) Change: Moved from tab_plotting_child_Single.py.
        (2025-08-01) Change: Updated debug_print to debug_log.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        if not hasattr(self, 'grouped_csv_files') or not self.grouped_csv_files:
            self.console_print_func("Warning: No data. Please select a folder and identify CSV file groups first. What the hell are you trying to average?")
            debug_log(f"Exiting {current_function} (no grouped_csv_files)",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        if not self.selected_group_prefix:
            self.console_print_func("Warning: No group selected. Please click on one of the group buttons to select files for averaging. Pick one, for crying out loud!")
            debug_log(f"Exiting {current_function} (no selected_group_prefix)",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        files_to_average = self.grouped_csv_files[self.selected_group_prefix]
        debug_log(f"Files to average for selected group '{self.selected_group_prefix}': {files_to_average}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        if not files_to_average:
            self.console_print_func("Error: No files found for the selected group. This is utterly useless!")
            debug_log(f"Exiting {current_function} (files_to_average is empty)",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        # Get selected average types from app_instance variables
        selected_avg_types = [
            "Average" if self.app_instance.math_average_var.get() else None,
            "Median" if self.app_instance.math_median_var.get() else None,
            "Range" if self.app_instance.math_range_var.get() else None,
            "Standard Deviation" if self.app_instance.math_standard_deviation_var.get() else None,
            "Variance" if self.app_instance.math_variance_var.get() else None,
            "Power Spectral Density (PSD)" if self.app_instance.math_psd_var.get() else None
        ]
        selected_avg_types = [t for t in selected_avg_types if t is not None]

        debug_log(f"Selected average types BEFORE check: {selected_avg_types}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        if not selected_avg_types:
            self.console_print_func("Warning: No average type selected. Please select at least one type of average to generate CSVs (e.g., Average, Median). Are you even trying?!")
            debug_log(f"Exiting {current_function} (no selected_avg_types)",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        self.console_print_func(f"Generating CSVs for selected series. This may take some time depending on the number and size of scans. Don't go anywhere!")

        output_dir_base = self.last_opened_folder # Use the folder where files were opened as base for new subfolder

        # Call the new average_scan function
        aggregated_df, output_folder_path = average_scan(
            file_paths=files_to_average,
            selected_avg_types=selected_avg_types,
            plot_title_prefix=self.selected_group_prefix,
            output_html_path_base=output_dir_base,
            console_print_func=self.console_print_func
        )

        if output_folder_path:
            self.last_applied_math_folder = output_folder_path
            self.console_print_func(f"CSV files generated in: {output_folder_path}")
            self.open_applied_math_folder_button.config(state=tk.NORMAL) # Enable the button
            self.console_print_func("🎉 CSV generation complete! Now that's what I call progress! 🎉")
        else:
            self.console_print_func("🚫 CSV generation failed. FML, this is frustrating!")
            self.open_applied_math_folder_button.config(state=tk.DISABLED)
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    def _open_applied_math_folder(self):
        """
        Function Description:
        Opens the folder where the applied math (averaged CSVs and plots) were saved.
        It uses platform-specific commands to open the folder in the file explorer.

        Inputs to this function:
            None.

        Process of this function:
            1. Checks if `self.last_applied_math_folder` is set and exists.
            2. If so, attempts to open the folder using `os.startfile` (Windows),
               `subprocess.Popen(["open", ...])` (macOS), or `subprocess.Popen(["xdg-open", ...])` (Linux).
            3. If an error occurs, logs it to the console.
            4. If no folder is available, logs a message to the console.

        Outputs of this function:
            None. Opens a file explorer window.

        (2025-07-31) Change: Moved from tab_plotting_child_Single.py.
        (2025-08-01) Change: Updated debug_print to debug_log.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        if self.last_applied_math_folder and os.path.exists(self.last_applied_math_folder):
            self.console_print_func(f"Opening folder: {self.last_applied_math_folder}")
            try:
                if platform.system() == "Windows":
                    os.startfile(self.last_applied_math_folder)
                elif platform.system() == "Darwin": # macOS
                    import subprocess
                    subprocess.Popen(["open", self.last_applied_math_folder])
                else: # Linux and other Unix-like systems
                    import subprocess
                    subprocess.Popen(["xdg-open", self.last_applied_math_folder])
            except Exception as e:
                self.console_print_func(f"❌ Error opening folder: {e}. Are you kidding me?!")
                debug_log(f"Error opening folder {self.last_applied_math_folder}: {e}",
                            file=__file__,
                            version=current_version,
                            function=current_function)
        else:
            self.console_print_func("No folder of applied math available. Please generate CSVs first. What did you expect, magic?")
            debug_log("No applied math folder to open.",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    def _generate_multi_average_plot(self, include_scans=False):
        """
        Function Description:
        Generates a plot of selected averages from the 'COMPLETE_MATH' CSV,
        optionally overlaying individual scan data.

        Inputs to this function:
            include_scans (bool): If True, individual scan data will be overlaid on the plot.

        Process of this function:
            1. Checks for the existence of `self.last_applied_math_folder` and `self.selected_group_prefix`.
            2. Constructs a path to find the `COMPLETE_MATH` CSV file within the applied math folder.
            3. Loads the `COMPLETE_MATH` CSV into a Pandas DataFrame.
            4. Filters the DataFrame to include only the selected average types for plotting.
            5. If `include_scans` is True, loads individual scan CSVs from the original folder
               and prepares them for overlay.
            6. Determines the plot title and output HTML filename.
            7. Dynamically sets the y-axis range override based on the selected average types.
            8. Calls `plot_multi_trace_data` from `utils.plotting_utils` to generate the plot.
            9. Stores the path of the generated HTML plot in `self.current_plot_file`.
            10. Logs success or failure messages to the console.

        Outputs of this function:
            None. Generates an HTML plot file and updates `self.current_plot_file`.

        (2025-07-31) Change: Moved from tab_plotting_child_Single.py.
        (2025-08-01) Change: Updated debug_print to debug_log.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function} with include_scans={include_scans}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        if not self.last_applied_math_folder or not os.path.exists(self.last_applied_math_folder):
            self.console_print_func("Error: No 'Applied Math' folder found. Please generate CSVs first. What the hell are you trying to plot?")
            debug_log("No 'Applied Math' folder found.",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        if not self.selected_group_prefix:
            self.console_print_func("Warning: No group selected. Please click on one of the group buttons to select files for averaging. Pick a damn group!")
            debug_log(f"Exiting {current_function} (no selected_group_prefix)",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        self.console_print_func(f"Generating plot for selected series. This may take some time depending on the number and size of scans. Patience, my friend, patience!")

        # Construct the path to the COMPLETE_MATH CSV
        complete_math_csv_pattern = os.path.join(self.last_applied_math_folder, f"COMPLETE_MATH_{self.selected_group_prefix}_MultiFileAverage_*.csv")
        complete_math_csv_files = glob.glob(complete_math_csv_pattern)

        if not complete_math_csv_files:
            self.console_print_func(f"Error: No COMPLETE_MATH CSV found in '{self.last_applied_math_folder}' for group '{self.selected_group_prefix}'. This is a nightmare!")
            debug_log(f"No COMPLETE_MATH CSV found for group '{self.selected_group_prefix}'.",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        # Take the most recent COMPLETE_MATH CSV if multiple exist
        complete_math_csv_path = max(complete_math_csv_files, key=os.path.getctime)
        self.console_print_func(f"Loaded COMPLETE_MATH CSV from: {complete_math_csv_path}")
        debug_log(f"Loaded COMPLETE_MATH CSV from: {complete_math_csv_path}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        try:
            # Read the COMPLETE_MATH CSV. Assuming the first column is Frequency (Hz) and others are data.
            # Use header=True to correctly read the column names (Average, Median, etc.)
            aggregated_df = pd.read_csv(complete_math_csv_path)
            debug_log(f"Loaded aggregated_df columns: {aggregated_df.columns.tolist()}",
                        file=__file__,
                        version=current_version,
                        function=current_function)

            # Filter aggregated_df to include only selected average types for plotting
            selected_avg_types = [
                "Average" if self.app_instance.math_average_var.get() else None,
                "Median" if self.app_instance.math_median_var.get() else None,
                "Range" if self.app_instance.math_range_var.get() else None,
                "Standard Deviation" if self.app_instance.math_standard_deviation_var.get() else None,
                "Variance" if self.app_instance.math_variance_var.get() else None,
                "Power Spectral Density (PSD)" if self.app_instance.math_psd_var.get() else None
            ]
            selected_avg_types = [t for t in selected_avg_types if t is not None]

            # Map the full names back to the column names in the CSV if they are different
            # (e.g., "Standard Deviation" -> "Std Dev")
            column_name_map = {
                "Average": "Average",
                "Median": "Median",
                "Range": "Range",
                "Standard Deviation": "Std Dev",
                "Variance": "Variance",
                "Power Spectral Density (PSD)": "PSD (dBm/Hz)"
            }
            plot_columns = ['Frequency (Hz)'] + [column_name_map[t] for t in selected_avg_types if column_name_map[t] in aggregated_df.columns]

            if not plot_columns or len(plot_columns) < 2: # Need at least Frequency and one data column
                self.console_print_func("Error: No selected average types found in the loaded COMPLETE_MATH CSV for plotting. This is a goddamn travesty!")
                debug_log("No selected average types found in COMPLETE_MATH CSV.",
                            file=__file__,
                            version=current_version,
                            function=current_function)
                return

            aggregated_df_for_plot = aggregated_df[plot_columns].copy()
            debug_log(f"DataFrame for plotting (selected averages) columns: {aggregated_df_for_plot.columns.tolist()}",
                        file=__file__,
                        version=current_version,
                        function=current_function)

            individual_scan_dfs_for_overlay = []
            if include_scans:
                self.console_print_func("Loading individual scans for overlay... This better work!")
                files_to_overlay = self.grouped_csv_files[self.selected_group_prefix]
                for f_path in files_to_overlay:
                    try:
                        scan_df = pd.read_csv(f_path, header=None, names=['Frequency (Hz)', 'Power (dBm)'])
                        scan_name = os.path.splitext(os.path.basename(f_path))[0]
                        individual_scan_dfs_for_overlay.append((scan_df, scan_name))
                        debug_log(f"Loaded individual scan for overlay: {scan_name}",
                                    file=__file__,
                                    version=current_version,
                                    function=current_function)
                    except Exception as e:
                        self.console_print_func(f"Warning: Could not load individual scan {os.path.basename(f_path)} for overlay: {e}. What a pain!")
                        debug_log(f"Could not load individual scan {os.path.basename(f_path)}: {e}",
                                    file=__file__,
                                    version=current_version,
                                    function=current_function)

            # Define historical_dfs_with_names as None before the debug print
            historical_dfs_with_names = None

            plot_title_suffix = ", ".join(selected_avg_types)
            plot_title = f"{self.selected_group_prefix} - {plot_title_suffix} (Multi-File Average)"
            if include_scans:
                plot_title += " with Individual Scans"

            # Determine y_range_max_override based on selected average types
            y_range_max_override_val = 0 # Default for power plots
            # Check if any of the statistical measures are selected
            if any(avg_type in selected_avg_types for avg_type in ["Range", "Standard Deviation", "Variance", "Power Spectral Density (PSD)"]):
                y_range_max_override_val = 30 # Set to 30 for these statistical plots

            # --- DEEPER DEBUGGING FOR plot_multi_trace_data CALL ---
            debug_log(f"DEBUG: Calling plot_multi_trace_data with the following arguments:",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            debug_log(f"  aggregated_df_for_plot (shape): {aggregated_df_for_plot.shape}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            debug_log(f"  plot_title: {plot_title}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            debug_log(f"  include_tv_markers: {self.app_instance.avg_include_tv_markers_var.get()}",
                        file=__file__,
                        version=current_version,
                        function=current_function) # Use app_instance var
            debug_log(f"  include_gov_markers: {self.app_instance.avg_include_gov_markers_var.get()}",
                        file=__file__,
                        version=current_version,
                        function=current_function) # Use app_instance var
            debug_log(f"  include_markers: {self.app_instance.avg_include_markers_var.get()}",
                        file=__file__,
                        version=current_version,
                        function=current_function) # Use app_instance var
            debug_log(f"  include_intermod_markers: {self.app_instance.avg_include_intermod_markers_var.get()}",
                        file=__file__,
                        version=current_version,
                        function=current_function) # NEW
            debug_log(f"  historical_dfs_with_names: {historical_dfs_with_names is not None}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            debug_log(f"  individual_scan_dfs_with_names (count): {len(individual_scan_dfs_for_overlay) if individual_scan_dfs_for_overlay else 0}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            debug_log(f"  output_html_path: {os.path.join(self.last_applied_math_folder, f'{self.selected_group_prefix}_MultiFileAverage_Plot_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html')}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            debug_log(f"  y_range_max_override: {y_range_max_override_val}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            debug_log(f"  scan_data_folder: {self.last_opened_folder}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            # --- END DEEPER DEBUGGING ---

            fig, plot_html_path_return = plot_multi_trace_data(
                aggregated_df_for_plot, # Pass the filtered DataFrame
                plot_title,
                include_tv_markers=self.app_instance.avg_include_tv_markers_var.get(), # Use app_instance var
                include_gov_markers=self.app_instance.avg_include_gov_markers_var.get(), # Use app_instance var
                include_markers=self.app_instance.avg_include_markers_var.get(), # Use app_instance var
                include_intermod_markers=self.app_instance.avg_include_intermod_markers_var.get(), # NEW
                historical_dfs_with_names=None, # No historical overlays for this multi-file average from external folder
                individual_scan_dfs_with_names=individual_scan_dfs_for_overlay if include_scans else None,
                output_html_path=os.path.join(self.last_applied_math_folder, f"{self.selected_group_prefix}_MultiFileAverage_Plot_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html"),
                y_range_min_override=None, # Let the plotting function determine min
                y_range_max_override=y_range_max_override_val, # Pass the dynamically set override
                console_print_func=self.console_print_func,
                # CORRECTED: Pass the original folder where scans were opened for MARKERS.CSV
                scan_data_folder=self.last_opened_folder
            )

            if fig:
                self.current_plot_file = plot_html_path_return
                if self.app_instance.create_html_var.get():
                    self.console_print_func(f"✅ Multi-file averaged plot saved to: {self.current_plot_file}. BOOM! Nailed it!")
                    debug_log(f"Multi-file averaged plot saved to: {self.current_plot_file}",
                                file=__file__,
                                version=current_version,
                                function=current_function)
                else:
                    self.console_print_func("✅ Multi-file averaged plot data processed (HTML not saved as per setting).")
                    debug_log("Plot data processed, HTML not saved.",
                                file=__file__,
                                version=current_version,
                                function=current_function)

                if self.app_instance.open_html_after_complete_var.get() and self.app_instance.create_html_var.get() and plot_html_path_return:
                    _open_plot_in_browser(plot_html_path_return, self.console_print_func)
            else:
                self.console_print_func("🚫 Plotly figure was not generated for multi-file averaged data. Fucking hell, not again!")
                debug_log("Plotly figure not generated for multi-file averaged data.",
                            file=__file__,
                            version=current_version,
                            function=current_function)

        except Exception as e:
            self.console_print_func(f"❌ Error generating plot: {e}. This is a nightmare!")
            debug_log(f"Error generating plot: {e}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    # Removed: _generate_plot_scans_over_time - Moved to tab_plotting_child_3D.py


    def _on_tab_selected(self, event):
        """
        Function Description:
        Callback for when this tab is selected.
        This can be used to refresh data or update UI elements specific to this tab.

        Inputs to this function:
            event (tkinter.Event): The event object that triggered the tab selection.

        Process of this function:
            1. Logs a debug message indicating the tab selection.
            2. Enables/Disables multi-file averaging buttons based on whether a folder has been opened
               and groups of CSV files have been identified.
            3. Enables/Disables the "Open Applied Math Folder" button based on whether a folder
               for applied math exists.

        Outputs of this function:
            None. Updates the state of various GUI buttons.

        (2025-07-31) Change: Moved from tab_plotting_child_Single.py and adapted for AveragingTab. Removed 3D plot button state management.
        (2025-08-01) Change: Updated debug_print to debug_log.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        debug_log("Averaging Tab selected.",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        # Enable/Disable multi-file averaging buttons based on last_opened_folder and grouped_csv_files
        if hasattr(self, 'last_opened_folder') and self.last_opened_folder and \
           hasattr(self, 'grouped_csv_files') and self.grouped_csv_files:
            self.generate_csv_button.config(state=tk.NORMAL)
            self.generate_plot_averages_button.config(state=tk.NORMAL)
            self.generate_plot_averages_with_scan_button.config(state=tk.NORMAL)
            # Removed: self.generate_plot_scans_over_time_button.config(state=tk.NORMAL)
            debug_log("Multi-file averaging buttons enabled (folder and groups exist).",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        else:
            self.generate_csv_button.config(state=tk.DISABLED)
            self.generate_plot_averages_button.config(state=tk.DISABLED)
            self.generate_plot_averages_with_scan_button.config(state=tk.DISABLED)
            # Removed: self.generate_plot_scans_over_time_button.config(state=tk.DISABLED)
            debug_log("Multi-file averaging buttons disabled (no folder or groups).",
                        file=__file__,
                        version=current_version,
                        function=current_function)

        # Enable/Disable "Open Applied Math Folder" button
        if self.last_applied_math_folder and os.path.exists(self.last_applied_math_folder):
            self.open_applied_math_folder_button.config(state=tk.NORMAL)
            debug_log("Open Applied Math Folder button enabled.",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        else:
            self.open_applied_math_folder_button.config(state=tk.DISABLED)
            debug_log("Open Applied Math Folder button disabled.",
                        file=__file__,
                        version=current_version,
                        function=current_function)

        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


#####################################
### File: OPEN-AIR\Plotting\utils_plotting.py
#####################################
# utils/utils_plotting.py
#
# This module provides functions for generating interactive plots of spectrum analyzer data
# using Plotly. It supports plotting single scan traces, as well as aggregated data
# (average, median, range, standard deviation, variance, PSD) with historical overlays.
# It also includes functionalities for adding frequency band markers (TV, Government)
# and saving plots to HTML files.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250810.140800.1 (FIXED: Removed top-level import of frequency_bands.py constants to resolve startup error. The constants will now be passed to the functions that need them.)

current_version = "20250810.140800.1" # this variable should always be defined below the header to make the debugging better
current_version_hash = 20250810 * 140800 * 1 # Example hash, adjust as needed

import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import webbrowser
import os
import re # Added import for regular expressions
import csv # New: Import csv for MARKERS.CSV
import inspect # Import inspect for debug_log

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log

# The `frequency_bands` constants are now passed to the functions that need them.
# The previous `try...except` block has been removed, resolving the startup error.

def _open_plot_in_browser(html_file_path, console_print_func):
    """
    Function Description:
    Opens the generated HTML plot in the default web browser.

    Inputs to this function:
        html_file_path (str): The full path to the HTML plot file.
        console_print_func (function): Function to print messages to the GUI console.

    Process of this function:
        1. Checks if the HTML file exists.
        2. If it exists, uses `webbrowser.open_new_tab` to open it.
        3. Logs success or failure to the console and debug log.

    Outputs of this function:
        None. Opens a web browser tab.

    (2025-07-31) Change: Moved from main_app.py to utils_plotting.py.
    (2025-08-01) Change: Updated debug_print to debug_log.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Attempting to open plot in browser: {html_file_path}",
                file=__file__,
                version=current_version,
                function=current_function)
    if os.path.exists(html_file_path):
        try:
            webbrowser.open_new_tab(html_file_path)
            console_print_func(f"✅ Plot opened in browser: {os.path.basename(html_file_path)}")
            debug_log(f"Plot opened successfully: {html_file_path}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        except Exception as e:
            console_print_func(f"❌ Error opening plot in browser: {e}. This is a goddamn mess!")
            debug_log(f"Error opening plot {html_file_path} in browser: {e}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
    else:
        console_print_func(f"❌ Error: Plot file not found at {html_file_path}. What the hell?!")
        debug_log(f"Plot file not found: {html_file_path}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


def _add_band_markers(fig, markers_dict, line_color, line_dash, band_name_suffix, MHZ_TO_HZ, console_print_func):
    """
    Function Description:
    Adds rectangular shape annotations to a Plotly figure to represent frequency bands.

    Inputs to this function:
        fig (go.Figure): The Plotly figure object to which markers will be added.
        markers_dict (dict): A dictionary where keys are band names (str) and values are
                             lists of [min_freq_MHz, max_freq_MHz].
        line_color (str): The color for the band outlines (e.g., 'rgba(255, 0, 0, 0.5)').
        line_dash (str): The dash style for the band outlines (e.g., 'dot', 'dash').
        band_name_suffix (str): A suffix to add to the band names for legend clarity (e.g., " (TV)").
        MHZ_TO_HZ (float): The conversion factor from MHz to Hz.
        console_print_func (function): Function to print messages to the GUI console.

    Outputs of this function:
        Modifies the `fig` object by adding shapes.

    (2025-07-31) Change: Moved from main_app.py to utils_plotting.py.
    (2025-08-01) Change: Updated debug_print to debug_log.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Adding band markers with suffix '{band_name_suffix}'...",
                file=__file__,
                version=current_version,
                function=current_function)
    for band_name, freq_range_mhz in markers_dict.items():
        min_freq_hz = freq_range_mhz[0] * MHZ_TO_HZ
        max_freq_hz = freq_range_mhz[1] * MHZ_TO_HZ
        fig.add_shape(
            type="rect",
            xref="x", yref="paper",
            x0=min_freq_hz, y0=0, x1=max_freq_hz, y1=1,
            line=dict(color=line_color, width=1, dash=line_dash),
            fillcolor=line_color.replace('0.5', '0.1'), # Lighter fill
            layer="below",
            name=f"{band_name}{band_name_suffix}",
            # Add a legend group to show these as distinct items in the legend
            # but still allow toggling them together if desired by Plotly's default behavior
            legendgroup=f"{band_name_suffix.strip()}_bands",
            showlegend=True # Ensure they appear in the legend
        )
        # Add a dummy trace for the legend entry if the shape's name doesn't show up correctly
        fig.add_trace(go.Scatter(
            x=[None], y=[None],
            mode='lines',
            line=dict(color=line_color, width=1, dash=line_dash),
            name=f"{band_name}{band_name_suffix}",
            legendgroup=f"{band_name_suffix.strip()}_bands",
            showlegend=True
        ))
        debug_log(f"Added band marker: {band_name}{band_name_suffix} ({min_freq_hz/MHZ_TO_HZ:.2f}-{max_freq_hz/MHZ_TO_HZ:.2f} MHz)",
                    file=__file__,
                    version=current_version,
                    function=current_function)
    debug_log(f"Finished adding band markers with suffix '{band_name_suffix}'.",
                file=__file__,
                version=current_version,
                function=current_function)


def _add_markers_from_csv(fig, markers_csv_path, MHZ_TO_HZ, console_print_func):
    """
    Function Description:
    Reads markers from a specified CSV file and adds vertical line annotations to a Plotly figure.
    The CSV is expected to have 'FREQ' and 'NAME' columns.

    Inputs to this function:
        fig (go.Figure): The Plotly figure object to which markers will be added.
        markers_csv_path (str): The path to the CSV file containing marker data.
        MHZ_TO_HZ (float): The conversion factor from MHz to Hz.
        console_print_func (function): Function to print messages to the GUI console.

    Outputs of this function:
        Modifies the `fig` object by adding vertical lines and text annotations.

    (2025-07-31) Change: Moved from main_app.py to utils_plotting.py.
    (2025-08-01) Change: Updated debug_print to debug_log.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Attempting to add markers from CSV: {markers_csv_path}",
                file=__file__,
                version=current_version,
                function=current_function)
    if not os.path.exists(markers_csv_path):
        console_print_func(f"⚠️ Warning: Markers CSV file not found at {markers_csv_path}. Cannot add markers. What the hell?!")
        debug_log(f"Markers CSV not found: {markers_csv_path}. Fucking useless!",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        return

    try:
        df_markers = pd.read_csv(markers_csv_path)
        if 'FREQ' not in df_markers.columns or 'NAME' not in df_markers.columns:
            console_print_func(f"❌ Error: Markers CSV '{markers_csv_path}' must contain 'FREQ' and 'NAME' columns. This is a goddamn mess!")
            debug_log(f"Markers CSV '{markers_csv_path}' missing required columns.",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        for index, row in df_markers.iterrows():
            freq_hz = row['FREQ']
            marker_name = row['NAME']
            fig.add_vline(x=freq_hz, line_width=1, line_dash="dash", line_color="purple",
                          annotation_text=marker_name, annotation_position="top right")
            debug_log(f"Added marker from CSV: {marker_name} at {freq_hz/MHZ_TO_HZ:.3f} MHz",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        console_print_func(f"✅ Added markers from {os.path.basename(markers_csv_path)}.")
    except Exception as e:
        console_print_func(f"❌ Error reading or adding markers from CSV {os.path.basename(markers_csv_path)}: {e}. This CSV is a stubborn bastard!")
        debug_log(f"Error reading or adding markers from CSV {markers_csv_path}: {e}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


def _add_intermodulation_markers(fig, intermod_csv_path, MHZ_TO_HZ, console_print_func):
    """
    Function Description:
    Reads intermodulation product frequencies from a specified CSV file and adds
    vertical line annotations to a Plotly figure. The CSV is expected to have
    a 'Frequency_MHz' column.

    Inputs to this function:
        fig (go.Figure): The Plotly figure object to which markers will be added.
        intermod_csv_path (str): The path to the CSV file containing intermodulation data.
        MHZ_TO_HZ (float): The conversion factor from MHz to Hz.
        console_print_func (function): Function to print messages to the GUI console.

    Outputs of this function:
        Modifies the `fig` object by adding vertical lines and text annotations.

    (2025-08-01) Change: New function to add intermodulation markers.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Attempting to add intermodulation markers from CSV: {intermod_csv_path}",
                file=__file__,
                version=current_version,
                function=current_function)
    if not os.path.exists(intermod_csv_path):
        console_print_func(f"⚠️ Warning: Intermodulation CSV file not found at {intermod_csv_path}. Cannot add IMD markers. What the hell?!")
        debug_log(f"Intermodulation CSV not found: {intermod_csv_path}. Fucking useless!",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        return

    try:
        df_intermod = pd.read_csv(intermod_csv_path)
        if 'Frequency_MHz' not in df_intermod.columns:
            console_print_func(f"❌ Error: Intermodulation CSV '{intermod_csv_path}' must contain 'Frequency_MHz' column. This is a goddamn mess!")
            debug_log(f"Intermodulation CSV '{intermod_csv_path}' missing required 'Frequency_MHz' column.",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        for index, row in df_intermod.iterrows():
            freq_mhz = row['Frequency_MHz']
            freq_hz = freq_mhz * MHZ_TO_HZ
            # Create a descriptive name for the IMD marker
            imd_name = f"IMD {row.get('Order', '')} ({row.get('Type', '')}) from {row.get('Parent_Freq1', 'N/A')} & {row.get('Parent_Freq2', 'N/A')} MHz"
            fig.add_vline(x=freq_hz, line_width=1, line_dash="solid", line_color="red",
                          annotation_text=f"IMD {freq_mhz:.3f} MHz", annotation_position="bottom right")
            debug_log(f"Added intermodulation marker: {imd_name} at {freq_mhz:.3f} MHz",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        console_print_func(f"✅ Added intermodulation markers from {os.path.basename(intermod_csv_path)}.")
    except Exception as e:
        console_print_func(f"❌ Error reading or adding intermodulation markers from CSV {os.path.basename(intermod_csv_path)}: {e}. This IMD CSV is a stubborn bastard!")
        debug_log(f"Error reading or adding intermodulation markers from CSV {intermod_csv_path}: {e}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


def _create_spectrum_plot(data_traces, plot_title, include_tv_markers, include_gov_markers,
                          include_markers, include_intermod_markers, output_html_path,
                          y_range_min_override, y_range_max_override, console_print_func,
                          scan_data_folder, MHZ_TO_HZ, TV_BAND_MARKERS_MHZ, GOVERNMENT_BAND_MARKERS_MHZ,
                          DEFAULT_MARKERS_FILE, DEFAULT_INTERMOD_FILE):
    """
    Function Description:
    Generates a Plotly HTML interactive plot for spectrum analyzer data.
    This is a core plotting function that can handle multiple traces (e.g., current, historical, averages).
    It includes options for adding TV, Government, and custom markers.

    Inputs to this function:
        data_traces (list of dict): A list where each dict represents a trace to plot, e.g.:
                                    `{'df': DataFrame, 'name': 'Trace Name', 'color': 'blue', 'width': 2, 'dash': 'solid', 'show_legend': True, 'y_column_name': 'Power (dBm)'}`
        plot_title (str): The title of the plot.
        include_tv_markers (bool): If True, TV band markers are added.
        include_gov_markers (bool): If True, Government band markers are added.
        include_markers (bool): If True, custom markers from MARKERS.csv are added.
        include_intermod_markers (bool): If True, intermodulation markers from INTERMOD.csv are added.
        output_html_path (str or None): If a string, saves the plot to this HTML file. If None, does not save.
        y_range_min_override (float or None): Optional minimum Y-axis value.
        y_range_max_override (float or None): Optional maximum Y-axis value.
        console_print_func (function): Function to print messages to the GUI console.
        scan_data_folder (str): The folder where scan data (and potentially MARKERS.csv/INTERMOD.csv) resides.
        MHZ_TO_HZ (float): The conversion factor from MHz to Hz.
        TV_BAND_MARKERS_MHZ (dict): Dictionary of TV band markers.
        GOVERNMENT_BAND_MARKERS_MHZ (dict): Dictionary of Government band markers.
        DEFAULT_MARKERS_FILE (str): Default filename for markers CSV.
        DEFAULT_INTERMOD_FILE (str): Default filename for intermodulation CSV.

    Process of this function:
        1. Initializes an empty Plotly figure.
        2. Adds each trace from `data_traces` to the figure.
        3. Configures the layout (title, axes labels, hover mode).
        4. Conditionally adds TV, Government, custom, and intermodulation band markers.
        5. Sets Y-axis range if overrides are provided.
        6. If `output_html_path` is provided, saves the figure to an HTML file.
        7. Logs debug information throughout the process.

    Outputs of this function:
        tuple: (go.Figure, str or None) - The Plotly figure object and the path to the saved HTML file (or None).

    (2025-07-31) Change: Consolidated plotting logic from plot_single_scan_data and plot_multi_trace_data.
    (2025-07-31) Change: Added y_range_min_override and y_range_max_override parameters.
    (2025-08-01) Change: Added include_intermod_markers parameter and call to _add_intermodulation_markers.
    (2025-08-01) Change: Updated debug_print to debug_log.
    (2025-08-10) Change: Updated function signature to accept constants as arguments.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Creating spectrum plot: '{plot_title}'",
                file=__file__,
                version=current_version,
                function=current_function)

    fig = go.Figure()

    for trace_data in data_traces:
        df = trace_data['df']
        name = trace_data['name']
        color = trace_data['color']
        width = trace_data['width']
        dash = trace_data['dash']
        show_legend = trace_data['show_legend']
        y_column_name = trace_data['y_column_name'] # Use this to select the Y-axis column

        if df.empty or 'Frequency (Hz)' not in df.columns or y_column_name not in df.columns:
            debug_log(f"Skipping trace '{name}': Invalid DataFrame or missing columns. What a bummer!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            continue

        fig.add_trace(go.Scatter(
            x=df['Frequency (Hz)'],
            y=df[y_column_name],
            mode='lines',
            name=name,
            line=dict(color=color, width=width, dash=dash),
            showlegend=show_legend
        ))
        debug_log(f"Added trace: '{name}' with Y-column '{y_column_name}'",
                    file=__file__,
                    version=current_version,
                    function=current_function)

    fig.update_layout(
        title={
            'text': plot_title,
            'y':0.9,
            'x':0.5,
            'xanchor': 'center',
            'yanchor': 'top'
        },
        xaxis_title="Frequency (Hz)",
        yaxis_title="Power (dBm)", # Default Y-axis title
        hovermode="x unified",
        template="plotly_dark",
        margin=dict(l=50, r=50, t=80, b=50),
        height=700,
        width=1000,
        legend=dict(
            orientation="h",
            yanchor="bottom",
            y=1.02,
            xanchor="right",
            x=1
        )
    )
    debug_log("Plot layout updated.",
                file=__file__,
                version=current_version,
                function=current_function)

    # Conditionally add markers
    if include_tv_markers:
        _add_band_markers(fig, TV_BAND_MARKERS_MHZ, 'rgba(0, 255, 0, 0.5)', 'dot', ' (TV)', MHZ_TO_HZ, console_print_func)
    if include_gov_markers:
        _add_band_markers(fig, GOVERNMENT_BAND_MARKERS_MHZ, 'rgba(255, 165, 0, 0.5)', 'dash', ' (Gov)', MHZ_TO_HZ, console_print_func)
    if include_markers and scan_data_folder:
        markers_csv_path = os.path.join(scan_data_folder, DEFAULT_MARKERS_FILE)
        _add_markers_from_csv(fig, markers_csv_path, MHZ_TO_HZ, console_print_func)
    if include_intermod_markers and scan_data_folder:
        intermod_csv_path = os.path.join(scan_data_folder, DEFAULT_INTERMOD_FILE)
        _add_intermodulation_markers(fig, intermod_csv_path, MHZ_TO_HZ, console_print_func)


    # Apply Y-axis range override if provided
    if y_range_min_override is not None and y_range_max_override is not None:
        fig.update_yaxes(range=[y_range_min_override, y_range_max_override])
        debug_log(f"Y-axis range overridden to: [{y_range_min_override}, {y_range_max_override}]",
                    file=__file__,
                    version=current_version,
                    function=current_function)
    elif y_range_max_override is not None: # Only max override
        fig.update_yaxes(range=[fig.layout.yaxis.range[0], y_range_max_override])
        debug_log(f"Y-axis max range overridden to: {y_range_max_override}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
    elif y_range_min_override is not None: # Only min override
        fig.update_yaxes(range=[y_range_min_override, fig.layout.yaxis.range[1]])
        debug_log(f"Y-axis min range overridden to: {y_range_min_override}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    plot_html_path_return = None
    if output_html_path:
        output_dir = os.path.dirname(output_html_path)
        if output_dir and not os.path.exists(output_dir):
            os.makedirs(output_dir)
            debug_log(f"Created output directory for plot: {output_html_path}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        debug_log(f"Saving plot to: {output_html_path}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        fig.write_html(output_html_path, auto_open=False)
        plot_html_path_return = output_html_path
        debug_log(f"Plot saved to: {output_html_path}. Fucking brilliant!",
                    file=__file__,
                    version=current_version,
                    function=current_function)
    else:
        debug_log("Output HTML path not provided, skipping saving plot to file. What a waste!",
                    file=__file__,
                    version=current_version,
                    function=current_function)

    debug_log(f"Exiting {current_function}",
                file=__file__,
                version=current_version,
                function=current_function)
    return fig, plot_html_path_return


def plot_single_scan_data(df_scan, plot_title, include_tv_markers, include_gov_markers,
                          include_markers, include_intermod_markers, output_html_path, console_print_func,
                          scan_data_folder, MHZ_TO_HZ, TV_BAND_MARKERS_MHZ, GOVERNMENT_BAND_MARKERS_MHZ,
                          DEFAULT_MARKERS_FILE, DEFAULT_INTERMOD_FILE):
    """
    Function Description:
    Plots a single spectrum analyzer scan. This is a wrapper around `_create_spectrum_plot`.

    Inputs to this function:
        df_scan (pd.DataFrame): DataFrame containing 'Frequency (Hz)' and 'Power (dBm)'.
        plot_title (str): The title for the plot.
        include_tv_markers (bool): If True, TV band markers are added.
        include_gov_markers (bool): If True, Government band markers are added.
        include_markers (bool): If True, custom markers from MARKERS.csv are added.
        include_intermod_markers (bool): If True, intermodulation markers from INTERMOD.csv are added.
        output_html_path (str or None): If a string, saves the plot to this HTML file. If None, does not save.
        console_print_func (function): Function to print messages to the GUI console.
        scan_data_folder (str): The folder where scan data (and potentially MARKERS.csv/INTERMOD.csv) resides.
        MHZ_TO_HZ (float): The conversion factor from MHz to Hz.
        TV_BAND_MARKERS_MHZ (dict): Dictionary of TV band markers.
        GOVERNMENT_BAND_MARKERS_MHZ (dict): Dictionary of Government band markers.
        DEFAULT_MARKERS_FILE (str): Default filename for markers CSV.
        DEFAULT_INTERMOD_FILE (str): Default filename for intermodulation CSV.

    Outputs of this function:
        tuple: (go.Figure, str or None) - The Plotly figure object and the path to the saved HTML file (or None).

    (2025-07-31) Change: Simplified to be a wrapper for _create_spectrum_plot.
    (2025-08-01) Change: Added include_intermod_markers parameter.
    (2025-08-01) Change: Updated debug_print to debug_log.
    (2025-08-10) Change: Updated function signature to accept constants as arguments.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Plotting single scan data for '{plot_title}'...",
                file=__file__,
                version=current_version,
                function=current_function)

    data_traces = [{
        'df': df_scan,
        'name': 'Current Scan',
        'color': 'blue',
        'width': 2,
        'dash': 'solid',
        'show_legend': True,
        'y_column_name': 'Power (dBm)'
    }]

    fig, html_path = _create_spectrum_plot(
        data_traces,
        plot_title,
        include_tv_markers,
        include_gov_markers,
        include_markers,
        include_intermod_markers, # Pass the new parameter
        output_html_path,
        y_range_min_override=None,
        y_range_max_override=None,
        console_print_func=console_print_func,
        scan_data_folder=scan_data_folder,
        MHZ_TO_HZ=MHZ_TO_HZ,
        TV_BAND_MARKERS_MHZ=TV_BAND_MARKERS_MHZ,
        GOVERNMENT_BAND_MARKERS_MHZ=GOVERNMENT_BAND_MARKERS_MHZ,
        DEFAULT_MARKERS_FILE=DEFAULT_MARKERS_FILE,
        DEFAULT_INTERMOD_FILE=DEFAULT_INTERMOD_FILE
    )
    debug_log(f"Finished plotting single scan data for '{plot_title}'.",
                file=__file__,
                version=current_version,
                function=current_function)
    return fig, html_path


def plot_multi_trace_data(df_aggregated, plot_title, include_tv_markers, include_gov_markers,
                          include_markers, include_intermod_markers, historical_dfs_with_names,
                          individual_scan_dfs_with_names, output_html_path,
                          y_range_min_override, y_range_max_override, console_print_func,
                          scan_data_folder, MHZ_TO_HZ, TV_BAND_MARKERS_MHZ, GOVERNMENT_BAND_MARKERS_MHZ,
                          DEFAULT_MARKERS_FILE, DEFAULT_INTERMOD_FILE):
    """
    Function Description:
    Plots multiple traces on a single Plotly graph, including an aggregated trace (e.g., average)
    and optional historical or individual scan overlays. This is a wrapper around `_create_spectrum_plot`.

    Inputs to this function:
        df_aggregated (pd.DataFrame): DataFrame for the main aggregated trace (e.g., current average).
                                      Expected to have 'Frequency (Hz)' and other calculated columns.
        plot_title (str): The title for the plot.
        include_tv_markers (bool): If True, TV band markers are added.
        include_gov_markers (bool): If True, Government band markers are added.
        include_markers (bool): If True, custom markers from MARKERS.csv are added.
        include_intermod_markers (bool): If True, intermodulation markers from INTERMOD.csv are added.
        historical_dfs_with_names (list of tuples or None): List of (DataFrame, name) for historical overlays.
                                                            Each DataFrame should have 'Frequency (Hz)' and 'Power (dBm)'.
        individual_scan_dfs_with_names (list of tuples or None): List of (DataFrame, name) for individual scan overlays.
                                                                  Each DataFrame should have 'Frequency (Hz)' and 'Power (dBm)'.
        output_html_path (str or None): If a string, saves the plot to this HTML file. If None, does not save.
        y_range_min_override (float or None): Optional minimum Y-axis value.
        y_range_max_override (float or None): Optional maximum Y-axis value.
        console_print_func (function): Function to print messages to the GUI console.
        scan_data_folder (str): The folder where scan data (and potentially MARKERS.csv/INTERMOD.csv) resides.
        MHZ_TO_HZ (float): The conversion factor from MHz to Hz.
        TV_BAND_MARKERS_MHZ (dict): Dictionary of TV band markers.
        GOVERNMENT_BAND_MARKERS_MHZ (dict): Dictionary of Government band markers.
        DEFAULT_MARKERS_FILE (str): Default filename for markers CSV.
        DEFAULT_INTERMOD_FILE (str): Default filename for intermodulation CSV.

    Outputs of this function:
        tuple: (go.Figure, str or None) - The Plotly figure object and the path to the saved HTML file (or None).

    (2025-07-31) Change: Consolidated plotting logic into _create_spectrum_plot.
    (2025-07-31) Change: Added y_range_min_override and y_range_max_override parameters.
    (2025-08-01) Change: Added include_intermod_markers parameter.
    (2025-08-01) Change: Updated debug_print to debug_log.
    (2025-08-10) Change: Updated function signature to accept constants as arguments.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Plotting multi-trace data for '{plot_title}'...",
                file=__file__,
                version=current_version,
                function=current_function)

    data_traces = []

    # Add the main aggregated trace (e.g., Average, Median, etc.)
    # The y_column_name for the main aggregated trace will be the first data column after Frequency (Hz)
    # This assumes df_aggregated columns are ['Frequency (Hz)', 'Average', 'Median', ...]
    if not df_aggregated.empty and 'Frequency (Hz)' in df_aggregated.columns and len(df_aggregated.columns) > 1:
        # Get all columns except 'Frequency (Hz)' as y-axis columns
        y_cols = [col for col in df_aggregated.columns if col != 'Frequency (Hz)']
        for y_col in y_cols:
            data_traces.append({
                'df': df_aggregated,
                'name': y_col, # Use the column name as the trace name
                'color': px.colors.qualitative.Plotly[y_cols.index(y_col) % len(px.colors.qualitative.Plotly)], # Cycle through colors
                'width': 3,
                'dash': 'solid',
                'show_legend': True,
                'y_column_name': y_col # Specify the column to use for Y-axis
            })
        debug_log(f"Added aggregated trace(s) from columns: {y_cols}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
    else:
        debug_log("Aggregated DataFrame is empty or invalid. Skipping aggregated trace. Fucking useless!",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    # Add historical overlays if provided
    if historical_dfs_with_names:
        debug_log(f"Adding {len(historical_dfs_with_names)} historical overlays.",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        for i, (df_hist, name) in enumerate(historical_dfs_with_names):
            if not df_hist.empty and 'Frequency (Hz)' in df_hist.columns and 'Power (dBm)' in df_hist.columns:
                data_traces.append({
                    'df': df_hist,
                    'name': f'{name} (Historical)',
                    'color': f'rgba(100, 100, 100, {max(0, 0.8 - i * 0.1)})', # Faded gray for historical
                    'width': 1,
                    'dash': 'dot',
                    'show_legend': True,
                    'y_column_name': 'Power (dBm)' # Historical scans will have 'Power (dBm)'
                })
            else:
                debug_log(f"Skipping historical DF '{name}': Invalid DataFrame. What a pain!",
                            file=__file__,
                            version=current_version,
                            function=current_function)

    # Add individual scan overlays if provided
    if individual_scan_dfs_with_names:
        debug_log(f"Adding {len(individual_scan_dfs_with_names)} individual scan overlays.",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        for i, (df_scan_plot, name) in enumerate(individual_scan_dfs_with_names):
            debug_log(f"Preparing individual scan overlay: {name}",
                        file=__file__,
                        version=current_version,
                        function=current_function)

            if not df_scan_plot.empty and 'Frequency (Hz)' in df_scan_plot.columns and 'Power (dBm)' in df_scan_plot.columns:
                data_traces.append({
                    'df': df_scan_plot,
                    'name': f'{name} (Scan)',
                    'color': f'rgba(0, 200, 255, {max(0, 0.5 - i * 0.05)})', # Clamped alpha value
                    'width': 1,
                    'dash': 'dot',
                    'show_legend': True,
                    'y_column_name': 'Power (dBm)' # Individual scans will have 'Power (dBm)'
                })
            else:
                debug_log(f"Skipping individual scan DF '{name}': Invalid DataFrame. Fucking useless!",
                            file=__file__,
                            version=current_version,
                            function=current_function)

    if not data_traces:
        console_print_func("No valid data to plot in multi-trace function. This is a goddamn mess!")
        debug_log("No valid data traces prepared for multi-trace plot.",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        return None, None

    return _create_spectrum_plot(
        data_traces,
        plot_title,
        include_tv_markers,
        include_gov_markers,
        include_markers,
        include_intermod_markers, # Pass the new parameter
        output_html_path,
        y_range_min_override,
        y_range_max_override,
        console_print_func,
        scan_data_folder,
        MHZ_TO_HZ=MHZ_TO_HZ,
        TV_BAND_MARKERS_MHZ=TV_BAND_MARKERS_MHZ,
        GOVERNMENT_BAND_MARKERS_MHZ=GOVERNMENT_BAND_MARKERS_MHZ,
        DEFAULT_MARKERS_FILE=DEFAULT_MARKERS_FILE,
        DEFAULT_INTERMOD_FILE=DEFAULT_INTERMOD_FILE
    )


#####################################
### File: OPEN-AIR\Plotting\utils_plotting_scans_over_time.py
#####################################
# utils/utils_plotting_scans_over_time.py
#
# This module provides a function for generating an interactive 3D Plotly plot
# of spectrum analyzer scan data over time. It visualizes frequency, amplitude,
# and the time of each scan, with amplitude color-coded based on user-defined
# thresholds.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250801.2245.1 (Refactored debug_print to use debug_log and console_log.)

current_version = "20250801.2245.1" # this variable should always be defined below the header to make the debugging better
current_version_hash = 20250801 * 2245 * 1 # Example hash, adjust as needed

import pandas as pd
import plotly.graph_objects as go
import plotly.colors as pcolors # For color scales
import webbrowser
import os
import re
import inspect
from datetime import datetime

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log

# Import constants from frequency_bands.py - CORRECTED PATH
try:
    from ref.ref_frequency_bands import MHZ_TO_HZ
except ImportError:
    debug_log("Error: frequency_bands.py not found in 'ref' or current directory. Using default MHZ_TO_HZ. This is a goddamn mess!",
                file=__file__,
                version=current_version,
                function=inspect.currentframe().f_code.co_name)
    MHZ_TO_HZ = 1_000_000 # Default fallback


def plot_Scans_over_time(grouped_csv_files, selected_group_prefix, output_folder,
                         amplitude_threshold_dbm, console_print_func):
    """
    Function Description:
    Generates an interactive 3D Plotly plot of spectrum analyzer scan data over time.
    It visualizes frequency, amplitude, and the time of each scan, with amplitude
    color-coded based on a user-defined threshold.

    Inputs to this function:
        grouped_csv_files (dict): A dictionary where keys are group prefixes (str) and values are
                                  lists of full file paths to CSV scan data.
        selected_group_prefix (str): The prefix of the group to be plotted.
        output_folder (str): The directory where the HTML plot file will be saved.
        amplitude_threshold_dbm (float): The amplitude threshold (in dBm) for color-coding.
        console_print_func (function): Function to print messages to the GUI console.

    Process of this function:
        1. Checks if the selected group exists and contains files.
        2. Initializes lists to store frequency, power, and time data.
        3. Iterates through each CSV file in the selected group:
           a. Reads the CSV into a Pandas DataFrame, assuming 'Frequency (Hz)' and 'Power (dBm)' columns.
           b. Extracts frequency, power, and a timestamp for each scan.
           c. Appends the data to the respective lists.
        4. Creates a Pandas DataFrame from the collected data (Frequency, Power, Time).
        5. Creates a 3D scatter plot using `plotly.graph_objects.Scatter3d`.
           - X-axis: Frequency (Hz)
           - Y-axis: Time (numerical representation for plotting)
           - Z-axis: Power (dBm)
           - Color: Based on `Power (dBm)` relative to `amplitude_threshold_dbm`.
        6. Configures the 3D plot layout (title, axis labels, camera settings).
        7. Saves the figure to an HTML file in the specified `output_folder`.
        8. Logs progress and errors to the console and debug log.

    Outputs of this function:
        tuple: (go.Figure, str or None) - The Plotly figure object and the path to the saved HTML file (or None).

    (2025-07-31) Change: Initial implementation for 3D plotting.
    (2025-08-01) Change: Updated debug_print to debug_log.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Entering {current_function} for group '{selected_group_prefix}' with threshold {amplitude_threshold_dbm} dBm.",
                file=__file__,
                version=current_version,
                function=current_function)

    files_to_plot = grouped_csv_files.get(selected_group_prefix)
    if not files_to_plot:
        console_print_func(f"Error: No files found for group '{selected_group_prefix}'. What the hell am I supposed to plot?!")
        debug_log(f"No files found for group '{selected_group_prefix}'. Fucking useless!",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        return None, None

    all_frequencies = []
    all_powers = []
    all_times = []
    time_labels = [] # To store human-readable time labels for hover text

    # Sort files by creation time to ensure correct time progression
    files_to_plot.sort(key=os.path.getctime)

    start_time = None

    for file_path in files_to_plot:
        try:
            df = pd.read_csv(file_path, header=None, names=['Frequency (Hz)', 'Power (dBm)'])
            # Extract timestamp from filename or file modification time
            # Assuming filename format like "PREFIX_YYYYMMDD_HHMMSS.csv" or similar
            filename = os.path.basename(file_path)
            match = re.search(r'(\d{8}_\d{6})', filename)
            if match:
                timestamp_str = match.group(1)
                scan_datetime = datetime.strptime(timestamp_str, '%Y%m%d_%H%M%S')
            else:
                # Fallback to file modification time if no timestamp in filename
                scan_datetime = datetime.fromtimestamp(os.path.getmtime(file_path))
                debug_log(f"No timestamp in filename for {filename}. Using file modification time. This is a bit of a mess!",
                            file=__file__,
                            version=current_version,
                            function=current_function)

            if start_time is None:
                start_time = scan_datetime

            # Calculate time difference in seconds from the first scan
            time_diff_seconds = (scan_datetime - start_time).total_seconds()

            all_frequencies.extend(df['Frequency (Hz)'].tolist())
            all_powers.extend(df['Power (dBm)'].tolist())
            all_times.extend([time_diff_seconds] * len(df))
            time_labels.extend([scan_datetime.strftime('%Y-%m-%d %H:%M:%S')] * len(df))

            debug_log(f"Processed file: {filename}, Scan Time: {scan_datetime.strftime('%H:%M:%S')}, Time Offset: {time_diff_seconds:.2f}s",
                        file=__file__,
                        version=current_version,
                        function=current_function)

        except Exception as e:
            console_print_func(f"❌ Error processing file {os.path.basename(file_path)} for 3D plot: {e}. This file is a stubborn bastard!")
            debug_log(f"Error processing {file_path} for 3D plot: {e}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            continue

    if not all_frequencies:
        console_print_func("No valid scan data found to create 3D plot. This is utterly useless!")
        debug_log("No valid scan data for 3D plot.",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        return None, None

    df_3d = pd.DataFrame({
        'Frequency (Hz)': all_frequencies,
        'Power (dBm)': all_powers,
        'Time (s)': all_times,
        'Time Label': time_labels
    })

    # Create a color scale based on the amplitude threshold
    colorscale = [
        [0, 'blue'], # Below threshold
        [max(0.0, (amplitude_threshold_dbm + 100) / 100), 'green'], # Around threshold (adjust 100 based on expected power range)
        [max(0.0, (amplitude_threshold_dbm + 50) / 100), 'yellow'],
        [max(0.0, (amplitude_threshold_dbm + 20) / 100), 'orange'],
        [1, 'red'] # Above threshold
    ]
    # Normalize the threshold to 0-1 range for colorscale mapping. Assuming power range -100 to 0 dBm
    # This might need adjustment based on typical power ranges.
    normalized_threshold = (amplitude_threshold_dbm + 100) / 100.0
    colorscale = [
        [0, 'blue'],
        [max(0.0, normalized_threshold - 0.05), 'green'], # Slightly below threshold
        [normalized_threshold, 'yellow'], # At threshold
        [min(1.0, normalized_threshold + 0.05), 'red'], # Slightly above threshold
        [1, 'darkred'] # Significantly above threshold
    ]
    # Ensure the colorscale points are ordered correctly
    colorscale.sort(key=lambda x: x[0])
    debug_log(f"Generated colorscale: {colorscale}",
                file=__file__,
                version=current_version,
                function=current_function)


    # Create the 3D scatter plot
    fig = go.Figure(data=[go.Scatter3d(
        x=df_3d['Frequency (Hz)'],
        y=df_3d['Time (s)'],
        z=df_3d['Power (dBm)'],
        mode='markers',
        marker=dict(
            size=3,
            color=df_3d['Power (dBm)'], # Color by power
            colorscale=colorscale, # Apply custom colorscale
            colorbar=dict(title='Power (dBm)'),
            cmin=-100, # Adjust based on expected min power
            cmax=0 # Adjust based on expected max power
        ),
        hoverinfo='text',
        hovertext=[
            f"Freq: {f/MHZ_TO_HZ:.3f} MHz<br>Power: {p:.2f} dBm<br>Time: {t_label}"
            for f, p, t_label in zip(df_3d['Frequency (Hz)'], df_3d['Power (dBm)'], df_3d['Time Label'])
        ]
    )])
    debug_log("Plotly 3D Scatter3d trace created.",
                file=__file__,
                version=current_version,
                function=current_function)

    # Update layout
    fig.update_layout(
        title={
            'text': f"3D Scans Over Time: {selected_group_prefix} (Threshold: {amplitude_threshold_dbm} dBm)",
            'y':0.9,
            'x':0.5,
            'xanchor': 'center',
            'yanchor': 'top'
        },
        scene=dict(
            xaxis_title='Frequency (Hz)',
            yaxis_title='Time (seconds from start)',
            zaxis_title='Power (dBm)',
            xaxis=dict(
                type='linear', # Can also be 'log' if frequencies span wide range
                tickformat=".3s", # Format ticks nicely
                tickangle=-45,
                nticks=10,
                backgroundcolor="#2d2d2d", # Dark background for axes
                gridcolor="#444444",
                zerolinecolor="#666666"
            ),
            yaxis=dict(
                type='linear',
                backgroundcolor="#2d2d2d",
                gridcolor="#444444",
                zerolinecolor="#666666"
            ),
            zaxis=dict(
                type='linear',
                backgroundcolor="#2d2d2d",
                gridcolor="#444444",
                zerolinecolor="#666666"
            ),
            camera=dict(
                eye=dict(x=1.5, y=1.5, z=1.5) # Initial camera position
            )
        ),
        paper_bgcolor="#222222", # Dark background for the plot area
        plot_bgcolor="#222222", # Dark background for the plot itself
        font=dict(color="#cccccc"), # Font color for titles, labels, etc.
        # Removed the legend dictionary entirely to turn off the legend
        margin=dict(l=50, r=50, t=80, b=50),
        height=None,
        width=None,
        autosize=True,
        showlegend=False # Explicitly set showlegend to False to turn off the legend
    )
    debug_log("Plotly 3D layout updated.",
                file=__file__,
                version=current_version,
                function=current_function)

    output_html_path = os.path.join(output_folder, f"{selected_group_prefix}_3D_Scans_Over_Time_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html")

    if output_html_path:
        output_dir = os.path.dirname(output_html_path)
        if output_dir and not os.path.exists(output_dir):
            os.makedirs(output_dir)
            debug_log(f"Created directory for plot: {output_html_path}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        debug_log(f"Saving 3D plot to: {output_html_path}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        fig.write_html(output_html_path, auto_open=False)
        console_print_func(f"✅ 3D plot saved to: {output_html_path}. Fucking brilliant!")
        debug_log(f"✅ 3D plot saved to: {output_html_path}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
    else:
        debug_log("Output HTML path not provided, skipping saving 3D plot to file. What a waste!",
                    file=__file__,
                    version=current_version,
                    function=current_function)

    debug_log(f"Exiting {current_function}",
                file=__file__,
                version=current_version,
                function=current_function)
    return fig, output_html_path


#####################################
### File: OPEN-AIR\Presets\TAB_PRESETS_PARENT.py
#####################################
# tabs/Presets/TAB_PRESETS_PARENT.py
#
# This file defines the TAB_PRESETS_PARENT class, which serves as a container
# for all preset-related child tabs.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250803.2300.3
# FIXED: Corrected the AttributeError by changing the style object from 'style' to 'style_obj'.
# REFACTORED: Applied color-coded child notebook style.

current_version = "20250803.2300.3"
current_version_hash = (20250803 * 2300 * 3)

import tkinter as tk
from tkinter import ttk
import inspect
import os

from .tab_presets_child_local import LocalPresetsTab
from .tab_presets_child_device import DevicePresetsTab
from .tab_presets_child_preset_editor import PresetEditorTab
from display.debug_logic import debug_log
from display.console_logic import console_log

class TAB_PRESETS_PARENT(ttk.Frame):
    """
    A parent tab for all preset-related functionalities.
    """
    def __init__(self, parent_notebook, app_instance, console_print_func):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"📘 🟢 Entering {current_function}",
                  file=f"{os.path.basename(__file__)}",
                  version=current_version,
                  function=current_function)

        super().__init__(parent_notebook)
        
        self.app_instance = app_instance
        self.console_print_func = console_print_func
        self.child_tabs = {} # Dictionary to hold child tab instances
        
        # Configure grid for this frame
        self.grid_rowconfigure(0, weight=1)
        self.grid_columnconfigure(0, weight=1)

        # Create a notebook for the child tabs
        self.child_notebook = ttk.Notebook(self, style='Presets.Child.TNotebook')
        self.child_notebook.pack(expand=True, fill="both", padx=5, pady=5)

        self.local_presets_tab = LocalPresetsTab(self.child_notebook, self.app_instance, self.console_print_func)
        self.child_notebook.add(self.local_presets_tab, text="Local Presets")
        self.child_tabs["Local Presets"] = self.local_presets_tab

        self.preset_editor_tab = PresetEditorTab(self.child_notebook, self.app_instance, self.console_print_func)
        self.child_notebook.add(self.preset_editor_tab, text="Preset Editor")
        self.child_tabs["Preset Editor"] = self.preset_editor_tab

        # FIXED: Changed app_instance.style to app_instance.style_obj
        self.device_presets_tab = DevicePresetsTab(self.child_notebook, self.app_instance, self.console_print_func, style_obj=self.app_instance.style_obj)
        self.child_notebook.add(self.device_presets_tab, text="Presets In Device")
        self.child_tabs["Presets In Device"] = self.device_presets_tab
        
        self.child_notebook.bind("<<NotebookTabChanged>>", self._on_child_tab_selected)

        debug_log(f"📘 ✅ Exiting {current_function}",
                  file=f"{os.path.basename(__file__)}",
                  version=current_version,
                  function=current_function)

    def _on_child_tab_selected(self, event):
        """Handles tab change events within this parent's child notebook."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"📘 🟢 Child tab selected in Presets Parent. Checking for tab handler.",
                  file=f"{os.path.basename(__file__)}",
                  version=current_version,
                  function=current_function)
        
        selected_child_tab_id = self.child_notebook.select()
        if selected_child_tab_id:
            selected_child_tab_widget = self.child_notebook.nametowidget(selected_child_tab_id)
            if hasattr(selected_child_tab_widget, '_on_tab_selected'):
                selected_child_tab_widget._on_tab_selected(event)
        
        debug_log(f"📘 ✅ Exiting {current_function}",
                  file=f"{os.path.basename(__file__)}",
                  version=current_version,
                  function=current_function)

    def _on_parent_tab_selected(self, event):
        """
        Handles the event when this parent tab is selected.
        It delegates the event to the currently active child tab.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"📘 🟢 Presets Parent tab selected. Initializing child tab handlers.",
                  file=f"{os.path.basename(__file__)}",
                  version=current_version,
                  function=current_function)

        # Delegate to the currently active child tab to ensure it is properly refreshed
        selected_child_tab_id = self.child_notebook.select()
        if selected_child_tab_id:
            selected_child_tab_widget = self.child_notebook.nametowidget(selected_child_tab_id)
            if hasattr(selected_child_tab_widget, '_on_tab_selected'):
                selected_child_tab_widget._on_tab_selected(event)
        
        debug_log(f"📘 ✅ Exiting {current_function}",
                  file=f"{os.path.basename(__file__)}",
                  version=current_version,
                  function=current_function)

#####################################
### File: OPEN-AIR\Presets\tab_presets_child_device.py
#####################################
# tabs/Presets/tab_presets_child_device.py
#
# This file defines the DevicePresetsTab, a Tkinter Frame that provides
# functionality for managing instrument-defined presets. It allows querying
# presets from the connected instrument and loading selected presets.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.173331.1
# UPDATED: Refactored logic to break circular dependencies by moving the core load preset logic 
#          to `utils_preset_query_and_load.py` and importing push_preset_logic lazily.

import tkinter as tk
from tkinter import ttk, filedialog, simpledialog
import inspect
import os
import csv
from datetime import datetime

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log
from src.program_style import COLOR_PALETTE

# Import functions from preset utility modules
from Presets.utils_preset_csv_process import load_user_presets_from_csv, overwrite_user_presets_csv
from Presets.utils_preset_query_and_load import query_device_presets_logic, load_selected_preset_logic
from Instrument.connection.instrument_logic import query_current_settings_logic

# --- Versioning ---
w = 20250821
x_str = '173331'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = f"{os.path.basename(__file__)}"


class DevicePresetsTab(ttk.Frame):
    def __init__(self, parent, app_instance, console_print_func, style_obj, *args, **kwargs):
        super().__init__(parent, *args, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func
        self.style_obj = style_obj
        self.cached_user_presets = {}

        self.create_widgets()
        self.setup_layout()
        self.bind_events()

        is_connected = self.app_instance.inst is not None
        instrument_model = self.app_instance.connected_instrument_model.get() if hasattr(self.app_instance, 'connected_instrument_model') else ""
        self._on_connection_status_changed(is_connected, instrument_model)

        debug_log(f"DevicePresetsTab initialized. Version: {current_version}",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)

    def create_widgets(self):
        self.device_presets_frame = ttk.LabelFrame(self, text="Device Presets", style='Custom.TLabelframe')
        self.device_presets_frame.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")

        self.query_device_presets_button = ttk.Button(self.device_presets_frame,
                                                    text="Query Device Presets",
                                                    command=self._query_and_populate_device_presets,
                                                    style='TButton')
        self.query_device_presets_button.grid(row=0, column=0, padx=5, pady=5, sticky="ew")
        self.query_device_presets_button.config(state=tk.DISABLED)

        self.device_preset_listbox_label = ttk.Label(self.device_presets_frame, text="Available Device Presets:")
        self.device_preset_listbox_label.grid(row=1, column=0, padx=5, pady=2, sticky="w")

        self.device_preset_listbox_frame = ttk.Frame(self.device_presets_frame, style='TFrame')
        self.device_preset_listbox_frame.grid(row=2, column=0, padx=5, pady=5, sticky="nsew")

        self.device_preset_listbox = tk.Listbox(self.device_preset_listbox_frame, height=10, width=50,
                                                selectmode=tk.SINGLE, exportselection=False,
                                                bg=COLOR_PALETTE.get('input_bg'),
                                                fg=COLOR_PALETTE.get('input_fg'),
                                                selectbackground=COLOR_PALETTE.get('select_bg'),
                                                selectforeground=COLOR_PALETTE.get('select_fg'))
        self.device_preset_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        self.device_preset_scrollbar = ttk.Scrollbar(self.device_preset_listbox_frame, orient="vertical", command=self.device_preset_listbox.yview)
        self.device_preset_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.device_preset_listbox.config(yscrollcommand=self.device_preset_scrollbar.set)

        self.load_device_preset_button = ttk.Button(self.device_presets_frame,
                                                    text="Load Selected Device Preset",
                                                    command=self._load_selected_device_preset,
                                                    style='TButton')
        self.load_device_preset_button.grid(row=3, column=0, padx=5, pady=5, sticky="ew")
        self.load_device_preset_button.config(state=tk.DISABLED)

        self.save_current_frame = ttk.LabelFrame(self, text="Save Current Instrument Settings as User Preset", style='Custom.TLabelframe')
        self.save_current_frame.grid(row=4, column=0, padx=10, pady=10, sticky="ew")

        self.filename_label = ttk.Label(self.save_current_frame, text="Filename (e.g., MY_PRESET.STA):")
        self.filename_label.grid(row=0, column=0, padx=5, pady=2, sticky="w")
        self.filename_entry = ttk.Entry(self.save_current_frame, style='TEntry')
        self.filename_entry.grid(row=0, column=1, padx=5, pady=2, sticky="ew")

        self.nickname_label = ttk.Label(self.save_current_frame, text="Nickname (optional):")
        self.nickname_label.grid(row=1, column=0, padx=5, pady=2, sticky="w")
        self.nickname_entry = ttk.Entry(self.save_current_frame, style='TEntry')
        self.nickname_entry.grid(row=1, column=1, padx=5, pady=2, sticky="ew")

        self.save_current_button = ttk.Button(self.save_current_frame,
                                            text="Save Current Settings to PRESETS.CSV",
                                            command=self.save_current_settings_as_user_preset,
                                            style='TButton')
        self.save_current_button.grid(row=2, column=0, columnspan=2, padx=5, pady=5, sticky="ew")
        self.save_current_button.config(state=tk.DISABLED)

    def setup_layout(self):
        self.grid_rowconfigure(0, weight=1)
        self.grid_columnconfigure(0, weight=1)
        self.device_presets_frame.grid_columnconfigure(0, weight=1)
        self.device_preset_listbox_frame.grid_columnconfigure(0, weight=1)
        self.save_current_frame.grid_columnconfigure(1, weight=1)

    def bind_events(self):
        self.device_preset_listbox.bind("<<ListboxSelect>>", self._on_device_preset_select)
        self.app_instance.bind("<<ConnectionStatusChanged>>", self._handle_connection_status_change_event)

    def _handle_connection_status_change_event(self, event=None):
        is_connected = self.app_instance.inst is not None
        instrument_model = self.app_instance.connected_instrument_model.get() if hasattr(self.app_instance, 'connected_instrument_model') else ""
        self._on_connection_status_changed(is_connected, instrument_model)

    def _on_connection_status_changed(self, is_connected, instrument_model):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Connection status changed event received in DevicePresetsTab: Connected={is_connected}, Model={instrument_model}. Updating UI state.",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        if is_connected and "N9342CN" in instrument_model:
            self.query_device_presets_button.config(state=tk.NORMAL)
            self.load_device_preset_button.config(state=tk.NORMAL)
            self.save_current_button.config(state=tk.NORMAL)
            if not self.device_preset_listbox.get(0, tk.END):
                self._query_and_populate_device_presets()
        else:
            self.query_device_presets_button.config(state=tk.DISABLED)
            self.load_device_preset_button.config(state=tk.DISABLED)
            self.save_current_button.config(state=tk.DISABLED)
            self._populate_device_preset_listboxes([])
            self.console_print_func("⚠️ Query Device Presets button disabled (not connected or not N9342CN).")

    def _query_and_populate_device_presets(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Querying device presets. Getting the list of presets from the instrument. Version: {current_version}",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        if self.app_instance.inst:
            presets = query_device_presets_logic(self.app_instance, self.console_print_func)
            self._populate_device_preset_listboxes(presets)
            if presets:
                self.console_print_func(f"✅ Found {len(presets)} device presets.")
            else:
                self.console_print_func("ℹ️ No device presets found or instrument does not support preset querying.")
        else:
            self.console_print_func("❌ Instrument not connected. Cannot query device presets.")
            debug_log("Instrument not connected. Cannot query device presets. What a mess!",
                        file=current_file,
                        version=current_version,
                        function=current_function)

    def _populate_device_preset_listboxes(self, presets):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Populating device preset listbox with {len(presets)} entries. Filling up the display!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        self.device_preset_listbox.delete(0, tk.END)
        for preset in presets:
            self.device_preset_listbox.insert(tk.END, preset)
        debug_log("Device preset listbox populated.",
                    file=current_file,
                    version=current_version,
                    function=current_function)

    def _on_device_preset_select(self, event):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Device preset selected event triggered. Let's see what's chosen! Version: {current_version}",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        if self.device_preset_listbox.curselection():
            self.load_device_preset_button.config(state=tk.NORMAL)
        else:
            self.load_device_preset_button.config(state=tk.DISABLED)
        debug_log("Device preset selection handled.",
                    file=current_file,
                    version=current_version,
                    function=current_function)

    def _load_selected_device_preset(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Loading selected device preset. Applying the magic! Version: {current_version}",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        selected_index = self.device_preset_listbox.curselection()
        if selected_index:
            selected_preset_name = self.device_preset_listbox.get(selected_index[0])
            self.console_print_func(f"Attempting to load device preset: {selected_preset_name}...")
            # Use the new centralized logic function
            success = load_selected_preset_logic(
                app_instance=self.app_instance,
                selected_preset_name=selected_preset_name,
                console_print_func=self.console_print_func,
                is_device_preset=True
            )
            if success:
                self.console_print_func(f"✅ Successfully loaded device preset: {selected_preset_name}.")
                debug_log(f"Device preset '{selected_preset_name}' loaded successfully. Good job!",
                            file=current_file,
                            version=current_version,
                            function=current_function)
            else:
                self.console_print_func(f"❌ Failed to load device preset: {selected_preset_name}. Something went wrong!")
                debug_log(f"Failed to load device preset '{selected_preset_name}'. This is a disaster!",
                            file=current_file,
                            version=current_version,
                            function=current_function)
        else:
            self.console_print_func("⚠️ No device preset selected to load. Pick one!")
            debug_log("No device preset selected to load.",
                        file=current_file,
                        version=current_version,
                        function=current_function)

    def save_current_settings_as_user_preset(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Saving current settings as user preset. Getting all the goodies! Version: {current_version}",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        filename = self.filename_entry.get().strip()
        nickname = self.nickname_entry.get().strip()

        if not filename:
            self.console_print_func("❌ Filename cannot be empty. Please enter a filename.")
            debug_log("Filename for new preset was empty. User needs to provide one.",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return

        if not filename.endswith(".STA"):
            filename += ".STA"
        
        # LAZY IMPORT: Imports moved here to break circular dependency
        from Presets.utils_push_preset import push_preset_logic

        current_settings = query_current_settings_logic(self.app_instance, self.console_print_func)
        if not current_settings:
            self.console_print_func("❌ Could not retrieve current instrument settings to save.")
            debug_log("Failed to retrieve current instrument settings. Cannot save preset.",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return

        new_preset = {
            'Filename': filename,
            'NickName': nickname,
            'Center': str(current_settings.get('center_freq_hz', 0.0)),
            'Span': str(current_settings.get('span_freq_hz', 0.0)),
            'RBW': str(current_settings.get('rbw_hz', 0.0)),
            'VBW': str(current_settings.get('vbw_hz', '')),
            'RefLevel': str(current_settings.get('ref_level_dbm', '')),
            'Attenuation': str(current_settings.get('attenuation_db', '')),
            'MaxHold': current_settings.get('max_hold_enabled', 'OFF'),
            'HighSens': current_settings.get('high_sensitivity_enabled', 'OFF'),
            'PreAmp': current_settings.get('preamp_enabled', 'OFF'),
            'Trace1Mode': current_settings.get('trace1_mode', ''),
            'Trace2Mode': current_settings.get('trace2_mode', ''),
            'Trace3Mode': current_settings.get('trace3_mode', ''),
            'Trace4Mode': current_settings.get('trace4_mode', ''),
            'Marker1Max': str(current_settings.get('marker1_max', '')),
            'Marker2Max': str(current_settings.get('marker2_max', '')),
            'Marker3Max': str(current_settings.get('marker3_max', '')),
            'Marker4Max': str(current_settings.get('marker4_max', '')),
            'Marker5Max': str(current_settings.get('marker5_max', '')),
            'Marker6Max': str(current_settings.get('marker6_max', ''))
        }

        all_presets = load_user_presets_from_csv(self.app_instance.CONFIG_FILE_PATH, self.console_print_func)

        existing_index = -1
        for i, preset in enumerate(all_presets):
            if preset.get('Filename') == filename:
                existing_index = i
                break

        if existing_index != -1:
            if tk.messagebox.askyesno("Overwrite Preset",
                                    f"A preset with filename '{filename}' already exists. Do you want to overwrite it?",
                                    parent=self):
                all_presets[existing_index] = new_preset
                self.console_print_func(f"ℹ️ Overwriting existing preset: {filename}.")
                debug_log(f"User confirmed overwrite for preset: {filename}",
                            file=current_file,
                            version=current_version,
                            function=current_function)
            else:
                self.console_print_func("ℹ️ Preset save cancelled by user.")
                debug_log("User cancelled preset overwrite.",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return
        else:
            all_presets.append(new_preset)
            self.console_print_func(f"ℹ️ Adding new preset: {filename}.")
            debug_log(f"Adding new preset: {filename}",
                        file=current_file,
                        version=current_version,
                        function=current_function)

        if overwrite_user_presets_csv(self.app_instance.CONFIG_FILE_PATH, all_presets, self.console_print_func):
            self.console_print_func(f"✅ Preset '{filename}' saved successfully to PRESETS.CSV!")
            debug_log(f"Preset '{filename}' saved to CSV. All good!",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            self.filename_entry.delete(0, tk.END)
            self.nickname_entry.delete(0, tk.END)
        else:
            self.console_print_func(f"❌ Failed to save preset '{filename}'. Check console for errors.")
            debug_log(f"Failed to save preset '{filename}'. This is a nightmare!",
                        file=current_file,
                        version=current_version,
                        function=current_function)

    def __load_selected_preset_logic(self, selected_preset_name, is_device_preset=True, preset_data_dict=None):
        return load_selected_preset_logic(self.app_instance, selected_preset_name, self.console_print_func, is_device_preset, preset_data_dict)

#####################################
### File: OPEN-AIR\Presets\tab_presets_child_local.py
#####################################
# tabs/Presets/tab_presets_child_local.py
#
# This file defines the LocalPresetsTab, a Tkinter Frame that provides
# functionality for displaying and loading user-defined presets stored
# locally in a CSV file. It does NOT include direct editing capabilities;
# editing is handled in the separate PresetEditorTab.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.173331.1
# UPDATED: Refactored logic to break circular dependencies by using a shared load preset logic
#          file and importing push_preset_logic lazily.

import tkinter as tk
from tkinter import ttk
import inspect
import os

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log

# Import functions from preset utility modules
from Presets.utils_preset_csv_process import load_user_presets_from_csv
from src.program_style import COLOR_PALETTE
from settings_and_config.config_manager_save import save_program_config 
from ref.ref_file_paths import CONFIG_FILE_PATH, PRESETS_FILE_PATH
from Presets.utils_preset_query_and_load import load_selected_preset_logic

# --- Versioning ---
w = 20250821
x_str = '173331'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = f"{os.path.basename(__file__)}"


class LocalPresetsTab(ttk.Frame):
    """
    A Tkinter Frame for displaying and loading user-defined local presets.
    It lists presets from PRESETS.CSV as a grid of buttons and allows the user
    to load them, which updates the main application's instrument settings
    and pushes them to the connected instrument.
    """

    def __init__(self, master=None, app_instance=None, console_print_func=None, style_obj=None, **kwargs):
        filtered_kwargs = {k: v for k, v in kwargs.items() if k != 'style_obj'}
        super().__init__(master, **filtered_kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func
        self.style_obj = style_obj

        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Initializing LocalPresetsTab. Version: {current_version}. Setting up local preset display! 💾", file=current_file,
                    version=current_version,
                    function=current_function)

        self.user_presets_data = []
        self.last_clicked_button = None
        
        self.selected_preset_nickname_var = tk.StringVar(self, value="N/A")
        self.selected_preset_start_var = tk.StringVar(self, value="N/A")
        self.selected_preset_stop_var = tk.StringVar(self, value="N/A")
        self.selected_preset_center_var = tk.StringVar(self, value="N/A")
        self.selected_preset_span_var = tk.StringVar(self, value="N/A")
        self.selected_preset_rbw_var = tk.StringVar(self, value="N/A")
        self.selected_preset_vbw_var = tk.StringVar(self, value="N/A")
        self.selected_preset_reflevel_var = tk.StringVar(self, value="N/A")
        self.selected_preset_attenuation_var = tk.StringVar(self, value="N/A")
        self.selected_preset_maxhold_var = tk.StringVar(self, value="N/A")
        self.selected_preset_highsens_var = tk.StringVar(self, value="N/A")
        self.selected_preset_preamp_var = tk.StringVar(self, value="N/A")
        self.selected_preset_trace1_var = tk.StringVar(self, value="N/A")
        self.selected_preset_trace2_var = tk.StringVar(self, value="N/A")
        self.selected_preset_trace3_var = tk.StringVar(self, value="N/A")
        self.selected_preset_trace4_var = tk.StringVar(self, value="N/A")
        self.selected_preset_marker1_var = tk.StringVar(self, value="N/A")
        self.selected_preset_marker2_var = tk.StringVar(self, value="N/A")
        self.selected_preset_marker3_var = tk.StringVar(self, value="N/A")
        self.selected_preset_marker4_var = tk.StringVar(self, value="N/A")
        self.selected_preset_marker5_var = tk.StringVar(self, value="N/A")
        self.selected_preset_marker6_var = tk.StringVar(self, value="N/A")
        
        self.display_variables_map = {
            'NickName': self.selected_preset_nickname_var,
            'Start': self.selected_preset_start_var,
            'Stop': self.selected_preset_stop_var,
            'Center': self.selected_preset_center_var,
            'Span': self.selected_preset_span_var,
            'RBW': self.selected_preset_rbw_var,
            'VBW': self.selected_preset_vbw_var,
            'RefLevel': self.selected_preset_reflevel_var,
            'Attenuation': self.selected_preset_attenuation_var,
            'MaxHold': self.selected_preset_maxhold_var,
            'HighSens': self.selected_preset_highsens_var,
            'PreAmp': self.selected_preset_preamp_var,
            'Trace1Mode': self.selected_preset_trace1_var,
            'Trace2Mode': self.selected_preset_trace2_var,
            'Trace3Mode': self.selected_preset_trace3_var,
            'Trace4Mode': self.selected_preset_trace4_var,
            'Marker1Max': self.selected_preset_marker1_var,
            'Marker2Max': self.selected_preset_marker2_var,
            'Marker3Max': self.selected_preset_marker3_var,
            'Marker4Max': self.selected_preset_marker4_var,
            'Marker5Max': self.selected_preset_marker5_var,
            'Marker6Max': self.selected_preset_marker6_var,
        }

        self._create_widgets()
        self.populate_local_presets_list()

        debug_log(f"LocalPresetsTab initialized. Version: {current_version}. Local presets ready! ✅", file=current_file,
                    version=current_version,
                    function=current_function)

    def _create_widgets(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log("Creating LocalPresetsTab widgets...", file=current_file,
                    version=current_version,
                    function=current_function)

        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(0, weight=1)
        self.grid_rowconfigure(1, weight=0)

        self.canvas = tk.Canvas(self, bg=COLOR_PALETTE.get('background'), highlightthickness=0)
        self.scrollbar = ttk.Scrollbar(self, orient="vertical", command=self.canvas.yview)
        self.scrollable_frame = ttk.Frame(self.canvas, style='Dark.TFrame')

        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: self.canvas.configure(
                scrollregion=self.canvas.bbox("all")
            )
        )

        self.canvas_window = self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")

        self.canvas.configure(yscrollcommand=self.scrollbar.set)

        self.canvas.grid(row=0, column=0, sticky="nsew")
        self.scrollbar.grid(row=0, column=1, sticky="ns")

        self.canvas.bind('<Enter>', lambda e: self.canvas.bind_all("<MouseWheel>", self._on_mousewheel))
        self.canvas.bind('<Leave>', lambda e: self.canvas.unbind_all("<MouseWheel>"))

        self.max_cols = 5
        for i in range(self.max_cols):
            self.scrollable_frame.grid_columnconfigure(i, weight=1)

        selected_preset_box = ttk.LabelFrame(self, text="Selected Preset Details", style='Dark.TLabelframe')
        selected_preset_box.grid(row=1, column=0, padx=10, pady=10, sticky="ew")
        
        details_grid_frame = ttk.Frame(selected_preset_box)
        details_grid_frame.pack(fill="both", expand=True, padx=5, pady=5)
        details_grid_frame.grid_columnconfigure(1, weight=1)

        details_grid_frame.grid_columnconfigure(0, weight=1)
        details_grid_frame.grid_columnconfigure(1, weight=1)
        details_grid_frame.grid_columnconfigure(2, weight=1)
        details_grid_frame.grid_columnconfigure(3, weight=1)

        row_idx = 0
        ttk.Label(details_grid_frame, text="Nickname:", style='TLabel').grid(row=row_idx, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_nickname_var, style='Dark.TLabel.Value').grid(row=row_idx, column=1, padx=5, pady=2, sticky="ew", columnspan=3)

        row_idx += 1
        ttk.Separator(details_grid_frame, orient=tk.HORIZONTAL).grid(row=row_idx, column=0, columnspan=4, sticky="ew", pady=5)
        row_idx += 1
        ttk.Label(details_grid_frame, text="Frequency Settings", style='Dark.TLabel.Value').grid(row=row_idx, column=0, columnspan=4, sticky="ew")

        row_idx += 1
        ttk.Label(details_grid_frame, text="Start (MHz):", style='TLabel').grid(row=row_idx, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_start_var, style='Dark.TLabel.Value').grid(row=row_idx, column=1, padx=5, pady=2, sticky="ew")
        ttk.Label(details_grid_frame, text="Stop (MHz):", style='TLabel').grid(row=row_idx, column=2, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_stop_var, style='Dark.TLabel.Value').grid(row=row_idx, column=3, padx=5, pady=2, sticky="ew")
        
        row_idx += 1
        ttk.Label(details_grid_frame, text="Center (MHz):", style='TLabel').grid(row=row_idx, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_center_var, style='Dark.TLabel.Value').grid(row=row_idx, column=1, padx=5, pady=2, sticky="ew")
        ttk.Label(details_grid_frame, text="Span (MHz):", style='TLabel').grid(row=row_idx, column=2, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_span_var, style='Dark.TLabel.Value').grid(row=row_idx, column=3, padx=5, pady=2, sticky="ew")
        
        row_idx += 1
        ttk.Separator(details_grid_frame, orient=tk.HORIZONTAL).grid(row=row_idx, column=0, columnspan=4, sticky="ew", pady=5)
        row_idx += 1
        ttk.Label(details_grid_frame, text="Bandwidth Settings", style='Dark.TLabel.Value').grid(row=row_idx, column=0, columnspan=4, sticky="ew")

        row_idx += 1
        ttk.Label(details_grid_frame, text="RBW (Hz):", style='TLabel').grid(row=row_idx, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_rbw_var, style='Dark.TLabel.Value').grid(row=row_idx, column=1, padx=5, pady=2, sticky="ew")
        ttk.Label(details_grid_frame, text="VBW (Hz):", style='TLabel').grid(row=row_idx, column=2, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_vbw_var, style='Dark.TLabel.Value').grid(row=row_idx, column=3, padx=5, pady=2, sticky="ew")

        row_idx += 1
        ttk.Separator(details_grid_frame, orient=tk.HORIZONTAL).grid(row=row_idx, column=0, columnspan=4, sticky="ew", pady=5)
        row_idx += 1
        ttk.Label(details_grid_frame, text="Amplitude Settings", style='Dark.TLabel.Value').grid(row=row_idx, column=0, columnspan=4, sticky="ew")

        row_idx += 1
        ttk.Label(details_grid_frame, text="Ref Level:", style='TLabel').grid(row=row_idx, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_reflevel_var, style='Dark.TLabel.Value').grid(row=row_idx, column=1, padx=5, pady=2, sticky="ew")
        ttk.Label(details_grid_frame, text="Attenuation:", style='TLabel').grid(row=row_idx, column=2, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_attenuation_var, style='Dark.TLabel.Value').grid(row=row_idx, column=3, padx=5, pady=2, sticky="ew")

        row_idx += 1
        ttk.Label(details_grid_frame, text="Max Hold:", style='TLabel').grid(row=row_idx, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_maxhold_var, style='Dark.TLabel.Value').grid(row=row_idx, column=1, padx=5, pady=2, sticky="ew")
        ttk.Label(details_grid_frame, text="High Sens.:", style='TLabel').grid(row=row_idx, column=2, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_highsens_var, style='Dark.TLabel.Value').grid(row=row_idx, column=3, padx=5, pady=2, sticky="ew")
        
        row_idx += 1
        ttk.Label(details_grid_frame, text="PreAmp:", style='TLabel').grid(row=row_idx, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_preamp_var, style='Dark.TLabel.Value').grid(row=row_idx, column=1, padx=5, pady=2, sticky="ew")
        
        row_idx += 1
        ttk.Separator(details_grid_frame, orient=tk.HORIZONTAL).grid(row=row_idx, column=0, columnspan=4, sticky="ew", pady=5)
        row_idx += 1
        ttk.Label(details_grid_frame, text="Trace Modes", style='Dark.TLabel.Value').grid(row=row_idx, column=0, columnspan=4, sticky="ew")
        
        row_idx += 1
        ttk.Label(details_grid_frame, text="T1 Mode:", style='TLabel').grid(row=row_idx, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_trace1_var, style='Dark.TLabel.Value').grid(row=row_idx, column=1, padx=5, pady=2, sticky="ew")
        ttk.Label(details_grid_frame, text="T2 Mode:", style='TLabel').grid(row=row_idx, column=2, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_trace2_var, style='Dark.TLabel.Value').grid(row=row_idx, column=3, padx=5, pady=2, sticky="ew")
        
        row_idx += 1
        ttk.Label(details_grid_frame, text="T3 Mode:", style='TLabel').grid(row=row_idx, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_trace3_var, style='Dark.TLabel.Value').grid(row=row_idx, column=1, padx=5, pady=2, sticky="ew")
        ttk.Label(details_grid_frame, text="T4 Mode:", style='TLabel').grid(row=row_idx, column=2, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_trace4_var, style='Dark.TLabel.Value').grid(row=row_idx, column=3, padx=5, pady=2, sticky="ew")

        row_idx += 1
        ttk.Separator(details_grid_frame, orient=tk.HORIZONTAL).grid(row=row_idx, column=0, columnspan=4, sticky="ew", pady=5)
        row_idx += 1
        ttk.Label(details_grid_frame, text="Marker Settings", style='Dark.TLabel.Value').grid(row=row_idx, column=0, columnspan=4, sticky="ew")
        
        row_idx += 1
        ttk.Label(details_grid_frame, text="M1 Max:", style='TLabel').grid(row=row_idx, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_marker1_var, style='Dark.TLabel.Value').grid(row=row_idx, column=1, padx=5, pady=2, sticky="ew")
        ttk.Label(details_grid_frame, text="M2 Max:", style='TLabel').grid(row=row_idx, column=2, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_marker2_var, style='Dark.TLabel.Value').grid(row=row_idx, column=3, padx=5, pady=2, sticky="ew")

        row_idx += 1
        ttk.Label(details_grid_frame, text="M3 Max:", style='TLabel').grid(row=row_idx, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_marker3_var, style='Dark.TLabel.Value').grid(row=row_idx, column=1, padx=5, pady=2, sticky="ew")
        ttk.Label(details_grid_frame, text="M4 Max:", style='TLabel').grid(row=row_idx, column=2, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_marker4_var, style='Dark.TLabel.Value').grid(row=row_idx, column=3, padx=5, pady=2, sticky="ew")

        row_idx += 1
        ttk.Label(details_grid_frame, text="M5 Max:", style='TLabel').grid(row=row_idx, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_marker5_var, style='Dark.TLabel.Value').grid(row=row_idx, column=1, padx=5, pady=2, sticky="ew")
        ttk.Label(details_grid_frame, text="M6 Max:", style='TLabel').grid(row=row_idx, column=2, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_marker6_var, style='Dark.TLabel.Value').grid(row=row_idx, column=3, padx=5, pady=2, sticky="ew")

        debug_log("LocalPresetsTab widgets created. Scrollable button container and details box ready! 🖼️", file=current_file,
                    version=current_version,
                    function=current_function)

    def _on_mousewheel(self, event):
        self.canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        debug_log(f"Mouse wheel scrolled by {event.delta} units. Adjusting canvas view.", file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)

    def populate_local_presets_list(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log("Populating local presets buttons...", file=current_file,
                    version=current_version,
                    function=current_function)

        for widget in self.scrollable_frame.winfo_children():
            widget.destroy()
        
        self.last_clicked_button = None
        for var in self.display_variables_map.values():
            var.set("N/A")

        self.user_presets_data = load_user_presets_from_csv(PRESETS_FILE_PATH, self.console_print_func)

        if not self.user_presets_data:
            ttk.Label(self.scrollable_frame, text="No local presets found.", style='TLabel').grid(row=0, column=0, columnspan=self.max_cols, padx=10, pady=10)
            self.console_print_func("ℹ️ No local presets found in PRESETS.CSV.")
            debug_log("No local presets found. 🤷‍♂️", file=current_file,
                        version=current_version,
                        function=current_function)
            return

        row_idx = 0
        col_idx = 0
        
        for preset in self.user_presets_data:
            nickname = preset.get('NickName', preset.get('Filename', 'Unnamed Preset'))
            
            start_freq_mhz_display = "N/A"
            stop_freq_mhz_display = "N/A"
            try:
                if preset.get('Start', '').strip():
                    start_freq_mhz_display = f"{float(preset.get('Start')):.3f}"
                if preset.get('Stop', '').strip():
                    stop_freq_mhz_display = f"{float(preset.get('Stop')):.3f}"
            except ValueError:
                debug_log(f"Warning: Could not convert Start/Stop for button text for preset '{nickname}'. What a mess!", file=current_file,
                            version=current_version,
                            function=current_function)

            button_text = f"{nickname}\nStart: {start_freq_mhz_display} MHz\nStop: {stop_freq_mhz_display} MHz"

            preset_button = ttk.Button(self.scrollable_frame,
                                       text=button_text,
                                       command=lambda p=preset, b=None: self._on_preset_button_click(p, b),
                                       style='LocalPreset.TButton')
            
            preset_button.configure(command=lambda p=preset, b=preset_button: self._on_preset_button_click(p, b))

            preset_button.grid(row=row_idx, column=col_idx, padx=5, pady=5, sticky="nsew")

            col_idx += 1
            if col_idx >= self.max_cols:
                col_idx = 0
                row_idx += 1
        
        self.canvas.update_idletasks()
        self.canvas.config(scrollregion=self.canvas.bbox("all"))

        self.console_print_func(f"✅ Displayed {len(self.user_presets_data)} local presets as buttons.")
        debug_log(f"Local presets buttons populated with {len(self.user_presets_data)} entries. Looking good! 👍", file=current_file,
                    version=current_version,
                    function=current_function)

    def _on_preset_button_click(self, preset_data, clicked_button):
        current_function = inspect.currentframe().f_code.co_name
        display_name = preset_data.get('NickName', preset_data.get('Filename', 'Unnamed Preset'))
        self.console_print_func(f"Attempting to load and apply preset: {display_name}...")
        debug_log(f"Preset button clicked for: {display_name}. Applying settings to GUI and instrument. 🖱️", file=current_file,
                    version=current_version,
                    function=current_function)

        if self.last_clicked_button and self.last_clicked_button != clicked_button:
            self.last_clicked_button.config(style='LocalPreset.TButton')
            debug_log(f"Reset style of previous button: {self.last_clicked_button.cget('text').splitlines()[0]}", file=current_file,
                        version=current_version,
                        function=current_function)

        clicked_button.config(style='SelectedPreset.Orange.TButton')
        self.last_clicked_button = clicked_button
        debug_log(f"Set style of current button to orange: {display_name}", file=current_file,
                    version=current_version,
                    function=current_function)

        self.app_instance.defer_config_save = True
        debug_log("Config saving deferred. GUI updates won't trigger saves yet. 🛑", file=current_file,
                    version=current_version,
                    function=current_function)

        success_push_to_instrument = False
        if not self.app_instance.inst:
            self.console_print_func("⚠️ Instrument not connected. Settings will be applied to GUI only.")
            debug_log("Instrument not connected. Skipping SCPI commands. GUI only update. 🖥️", file=current_file,
                        version=current_version,
                        function=current_function)
            self._update_gui_from_preset_data(preset_data)
        else:
            self._update_gui_from_preset_data(preset_data)
            debug_log(f"Instrument is connected ({self.app_instance.inst}). Attempting to push preset to device. ⚡", file=current_file,
                        version=current_version,
                        function=current_function)
            
            # LAZY IMPORT: Imports moved here to break circular dependency
            from Presets.utils_push_preset import push_preset_logic
            
            success_push_to_instrument = push_preset_logic(self.app_instance, self.console_print_func, preset_data)
        
        if success_push_to_instrument:
            self.console_print_func(f"✅ Preset '{display_name}' applied to instrument and GUI. Fantastic!")
            debug_log(f"Preset '{display_name}' applied to instrument and GUI successfully. 🎉", file=current_file,
                        version=current_version,
                        function=current_function)
        elif self.app_instance.inst:
             self.console_print_func(f"❌ Failed to apply preset '{display_name}' to instrument. GUI updated only.")
             debug_log(f"Failed to apply preset '{display_name}' to instrument. GUI updated only. 🤦‍♂️", file=current_file,
                         version=current_version,
                         function=current_function)

        try:
            if hasattr(self.app_instance, 'instrument_parent_tab') and \
               hasattr(self.app_instance.instrument_parent_tab, 'settings_tab') and \
               hasattr(self.app_instance.instrument_parent_tab.settings_tab, 'refresh_all_child_tabs'):
                self.app_instance.instrument_parent_tab.settings_tab.refresh_all_child_tabs()
        finally:
            self.app_instance.defer_config_save = False
            debug_log("Config saving re-enabled. Triggering final save. ✅", file=current_file,
                        version=current_version,
                        function=current_function)
            
            try:
                save_program_config (self.app_instance.program_config, self.console_print_func, self.app_instance)
            except Exception as e:
                debug_log(f"CRITICAL ERROR: Could not save config after preset load: {e}. Config not saved!", file=current_file,
                            version=current_version,
                            function=current_function)
                self.console_print_func("❌ CRITICAL ERROR: Application config could not be saved! See debug log.")

    def _update_gui_from_preset_data(self, preset_data):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Updating GUI from preset data: {preset_data.get('NickName', 'Unnamed')}. 🔄", file=current_file,
                    version=current_version,
                    function=current_function)

        self.selected_preset_nickname_var.set(preset_data.get('NickName', 'N/A'))
        
        for var in self.display_variables_map.values():
            var.set("N/A")

        def set_display_var(tk_var, key, format_str="{}", conversion_func=str, default_val="N/A"):
            value_str = preset_data.get(key, '').strip()
            if not value_str:
                tk_var.set(default_val)
                debug_log(f"Preset '{key}' is empty for display. Setting display to '{default_val}'.", file=current_file,
                            version=current_version,
                            function=current_function)
                return

            try:
                converted_value = conversion_func(value_str)
                tk_var.set(format_str.format(converted_value))
                debug_log(f"Preset '{key}' value '{value_str}' converted to '{converted_value}' and displayed as '{tk_var.get()}'.", file=current_file,
                            version=current_version,
                            function=current_function)
            except ValueError as e:
                tk_var.set("Invalid Value")
                debug_log(f"Error converting preset '{key}' value '{value_str}' to {conversion_func.__name__}: {e}. Displaying 'Invalid Value'. 💥", file=current_file,
                            version=current_version,
                            function=current_function)
            except Exception as e:
                tk_var.set("Error")
                debug_log(f"Unexpected error processing preset '{key}' value '{value_str}': {e}. Displaying 'Error'. 🤯", file=current_file,
                            version=current_version,
                            function=current_function)

        set_display_var(self.selected_preset_start_var, 'Start', "{:.3f}", float)
        set_display_var(self.selected_preset_stop_var, 'Stop', "{:.3f}", float)
        set_display_var(self.selected_preset_center_var, 'Center', "{:.3f}", float)
        set_display_var(self.selected_preset_span_var, 'Span', "{:.3f}", float)
        set_display_var(self.selected_preset_rbw_var, 'RBW', "{:.0f}", float)
        set_display_var(self.selected_preset_vbw_var, 'VBW', "{:.0f}", float)
        set_display_var(self.selected_preset_reflevel_var, 'RefLevel', "{:.1f}", float)
        set_display_var(self.selected_preset_attenuation_var, 'Attenuation', "{:.0f}", float)
        set_display_var(self.selected_preset_maxhold_var, 'MaxHold')
        set_display_var(self.selected_preset_highsens_var, 'HighSens')
        set_display_var(self.selected_preset_preamp_var, 'PreAmp')
        set_display_var(self.selected_preset_trace1_var, 'Trace1Mode')
        set_display_var(self.selected_preset_trace2_var, 'Trace2Mode')
        set_display_var(self.selected_preset_trace3_var, 'Trace3Mode')
        set_display_var(self.selected_preset_trace4_var, 'Trace4Mode')
        set_display_var(self.selected_preset_marker1_var, 'Marker1Max')
        set_display_var(self.selected_preset_marker2_var, 'Marker2Max')
        set_display_var(self.selected_preset_marker3_var, 'Marker3Max')
        set_display_var(self.selected_preset_marker4_var, 'Marker4Max')
        set_display_var(self.selected_preset_marker5_var, 'Marker5Max')
        set_display_var(self.selected_preset_marker6_var, 'Marker6Max')

        def get_and_set_app_var(preset_key, app_attr_name, conversion_func=str, scale_factor=1.0):
            value_str = preset_data.get(preset_key, '').strip()
            app_tk_var = getattr(self.app_instance, app_attr_name, None)

            if app_tk_var is None:
                debug_log(f"WARNING: app_instance does not have attribute '{app_attr_name}'. Cannot update. ⚠️", file=current_file,
                            version=current_version,
                            function=current_function)
                return
            
            if not value_str:
                debug_log(f"Preset '{preset_key}' is empty. Skipping update for app_instance.{app_attr_name}. 🤷‍♀️", file=current_file,
                            version=current_version,
                            function=current_function)
                return

            try:
                converted_value = conversion_func(value_str) * scale_factor
                app_tk_var.set(converted_value)
                debug_log(f"App var '{app_attr_name}' (from '{preset_key}') updated to '{converted_value}'.", file=current_file,
                            version=current_version,
                            function=current_function)
            except ValueError as e:
                debug_log(f"Error converting preset '{preset_key}' value '{value_str}' to {conversion_func.__name__}: {e}. Skipping update. 💥", file=current_file,
                            version=current_version,
                            function=current_function)
            except Exception as e:
                debug_log(f"Unexpected error processing preset '{preset_key}' value '{value_str}': {e}. Skipping update. 🤯", file=current_file,
                            version=current_version,
                            function=current_function)

        get_and_set_app_var('Center', 'center_freq_mhz_var', float, self.app_instance.MHZ_TO_HZ)
        get_and_set_app_var('Span', 'span_freq_mhz_var', float, self.app_instance.MHZ_TO_HZ)
        get_and_set_app_var('RBW', 'rbw_hz_var', float)
        get_and_set_app_var('VBW', 'vbw_hz_var', float)
        get_and_set_app_var('RefLevel', 'reference_level_dbm_var', float)
        get_and_set_app_var('Attenuation', 'attenuation_db_var', int)
        get_and_set_app_var('FreqShift', 'freq_shift_hz_var', float)

        def get_and_set_bool_app_var(preset_key, app_attr_name):
            value_str = preset_data.get(preset_key, '').strip().upper()
            app_tk_var = getattr(self.app_instance, app_attr_name, None)

            if app_tk_var is None:
                debug_log(f"WARNING: app_instance does not have attribute '{app_attr_name}'. Cannot update. ⚠️", file=current_file,
                            version=current_version,
                            function=current_function)
                return

            if value_str in ['ON', 'TRUE', 'WRITE']:
                app_tk_var.set(True)
            elif value_str in ['OFF', 'FALSE', '']:
                app_tk_var.set(False)
            else:
                debug_log(f"Warning: Unexpected boolean value for '{preset_key}': '{value_str}'. Not updating app_instance.{app_attr_name}. ⚠️", file=current_file,
                            version=current_version,
                            function=current_function)

        get_and_set_bool_app_var('MaxHold', 'maxhold_enabled_var')
        get_and_set_bool_app_var('HighSens', 'high_sensitivity_var')
        get_and_set_bool_app_var('PreAmp', 'preamp_on_var')

        get_and_set_app_var('Trace1Mode', 'trace1_mode_var')
        get_and_set_app_var('Trace2Mode', 'trace2_mode_var')
        get_and_set_app_var('Trace3Mode', 'trace3_mode_var')
        get_and_set_app_var('Trace4Mode', 'trace4_mode_var')

        get_and_set_bool_app_var('Marker1Max', 'marker1_calculate_max_var')
        get_and_set_bool_app_var('Marker2Max', 'marker2_calculate_max_var')
        get_and_set_bool_app_var('Marker3Max', 'marker3_calculate_max_var')
        get_and_set_bool_app_var('Marker4Max', 'marker4_calculate_max_var')
        get_and_set_bool_app_var('Marker5Max', 'marker5_calculate_max_var')
        get_and_set_bool_app_var('Marker6Max', 'marker6_calculate_max_var')


        self.app_instance.last_selected_preset_name_var.set(preset_data.get('NickName', preset_data.get('Filename', '')))
        
        set_display_var(self.app_instance.last_loaded_preset_center_freq_mhz_var, 'Center', "{:.3f}", float)
        set_display_var(self.app_instance.last_loaded_preset_span_mhz_var, 'Span', "{:.3f}", float)
        set_display_var(self.app_instance.last_loaded_preset_rbw_hz_var, 'RBW', "{:.0f}", float)


        self.console_print_func(f"✅ GUI settings updated from local preset '{preset_data.get('NickName', 'Unnamed')}'.")
        debug_log("GUI settings updated from local preset. Done! ✅", file=current_file,
                    version=current_version,
                    function=current_function)

    def _on_tab_selected(self, event):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Local Presets tab selected. Refreshing buttons instantly. ✅", file=current_file,
                    version=current_version,
                    function=current_function)
        self.populate_local_presets_list()
        debug_log(f"Local Presets tab refreshed after selection. 👍", file=current_file,
                    version=current_version,
                    function=current_function)

#####################################
### File: OPEN-AIR\Presets\tab_presets_child_preset_editor.py
#####################################
# tabs/Presets/tab_presets_child_preset_editor.py
#
# This file defines the PresetEditorTab, a Tkinter Frame that provides
# comprehensive functionality for managing user-defined presets stored locally
# in a CSV file. It allows displaying, editing (cell-by-cell), saving, importing,
# exporting, and adding new presets (including current instrument settings).
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250814.162500.1 (REBUILT: Refactored the GUI to use the new PresetEditorLogic class, decoupling presentation from data management.)

current_version = "20250814.162500.1"
current_version_hash = 20250814 * 162500 * 1

import tkinter as tk
from tkinter import ttk, filedialog, simpledialog
import inspect
import os
from datetime import datetime
import pandas as pd
import numpy as np

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log

# Import the new utility file
from .utils_presets_editor import PresetEditorLogic

from Instrument.connection.instrument_logic import query_current_settings_logic
from src.program_style import COLOR_PALETTE


class PresetEditorTab(ttk.Frame):
    """
    A Tkinter Frame that provides comprehensive functionality for managing
    user-defined presets stored locally in a CSV file. It allows displaying,
    editing (cell-by-cell), saving, importing, exporting, and adding new presets
    (including current instrument settings).
    """
    def __init__(self, master=None, app_instance=None, console_print_func=None, style_obj=None, **kwargs):
        filtered_kwargs = {k: v for k, v in kwargs.items() if k != 'style_obj'}
        super().__init__(master, **filtered_kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func if console_print_func else console_log
        self.style_obj = style_obj

        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Initializing PresetEditorTab. Version: {current_version}. Get ready to edit presets!",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)

        self.columns = [
            'Filename', 'NickName', 'Start (MHz)', 'Stop (MHz)', 'Center (MHz)', 'Span (MHz)', 'RBW (Hz)', 'VBW (Hz)',
            'RefLevel (dBm)', 'Attenuation (dB)', 'MaxHold', 'HighSens', 'PreAmp',
            'Trace1Mode', 'Trace2Mode', 'Trace3Mode', 'Trace4Mode',
            'Marker1Max', 'Marker2Max', 'Marker3Max', 'Marker4Max',
            'Marker5Max', 'Marker6Max'
        ]
        self.column_widths = {'Filename': 120, 'NickName': 120, 'Start (MHz)': 100, 'Stop (MHz)': 100, 'Center (MHz)': 100, 'Span (MHz)': 100, 'RBW (Hz)': 80, 'VBW (Hz)': 80,
            'RefLevel (dBm)': 80, 'Attenuation (dB)': 90, 'MaxHold': 80, 'HighSens': 80, 'PreAmp': 80,
            'Trace1Mode': 90, 'Trace2Mode': 90, 'Trace3Mode': 90, 'Trace4Mode': 90,
            'Marker1Max': 90, 'Marker2Max': 90, 'Marker3Max': 90, 'Marker4Max': 90,
            'Marker5Max': 90, 'Marker6Max': 90
        }

        # NEW: Instantiate the logic class
        self.logic = PresetEditorLogic(self.app_instance, self.console_print_func, self.columns)
        self.logic.load_presets()

        self.current_edit_cell = None
        self.is_editing_cell = False

        self._create_widgets()
        self.populate_presets_table()
        
        # Removed the problematic binding to <FocusIn>
        # self.app_instance.bind("<FocusIn>", self._on_window_focus_in)

        debug_log(f"PresetEditorTab initialized. Version: {current_version}. Preset editor is live!",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)

    def _on_window_focus_in(self, event):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Main window gained focus. Refreshing presets. 🔄", file=f"{os.path.basename(__file__)}",
                    version=current_version,
                    function=current_function)
        if self.master.winfo_exists() and self.master.select() == str(self):
            self.logic.load_presets()
            self.populate_presets_table()

    def _create_widgets(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log("Creating PresetEditorTab widgets...",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)

        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(0, weight=0)
        self.grid_rowconfigure(1, weight=0)
        self.grid_rowconfigure(2, weight=1)
        self.grid_rowconfigure(3, weight=0)
        self.grid_rowconfigure(4, weight=0)

        top_button_frame = ttk.Frame(self, style='Dark.TFrame')
        top_button_frame.grid(row=0, column=0, columnspan=2, sticky="ew", padx=10, pady=5)
        top_button_frame.grid_columnconfigure(0, weight=1)
        top_button_frame.grid_columnconfigure(1, weight=1)
        top_button_frame.grid_columnconfigure(2, weight=1)

        add_current_button = ttk.Button(top_button_frame, text="Add Current Settings", command=self._add_current_settings, style='Green.TButton')
        add_current_button.grid(row=0, column=0, padx=5, pady=5, sticky="ew")

        add_empty_row_button = ttk.Button(top_button_frame, text="Add New Empty Row", command=self._add_new_empty_row, style='Blue.TButton')
        add_empty_row_button.grid(row=0, column=1, padx=5, pady=5, sticky="ew")

        delete_button = ttk.Button(top_button_frame, text="Delete Selected", command=self._delete_selected_preset, style='Red.TButton')
        delete_button.grid(row=0, column=2, padx=5, pady=5, sticky="ew")

        move_button_frame = ttk.Frame(self, style='Dark.TFrame')
        move_button_frame.grid(row=1, column=0, columnspan=2, sticky="ew", padx=10, pady=5)
        move_button_frame.grid_columnconfigure(0, weight=1)
        move_button_frame.grid_columnconfigure(1, weight=1)

        move_up_button = ttk.Button(move_button_frame, text="Move Preset UP (CTRL+UP)", command=self._move_preset_up, style='Orange.TButton')
        move_up_button.grid(row=0, column=0, padx=5, pady=5, sticky="ew")

        move_down_button = ttk.Button(move_button_frame, text="Move Preset DOWN (CTRL+DOWN)", command=self._move_preset_down, style='Orange.TButton')
        move_down_button.grid(row=0, column=1, padx=5, pady=5, sticky="ew")

        self.presets_tree = ttk.Treeview(self, columns=self.columns, show='headings', style='Treeview')
        self.presets_tree.grid(row=2, column=0, sticky="nsew", padx=10, pady=10)

        for col in self.columns:
            self.presets_tree.heading(col, text=col, anchor=tk.W)
            self.presets_tree.column(col, width=self.column_widths.get(col, 100), anchor=tk.W, stretch=tk.NO)

        vsb = ttk.Scrollbar(self, orient="vertical", command=self.presets_tree.yview)
        vsb.grid(row=2, column=1, sticky='ns')
        self.presets_tree.configure(yscrollcommand=vsb.set)

        hsb = ttk.Scrollbar(self, orient="horizontal", command=self.presets_tree.xview)
        hsb.grid(row=3, column=0, sticky='ew')
        self.presets_tree.configure(xscrollcommand=hsb.set)

        self.presets_tree.bind("<Double-1>", self._on_double_click)
        self.presets_tree.bind("<<TreeviewSelect>>", self._on_tree_select)
        self.presets_tree.bind("<Control-Up>", lambda event: self._move_preset_up())
        self.presets_tree.bind("<Control-Down>", lambda event: self._move_preset_down())

        file_ops_button_frame = ttk.Frame(self, style='Dark.TFrame')
        file_ops_button_frame.grid(row=4, column=0, columnspan=2, pady=10, padx=10, sticky="ew")
        file_ops_button_frame.grid_columnconfigure(0, weight=1)
        file_ops_button_frame.grid_columnconfigure(1, weight=1)
        file_ops_button_frame.grid_columnconfigure(2, weight=1)

        import_button = ttk.Button(file_ops_button_frame, text="Import Presets", command=self._import_presets, style='Orange.TButton')
        import_button.grid(row=0, column=0, padx=5, pady=5, sticky="ew")

        export_button = ttk.Button(file_ops_button_frame, text="Export Presets", command=self._export_presets, style='Purple.TButton')
        export_button.grid(row=0, column=1, padx=5, pady=5, sticky="ew")

        debug_log("PresetEditorTab widgets created. Treeview and buttons are ready for action!",
                    file=f"{os.path.basename(__file__)}",
                    version=current_version,
                    function=current_function)

    def populate_presets_table(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log("Populating local presets table from internal data...",
                    file=f"{os.path.basename(__file__)}",
                    version=current_version,
                    function=current_function)

        for item in self.presets_tree.get_children():
            self.presets_tree.delete(item)

        if not self.logic.presets_data:
            self.console_print_func("ℹ️ No user presets in memory to display in editor.")
            return

        for preset in self.logic.presets_data:
            row_values = []
            for col_key in self.columns:
                clean_col_key = col_key.split(' ')[0]
                value = preset.get(clean_col_key, '')
                
                if isinstance(value, float) and np.isnan(value):
                    value = ''
                
                row_values.append(value)
            
            self.presets_tree.insert('', 'end', values=row_values)
        
        self.console_print_func(f"✅ Displayed {len(self.logic.presets_data)} user presets in the editor.")
        debug_log(f"Local presets table populated with {len(self.logic.presets_data)} entries from internal data.",
                    file=f"{os.path.basename(__file__)}",
                    version=current_version,
                    function=current_function)

    def _add_current_settings(self):
        if self.logic.add_current_settings():
            self.populate_presets_table()
            self.logic.save_presets()

    def _add_new_empty_row(self):
        if self.logic.add_new_empty_row():
            self.populate_presets_table()
            self.logic.save_presets()

    def _save_presets_to_csv(self):
        if self.logic.save_presets():
            self.console_print_func(f"✅ Presets saved successfully to: {self.app_instance.PRESETS_FILE_PATH}")

    def _import_presets(self):
        file_path = filedialog.askopenfilename(
            parent=self.app_instance,
            title="Select CSV file to import",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")]
        )
        if file_path and self.logic.import_presets(file_path):
            self.populate_presets_table()
            self.logic.save_presets()

    def _export_presets(self):
        file_path = filedialog.asksaveasfilename(
            parent=self.app_instance,
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
            initialfile=f"exported_presets_{datetime.now().strftime('%Y%m%d_%H%M')}.csv"
        )
        if file_path:
            self.logic.export_presets(file_path)

    def _delete_selected_preset(self):
        selected_items = self.presets_tree.selection()
        if not selected_items:
            self.console_print_func("⚠️ No preset selected for deletion. Pick one, genius!")
            return

        filenames_to_delete = [self.presets_tree.item(item, 'values')[0] for item in selected_items]
        if self.logic.delete_presets(filenames_to_delete):
            self.populate_presets_table()
            self.logic.save_presets()

    def _on_double_click(self, event):
        region = self.presets_tree.identify("region", event.x, event.y)
        if region == "cell":
            col = self.presets_tree.identify_column(event.x)
            item = self.presets_tree.identify_row(event.y)
            if item and self.columns[int(col[1:]) - 1] != 'Filename':
                col_index = int(col[1:]) - 1
                self._start_edit(item, col_index)

    def _start_edit(self, item_id, col_index):
        if hasattr(self, 'edit_entry') and self.edit_entry.winfo_exists():
            self._end_edit()

        x, y, width, height = self.presets_tree.bbox(item_id, f"#{col_index + 1}")
        current_values_in_tree = self.presets_tree.item(item_id, "values")
        current_value = current_values_in_tree[col_index]
        filename_of_edited_row = current_values_in_tree[0]

        self.edit_entry = ttk.Entry(self.presets_tree, style='TEntry')
        self.edit_entry.place(x=x, y=y, width=width, height=height, anchor="nw")
        self.edit_entry.insert(0, current_value)
        self.edit_entry.focus_set()

        self.current_edit_cell = (item_id, col_index, filename_of_edited_row)
        self.is_editing_cell = True

        self.edit_entry.bind("<FocusOut>", self._end_edit)
        self.edit_entry.bind("<Return>", self._on_edit_return)
        self.edit_entry.bind("<Escape>", self._on_edit_escape)

    def _on_edit_return(self, event):
        self._end_edit()
        return "break"

    def _on_edit_escape(self, event):
        if hasattr(self, 'edit_entry') and self.edit_entry.winfo_exists():
            self.edit_entry.destroy()
            self.current_edit_cell = None
            self.is_editing_cell = False
        return "break"

    def _end_edit(self, event=None):
        if not hasattr(self, 'edit_entry') or not self.edit_entry.winfo_exists():
            return

        if self.current_edit_cell:
            item_id_from_edit, col_index, filename_of_edited_row = self.current_edit_cell
            new_value = self.edit_entry.get()
            original_col_name = self.columns[col_index].split(' ')[0]
            
            if self.logic.update_preset_value(filename_of_edited_row, original_col_name, new_value):
                self.logic.save_presets()
            
            self.populate_presets_table()
            self.current_edit_cell = None

        self.edit_entry.destroy()
        self.is_editing_cell = False

    def _on_tab_selected(self, event):
        if self.logic.has_unsaved_changes:
            self.logic.save_presets()
        self.logic.load_presets()
        self.populate_presets_table()
        
    def _on_tree_select(self, event):
        pass

    def _move_preset_up(self):
        selected_items = self.presets_tree.selection()
        if not selected_items:
            self.console_print_func("⚠️ No preset selected to move up. Select one, genius!")
            return
        
        filenames_to_move = [self.presets_tree.item(item, 'values')[0] for item in selected_items]
        
        for filename in filenames_to_move:
            self.logic.move_preset_up(filename)
        
        self.populate_presets_table()
        self.presets_tree.selection_set(self.presets_tree.get_children()[:len(filenames_to_move)])
        self.logic.save_presets()

    def _move_preset_down(self):
        selected_items = self.presets_tree.selection()
        if not selected_items:
            self.console_print_func("⚠️ No preset selected to move down. Select one, buddy!")
            return
            
        filenames_to_move = [self.presets_tree.item(item, 'values')[0] for item in selected_items]
        
        for filename in reversed(filenames_to_move):
            self.logic.move_preset_down(filename)

        self.populate_presets_table()
        self.presets_tree.selection_set(self.presets_tree.get_children()[-len(filenames_to_move):])
        self.logic.save_presets()



#####################################
### File: OPEN-AIR\Presets\utils_preset_csv_process.py
#####################################
# tabs/Presets/utils_preset_process.py
#
# This file provides utility functions for loading, saving, and managing
# user-defined presets stored in a CSV file. It handles the file path resolution
# and the actual reading/writing operations.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250814.161800.1 (FIXED: The loading and saving functions were updated to correctly handle the new 'Start' and 'Stop' columns and gracefully manage potential header mismatches by using pandas for robust file operations.)

current_version = "20250814.161800.1"
current_version_hash = 20250814 * 161800 * 1

import os
import csv
import inspect
import pandas as pd # For robust CSV reading/writing
import numpy as np # For handling NaN values

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log

current_version = "20250814.161800.1"
current_version_hash = 20250814 * 161800 * 1

def get_presets_csv_path(config_file_path, console_print_func=None):
    """
    Determines the full path to the PRESETS.CSV file.
    It assumes PRESETS.CSV is in the same directory as the config file,
    or in a 'DATA' subdirectory if the config file is one level up.

    Inputs:
        config_file_path (str): The full path to the application's config.ini file.
        console_print_func (function, optional): A function to use for printing messages
                                                 to the console. If None, uses standard print.
    Returns:
        str: The full path to the PRESETS.CSV file.
    """
    _print = console_print_func if console_print_func else print
    current_function = inspect.currentframe().f_code.co_name
    
    # Get the directory containing the config file
    config_dir = os.path.dirname(config_file_path)
    
    # Check if config_dir itself ends with 'DATA'
    if os.path.basename(config_dir).upper() == 'DATA':
        # If config_file_path is already within the DATA folder, use that folder directly
        presets_csv_path = os.path.join(config_dir, "PRESETS.CSV")
    else:
        # Otherwise, assume DATA is a sibling directory to config_dir
        # This might need adjustment based on your exact project structure.
        # For now, let's assume config_file_path is like ".../OPEN-AIR/config.ini"
        # and DATA is ".../OPEN-AIR/DATA/"
        app_root_dir = os.path.dirname(config_dir)
        data_folder = os.path.join(app_root_dir, "DATA")
        presets_csv_path = os.path.join(data_folder, "PRESETS.CSV")

    debug_log(f"Determined presets CSV path: {presets_csv_path}.",
                file=f"{os.path.basename(__file__)} - {current_version}",
                version=current_version,
                function=current_function)
    return presets_csv_path

def load_user_presets_from_csv(config_file_path, console_print_func=None):
    """
    Loads user-defined presets from the PRESETS.CSV file.
    If the file does not exist, it creates an empty one with headers.

    Inputs:
        config_file_path (str): The full path to the application's config.ini file.
        console_print_func (function, optional): A function to use for printing messages
                                                 to the console. If None, uses standard print.
    Returns:
        list: A list of dictionaries, where each dictionary represents a preset.
              Returns an empty list if the file is empty or cannot be read.
    """
    _print = console_print_func if console_print_func else print
    current_function = inspect.currentframe().f_code.co_name
    presets_csv_path = get_presets_csv_path(config_file_path, _print)
    
    # Define the expected headers for the PRESETS.CSV file
    # This list must match the columns expected by PresetEditorTab
    expected_headers = [
        'Filename', 'NickName', 'Start', 'Stop', 'Center', 'Span', 'RBW', 'VBW',
        'RefLevel', 'Attenuation', 'MaxHold', 'HighSens', 'PreAmp',
        'Trace1Mode', 'Trace2Mode', 'Trace3Mode', 'Trace4Mode',
        'Marker1Max', 'Marker2Max', 'Marker3Max', 'Marker4Max',
        'Marker5Max', 'Marker6Max'
    ]

    if not os.path.exists(presets_csv_path):
        _print(f"ℹ️ PRESETS.CSV not found at '{presets_csv_path}'. Creating a new empty file with headers.")
        debug_log(f"PRESETS.CSV not found. Creating new file.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        try:
            # Ensure the DATA directory exists
            os.makedirs(os.path.dirname(presets_csv_path), exist_ok=True)
            with open(presets_csv_path, 'w', newline='', encoding='utf-8') as csvfile:
                writer = csv.DictWriter(csvfile, fieldnames=expected_headers)
                writer.writeheader()
            _print("✅ New PRESETS.CSV created with headers.")
            debug_log("New PRESETS.CSV created with headers.",
                        file=f"{os.path.basename(__file__)} - {current_version}",
                        version=current_version,
                        function=current_function)
            return [] # Return empty list as the file is new and empty
        except Exception as e:
            _print(f"❌ Error creating PRESETS.CSV: {e}. Cannot load presets.")
            debug_log(f"Error creating PRESETS.CSV: {e}.",
                        file=f"{os.path.basename(__file__)} - {current_version}",
                        version=current_version,
                        function=current_function)
            return []
    
    # Use a try/except block to handle file reading errors gracefully.
    try:
        _print(f"💬 Loading user presets from existing file: {os.path.basename(presets_csv_path)}. Let's get this data!")
        debug_log(f"Loading user presets from existing file: {presets_csv_path}.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        # Use pandas for more robust CSV reading, handling potential missing columns
        df = pd.read_csv(presets_csv_path, dtype=str, keep_default_na=False) # Read all as string, keep empty strings as empty
        
        # Ensure all expected headers are present, add missing ones with empty string values
        for header in expected_headers:
            if header not in df.columns:
                df[header] = ''

        # Reorder columns to match expected_headers
        df = df[expected_headers]

        presets = df.to_dict(orient='records')

        # Convert NaN values to empty strings after reading with pandas
        for preset in presets:
            for key, value in preset.items():
                if pd.isna(value):
                    preset[key] = ''
                # Ensure all values are strings for consistency
                elif not isinstance(value, str):
                    preset[key] = str(value)

        _print(f"✅ Loaded {len(presets)} user presets from {os.path.basename(presets_csv_path)}.")
        debug_log(f"Loaded {len(presets)} user presets.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        return presets
    except pd.errors.EmptyDataError:
        _print(f"ℹ️ PRESETS.CSV at '{presets_csv_path}' is empty. Returning no presets.")
        debug_log(f"PRESETS.CSV is empty.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        # Re-create with headers if it was truly empty (not just header-only)
        try:
            with open(presets_csv_path, 'w', newline='', encoding='utf-8') as csvfile:
                writer = csv.DictWriter(csvfile, fieldnames=expected_headers)
                writer.writeheader()
            _print("✅ Empty PRESETS.CSV re-initialized with headers.")
            debug_log("Empty PRESETS.CSV re-initialized with headers.",
                        file=f"{os.path.basename(__file__)} - {current_version}",
                        version=current_version,
                        function=current_function)
        except Exception as e:
            _print(f"❌ Error re-initializing empty PRESETS.CSV: {e}.")
            debug_log(f"Error re-initializing empty PRESETS.CSV: {e}.",
                        file=f"{os.path.basename(__file__)} - {current_version}",
                        version=current_version,
                        function=current_function)
        return []
    except Exception as e:
        _print(f"❌ Error loading presets from {os.path.basename(presets_csv_path)}: {e}. Returning no presets.")
        debug_log(f"Error loading presets: {e}. What the hell?!",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        return []

def overwrite_user_presets_csv(config_file_path, presets_data, console_print_func=None, fieldnames=None):
    """
    Overwrites the PRESETS.CSV file with the provided presets data.
    Ensures all dictionary keys match the fieldnames for csv.DictWriter.

    Inputs:
        config_file_path (str): The full path to the application's config.ini file.
        presets_data (list): A list of dictionaries, where each dictionary represents a preset.
        console_print_func (function, optional): A function to use for printing messages
                                                 to the console. If None, uses standard print.
        fieldnames (list, optional): A list of strings representing the CSV header order.
                                     If None, it will be derived from the keys of the first preset,
                                     or a default set if presets_data is empty.
    Returns:
        bool: True if save was successful, False otherwise.
    """
    _print = console_print_func if console_print_func else print
    current_function = inspect.currentframe().f_code.co_name
    presets_csv_path = get_presets_csv_path(config_file_path, _print)

    try:
        # Determine fieldnames if not provided
        if fieldnames is None:
            if presets_data:
                # Use keys from the first preset as fieldnames
                fieldnames = list(presets_data[0].keys())
                debug_log(f"Derived fieldnames from first preset: {fieldnames}",
                            file=f"{os.path.basename(__file__)} - {current_version}",
                            version=current_version,
                            function=current_function)
            else:
                # If presets_data is empty and no fieldnames provided, use a default set
                fieldnames = [
                    'Filename', 'NickName', 'Start', 'Stop', 'Center', 'Span', 'RBW', 'VBW',
                    'RefLevel', 'Attenuation', 'MaxHold', 'HighSens', 'PreAmp',
                    'Trace1Mode', 'Trace2Mode', 'Trace3Mode', 'Trace4Mode',
                    'Marker1Max', 'Marker2Max', 'Marker3Max', 'Marker4Max',
                    'Marker5Max', 'Marker6Max'
                ]
                debug_log(f"Using default fieldnames as presets_data is empty: {fieldnames}",
                            file=f"{os.path.basename(__file__)} - {current_version}",
                            version=current_version,
                            function=current_function)

        # Ensure all dictionaries in presets_data have all keys defined in fieldnames
        # and convert values to strings, handling NaN
        cleaned_presets_data = []
        for preset in presets_data:
            cleaned_preset = {}
            for field in fieldnames:
                value = preset.get(field, '') # Get value, default to empty string if key is missing
                if pd.isna(value):
                    cleaned_preset[field] = '' # Replace NaN with empty string
                elif isinstance(value, (float, np.float64)) and value.is_integer():
                    cleaned_preset[field] = str(int(value))
                else:
                    cleaned_preset[field] = str(value) # Ensure all values are strings
            cleaned_presets_data.append(cleaned_preset)

        with open(presets_csv_path, 'w', newline='', encoding='utf-8') as csvfile:
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()
            writer.writerows(cleaned_presets_data)
        
        debug_log(f"Successfully overwrote PRESETS.CSV at: {presets_csv_path} with {len(cleaned_presets_data)} entries.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        return True
    except Exception as e:
        _print(f"❌ An unexpected error occurred overwriting presets: {e}. What a mess!")
        debug_log(f"An unexpected error occurred overwriting presets to {presets_csv_path}: {e}.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        return False


#####################################
### File: OPEN-AIR\Presets\utils_preset_query_and_load.py
#####################################
# utils/utils_preset_query_and_load.py
#
# This module provides utility functions for querying available presets from the
# connected instrument and loading selected presets (both device and user-defined).
# It abstracts the low-level SCPI commands for preset management and integrates
# with the GUI's state to update settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.173331.1
# UPDATED: The load_selected_preset_logic now correctly uses the YakSet and YakDo functions
#          to set all the instrument's values from a preset, ensuring a complete and
#          reliable state update.

import pyvisa
import time
import inspect
import os
from datetime import datetime
import csv
import pandas as pd

from display.debug_logic import debug_log, log_visa_command
from display.console_logic import console_log
from Instrument.connection.instrument_logic import query_current_settings_logic
from yak.Yakety_Yak import YakGet, YakSet, YakDo, query_safe, write_safe
from ref.ref_frequency_bands import MHZ_TO_HZ as MHZ_TO_HZ_CONVERSION

# --- Versioning ---
w = 20250821
x_str = '173331'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = f"{os.path.basename(__file__)}"


def query_device_presets_logic(app_instance, console_print_func):
    """
    Queries the connected instrument for available presets and returns their names.
    This function is specifically for device-stored presets (e.g., from :MMEMory:CATalog:STATe?).

    Inputs:
        app_instance (App): The main application instance.
        console_print_func (function): Function to print messages to the GUI console.
    Outputs:
        list: A list of preset names (strings) found on the instrument.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log("Querying device presets from instrument...",
                file=current_file,
                version=current_version,
                function=current_function)

    if not app_instance.inst:
        console_print_func("❌ No instrument connected. Cannot query device presets.")
        debug_log("No instrument connected. Aborting device preset query.",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return []

    if hasattr(app_instance, 'connected_instrument_model') and \
       app_instance.connected_instrument_model.get() != "N9342CN":
        console_print_func("⚠️ Device is not N9342CN. Cannot query device presets (feature limited to N9342CN).")
        debug_log("Device is not N9342CN. Aborting device preset query.",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return []

    try:
        response = query_safe(app_instance.inst, ":MMEMory:CATalog:STATe?", console_print_func)
        if response:
            preset_names = [name.strip().strip('"') for name in response.split(',') if name.strip()]
            console_print_func(f"✅ Found {len(preset_names)} device presets.")
            debug_log(f"Device presets found: {preset_names}.",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return preset_names
        else:
            console_print_func("ℹ️ No device presets found or query failed.")
            debug_log("No device presets found or query returned empty response.",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return []
    except Exception as e:
        console_print_func(f"❌ Error querying device presets: {e}. This is a disaster!")
        debug_log(f"Error querying device presets: {e}. Fucking hell!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return []


def load_selected_preset_logic(app_instance, selected_preset_name, console_print_func, is_device_preset=True, preset_data_dict=None):
    """
    Loads a selected preset (either from device or local CSV) onto the instrument
    and updates the GUI's settings variables.

    Inputs:
        app_instance (App): The main application instance.
        selected_preset_name (str): The name of the preset to load.
        console_print_func (function): Function to print messages to the GUI console.
        is_device_preset (bool): True if loading a device preset, False for a local user preset.
        preset_data_dict (dict, optional): For local presets, the dictionary containing
                                           the preset's data. Not used for device presets.

    Outputs:
        bool: True if load was successful, False otherwise.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Attempting to load preset: '{selected_preset_name}'. Is Device Preset: {is_device_preset}.",
                file=current_file,
                version=current_version,
                function=current_function)

    try:
        if is_device_preset:
            if not app_instance.inst:
                console_print_func("❌ No instrument connected. Cannot load device preset.")
                debug_log("No instrument connected. Aborting device preset load.",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return False

            if hasattr(app_instance, 'connected_instrument_model') and \
               app_instance.connected_instrument_model.get() != "N9342CN":
                console_print_func("⚠️ Device is not N9342CN. Cannot load device presets (feature limited to N9342CN).")
                debug_log("Device is not N9342CN. Aborting device preset load.",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return False

            load_command = f":MMEMory:LOAD:STATe \"{selected_preset_name}\""
            if write_safe(app_instance.inst, load_command, console_print_func):
                console_print_func(f"✅ Device preset '{selected_preset_name}' loaded to instrument.")
                debug_log(f"Device preset '{selected_preset_name}' loaded to instrument.",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                
                settings = query_current_settings_logic(app_instance, console_print_func)
                
                if settings:
                    center_freq_hz = settings.get('center_freq_hz', 0.0)
                    span_hz = settings.get('span_hz', 0.0)
                    rbw_hz = settings.get('rbw_hz', 0.0)

                    app_instance.center_freq_mhz_var.set(center_freq_hz / MHZ_TO_HZ_CONVERSION)
                    app_instance.span_freq_mhz_var.set(span_hz / MHZ_TO_HZ_CONVERSION)
                    app_instance.rbw_mhz_var.set(rbw_hz / MHZ_TO_HZ_CONVERSION)
                    
                    console_print_func(f"GUI settings updated from device preset: Center Freq={center_freq_hz / MHZ_TO_HZ_CONVERSION:.3f} MHz, Span={span_hz / MHZ_TO_HZ_CONVERSION:.3f} MHz, RBW={rbw_hz / 1000:.1f} kHz. Looking good!")
                    debug_log(f"GUI settings updated from loaded device preset.",
                                file=current_file,
                                version=current_version,
                                function=current_function)
                    return True
                else:
                    console_print_func("❌ Failed to query settings after loading device preset. This is frustrating!")
                    debug_log("Failed to query settings after loading device preset. What a pain!",
                                file=current_file,
                                version=current_version,
                                function=current_function)
                    return False
            else:
                console_print_func(f"❌ Failed to load device preset '{selected_preset_name}'. This is frustrating!")
                debug_log(f"Failed to load device preset '{selected_preset_name}'. What a pain!",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return False
        else:
            if preset_data_dict:
                from Presets.utils_push_preset import push_preset_logic
                return push_preset_logic(app_instance, console_print_func, preset_data_dict)
            else:
                console_print_func(f"❌ Failed to load local preset '{selected_preset_name}'. Preset data not provided.")
                debug_log(f"Failed to load local preset '{selected_preset_name}'. Preset data dictionary is missing.",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return False

    except Exception as e:
        console_print_func(f"❌ An unexpected error occurred in load_selected_preset_logic: {e}. This is a disaster!")
        debug_log(f"An unexpected error occurred in load_selected_preset_logic: {e}. Fucking hell!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return False


def query_current_instrument_settings_for_preset(inst, console_print_func=None):
    """
    Function Description:
    Queries and returns the current Center Frequency, Span, and RBW from the instrument.

    Inputs:
        inst (pyvisa.resources.Resource): The connected VISA instrument object.
        console_print_func (function, optional): Function to print to the GUI console.
                                               Defaults to console_log if None.
    Outputs:
        tuple: (center_freq_mhz, span_mhz, rbw_hz) or (None, None, None) on failure.
    """
    console_print_func = console_print_func if console_print_func else console_log
    current_function = inspect.currentframe().f_code.co_name
    debug_log("Querying current instrument settings... Let's see what's happening!",
                file=current_file,
                version=current_version,
                function=current_function)

    if not inst:
        debug_log("No instrument connected to query settings. Fucking useless!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        console_print_func("⚠️ Warning: No instrument connected. Cannot query settings. Connect the damn thing first!")
        return None, None, None

    center_freq_hz = None
    span_hz = None
    rbw_hz = None

    try:
        center_freq_str = query_safe(inst, ":SENSe:FREQuency:CENTer?", console_print_func)
        if center_freq_str:
            center_freq_hz = float(center_freq_str)

        span_str = query_safe(inst, ":SENSe:FREQuency:SPAN?", console_print_func)
        if span_str:
            span_hz = float(span_str)

        rbw_str = query_safe(inst, ":SENSe:BANDwidth:RESolution?", console_print_func)
        if rbw_str:
            rbw_hz = float(rbw_str)

        center_freq_mhz = center_freq_hz / 1_000_000 if center_freq_hz is not None else None
        span_mhz = span_hz / 1_000_000 if span_hz is not None else None

        debug_log(f"Queried settings: Center Freq: {center_freq_mhz:.3f} MHz, Span: {span_mhz:.3f} MHz, RBW: {rbw_hz} Hz. Got the info!",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        console_print_func(f"✅ Queried settings: C: {center_freq_mhz:.3f} MHz, SP: {span_mhz:.3f} MHz, RBW: {rbw_hz / 1000:.1f} kHz. Details acquired!")

        return center_freq_mhz, span_mhz, rbw_hz

    except Exception as e:
        debug_log(f"❌ Error querying current instrument settings: {e}. What a mess!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        console_print_func(f"❌ Error querying current instrument settings: {e}. This is a disaster!")
        return None, None, None

#####################################
### File: OPEN-AIR\Presets\utils_presets_editor.py
#####################################
# tabs/Presets/utils_presets_editor.py
#
# This file provides utility functions and classes for managing user-defined
# presets. It handles loading, saving, importing, exporting, and manipulating
# presets data in a decoupled way from the GUI elements.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250814.162500.1 (REBUILT: Extracted all logic from PresetEditorTab to separate data from the GUI.)

current_version = "20250814.162500.1"
current_version_hash = 20250814 * 162500 * 1

import inspect
import os
import csv
from datetime import datetime
import shutil
import pandas as pd
import numpy as np

from display.debug_logic import debug_log
from display.console_logic import console_log
from .utils_preset_csv_process import (
    get_presets_csv_path,
    load_user_presets_from_csv,
    overwrite_user_presets_csv
)
from Instrument.connection.instrument_logic import query_current_settings_logic
from ref.ref_file_paths import PRESETS_FILE_PATH

class PresetEditorLogic:
    def __init__(self, app_instance, console_print_func, columns):
        self.app_instance = app_instance
        self.console_print_func = console_print_func
        self.columns = columns
        self.presets_data = []
        self.has_unsaved_changes = False

    def load_presets(self):
        """Loads presets from the CSV file into memory."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log("Loading presets from CSV into memory.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        self.presets_data = load_user_presets_from_csv(PRESETS_FILE_PATH, self.console_print_func)
        self.has_unsaved_changes = False

    def save_presets(self):
        """Saves the current presets in memory to the CSV file."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log("Saving all presets from memory to PRESETS.CSV.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        fieldnames_for_save = [col.split(' ')[0] for col in self.columns]
        if overwrite_user_presets_csv(self.app_instance.CONFIG_FILE_PATH, self.presets_data, self.console_print_func, fieldnames=fieldnames_for_save):
            self.has_unsaved_changes = False
            return True
        return False

    def add_current_settings(self):
        """Queries current instrument settings and adds them as a new preset."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log("Attempting to add current settings.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)

        if not self.app_instance.inst:
            self.console_print_func("❌ No instrument connected. Cannot get current settings. Connect first!")
            return False

        current_settings = query_current_settings_logic(self.app_instance, self.console_print_func)
        if current_settings:
            timestamp_filename = datetime.now().strftime('%Y%m%d_%H%M%S')
            timestamp_nickname = datetime.now().strftime('%Y%m%d %H%M')

            center_freq_mhz = current_settings.get('center_freq_mhz')
            span_mhz = current_settings.get('span_mhz')
            start_freq_mhz = center_freq_mhz - (span_mhz / 2) if center_freq_mhz is not None and span_mhz is not None else ''
            stop_freq_mhz = center_freq_mhz + (span_mhz / 2) if center_freq_mhz is not None and span_mhz is not None else ''

            new_preset = {
                'Filename': f"USER_{timestamp_filename}.STA",
                'NickName': f"Device {timestamp_nickname}",
                'Start': f"{start_freq_mhz:.3f}" if isinstance(start_freq_mhz, (int, float)) else '',
                'Stop': f"{stop_freq_mhz:.3f}" if isinstance(stop_freq_mhz, (int, float)) else '',
                'Center': f"{center_freq_mhz:.3f}" if isinstance(center_freq_mhz, (int, float)) else '',
                'Span': f"{span_mhz:.3f}" if isinstance(span_mhz, (int, float)) else '',
                'RBW': f"{current_settings.get('rbw_hz'):.0f}" if isinstance(current_settings.get('rbw_hz'), (int, float)) else '',
                'VBW': f"{current_settings.get('vbw_hz'):.0f}" if isinstance(current_settings.get('vbw_hz'), (int, float)) else '',
                'RefLevel': f"{current_settings.get('ref_level_dbm'):.1f}" if isinstance(current_settings.get('ref_level_dbm'), (int, float)) else '',
                'Attenuation': f"{current_settings.get('attenuation_db'):.0f}" if isinstance(current_settings.get('attenuation_db'), (int, float)) else '',
                'MaxHold': 'ON' if current_settings.get('maxhold_enabled') else 'OFF',
                'HighSens': 'ON' if current_settings.get('high_sensitivity_on') else 'OFF',
                'PreAmp': 'ON' if current_settings.get('preamp_on') else 'OFF',
                'Trace1Mode': current_settings.get('trace1_mode', ''),
                'Trace2Mode': current_settings.get('trace2_mode', ''),
                'Trace3Mode': current_settings.get('trace3_mode', ''),
                'Trace4Mode': current_settings.get('trace4_mode', ''),
                'Marker1Max': 'WRITE' if current_settings.get('marker1_calc_max') else '',
                'Marker2Max': 'WRITE' if current_settings.get('marker2_calc_max') else '',
                'Marker3Max': 'WRITE' if current_settings.get('marker3_calc_max') else '',
                'Marker4Max': 'WRITE' if current_settings.get('marker4_calc_max') else '',
                'Marker5Max': 'WRITE' if current_settings.get('marker5_calc_max') else '',
                'Marker6Max': 'WRITE' if current_settings.get('marker6_calc_max') else '',
            }
            self.presets_data.append(new_preset)
            self.has_unsaved_changes = True
            self.console_print_func("✅ Current instrument settings added as a new preset. Remember to save your changes!")
            return True
        else:
            self.console_print_func("❌ Failed to query all current settings from instrument. Some values were missing.")
            return False

    def add_new_empty_row(self):
        """Adds a new empty row to the presets list with default values."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log("Adding new empty row.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)

        new_empty_preset = {col.split(' ')[0]: '' for col in self.columns}
        new_empty_preset['Filename'] = f"NEW_{datetime.now().strftime('%Y%m%d_%H%M%S')}.STA"
        new_empty_preset['NickName'] = "New Preset"
        new_empty_preset['Start'] = "100.0"
        new_empty_preset['Stop'] = "200.0"
        new_empty_preset['Center'] = "150.0"
        new_empty_preset['Span'] = "100.0"
        new_empty_preset['RBW'] = "100000.0"
        self.presets_data.append(new_empty_preset)
        self.has_unsaved_changes = True
        self.console_print_func("✅ New empty row added. Remember to save your changes!")
        return True

    def delete_presets(self, selected_filenames):
        """Deletes selected presets from the list."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Deleting presets: {selected_filenames}.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        initial_len = len(self.presets_data)
        self.presets_data = [p for p in self.presets_data if p.get('Filename') not in selected_filenames]
        deleted_count = initial_len - len(self.presets_data)
        
        if deleted_count > 0:
            self.has_unsaved_changes = True
            self.console_print_func(f"✅ Deleted {deleted_count} preset(s). Automatically saving changes...")
            return True
        return False
        
    def update_preset_value(self, filename, column_name, new_value):
        """Updates a single value in a preset."""
        current_function = inspect.currentframe().f_code.co_name
        for preset in self.presets_data:
            if preset.get('Filename') == filename:
                if str(preset.get(column_name, '')) != new_value:
                    preset[column_name] = new_value
                    self.has_unsaved_changes = True
                    self.console_print_func(f"✅ Updated '{column_name}' for '{preset.get('NickName', filename)}' to '{new_value}'. Automatically saving changes!")
                    return True
        return False

    def import_presets(self, file_path):
        """Imports presets from a CSV file, replacing current data."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Importing presets from {file_path}.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        try:
            df_imported = pd.read_csv(file_path)
            imported_presets = df_imported.to_dict(orient='records')
            
            for preset in imported_presets:
                for key, value in preset.items():
                    if pd.isna(value):
                        preset[key] = ''
                    elif isinstance(value, (float, np.float64)) and value.is_integer():
                        preset[key] = str(int(value))
                    else:
                        preset[key] = str(value)
            
            self.presets_data = imported_presets
            self.has_unsaved_changes = True
            self.console_print_func(f"✅ Successfully imported {len(imported_presets)} presets. Automatically saving changes...")
            return True
        except Exception as e:
            self.console_print_func(f"❌ Error importing presets: {e}. Check file format.")
            return False

    def export_presets(self, file_path):
        """Exports the current presets data to a new CSV file."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Exporting presets to {file_path}.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)

        if not self.presets_data:
            self.console_print_func("⚠️ No presets to export. Add some first!")
            return False

        try:
            fieldnames = [col.split(' ')[0] for col in self.columns]
            with open(file_path, 'w', newline='', encoding='utf-8') as csvfile:
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                writer.writeheader()
                for preset in self.presets_data:
                    row_to_write = {field: preset.get(field, '') for field in fieldnames}
                    writer.writerow(row_to_write)
            self.console_print_func(f"✅ Successfully exported {len(self.presets_data)} presets to {os.path.basename(file_path)}.")
            return True
        except Exception as e:
            self.console_print_func(f"❌ Error exporting presets: {e}. This is a disaster!")
            return False
            
    def move_preset_up(self, filename):
        """Moves a preset one position up."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Moving preset '{filename}' up.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        for i, p in enumerate(self.presets_data):
            if p.get('Filename') == filename:
                if i > 0:
                    self.presets_data[i-1], self.presets_data[i] = self.presets_data[i], self.presets_data[i-1]
                    self.has_unsaved_changes = True
                    return True
                break
        return False

    def move_preset_down(self, filename):
        """Moves a preset one position down."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Moving preset '{filename}' down.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)

        for i, p in enumerate(self.presets_data):
            if p.get('Filename') == filename:
                if i < len(self.presets_data) - 1:
                    self.presets_data[i], self.presets_data[i+1] = self.presets_data[i+1], self.presets_data[i]
                    self.has_unsaved_changes = True
                    return True
                break
        return False


#####################################
### File: OPEN-AIR\Presets\utils_push_preset.py
#####################################
# tabs/Presets/utils_push_preset.py
#
# This file contains the logic for pushing saved preset settings to the connected instrument.
# It retrieves settings from the application instance and sends the appropriate SCPI commands.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.173331.1
# UPDATED: The push_preset_logic now correctly uses YakSet and YakDo with proper command types
#          and includes all missing preset variables and trace configurations.

import os
import inspect
import re

from display.debug_logic import debug_log
from display.console_logic import console_log

from yak.Yakety_Yak import YakSet, YakDo
from ref.ref_frequency_bands import MHZ_TO_HZ

# --- Versioning ---
w = 20250821
x_str = '173331'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = f"{os.path.basename(__file__)}"


def push_preset_logic(app_instance, console_print_func, preset_data):
    """
    Function Description:
    Applies the current settings from the GUI (or a provided preset_data dictionary)
    to the connected instrument using the Yak command protocol.

    Inputs:
    - app_instance: The main application instance, used to access Tkinter variables and retrieve settings.
    - console_print_func: A function to print messages to the GUI console.
    - preset_data (dict): A dictionary containing the preset settings to apply.
                          Keys should match the CSV headers (e.g., 'Center', 'Span', 'RBW').

    Process:
    1. Logs the start of applying settings.
    2. Checks if an instrument is connected.
    3. Retrieves settings from the provided preset_data dictionary.
    4. Converts frequency values (Center, Span) from MHz to Hz for SCPI commands.
    5. Sends SCPI commands to the instrument using YakSet and YakDo.
    6. Handles model-specific commands (e.g., for N9340B/N9342CN).
    7. Logs success or failure.

    Outputs:
    - True if settings are applied successfully, False otherwise.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Applying settings to instrument with the Yak Attack! Version: {current_version}",
                file=current_file,
                version=current_version,
                function=current_function)

    if not app_instance.inst:
        console_print_func("❌ No instrument connected. Please connect to an instrument first. What are you doing?!")
        debug_log("No instrument connected. Cannot apply settings.",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return False

    success = True
    try:
        center_freq_mhz_str = preset_data.get('Center', '').strip()
        center_freq_hz = float(center_freq_mhz_str) * MHZ_TO_HZ if center_freq_mhz_str else None

        span_mhz_str = preset_data.get('Span', '').strip()
        span_hz = float(span_mhz_str) * MHZ_TO_HZ if span_mhz_str else None

        rbw_hz_str = preset_data.get('RBW', '').strip()
        rbw_hz = float(rbw_hz_str) if rbw_hz_str else None

        vbw_hz_str = preset_data.get('VBW', '').strip()
        vbw_hz = float(vbw_hz_str) if vbw_hz_str else None

        ref_level_str = preset_data.get('RefLevel', '').strip()
        reference_level_dbm = ref_level_str if ref_level_str else None

        attenuation_str = preset_data.get('Attenuation', '').strip()
        attenuation_db = int(attenuation_str) if attenuation_str else None

        maxhold_str = preset_data.get('MaxHold', '').strip()
        maxhold_enabled = maxhold_str.upper() == 'ON' if maxhold_str else None

        high_sensitivity_str = preset_data.get('HighSens', '').strip()
        high_sensitivity_on = high_sensitivity_str.upper() == 'ON' if high_sensitivity_str else None

        preamp_str = preset_data.get('PreAmp', '').strip()
        preamp_on = preamp_str.upper() == 'ON' if preamp_str else None

        trace1_mode = preset_data.get('Trace1Mode', '').strip()
        trace2_mode = preset_data.get('Trace2Mode', '').strip()
        trace3_mode = preset_data.get('Trace3Mode', '').strip()
        trace4_mode = preset_data.get('Trace4Mode', '').strip()

        marker1_max = preset_data.get('Marker1Max', '').strip()
        marker2_max = preset_data.get('Marker2Max', '').strip()
        marker3_max = preset_data.get('Marker3Max', '').strip()
        marker4_max = preset_data.get('Marker4Max', '').strip()
        marker5_max = preset_data.get('Marker5Max', '').strip()
        marker6_max = preset_data.get('Marker6Max', '').strip()

        console_print_func("💬 Applying settings to instrument using Yak commands...")

        if center_freq_hz is not None:
            if YakSet(app_instance, "FREQUENCY/CENTER", str(int(center_freq_hz)), console_print_func) == "FAILED": success = False
            debug_log(f"Applied Center Frequency: {int(center_freq_hz)} Hz.", file=current_file, version=current_version, function=current_function)
        if span_hz is not None:
            if YakSet(app_instance, "FREQUENCY/SPAN", str(int(span_hz)), console_print_func) == "FAILED": success = False
            debug_log(f"Applied Span Frequency: {int(span_hz)} Hz.", file=current_file, version=current_version, function=current_function)
        if attenuation_db is not None:
            if YakSet(app_instance, "AMPLITUDE/POWER/ATTENUATION", str(attenuation_db), console_print_func) == "FAILED": success = False
            debug_log(f"Applied Attenuation: {attenuation_db} dB.", file=current_file, version=current_version, function=current_function)

        if rbw_hz is not None:
            if YakSet(app_instance, "BANDWIDTH/RESOLUTION", str(int(rbw_hz)), console_print_func) == "FAILED": success = False
            debug_log(f"Applied RBW: {int(rbw_hz)} Hz.", file=current_file, version=current_version, function=current_function)
        if vbw_hz is not None:
            if YakSet(app_instance, "BANDWIDTH/VIDEO", str(int(vbw_hz)), console_print_func) == "FAILED": success = False
            debug_log(f"Applied VBW: {int(vbw_hz)} Hz.", file=current_file, version=current_version, function=current_function)

        if reference_level_dbm is not None:
            if YakDo(app_instance, f"AMPLITUDE/REFERENCE LEVEL/{reference_level_dbm}", console_print_func) == "FAILED": success = False
            debug_log(f"Applied Reference Level: {reference_level_dbm} dBm.", file=current_file, version=current_version, function=current_function)

        if high_sensitivity_on is not None:
            if YakSet(app_instance, "AMPLITUDE/POWER/HIGH SENSITIVE", 'ON' if high_sensitivity_on else 'OFF', console_print_func) == "FAILED": success = False
            debug_log(f"Applied High Sensitivity: {'ON' if high_sensitivity_on else 'OFF'}.", file=current_file, version=current_version, function=current_function)
        if preamp_on is not None:
            if YakSet(app_instance, "AMPLITUDE/POWER/GAIN", 'ON' if preamp_on else 'OFF', console_print_func) == "FAILED": success = False
            debug_log(f"Applied Preamp: {'ON' if preamp_on else 'OFF'}.", file=current_file, version=current_version, function=current_function)
        
        if trace1_mode:
            if YakDo(app_instance, f"TRACE/1/MODE/{trace1_mode}", console_print_func) == "FAILED": success = False
            debug_log(f"Applied Trace 1 Mode: {trace1_mode}.", file=current_file, version=current_version, function=current_function)
        if trace2_mode:
            if YakDo(app_instance, f"TRACE/2/MODE/{trace2_mode}", console_print_func) == "FAILED": success = False
            debug_log(f"Applied Trace 2 Mode: {trace2_mode}.", file=current_file, version=current_version, function=current_function)
        if trace3_mode:
            if YakDo(app_instance, f"TRACE/3/MODE/{trace3_mode}", console_print_func) == "FAILED": success = False
            debug_log(f"Applied Trace 3 Mode: {trace3_mode}.", file=current_file, version=current_version, function=current_function)
        if trace4_mode:
            if YakDo(app_instance, f"TRACE/4/MODE/{trace4_mode}", console_print_func) == "FAILED": success = False
            debug_log(f"Applied Trace 4 Mode: {trace4_mode}.", file=current_file, version=current_version, function=current_function)

        if marker1_max:
            if YakSet(app_instance, "MARKER/1/CALCULATE/MAX", 'ON' if marker1_max.upper() == 'WRITE' else 'OFF', console_print_func) == "FAILED": success = False
            debug_log(f"Applied Marker 1 Max: {marker1_max}.", file=current_file, version=current_version, function=current_function)
        if marker2_max:
            if YakSet(app_instance, "MARKER/2/CALCULATE/MAX", 'ON' if marker2_max.upper() == 'WRITE' else 'OFF', console_print_func) == "FAILED": success = False
            debug_log(f"Applied Marker 2 Max: {marker2_max}.", file=current_file, version=current_version, function=current_function)
        if marker3_max:
            if YakSet(app_instance, "MARKER/3/CALCULATE/MAX", 'ON' if marker3_max.upper() == 'WRITE' else 'OFF', console_print_func) == "FAILED": success = False
            debug_log(f"Applied Marker 3 Max: {marker3_max}.", file=current_file, version=current_version, function=current_function)
        if marker4_max:
            if YakSet(app_instance, "MARKER/4/CALCULATE/MAX", 'ON' if marker4_max.upper() == 'WRITE' else 'OFF', console_print_func) == "FAILED": success = False
            debug_log(f"Applied Marker 4 Max: {marker4_max}.", file=current_file, version=current_version, function=current_function)
        if marker5_max:
            if YakSet(app_instance, "MARKER/5/CALCULATE/MAX", 'ON' if marker5_max.upper() == 'WRITE' else 'OFF', console_print_func) == "FAILED": success = False
            debug_log(f"Applied Marker 5 Max: {marker5_max}.", file=current_file, version=current_version, function=current_function)
        if marker6_max:
            if YakSet(app_instance, "MARKER/6/CALCULATE/MAX", 'ON' if marker6_max.upper() == 'WRITE' else 'OFF', console_print_func) == "FAILED": success = False
            debug_log(f"Applied Marker 6 Max: {marker6_max}.", file=current_file, version=current_version, function=current_function)


        if success:
            console_print_func("✅ All settings applied successfully. Boom!")
            debug_log("All settings applied to instrument. Fucking awesome!",
                        file=current_file,
                        version=current_version,
                        function=current_function)
        else:
            console_print_func("❌ Failed to apply all settings. This thing is a pain in the ass!")
            debug_log("Failed to apply all settings.",
                        file=current_file,
                        version=current_version,
                        function=current_function)

        return success
    except ValueError as e:
        console_print_func(f"❌ Invalid setting value: {e}. Please check your inputs. You entered some garbage!")
        debug_log(f"ValueError applying settings: {e}. User entered some crap.",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return False
    except Exception as e:
        console_print_func(f"❌ An unexpected error occurred while applying settings: {e}. This thing is a pain in the ass!")
        debug_log(f"An unexpected error occurred applying settings: {e}. Fucking hell!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return False

#####################################
### File: OPEN-AIR\process_math\__init__ .py
#####################################


#####################################
### File: OPEN-AIR\process_math\averaging_utils.py
#####################################
# averaging_utils.py
#
# This module provides utility functions for processing and analyzing collected
# spectrum analyzer data. It includes functionalities for calculating various
# statistical measures such as average, median, range, standard deviation,
# variance, and power spectral density (PSD) from multiple scan cycles.
# It is crucial for generating insightful plots and CSV reports from the raw scan data.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
# Version 20250802.0055.1 (Refactored debug_print to debug_log; updated imports and flair.)

current_version = "20250802.0055.1" # this variable should always be defined below the header to make the debugging better
current_version_hash = 20250802 * 55 * 1 # Example hash, adjust as needed

import pandas as pd
import numpy as np # Ensure numpy is imported for std, var, and log10
import os
import csv
from datetime import datetime
import re
import platform # For opening folder cross-platform
import inspect # Import inspect module

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log

# Import plotting functions and constants
from Plotting.utils_plotting import plot_multi_trace_data, _open_plot_in_browser
from ref.ref_frequency_bands import (
    MHZ_TO_HZ,
    TV_PLOT_BAND_MARKERS,
    GOV_PLOT_BAND_MARKERS
)

# --- Helper Functions for Calculations and Folder Management ---

def _create_output_subfolder(base_output_dir, prefix, timestamp_str, console_print_func=None):
    """
    Function Description:
    Creates a new subfolder for scan outputs based on a prefix and timestamp.

    Inputs:
        base_output_dir (str): The base directory where the subfolder will be created.
        prefix (str): A descriptive prefix for the subfolder name (e.g., scan name, group name).
        timestamp_str (str): A timestamp string (e.g., YYYYMMDD_HHMMSS) for uniqueness.
        console_print_func (function, optional): Function to print messages to the GUI console.
                                               Defaults to console_log if None.

    Process of this function:
    1. Constructs the full path for the new subfolder.
    2. Creates the directory using `os.makedirs(exist_ok=True)`.
    3. Logs the creation of the subfolder to the console and debug log.

    Outputs of this function:
        str: The full path to the newly created subfolder.
    """
    console_print_func = console_print_func if console_print_func else console_log # Use console_log as default
    current_function = inspect.currentframe().f_code.co_name
    current_file = __file__
    debug_log(f"Entering {current_function}. Preparing to create output subfolder! Version: {current_version}",
                file=current_file, version=current_version, function=current_function)

    subfolder_name = f"{prefix}_{timestamp_str}"
    output_dir_full = os.path.join(base_output_dir, subfolder_name)
    os.makedirs(output_dir_full, exist_ok=True)
    console_print_func(f"Created output subfolder: {output_dir_full}")
    debug_log(f"Created output subfolder: {output_dir_full}. Ready for data!",
                file=current_file, version=current_version, function=current_function)
    debug_log(f"Exiting {current_function}. Subfolder created successfully! Version: {current_version}",
                file=current_file, version=current_version, function=current_function)
    return output_dir_full

def _calculate_average(power_levels_df, console_print_func=None):
    """
    Function Description:
    Calculates the average power levels across all traces in the DataFrame.

    Inputs:
    - power_levels_df (pandas.DataFrame): DataFrame where each column represents a scan trace
                                          and rows are frequency points.
    - console_print_func (function, optional): Function to print messages to the GUI console.
                                               Defaults to console_log if None.

    Process of this function:
    1. Calculates the mean across rows (axis=1) of the input DataFrame.
    2. Logs the calculation and a sample of the results.

    Outputs of this function:
    - pandas.Series: A Series containing the average power level for each frequency point.
    """
    console_print_func = console_print_func if console_print_func else console_log # Use console_log as default
    current_function = inspect.currentframe().f_code.co_name
    current_file = __file__
    debug_log(f"Entering {current_function}. Calculating average power levels! Version: {current_version}",
                file=current_file, version=current_version, function=current_function)
    average_levels = power_levels_df.mean(axis=1)
    debug_log(f"Calculated Average. First 5 values: {average_levels.head().tolist()}. Looking good!",
                file=current_file, version=current_version, function=current_function)
    debug_log(f"Exiting {current_function}. Average calculation complete! Version: {current_version}",
                file=current_file, version=current_version, function=current_function)
    return average_levels

def _calculate_median(power_levels_df, console_print_func=None):
    """
    Function Description:
    Calculates the median power levels across all traces in the DataFrame.

    Inputs:
    - power_levels_df (pandas.DataFrame): DataFrame where each column represents a scan trace
                                          and rows are frequency points.
    - console_print_func (function, optional): Function to print messages to the GUI console.
                                               Defaults to console_log if None.

    Process of this function:
    1. Calculates the median across rows (axis=1) of the input DataFrame.
    2. Logs the calculation and a sample of the results.

    Outputs of this function:
    - pandas.Series: A Series containing the median power level for each frequency point.
    """
    console_print_func = console_print_func if console_print_func else console_log # Use console_log as default
    current_function = inspect.currentframe().f_code.co_name
    current_file = __file__
    debug_log(f"Entering {current_function}. Calculating median power levels! Version: {current_version}",
                file=current_file, version=current_version, function=current_function)
    median_levels = power_levels_df.median(axis=1)
    debug_log(f"Calculated Median. First 5 values: {median_levels.head().tolist()}. Spot on!",
                file=current_file, version=current_version, function=current_function)
    debug_log(f"Exiting {current_function}. Median calculation complete! Version: {current_version}",
                file=current_file, version=current_version, function=current_function)
    return median_levels

def _calculate_range(power_levels_df, console_print_func=None):
    """
    Function Description:
    Calculates the range (max - min) of power levels across all traces in the DataFrame.

    Inputs:
    - power_levels_df (pandas.DataFrame): DataFrame where each column represents a scan trace
                                          and rows are frequency points.
    - console_print_func (function, optional): Function to print messages to the GUI console.
                                               Defaults to console_log if None.

    Process of this function:
    1. Calculates the maximum and minimum across rows (axis=1).
    2. Subtracts min from max to get the range.
    3. Logs the calculation and a sample of the results.

    Outputs of this function:
    - pandas.Series: A Series containing the range of power levels for each frequency point.
    """
    console_print_func = console_print_func if console_print_func else console_log # Use console_log as default
    current_function = inspect.currentframe().f_code.co_name
    current_file = __file__
    debug_log(f"Entering {current_function}. Calculating power level range! Version: {current_version}",
                file=current_file, version=current_version, function=current_function)
    range_levels = power_levels_df.max(axis=1) - power_levels_df.min(axis=1)
    debug_log(f"Calculated Range. First 5 values: {range_levels.head().tolist()}. Getting the spread!",
                file=current_file, version=current_version, function=current_function)
    debug_log(f"Exiting {current_function}. Range calculation complete! Version: {current_version}",
                file=current_file, version=current_version, function=current_function)
    return range_levels

def _calculate_std_dev(power_levels_df, console_print_func=None):
    """
    Function Description:
    Calculates the standard deviation of power levels across all traces in the DataFrame.

    Inputs:
    - power_levels_df (pandas.DataFrame): DataFrame where each column represents a scan trace
                                          and rows are frequency points.
    - console_print_func (function, optional): Function to print messages to the GUI console.
                                               Defaults to console_log if None.

    Process of this function:
    1. Calculates the standard deviation across rows (axis=1) of the input DataFrame.
    2. Logs the calculation and a sample of the results.

    Outputs of this function:
    - pandas.Series: A Series containing the standard deviation of power levels for each frequency point.
    """
    console_print_func = console_print_func if console_print_func else console_log # Use console_log as default
    current_function = inspect.currentframe().f_code.co_name
    current_file = __file__
    debug_log(f"Entering {current_function}. Calculating standard deviation! Version: {current_version}",
                file=current_file, version=current_version, function=current_function)
    std_dev_levels = power_levels_df.std(axis=1)
    debug_log(f"Calculated Std Dev. First 5 values: {std_dev_levels.head().tolist()}. Measuring consistency!",
                file=current_file, version=current_version, function=current_function)
    debug_log(f"Exiting {current_function}. Standard deviation calculation complete! Version: {current_version}",
                file=current_file, version=current_version, function=current_function)
    return std_dev_levels

def _calculate_variance(power_levels_df, console_print_func=None):
    """
    Function Description:
    Calculates the variance of power levels across all traces in the DataFrame.

    Inputs:
    - power_levels_df (pandas.DataFrame): DataFrame where each column represents a scan trace
                                          and rows are frequency points.
    - console_print_func (function, optional): Function to print messages to the GUI console.
                                               Defaults to console_log if None.

    Process of this function:
    1. Calculates the variance across rows (axis=1) of the input DataFrame.
    2. Logs the calculation and a sample of the results.

    Outputs of this function:
    - pandas.Series: A Series containing the variance of power levels for each frequency point.
    """
    console_print_func = console_print_func if console_print_func else console_log # Use console_log as default
    current_function = inspect.currentframe().f_code.co_name
    current_file = __file__
    debug_log(f"Entering {current_function}. Calculating power level variance! Version: {current_version}",
                file=current_file, version=current_version, function=current_function)
    variance_levels = power_levels_df.var(axis=1)
    debug_log(f"Calculated Variance. First 5 values: {variance_levels.head().tolist()}. Seeing the spread!",
                file=current_file, version=current_version, function=current_function)
    debug_log(f"Exiting {current_function}. Variance calculation complete! Version: {current_version}",
                file=current_file, version=current_version, function=current_function)
    return variance_levels

def _calculate_psd(power_levels_df, rbw_values, console_print_func=None):
    """
    Function Description:
    Calculates the Power Spectral Density (PSD) from power levels and RBW values.
    If multiple traces, calculates PSD for each then averages.

    Inputs:
    - power_levels_df (pandas.DataFrame): DataFrame where each column represents a scan trace
                                          and rows are frequency points.
    - rbw_values (list): A list of RBW values (in Hz), one for each trace in `power_levels_df`.
    - console_print_func (function, optional): Function to print messages to the GUI console.
                                               Defaults to console_log if None.

    Process of this function:
    1. Initializes a Series for PSD levels with NaN.
    2. Checks for valid RBW values. If invalid, logs a warning and returns NaN Series.
    3. Converts power levels from dBm to linear mW.
    4. Iterates through each trace, calculates its PSD, and appends to a list.
    5. If multiple PSD traces are calculated, combines them and takes the mean.
    6. Logs the calculation and a sample of the results.

    Outputs of this function:
    - pandas.Series: A Series containing the calculated PSD for each frequency point.
    """
    console_print_func = console_print_func if console_print_func else console_log # Use console_log as default
    current_function = inspect.currentframe().f_code.co_name
    current_file = __file__
    debug_log(f"Entering {current_function}. Calculating Power Spectral Density! Version: {current_version}",
                file=current_file, version=current_version, function=current_function)
    
    psd_levels = pd.Series([np.nan] * len(power_levels_df.index), index=power_levels_df.index) # Initialize with NaN

    if not rbw_values or all(rbw is None or rbw <= 0 for rbw in rbw_values):
        console_print_func("Warning: Resolution Bandwidth (RBW) not provided or invalid for PSD calculation. PSD will be NaN.")
        debug_log("RBW missing or invalid for PSD calculation. Can't do it!",
                    file=current_file, version=current_version, function=current_function)
        debug_log(f"Exiting {current_function} (invalid RBW). PSD calculation aborted! Version: {current_version}",
                    file=current_file, version=current_version, function=current_function)
        return psd_levels

    linear_power_mW_traces = 10**(power_levels_df / 10)
    psd_traces = []
    
    # Ensure rbw_values matches the number of columns in power_levels_df
    if len(rbw_values) != power_levels_df.shape[1]:
        console_print_func(f"Warning: Number of RBW values ({len(rbw_values)}) does not match number of power traces ({power_levels_df.shape[1]}). Using first RBW for all traces for PSD calculation.")
        debug_log(f"RBW count mismatch. Using first RBW for all traces. Adjusting!",
                    file=current_file, version=current_version, function=current_function)
        # Fallback to using the first valid RBW for all traces if mismatch
        valid_rbw = next((rbw for rbw in rbw_values if rbw is not None and rbw > 0), None)
        if valid_rbw:
            rbw_values = [valid_rbw] * power_levels_df.shape[1]
        else:
            console_print_func("Error: No valid RBW found for PSD calculation. PSD will be NaN.")
            debug_log("No valid RBW found for PSD. This is a problem!",
                        file=current_file, version=current_version, function=current_function)
            return psd_levels
    
    # Ensure all RBW values are valid before proceeding
    if any(rbw is None or rbw <= 0 for rbw in rbw_values):
        console_print_func("Error: One or more RBW values are invalid for PSD calculation. PSD will be NaN.")
        debug_log("Invalid RBW values detected during PSD calculation. Aborting!",
                    file=current_file, version=current_version, function=current_function)
        return psd_levels


    for i, col in enumerate(power_levels_df.columns):
        rbw = rbw_values[i]
        psd_trace = 10 * np.log10(linear_power_mW_traces[col] / rbw)
        psd_traces.append(psd_trace)
        debug_log(f"Calculated PSD for trace {i+1} with RBW {rbw}. Trace processed!",
                    file=current_file, version=current_version, function=current_function)

    if psd_traces:
        combined_psd_df = pd.concat(psd_traces, axis=1)
        psd_levels = combined_psd_df.mean(axis=1)
        debug_log(f"Calculated multi-trace averaged PSD. First 5 values: {psd_levels.head().tolist()}. Done and dusted!",
                    file=current_file, version=current_version, function=current_function)
    else:
        console_print_func("No valid PSD data could be calculated for any trace. PSD column will be NaN.")
        debug_log("No valid PSD data for multi-trace average. Nothing to combine!",
                    file=current_file, version=current_version, function=current_function)

    debug_log(f"Exiting {current_function}. PSD calculation complete! Version: {current_version}",
                file=current_file, version=current_version, function=current_function)
    return psd_levels


def average_scan(
    file_paths,
    selected_avg_types,
    plot_title_prefix,
    output_html_path_base,
    console_print_func=None
):
    """
    Function Description:
    Performs averaging and statistical calculations on a list of scan files
    and saves the results to separate CSV files in a new subfolder.

    Inputs:
        file_paths (list): A list of full paths to the CSV scan files.
        selected_avg_types (list): A list of strings indicating which average types to calculate
                                   (e.g., ["Average", "Median", "PSD (dBm/Hz)"]).
        plot_title_prefix (str): A prefix for the output folder and file names (e.g., "MyScan").
        output_html_path_base (str): The base directory where the new subfolder will be created.
        console_print_func (function, optional): Function to print messages to the GUI console.
                                               Defaults to console_log if None.

    Returns:
        tuple: A tuple containing:
               - pandas.DataFrame: The aggregated DataFrame, or None if an error occurs.
               - str: The full path to the newly created output subfolder, or None if an error occurs.
    """
    console_print_func = console_print_func if console_print_func else console_log # Use console_log as default
    current_function = inspect.currentframe().f_code.co_name
    current_file = __file__
    debug_log(f"Entering {current_function}. Starting multi-file averaging! Version: {current_version}",
                file=current_file, version=current_version, function=current_function)
    debug_log(f"Input file_paths ({len(file_paths)} files): {file_paths}. Ready to process!",
                file=current_file, version=current_version, function=current_function)
    debug_log(f"Input selected_avg_types: {selected_avg_types}. Calculations selected!",
                file=current_file, version=current_version, function=current_function)
    debug_log(f"Input output_html_path_base: {output_html_path_base}. Output destination set!",
                file=current_file, version=current_version, function=current_function)

    if not file_paths:
        console_print_func("No file paths provided for averaging.")
        debug_log("No file paths provided for averaging. Nothing to do!",
                    file=current_file, version=current_version, function=current_function)
        debug_log(f"Exiting {current_function} (no file paths). Averaging aborted! Version: {current_version}",
                    file=current_file, version=current_version, function=current_function)
        return None, None

    # --- Create a new subfolder for this multi-file averaged plot's outputs ---
    timestamp_str = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_dir_full = _create_output_subfolder(
        base_output_dir,
        f"{plot_title_prefix}_AppliedMath", # Prefix for applied math folder
        timestamp_str, # Timestamp for subfolder
        console_print_func
    )
    debug_log(f"Output subfolder created for applied math: {output_dir_full}. Organized and ready!",
                file=current_file, version=current_version, function=current_function)

    all_scans_dfs = []
    # Regex to extract RBW and Offset from filename for PSD calculation and frequency normalization
    filename_pattern = re.compile(
        r'.*_RBW(?P<rbw_val>\d+K?)_HOLD\d+_(?:Offset(?P<offset_val>-?\d+))?_(?P<date_time>\d{8}_\d{6})\.csv$'
    )

    all_frequencies = pd.Series(dtype=float) # To collect all unique frequencies for the master reference

    for df_idx, f_path in enumerate(file_paths):
        debug_log(f"Processing file {df_idx+1}/{len(file_paths)}: {os.path.basename(f_path)}. Reading data!",
                    file=current_file, version=current_version, function=current_function)
        try:
            df = pd.read_csv(f_path, header=None)
            
            if df.shape[1] < 2:
                console_print_func(f"Skipping {os.path.basename(f_path)}: CSV does not contain at least two columns (Frequency, Power). Found {df.shape[1]} columns. Malformed file!")
                debug_log(f"Skipping {os.path.basename(f_path)}: Insufficient columns in CSV. Bad data!",
                            file=current_file, version=current_version, function=current_function)
                continue

            df.columns = ['Frequency (Hz)', 'Power (dBm)']
            debug_log(f"Successfully read CSV: {os.path.basename(f_path)} with implied columns: {df.columns.tolist()}. Data loaded!",
                        file=current_file, version=current_version, function=current_function)
            
            df['Frequency (Hz)'] = pd.to_numeric(df['Frequency (Hz)'], errors='coerce')
            df['Power (dBm)'] = pd.to_numeric(df['Power (dBm)'], errors='coerce') # Ensure power is numeric
            df.dropna(subset=['Frequency (Hz)', 'Power (dBm)'], inplace=True) # Drop rows with NaN in either
            df.drop_duplicates(subset=['Frequency (Hz)'], keep='first', inplace=True)

            if df.empty:
                console_print_func(f"Warning: File {os.path.basename(f_path)} became empty after cleaning non-numeric or duplicate data. Skipping. No usable data!")
                debug_log(f"File {os.path.basename(f_path)} empty after data cleanup. Nothing left!",
                            file=current_file, version=current_version, function=current_function)
                continue

            file_name = os.path.basename(f_path)
            match = filename_pattern.match(file_name)
            debug_log(f"Regex match result for '{file_name}': {match}. Pattern check complete!",
                        file=current_file, version=current_version, function=current_function)
            
            rbw_hz = None
            current_offset_hz = 0.0

            if match:
                rbw_str = match.group('rbw_val')
                if 'K' in rbw_str:
                    rbw_hz = float(rbw_str.replace('K', '')) * 1000
                else:
                    rbw_hz = float(rbw_str)

                offset_str = match.group('offset_val')
                if offset_str:
                    current_offset_hz = float(offset_str)

                df['Frequency (Hz)'] = df['Frequency (Hz)'] - current_offset_hz
                debug_log(f"File {file_name}: Extracted RBW={rbw_hz}, Offset={current_offset_hz}. Frequency normalized. Data adjusted!",
                            file=current_file, version=current_version, function=current_function)
            else:
                debug_log(f"File {file_name}: Filename pattern mismatch. RBW and Offset not extracted. Assuming no offset and default RBW for PSD. Can't parse!",
                            file=current_file, version=current_version, function=current_function)
                console_print_func(f"Warning: Filename '{file_name}' did not match expected pattern for RBW/Offset. PSD calculation might be inaccurate. Proceeding with caution!")

            df['RBW_Hz'] = rbw_hz # Add RBW to the dataframe for later PSD calculation
            all_scans_dfs.append(df)
            all_frequencies = pd.concat([all_frequencies, df['Frequency (Hz)']]) # Collect frequencies
            debug_log(f"Added DF from {os.path.basename(f_path)} to all_scans_dfs. Current count: {len(all_scans_dfs)}. Data collected!",
                        file=current_file, version=current_version, function=current_function)
        except Exception as e:
            console_print_func(f"Error reading {os.path.basename(f_path)}: {e}. File problem!")
            debug_log(f"Error reading {os.path.basename(f_path)}: {e}. Failed to load!",
                        file=current_file, version=current_version, function=current_function)

    if not all_scans_dfs:
        console_print_func("No valid scan data could be loaded from the selected files for averaging. Nothing to work with!")
        debug_log("No valid scan data could be loaded from the selected files for averaging. Empty handed!",
                    file=current_file, version=current_version, function=current_function)
        debug_log(f"Exiting {current_function} (no valid data). Averaging aborted! Version: {current_version}",
                    file=current_file, version=current_version, function=current_function)
        return None, None

    # Create a master reference frequency series from all collected frequencies
    reference_freq_series = all_frequencies.sort_values().drop_duplicates().reset_index(drop=True)
    
    # Add debug prints for reference_freq_series
    if reference_freq_series.empty or reference_freq_series.isnull().any():
        console_print_func("Error: Master reference frequency series is empty or contains NaN values. Cannot proceed. This is a critical bug!")
        debug_log("Master reference frequency series is invalid. Cannot proceed!",
                    file=current_file, version=current_version, function=current_function)
        return None, None
    debug_log(f"Master reference frequency axis (first few points): {reference_freq_series.head().tolist()}. Axis established!",
                file=current_file, version=current_version, function=current_function)
    debug_log(f"Master reference frequency axis (last few points): {reference_freq_series.tail().tolist()}. End of axis!",
                file=current_file, version=current_version, function=current_function)
    debug_log(f"Master reference frequency axis (info):\n{reference_freq_series.info()}. Axis details!",
                file=current_file, version=current_version, function=current_function)
    debug_log(f"Master reference frequency axis (isnull sum): {reference_freq_series.isnull().sum()}. NaN check!",
                file=current_file, version=current_version, function=current_function)


    # Initialize aggregated_df with the master frequency axis
    aggregated_df = pd.DataFrame({'Frequency (Hz)': reference_freq_series})
    debug_log(f"Initialized aggregated_df with Frequency (Hz) column. Shape: {aggregated_df.shape}. DataFrame ready!",
                file=current_file, version=current_version, function=current_function)

    power_levels_aligned_list = []
    rbw_values = [] # Collect RBW values for PSD calculation

    for df_idx, df in enumerate(all_scans_dfs):
        try:
            # Reindex the 'Power (dBm)' column to the common reference frequency
            aligned_power_series = df.set_index('Frequency (Hz)')['Power (dBm)'].reindex(reference_freq_series)

            # Interpolate NaN values introduced by reindex
            aligned_power_series = aligned_power_series.interpolate(method='linear', limit_direction='both')

            if aligned_power_series.empty or aligned_power_series.isnull().all():
                console_print_func(f"Warning: Aligned and interpolated power series for file {os.path.basename(file_paths[df_idx])} is empty or all NaNs. Skipping this file for averaging. No usable data after alignment!")
                debug_log(f"Aligned and interpolated power series for file {os.path.basename(file_paths[df_idx])} is empty/NaNs. Skipping!",
                            file=current_file, version=current_version, function=current_function)
                continue

            power_levels_aligned_list.append(aligned_power_series)
            
            # Ensure RBW is extracted and appended for PSD calculation
            if 'RBW_Hz' in df.columns and not df['RBW_Hz'].isnull().all():
                rbw_values.append(df['RBW_Hz'].iloc[0]) # Assuming RBW is constant per file
            else:
                rbw_values.append(None) # Append None if RBW is missing or all NaN for this file
                console_print_func(f"Warning: RBW not found or invalid for file {os.path.basename(file_paths[df_idx])}. PSD for this file will be affected. Inaccurate PSD ahead!")
            
            debug_log(f"Aligned dataframe {df_idx+1}'s power levels and collected RBW: {rbw_values[-1]}. Alignment complete!",
                        file=current_file, version=current_version, function=current_function)

        except Exception as e:
            console_print_func(f"Error during alignment and interpolation for file {os.path.basename(file_paths[df_idx])}: {e}. Skipping this file. Alignment failed!")
            debug_log(f"Error during alignment and interpolation for file {os.path.basename(file_paths[df_idx])}: {e}. Skipping file!",
                        file=current_file, version=current_version, function=current_function)
            continue

    debug_log(f"After alignment loop: len(power_levels_aligned_list) = {len(power_levels_aligned_list)}. All aligned!",
                file=current_file, version=current_version, function=current_function)
    debug_log(f"After alignment loop: len(rbw_values) = {len(rbw_values)}. RBW values collected!",
                file=current_file, version=current_version, function=current_function)

    if not power_levels_aligned_list:
        console_print_func("No dataframes successfully aligned for concatenation. Cannot proceed with averaging. No data to combine!")
        debug_log("No dataframes successfully aligned for concatenation. Nothing to average!",
                    file=current_file, version=current_version, function=current_function)
        debug_log(f"Exiting {current_function} (no aligned data for concat). Averaging aborted! Version: {current_version}",
                    file=current_file, version=current_version, function=current_function)
        return None, None


    # Concatenate all aligned power series into a single DataFrame
    power_levels_df = pd.concat(power_levels_aligned_list, axis=1)
    power_levels_df.columns = [f"File_{i+1}" for i in range(len(power_levels_aligned_list))] # Name columns
    debug_log(f"Combined and aligned power_levels_df shape: {power_levels_df.shape}. DataFrame assembled!",
                file=current_file, version=current_version, function=current_function)

    # Add debug prints to check for NaNs in power_levels_df
    if power_levels_df.empty or power_levels_df.isnull().all().all():
        console_print_func("Error: Aligned power data is empty or all NaN after processing. Cannot perform calculations. Critical data loss!")
        debug_log("Aligned power data is empty or all NaN. Cannot calculate!",
                    file=current_file, version=current_version, function=current_function)
        return None, None

    debug_log(f"Power levels DF before calculations (head):\n{power_levels_df.head()}. Ready for math!",
                file=current_file, version=current_version, function=current_function)
    debug_log(f"Power levels DF NaN counts per column:\n{power_levels_df.isnull().sum()}. NaN check complete!",
                file=current_file, version=current_version, function=current_function)


    # Use a dictionary to map selected types to calculation functions
    calculation_functions = {
        "Average": _calculate_average,
        "Median": _calculate_median,
        "Range": _calculate_range,
        "Std Dev": _calculate_std_dev,
        "Variance": _calculate_variance,
        "PSD (dBm/Hz)": _calculate_psd
    }

    for avg_type in selected_avg_types:
        if avg_type in calculation_functions:
            if avg_type == "PSD (dBm/Hz)":
                calculated_series = calculation_functions[avg_type](power_levels_df, rbw_values, console_print_func)
            else:
                calculated_series = calculation_functions[avg_type](power_levels_df, console_print_func)
            
            # Assign the calculated series directly to the aggregated_df
            aggregated_df[avg_type] = calculated_series.values # Use .values to ensure alignment by index
            debug_log(f"Added '{avg_type}' column to aggregated_df. First 5 values: {aggregated_df[avg_type].head().tolist()}. Column added!",
                        file=current_file, version=current_version, function=current_function)
        else:
            console_print_func(f"Warning: Unknown average type '{avg_type}' requested. Skipping calculation. What is this?!")
            debug_log(f"Unknown average type '{avg_type}' requested. Skipping!",
                        file=current_file, version=current_version, function=current_function)

    debug_log(f"Final aggregated_df columns: {aggregated_df.columns.tolist()}. All columns present!",
                file=current_file, version=current_version, function=current_function)
    debug_log(f"Aggregated DataFrame head:\n{aggregated_df.head()}. Final data overview!",
                file=current_file, version=current_version, function=current_function)
    debug_log(f"Aggregated DataFrame info:\n{aggregated_df.info()}. DataFrame details!",
                file=current_file, version=current_version, function=current_function)

    # --- Save the COMPLETE_MATH CSV with all selected columns ---
    complete_math_csv_filename = os.path.join(output_dir_full, f"COMPLETE_MATH_{plot_title_prefix}_MultiFileAverage_{timestamp_str}.csv")
    try:
        # Ensure headers are included for the complete math file
        aggregated_df.to_csv(complete_math_csv_filename, index=False, float_format='%.3f', sep=',')
        console_print_func(f"✅ Complete Math data saved to: {complete_math_csv_filename}. Success!")
        debug_log(f"Saved Complete Math CSV to: {complete_math_csv_filename}. Mission accomplished!",
                    file=current_file, version=current_version, function=current_function)
    except Exception as e:
        console_print_func(f"❌ Failed to save COMPLETE_MATH CSV: {e}. This is a disaster!")
        debug_log(f"Error saving COMPLETE_MATH CSV: {e}. Failed to save!",
                    file=current_file, version=current_version, function=current_function)
        return None, None # Return None if saving fails


    # --- Save individual selected data to separate CSVs in the new subfolder ---
    try:
        for col_name in aggregated_df.columns:
            if col_name != 'Frequency (Hz)':
                # Clean up column name for filename
                clean_col_name = re.sub(r'[^a-zA-Z0-9_]+', '', col_name).replace('dBm', '').replace('Hz', '').strip()
                csv_filename = os.path.join(output_dir_full, f"{clean_col_name}_{plot_title_prefix}_MultiFileAverage_{timestamp_str}.csv")
                # Do not include header for individual files as per previous request/pattern
                # Ensure that if a column is all NaN, it's not saved or handled gracefully
                if not aggregated_df[col_name].isnull().all():
                    aggregated_df[['Frequency (Hz)', col_name]].to_csv(csv_filename, index=False, float_format='%.3f', header=False, sep=',')
                    console_print_func(f"✅ Multi-file {col_name} data saved to: {csv_filename}. Data exported!")
                    debug_log(f"Saved {col_name} CSV to: {csv_filename}. File created!",
                                file=current_file, version=current_version, function=current_function)
                else:
                    console_print_func(f"Skipping saving {col_name} CSV: All values are NaN. Nothing to save!")
                    debug_log(f"Skipping saving {col_name} CSV: All values are NaN. Empty column!",
                                file=current_file, version=current_version, function=current_function)

        console_print_func("🎉 All selected individual CSVs generated successfully! What a triumph!")
    except Exception as e:
        console_print_func(f"❌ Failed to save individual multi-file aggregated CSVs: {e}. This is a problem!")
        debug_log(f"Error saving individual multi-file aggregated CSVs: {e}. Failed to export!",
                    file=current_file, version=current_version, function=current_function)
        return None, None # Return None if CSV saving fails

    debug_log(f"Exiting {current_function}. Averaging and CSV generation complete! Version: {current_version}",
                file=current_file, version=current_version, function=current_function)
    return aggregated_df, output_dir_full


def generate_multi_file_average_and_plot(
    file_paths,
    selected_avg_types,
    plot_title_prefix,
    include_tv_markers,
    include_gov_markers,
    include_markers, # Added general markers for multi-file plot
    output_html_path_base, # Renamed to output_html_path_base for clarity
    open_html_after_complete,
    console_print_func=None
):
    """
    Function Description:
    Generates an aggregated plot from multiple scan files after performing selected averaging.

    Inputs:
        file_paths (list): A list of full paths to the CSV scan files.
        selected_avg_types (list): A list of strings indicating which average types to calculate
                                   (e.g., ["Average", "Median", "PSD (dBm/Hz)"]).
        plot_title_prefix (str): A prefix for the plot title and output file names.
        include_tv_markers (bool): Whether to include TV band markers on the plot.
        include_gov_markers (bool): Whether to include Government band markers on the plot.
        include_markers (bool): Whether to include general markers on the plot.
        output_html_path_base (str): The base directory where the HTML plot will be saved.
        open_html_after_complete (bool): Whether to open the generated HTML plot in a browser.
        console_print_func (function, optional): Function to print messages to the GUI console.
                                               Defaults to console_log if None.

    Returns:
        tuple: A tuple containing the Plotly figure object and the path to the saved HTML file,
               or (None, None) if an error occurs.
    """
    console_print_func = console_print_func if console_print_func else console_log # Use console_log as default
    current_function = inspect.currentframe().f_code.co_name
    current_file = __file__
    debug_log(f"Entering {current_function}. Preparing to generate multi-file average plot! Version: {current_version}",
                file=current_file, version=current_version, function=current_function)
    debug_log(f"Input file_paths ({len(file_paths)} files): {file_paths}. Plotting these files!",
                file=current_file, version=current_version, function=current_function)
    debug_log(f"Input selected_avg_types: {selected_avg_types}. Plot types selected!",
                file=current_file, version=current_version, function=current_function)
    debug_log(f"Input output_html_path_base: {output_html_path_base}. Plot output destination set!",
                file=current_file, version=current_version, function=current_function)

    if not file_paths:
        console_print_func("No file paths provided for multi-file averaging.")
        debug_log("No file paths provided for multi-file averaging. Nothing to plot!",
                    file=current_file, version=current_version, function=current_function)
        debug_log(f"Exiting {current_function} (no file paths). Plotting aborted! Version: {current_version}",
                    file=current_file, version=current_version, function=current_function)
        return None, None

    # Call the new average_scan function to get the aggregated data and output folder
    aggregated_df, output_dir_full = average_scan(
        file_paths=file_paths,
        selected_avg_types=selected_avg_types,
        plot_title_prefix=plot_title_prefix,
        output_html_path_base=output_html_path_base,
        console_print_func=console_print_func
    )

    if aggregated_df is None or output_dir_full is None:
        console_print_func("🚫 Averaging and CSV generation failed. Cannot proceed with plotting. Data missing!")
        debug_log("Averaging and CSV generation failed. Plotting aborted!",
                    file=current_file, version=current_version, function=current_function)
        debug_log(f"Exiting {current_function} (averaging failed). Plotting aborted! Version: {current_version}",
                    file=current_file, version=current_version, function=current_function)
        return None, None

    # Define plot title
    plot_title_suffix = ", ".join(selected_avg_types)
    plot_title = f"{plot_title_prefix} - {plot_title_suffix} (Multi-File Average)"
    debug_log(f"Generated plot title: {plot_title}. Title ready!",
                file=current_file, version=current_version, function=current_function)

    # Define the actual HTML output path within the new subfolder
    timestamp_str = datetime.now().strftime("%Y%m%d_%H%M%S") # Use a new timestamp for the plot HTML
    html_output_path_final = os.path.join(output_dir_full, f"{plot_title_prefix}_MultiFileAverage_Plot_{timestamp_str}.html")
    debug_log(f"Final HTML output path: {html_output_path_final}. Path set!",
                file=current_file, version=current_version, function=current_function)

    # Generate plot using plot_multi_trace_data
    fig, plot_html_path_return = plot_multi_trace_data(
        aggregated_df,
        plot_title,
        include_tv_markers,
        include_gov_markers,
        include_markers=include_markers, # Pass general markers for multi-file plot
        historical_dfs_with_names=None, # No historical overlays for this multi-file average from external folder
        output_html_path=html_output_path_final, # Use the final path in the new subfolder
        console_print_func=console_print_func
    )

    if fig:
        if open_html_after_complete:
            _open_plot_in_browser(plot_html_path_return, console_print_func)
            debug_log(f"Opened plot in browser: {plot_html_path_return}. Plot launched!",
                        file=current_file, version=current_version, function=current_function)
    elif not fig:
        console_print_func("🚫 Plotly figure was not generated for multi-file averaged data. No plot to show!")
        debug_log("Plotly figure not generated for multi-file averaged data. Figure missing!",
                    file=current_file, version=current_version, function=current_function)

    debug_log(f"Exiting {current_function}. Multi-file averaging and plotting complete! Version: {current_version}",
                file=current_file, version=current_version, function=current_function)
    return fig, plot_html_path_return


#####################################
### File: OPEN-AIR\process_math\calculate_intermod.py
#####################################
# process_math/calculate_intermod.py
#
# This module provides functions for calculating intermodulation distortion (IMD)
# products from a set of wireless microphone frequencies across multiple zones.
# It includes logic for determining IMD frequencies, their order (3rd, 5th),
# and their severity based on proximity to other active frequencies.
# It also handles filtering for in-band products and exporting results to CSV.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
# Version 20250802.0100.1 (Refactored debug_print to debug_log; updated imports and flair.)

current_version = "20250802.0100.1" # this variable should always be defined below the header to make the debugging better
current_version_hash = 20250802 * 100 * 1 # Example hash, adjust as needed

import pandas as pd
import math
from typing import Dict, List, Tuple
import inspect # Used for enhanced debug printing context
import os

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log # Added for console_print_func


# Define a type alias for better clarity:
# ZoneData maps zone names (str) to a tuple:
#  - a list of (frequency (float), device_name (str)) tuples
#  - a position in 2D space (Tuple[float, float]) (e.g., coordinates in meters)
ZoneData = Dict[str, Tuple[List[Tuple[float, str]], Tuple[float, float]]]

# Distance limit in meters for considering cross-zone intermodulation effects.
# Beyond this distance, cross-zone IMD products are ignored.
DISTANCE_LIMIT_METERS = 100

def euclidean_distance(pos1: Tuple[float, float], pos2: Tuple[float, float]) -> float:
    """
    Function Description:
    Calculates the Euclidean distance between two 2D points.

    Inputs:
    - pos1 (Tuple[float, float]): The coordinates of the first point (x, y).
    - pos2 (Tuple[float, float]): The coordinates of the second point (x, y).

    Process of this function:
    1. Extracts x and y coordinates from both input tuples.
    2. Calculates the squared difference for x and y.
    3. Sums the squared differences and takes the square root to find the Euclidean distance.
    4. Logs the calculation using `debug_log`.

    Outputs of this function:
    - float: The Euclidean distance between the two points.
    """
    current_function = inspect.currentframe().f_code.co_name
    current_file = __file__
    debug_log(f"Entering {current_function}. Calculating Euclidean distance! pos1: {pos1}, pos2: {pos2}. Version: {current_version}",
                file=current_file, version=current_version, function=current_function)

    # Ensure pos1 and pos2 are tuples of two floats
    if not (isinstance(pos1, tuple) and len(pos1) == 2 and
            isinstance(pos2, tuple) and len(pos2) == 2 and
            all(isinstance(coord, (int, float)) for coord in pos1 + pos2)):
        debug_log(f"Invalid input types for euclidean_distance. pos1: {type(pos1)}, pos2: {type(pos2)}. Expected tuples of floats!",
                    file=current_file, version=current_version, function=current_function)
        raise ValueError("pos1 and pos2 must be tuples of two numeric values.")

    dist = math.sqrt((pos1[0] - pos2[0])**2 + (pos1[1] - pos2[1])**2)
    debug_log(f"Calculated distance: {dist:.2f} meters. Distance found! Version: {current_version}",
                file=current_file, version=current_version, function=current_function)
    return dist

def _get_severity(order_label: str) -> str:
    """
    Function Description:
    Determines the severity level of an intermodulation product based on its order label.

    Inputs:
    - order_label (str): The label of the intermodulation product (e.g., "2f1-f2", "3f1-2f2").

    Process of this function:
    1. Checks if the label corresponds to a 3rd order IMD.
    2. Checks if the label corresponds to a 5th order IMD.
    3. Assigns "High" for 3rd order, "Medium" for 5th order, and "Low" for others.
    4. Logs the severity determination.

    Outputs of this function:
    - str: The severity level ("High", "Medium", "Low").
    """
    current_function = inspect.currentframe().f_code.co_name
    current_file = __file__
    debug_log(f"Entering {current_function}. Determining severity for: {order_label}. Version: {current_version}",
                file=current_file, version=current_version, function=current_function)

    if order_label in ["2f1-f2", "2f2-f1"]:
        severity = "High"
    elif order_label in ["3f1-2f2", "3f2-2f1"]:
        severity = "Medium"
    else:
        severity = "Low" # For 7th order and higher, or other types
    
    debug_log(f"Severity for {order_label} is: {severity}. Severity determined! Version: {current_version}",
                file=current_file, version=current_version, function=current_function)
    return severity

def multi_zone_intermods(
    zones: ZoneData,
    in_band_low_freq: float,
    in_band_high_freq: float,
    export_csv: str,
    include_3rd_order: bool = True,
    include_5th_order: bool = True,
    include_cross_zone_imd: bool = True,
    console_print_func=None
) -> pd.DataFrame:
    """
    Function Description:
    Calculates intermodulation distortion (IMD) products for frequencies within and
    between multiple defined zones. It filters results based on order, in-band criteria,
    and inter-zone distance.

    Inputs:
    - zones (ZoneData): Dictionary mapping zone names to (frequencies, position).
    - in_band_low_freq (float): Lower frequency limit (in MHz) for in-band filtering.
    - in_band_high_freq (float): Upper frequency limit (in MHz) for in-band filtering.
    - export_csv (str): Full path to the CSV file where the results will be saved.
    - include_3rd_order (bool): If True, includes 3rd order IMD products.
    - include_5th_order (bool): If True, includes 5th order IMD products.
    - include_cross_zone_imd (bool): If True, includes cross-zone IMD products based on distance.
    - console_print_func (function, optional): Function to print messages to the GUI console.
                                               Defaults to console_log if None.

    Process of this function:
    1. Initializes an empty list to store IMD results.
    2. Iterates through each zone to calculate intra-zone IMD products.
       a. For each pair of frequencies (f1, f2) within the zone, calculates 3rd and 5th order IMDs.
       b. Filters IMDs based on `include_3rd_order`, `include_5th_order`, and `in_band` criteria.
       c. Appends valid IMDs to the results list.
    3. If `include_cross_zone_imd` is True, iterates through pairs of zones to calculate cross-zone IMD products.
       a. Calculates Euclidean distance between zone centers.
       b. If distance is within `DISTANCE_LIMIT_METERS`, calculates IMDs for all frequency pairs
          between the two zones.
       c. Filters IMDs based on order and `in_band` criteria.
       d. Appends valid IMDs to the results list.
    4. Converts the results list to a Pandas DataFrame.
    5. Exports the DataFrame to a CSV file.
    6. Logs the process and results.

    Outputs of this function:
    - pandas.DataFrame: A DataFrame containing the calculated IMD products.
    """
    console_print_func = console_print_func if console_print_func else console_log # Use console_log as default
    current_function = inspect.currentframe().f_code.co_name
    current_file = __file__
    debug_log(f"Entering {current_function}. Calculating multi-zone intermodulation products! Version: {current_version}",
                file=current_file, version=current_version, function=current_function)
    debug_log(f"In-band range: {in_band_low_freq}-{in_band_high_freq} MHz. Filters active!",
                file=current_file, version=current_version, function=current_function)
    debug_log(f"Include 3rd order: {include_3rd_order}, 5th order: {include_5th_order}, Cross-zone: {include_cross_zone_imd}. Options set!",
                file=current_file, version=current_version, function=current_function)

    results = []

    zone_names = list(zones.keys())
    
    # --- Intra-zone IMD calculations ---
    for zone_name in zone_names:
        freq_device_pairs, _ = zones[zone_name]
        frequencies = [f[0] for f in freq_device_pairs]
        devices = {f[0]: f[1] for f in freq_device_pairs} # Map frequency to device name

        num_freqs = len(frequencies)
        debug_log(f"Processing intra-zone IMD for Zone: {zone_name} with {num_freqs} frequencies. Starting calculations!",
                    file=current_file, version=current_version, function=current_function)

        for i in range(num_freqs):
            for j in range(i + 1, num_freqs):
                f1 = frequencies[i]
                f2 = frequencies[j]
                dev1 = devices[f1]
                dev2 = devices[f2]

                # Ensure f1 is always smaller for consistent calculation and labeling
                if f1 > f2:
                    f1, f2 = f2, f1
                    dev1, dev2 = dev2, dev1

                # 3rd Order IMD
                imd3_1 = (2 * f1) - f2
                imd3_2 = (2 * f2) - f1

                # 5th Order IMD
                imd5_1 = (3 * f1) - (2 * f2)
                imd5_2 = (3 * f2) - (2 * f1)

                imd_products = {
                    "2f1-f2": imd3_1,
                    "2f2-f1": imd3_2,
                    "3f1-2f2": imd5_1,
                    "3f2-2f1": imd5_2
                }
                
                for label, freq in imd_products.items():
                    # Check if IMD product is within the desired frequency range (in-band)
                    if in_band_low_freq <= freq <= in_band_high_freq:
                        is_3rd_order = label in ["2f1-f2", "2f2-f1"]
                        is_5th_order = label in ["3f1-2f2", "3f2-2f1"]

                        if (include_3rd_order and is_3rd_order) or \
                           (include_5th_order and is_5th_order):
                            results.append({
                                "Zone_1": zone_name,
                                "Zone_2": zone_name, # Same zone for intra-zone
                                "Type": "Intra-Zone",
                                "Order": label,
                                "Distance": 0.0, # Distance is 0 for intra-zone
                                "Frequency_MHz": round(freq, 3),
                                "Severity": _get_severity(label),
                                "Device_1": dev1,
                                "Device_2": dev2,
                                "Parent_Freq1": round(f1, 3), # ADDED
                                "Parent_Freq2": round(f2, 3)   # ADDED
                            })
                            debug_log(f"  Added intra-zone IMD: {label} @ {freq:.3f} MHz in {zone_name}. Found one!",
                                        file=current_file, version=current_version, function=current_function)
                    else:
                        debug_log(f"  Skipping intra-zone IMD {label} @ {freq:.3f} MHz (out of band). Not relevant!",
                                    file=current_file, version=current_version, function=current_function)

    # --- Cross-zone IMD calculations ---
    if include_cross_zone_imd:
        num_zones = len(zone_names)
        debug_log(f"Starting cross-zone IMD calculations. Total zones: {num_zones}. Bridging the gaps!",
                    file=current_file, version=current_version, function=current_function)

        for i in range(num_zones):
            for j in range(i + 1, num_zones):
                zone1_name = zone_names[i]
                zone2_name = zone_names[j]

                _, pos1 = zones[zone1_name]
                _, pos2 = zones[zone2_name]

                dist = euclidean_distance(pos1, pos2)
                debug_log(f"  Distance between {zone1_name} and {zone2_name}: {dist:.2f} meters. Checking proximity!",
                            file=current_file, version=current_version, function=current_function)

                if dist <= DISTANCE_LIMIT_METERS:
                    freq_device_pairs1, _ = zones[zone1_name]
                    freq_device_pairs2, _ = zones[zone2_name]

                    frequencies1 = [f[0] for f in freq_device_pairs1]
                    devices1 = {f[0]: f[1] for f in freq_device_pairs1}

                    frequencies2 = [f[0] for f in freq_device_pairs2]
                    devices2 = {f[0]: f[1] for f in freq_device_pairs2}

                    debug_log(f"  Calculating cross-zone IMD between {zone1_name} ({len(frequencies1)} freqs) and {zone2_name} ({len(frequencies2)} freqs). Interacting!",
                                file=current_file, version=current_version, function=current_function)

                    for f1 in frequencies1:
                        for f2 in frequencies2:
                            dev1 = devices1[f1]
                            dev2 = devices2[f2]

                            # Ensure f1 is always smaller for consistent calculation and labeling
                            if f1 > f2: # This is for the IMD calculation itself, not the parent freqs
                                # No need to swap dev1, dev2 here, they refer to devices in their original zones
                                pass # Keep f1, f2 as they are from different zones

                            # 3rd Order IMD
                            imd3_1 = (2 * f1) - f2
                            imd3_2 = (2 * f2) - f1

                            # 5th Order IMD
                            imd5_1 = (3 * f1) - (2 * f2)
                            imd5_2 = (3 * f2) - (2 * f1)

                            imd_products = {
                                "2f1-f2": imd3_1,
                                "2f2-f1": imd3_2,
                                "3f1-2f2": imd5_1,
                                "3f2-2f1": imd5_2
                            }

                            for label, freq in imd_products.items():
                                if in_band_low_freq <= freq <= in_band_high_freq:
                                    is_3rd_order = label in ["2f1-f2", "2f2-f1"]
                                    is_5th_order = label in ["3f1-2f2", "3f2-2f1"]

                                    if (include_3rd_order and is_3rd_order) or \
                                       (include_5th_order and is_5th_order):
                                        results.append({
                                            "Zone_1": zone1_name,
                                            "Zone_2": zone2_name,
                                            "Type": "Cross-Zone",
                                            "Order": label,
                                            "Distance": round(dist, 2),
                                            "Frequency_MHz": round(freq, 3),
                                            "Severity": _get_severity(label),
                                            "Device_1": dev1,
                                            "Device_2": dev2,
                                            "Parent_Freq1": round(f1, 3), # ADDED
                                            "Parent_Freq2": round(f2, 3)   # ADDED
                                        })
                                        debug_log(f"    Added cross-zone IMD: {label} @ {freq:.3f} MHz between {zone1_name} and {zone2_name}. Collision detected!",
                                                    file=current_file, version=current_version, function=current_function)
                                else:
                                    debug_log(f"    Skipping cross-zone IMD {label} @ {freq:.3f} MHz (out of band). Not relevant!",
                                                file=current_file, version=current_version, function=current_function)
                else:
                    debug_log(f"  Skipping cross-zone IMD between {zone1_name} and {zone2_name}: Distance {dist:.2f}m > {DISTANCE_LIMIT_METERS}m. Too far apart!",
                                file=current_file, version=current_version, function=current_function)


    # Export final results sorted by frequency
    df = pd.DataFrame(results).sort_values(by="Frequency_MHz")
    
    # Ensure the output directory exists
    output_dir = os.path.dirname(export_csv)
    if output_dir and not os.path.exists(output_dir):
        os.makedirs(output_dir)
        debug_log(f"Created directory for IMD report: {output_dir}. Folder ready!",
                    file=current_file, version=current_version, function=current_function)

    try:
        df.to_csv(export_csv, index=False)
        console_print_func(f"📁 Intermod report exported to: {export_csv}. Success!")
        debug_log(f"Intermod report exported to: {export_csv}. File saved!",
                    file=current_file, version=current_version, function=current_function)
    except Exception as e:
        console_print_func(f"❌ Error exporting intermod report to CSV: {e}. This is a disaster!")
        debug_log(f"Error exporting intermod report to CSV: {e}. Export failed!",
                    file=current_file, version=current_version, function=current_function)
        # Re-raise the exception to be handled by the caller, or return an empty DataFrame
        raise

    debug_log(f"Exiting {current_function}. Total IMD products: {len(df)}. Calculation complete! Version: {current_version}",
                file=current_file, version=current_version, function=current_function)
    return df


#####################################
### File: OPEN-AIR\process_math\google_maps_lookup.py
#####################################
# process_math/google_maps_lookup.py
#
# This file contains a Python function for performing geocoding lookups
# using the Google Maps Geocoding API, converting a text query (e.g., postal code)
# into structured address components like city, province, and street address.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
# Version 20250802.0105.1 (Refactored debug_print to debug_log; updated imports and flair.)

current_version = "20250802.0105.1" # this variable should always be defined below the header to make the debugging better
current_version_hash = 20250802 * 105 * 1 # Example hash, adjust as needed

import requests
import inspect
import time
from datetime import datetime
import json # Import json for pretty printing debug output

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log # Added for console_print_func

# IMPORTANT: Replace with your actual Google Maps API Key
# This key should ideally be loaded from a secure configuration or environment variable.
# For this example, it's hardcoded for demonstration purposes.
# GOOGLE_MAPS_API_KEY = "YOUR_GOOGLE_MAPS_API_KEY" # Placeholder

def get_location_from_google_maps(query, google_maps_api_key, console_print_func=None):
    """
    Function Description:
    Performs a geocoding lookup using the Google Maps Geocoding API for a given query
    (e.g., postal code, address) and extracts city, province/state, and street address.

    Inputs:
    - query (str): The postal code or address string to look up.
    - google_maps_api_key (str): Your Google Maps API Key.
    - console_print_func (function, optional): Function to print messages to the GUI console.
                                               Defaults to console_log if None.

    Process of this function:
    1. Prints a debug message.
    2. Constructs the API URL with the query and API key.
    3. Sends an HTTP GET request to the Google Maps Geocoding API.
    4. Parses the JSON response.
    5. Extracts city, province/state, and street address from the results.
    6. Handles various error scenarios (API key missing, request errors, no results).
    7. Logs success or failure.

    Outputs of this function:
    - tuple: (city, province, street) as strings, or (None, None, None) if lookup fails.
    """
    console_print_func = console_print_func if console_print_func else console_log # Use console_log as default
    current_function = inspect.currentframe().f_code.co_name
    current_file = __file__
    debug_log(f"Entering {current_function}. Performing Google Maps lookup for query: '{query}'. Getting location data!",
                file=current_file, version=current_version, function=current_function)

    if not google_maps_api_key:
        console_print_func("❌ Google Maps API Key is missing. Cannot perform lookup. Please configure it!")
        debug_log("Google Maps API Key is missing. Lookup aborted!",
                    file=current_file, version=current_version, function=current_function)
        return None, None, None

    base_url = "https://maps.googleapis.com/maps/api/geocode/json"
    params = {
        "address": query,
        "key": google_maps_api_key
    }

    try:
        debug_log(f"Sending request to Google Maps API for query: '{query}'...",
                    file=current_file, version=current_version, function=current_function)
        response = requests.get(base_url, params=params)
        response.raise_for_status() # Raise an exception for HTTP errors (4xx or 5xx)
        data = response.json()
        debug_log(f"Received response from Google Maps API. Status: {data.get('status')}. Data acquired!",
                    file=current_file, version=current_version, function=current_function)
        debug_log(f"Full API response (first 500 chars): {json.dumps(data, indent=2)[:500]}...",
                    file=current_file, version=current_version, function=current_function)

        if data["status"] == "OK" and data["results"]:
            result = data["results"][0]
            city = None
            province = None
            street_address = None

            for component in result["address_components"]:
                if "locality" in component["types"]:
                    city = component["long_name"]
                if "administrative_area_level_1" in component["types"]:
                    province = component["long_name"]
                if "route" in component["types"]:
                    street_address = component["long_name"]
                if "street_number" in component["types"] and street_address:
                    street_address = component["long_name"] + " " + street_address
                elif "street_number" in component["types"]:
                    street_address = component["long_name"] # In case route is not present

            console_print_func(f"✅ Location found for '{query}': City: {city}, Province: {province}, Street: {street_address}. Success!")
            debug_log(f"Location found: City='{city}', Province='{province}', Street='{street_address}'. Data parsed!",
                        file=current_file, version=current_version, function=current_function)
            return city, province, street_address
        elif data["status"] == "ZERO_RESULTS":
            console_print_func(f"ℹ️ No location found for '{query}'. Try a different query. No results!")
            debug_log(f"Google Maps API returned ZERO_RESULTS for query: '{query}'. Nothing found!",
                        file=current_file, version=current_version, function=current_function)
            return None, None, None
        else:
            error_msg = f"❌ Google Maps API error for '{query}': {data['status']}. Message: {data.get('error_message', 'No error message provided')}. API problem!"
            console_print_func(error_msg)
            debug_log(error_msg,
                        file=current_file, version=current_version, function=current_function)
            return None, None, None

    except requests.exceptions.RequestException as e:
        error_msg = f"❌ Network or HTTP error during Google Maps lookup for '{query}': {e}. Check your internet connection!"
        console_print_func(error_msg)
        debug_log(error_msg,
                    file=current_file, version=current_version, function=current_function)
        return None, None, None
    except json.JSONDecodeError as e:
        error_msg = f"❌ JSON decoding error from Google Maps API response for '{query}': {e}. Bad data format!"
        console_print_func(error_msg)
        debug_log(error_msg,
                    file=current_file, version=current_version, function=current_function)
        return None, None, None
    except Exception as e:
        error_msg = f"❌ An unexpected error occurred during Google Maps lookup for '{query}': {e}. General problem!"
        console_print_func(error_msg)
        debug_log(error_msg,
                    file=current_file, version=current_version, function=current_function)
        return None, None, None

# Example Usage (for testing purposes, you can uncomment this)
if __name__ == "__main__":
    # Remember to set your GOOGLE_MAPS_API_KEY above for these examples to work!
    # For testing, you can temporarily hardcode it here or pass it from an environment variable.
    # Example:
    # GOOGLE_MAPS_API_KEY_TEST = "YOUR_ACTUAL_API_KEY_HERE"

    # print("\n--- Testing L1N 9N8 (Whitby, Ontario) with Google Maps ---")
    # city, province, street = get_location_from_google_maps("", GOOGLE_MAPS_API_KEY_TEST)
    # print(f"L1N 9N8 -> City: {city}, Province: {province}, Street: {street}")

    # print("\n--- Testing L1N 6S1 (Whitby, Ontario) with Google Maps ---")
    # city, province, street = get_location_from_google_maps("", GOOGLE_MAPS_API_KEY_TEST)
    # print(f"L1N 6S1 -> City: {city}, Province: {province}, Street: {street}")

    # print("\n--- Testing 10001 (New York, NY) with Google Maps ---")
    # city, province, street = get_location_from_google_maps("10001", GOOGLE_MAPS_API_KEY_TEST)
    # print(f"10001 -> City: {city}, State: {province}, Street: {street}")

    # print("\n--- Testing Full Address with Google Maps ---")
    # city, province, street = get_location_from_google_maps("1600 Amphitheatre Parkway, Mountain View, CA", GOOGLE_MAPS_API_KEY_TEST)
    # print(f"1600 Amphitheatre Parkway, Mountain View, CA -> City: {city}, State: {province}, Street: {street}")

    # print("\n--- Testing Invalid Query ---")
    # city, province, street = get_location_from_google_maps("ASDFGHJKL", GOOGLE_MAPS_API_KEY_TEST)
    # print(f"ASDFGHJKL -> City: {city}, Province: {province}, Street: {street}")

    # print("\n--- Testing with Missing API Key (should show error) ---")
    # city, province, street = get_location_from_google_maps("L1N 9N8", "")
    # print(f"Missing API Key Test -> City: {city}, Province: {province}, Street: {street}")
    pass


#####################################
### File: OPEN-AIR\process_math\json_host.py
#####################################
# process_math/json_host.py
#
# This module provides a simple Flask-based JSON API to serve scan data
# from CSV files located in the 'scan_data' directory. It is designed
# to be queried by external applications, such as an Electron-based GUI.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
# Version 20250802.0110.1 (Refactored debug_print to debug_log; updated imports and flair.)

current_version = "20250802.0110.1" # this variable should always be defined below the header to make the debugging better
current_version_hash = 20250802 * 110 * 1 # Example hash, adjust as needed

import sys
import os
import csv
import inspect
from flask import Flask, jsonify, send_from_directory, request

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log # Added for console_print_func

# --- Path Configuration for Imports and Data Folder ---
# This block ensures that the project root is in sys.path, allowing imports
# from 'utils' or other top-level packages to resolve correctly,
# especially when this script is run directly.

# Get the directory of the current script (json_host.py)
current_script_dir = os.path.dirname(os.path.abspath(__file__))

# Navigate up to the project root.
# From process_math/json_host.py, it's two levels up:
# current_script_dir (process_math) -> parent (src) -> parent (project_root)
project_root = os.path.abspath(os.path.join(current_script_dir, '..', '..'))

# Add the project root to sys.path if it's not already there
if project_root not in sys.path:
    sys.path.insert(0, project_root)
    debug_log(f"Added project root to sys.path: {project_root}. Path configured!",
                file=__file__, version=current_version, function="sys_path_config")

# Now import the debug_log function correctly
# from utils.utils_instrument_control import debug_log # Old import
# from src.debug_logic import debug_log # Already imported above

# Define the base directory for scan data relative to the project root
SCAN_DATA_DIR = os.path.join(project_root, 'scan_data')
MARKERS_FILE = os.path.join(project_root, 'ref', 'MARKERS.CSV') # Path to MARKERS.CSV

app = Flask(__name__)

# --- Helper Functions ---

def _get_scan_files():
    """
    Function Description:
    Lists all CSV files in the SCAN_DATA_DIR.

    Inputs:
    - None.

    Process of this function:
    1. Checks if `SCAN_DATA_DIR` exists.
    2. If it exists, uses `os.listdir` to get all files.
    3. Filters for files ending with '.csv'.
    4. Logs the discovered files.

    Outputs of this function:
    - list: A list of CSV filenames found in `SCAN_DATA_DIR`.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Entering {current_function}. Listing scan files in {SCAN_DATA_DIR}. Searching for data!",
                file=__file__, version=current_version, function=current_function)
    if not os.path.exists(SCAN_DATA_DIR):
        debug_log(f"Scan data directory not found: {SCAN_DATA_DIR}. No scans here!",
                    file=__file__, version=current_version, function=current_function)
        return []
    files = [f for f in os.listdir(SCAN_DATA_DIR) if f.endswith('.csv')]
    debug_log(f"Found {len(files)} CSV scan files. Files discovered!",
                file=__file__, version=current_version, function=current_function)
    return files

def _read_scan_data(filename):
    """
    Function Description:
    Reads data from a specified CSV scan file.

    Inputs:
    - filename (str): The name of the CSV file to read.

    Process of this function:
    1. Constructs the full path to the file.
    2. Opens and reads the CSV file.
    3. Parses each row into a dictionary with 'frequency_mhz' and 'power_dbm'.
    4. Logs the reading process.

    Outputs of this function:
    - list: A list of dictionaries, each representing a data point.
            Returns an empty list if the file is not found or an error occurs.
    """
    current_function = inspect.currentframe().f_code.co_name
    file_path = os.path.join(SCAN_DATA_DIR, filename)
    debug_log(f"Entering {current_function}. Reading scan data from: {file_path}. Loading data!",
                file=__file__, version=current_version, function=current_function)
    data = []
    try:
        with open(file_path, 'r', newline='') as csvfile:
            reader = csv.reader(csvfile)
            # Assuming the first row is header, skip it if necessary or handle it
            # For simplicity, assuming no header or handling it implicitly
            for i, row in enumerate(reader):
                if len(row) >= 2:
                    try:
                        freq = float(row[0])
                        power = float(row[1])
                        data.append({"frequency_mhz": freq, "power_dbm": power})
                    except ValueError:
                        debug_log(f"Skipping row {i+1} in {filename}: Non-numeric data found. Bad row!",
                                    file=__file__, version=current_version, function=current_function)
                        continue
        debug_log(f"Successfully read {len(data)} data points from {filename}. Data loaded!",
                    file=__file__, version=current_version, function=current_function)
    except FileNotFoundError:
        debug_log(f"File not found: {file_path}. Can't find it!",
                    file=__file__, version=current_version, function=current_function)
    except Exception as e:
        debug_log(f"Error reading {file_path}: {e}. File problem!",
                    file=__file__, version=current_version, function=current_function)
    return data

def _read_markers_data():
    """
    Function Description:
    Reads marker data from MARKERS.CSV.

    Inputs:
    - None.

    Process of this function:
    1. Checks if `MARKERS_FILE` exists.
    2. Opens and reads the CSV file, assuming a header row.
    3. Parses each row into a dictionary.
    4. Logs the reading process.

    Outputs of this function:
    - list: A list of dictionaries, each representing a marker.
            Returns an empty list if the file is not found or an error occurs.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Entering {current_function}. Reading markers data from: {MARKERS_FILE}. Loading markers!",
                file=__file__, version=current_version, function=current_function)
    markers = []
    if not os.path.exists(MARKERS_FILE):
        debug_log(f"Markers file not found: {MARKERS_FILE}. No markers here!",
                    file=__file__, version=current_version, function=current_function)
        return []
    try:
        with open(MARKERS_FILE, 'r', newline='', encoding='utf-8') as csvfile:
            reader = csv.DictReader(csvfile)
            for row in reader:
                # Convert frequency to float, handle potential errors
                try:
                    row['Frequency'] = float(row['Frequency'])
                except (ValueError, KeyError):
                    row['Frequency'] = None # Or handle as appropriate
                    debug_log(f"Skipping marker row due to invalid frequency: {row}. Bad marker!",
                                file=__file__, version=current_version, function=current_function)
                    continue
                markers.append(row)
        debug_log(f"Successfully read {len(markers)} markers from {MARKERS_FILE}. Markers loaded!",
                    file=__file__, version=current_version, function=current_function)
    except Exception as e:
        debug_log(f"Error reading markers file {MARKERS_FILE}: {e}. Markers problem!",
                    file=__file__, version=current_version, function=current_function)
    return markers

# --- Flask API Endpoints ---

@app.route('/api/list_scans', methods=['GET'])
def list_scans():
    """
    Function Description:
    API endpoint to list all available scan CSV files.

    Inputs:
    - None. (Accessed via HTTP GET request)

    Process of this function:
    1. Calls `_get_scan_files` to retrieve the list of files.
    2. Returns the list as a JSON response.

    Outputs of this function:
    - flask.Response: JSON response containing the list of scan files.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"API endpoint '/api/list_scans' hit. Listing available scans! Version: {current_version}",
                file=__file__, version=current_version, function=current_function)
    scan_files = _get_scan_files()
    return jsonify(scan_files), 200

@app.route('/api/scan_data/<filename>', methods=['GET'])
def get_scan_data(filename):
    """
    Function Description:
    API endpoint to retrieve data for a specific scan CSV file.

    Inputs:
    - filename (str): The name of the CSV file requested in the URL.

    Process of this function:
    1. Calls `_read_scan_data` to get data for the specified file.
    2. If data is found, returns it as a JSON response.
    3. If no data (file not found or empty), returns a 404 error.

    Outputs of this function:
    - flask.Response: JSON response with scan data or an error message.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"API endpoint '/api/scan_data/<filename>' hit for filename: {filename}. Fetching scan data! Version: {current_version}",
                file=__file__, version=current_version, function=current_function)
    scan_data = _read_scan_data(filename)
    if scan_data:
        debug_log(f"Returning {len(scan_data)} data points for {filename}. Data sent!",
                    file=__file__, version=current_version, function=current_function)
        return jsonify(scan_data), 200
    else:
        debug_log(f"No data found for {filename} or error reading file. File problem!",
                    file=__file__, version=current_version, function=current_function)
        return jsonify({"error": "Scan data not found or an error occurred."}), 404

@app.route('/api/scan_in_progress_data', methods=['GET'])
def get_scan_in_progress_data():
    """
    Function Description:
    API endpoint to retrieve data for the currently active scan-in-progress file.
    This endpoint is designed to serve the latest data from a specific, known file
    that the main application is actively writing to.

    Inputs:
    - None. (Accessed via HTTP GET request)

    Process of this function:
    1. Retrieves the `current_scan_file_path` from Flask's `request.args` (or a global/app context).
       NOTE: In a real application, `current_scan_file_path` would be managed by the main app
       and passed/shared securely, e.g., via a shared memory segment or a more robust IPC.
       For this Flask app, we'll assume it's passed as a query parameter for demonstration.
       Alternatively, it could be a hardcoded path if only one scan-in-progress file exists.
    2. If a path is provided, reads data from that file.
    3. Returns the data as a JSON response or a 404 if not found/error.

    Outputs of this function:
    - flask.Response: JSON response with scan-in-progress data or an error message.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"API endpoint '/api/scan_in_progress_data' hit. Fetching live scan data! Version: {current_version}",
                file=__file__, version=current_version, function=current_function)
    
    # In a real scenario, this path would be dynamically set by the main app
    # For now, let's assume the main app passes it as a query parameter or it's a known fixed file.
    # Example: /api/scan_in_progress_data?path=/path/to/live_scan.csv
    current_scan_file_path = request.args.get('path')
    
    if not current_scan_file_path:
        # Fallback to a common or expected live scan file if no path is provided
        # This assumes the main app writes to a predictable location for live updates
        # For instance, the last created scan file in SCAN_DATA_DIR.
        # This is a simplification; a more robust solution would involve explicit IPC.
        all_scans = _get_scan_files()
        if all_scans:
            # Sort by modification time to get the most recent file
            all_scans.sort(key=lambda f: os.path.getmtime(os.path.join(SCAN_DATA_DIR, f)), reverse=True)
            current_scan_file_path = os.path.join(SCAN_DATA_DIR, all_scans[0])
            debug_log(f"No explicit path provided for scan_in_progress_data. Using most recent scan file: {current_scan_file_path}. Assuming live file!",
                        file=__file__, version=current_version, function=current_function)
        else:
            debug_log("No current_scan_file_path provided and no scan files found. Cannot provide scan in progress data!",
                        file=__file__, version=current_version, function=current_function)
            return jsonify({"error": "No scan in progress file specified or found."}), 400

    debug_log(f"Attempting to read scan in progress data from: {current_scan_file_path}.",
                file=__file__, version=current_version, function=current_function)
    
    # Read data directly from the specified path
    data = []
    try:
        with open(current_scan_file_path, 'r', newline='') as csvfile:
            reader = csv.reader(csvfile)
            for i, row in enumerate(reader):
                if len(row) >= 2:
                    try:
                        freq = float(row[0])
                        power = float(row[1])
                        data.append({"frequency_mhz": freq, "power_dbm": power})
                    except ValueError:
                        debug_log(f"Skipping row {i+1} in {current_scan_file_path}: Non-numeric data found. Bad row!",
                                    file=__file__, version=current_version, function=current_function)
                        continue
        debug_log(f"Successfully read {len(data)} data points from scan in progress file. Live data loaded!",
                    file=__file__, version=current_version, function=current_function)
        return jsonify(data), 200
    except FileNotFoundError:
        debug_log(f"Scan in progress file not found: {current_scan_file_path}. Can't find it!",
                    file=__file__, version=current_version, function=current_function)
        return jsonify({"error": "Scan in progress data not found."}), 404
    except Exception as e:
        debug_log(f"Error reading scan in progress file {current_scan_file_path}: {e}. File problem!",
                    file=__file__, version=current_version, function=current_function)
        return jsonify({"error": f"Error reading scan in progress data: {e}"}), 500


@app.route('/api/markers_data', methods=['GET'])
def get_markers_data():
    """
    Function Description:
    API endpoint to retrieve marker data from MARKERS.CSV.

    Inputs:
    - None. (Accessed via HTTP GET request)

    Process of this function:
    1. Calls `_read_markers_data` to get marker data.
    2. If data is found, returns it as a JSON response.
    3. If no data (file not found or empty), returns a 404 error.

    Outputs of this function:
    - flask.Response: JSON response with marker data or an error message.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"API endpoint '/api/markers_data' hit. Request for markers data! Version: {current_version}",
                file=__file__, version=current_version, function=current_function)
    
    markers_data = _read_markers_data()
    if markers_data:
        debug_log(f"Returning {len(markers_data)} markers. Data sent!",
                    file=__file__, version=current_version, function=current_function)
        return jsonify(markers_data), 200
    else:
        debug_log("No markers data found or error reading markers file. Markers problem!",
                    file=__file__, version=current_version, function=current_function)
        return jsonify({"error": "No markers data found or an error occurred."}), 404


@app.route('/')
def index():
    """
    Function Description:
    Basic endpoint to confirm the API is running.

    Inputs:
    - None. (Accessed via HTTP GET request)

    Process of this function:
    1. Returns a simple string message.

    Outputs of this function:
    - str: A confirmation message.
    """
    return "Scan Data API is running. Use /api/scan_data/<filename> to get data or /api/list_scans to list files."

# --- Running the Flask Application ---
if __name__ == '__main__':
    # This block allows you to run the Flask application directly for testing.
    # In a real Electron application, you would typically start this Python script
    # as a subprocess and communicate with it (e.g., using child_process in Node.js).
    
    # For development, set debug=True to enable Flask's debugger and auto-reloader.
    # For production deployment, always set debug=False for security and performance.
    debug_log(f"Starting JSON API server from {current_script_dir}. Version: {current_version}",
                file=__file__, version=current_version, function="main")
    debug_log(f"Serving files from SCAN_DATA_DIR: {SCAN_DATA_DIR}. Data source set!",
                file=__file__, version=current_version, function="main")
    debug_log(f"Serving markers from MARKERS_FILE: {MARKERS_FILE}. Marker source set!",
                file=__file__, version=current_version, function="main")
    
    # You might want to make the host configurable (e.g., '0.0.0.0' for external access)
    # and the port configurable.
    app.run(host='127.0.0.1', port=5000, debug=False) # Set debug=False for production


#####################################
### File: OPEN-AIR\process_math\math_frequency_translation.py
#####################################
# process_math/math_frequency_translation.py
#
# This file provides utility functions for converting and formatting frequency values.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250820.233400.1
# REFACTORED: Removed versioning and file-specific metadata to make this a globally
#             available utility file.

import os
import inspect
from display.debug_logic import debug_log

# Conversion factor from MHz to Hz
MHZ_TO_HZ = 1_000_000
KHZ_TO_HZ = 1_000

def format_hz(hz_value):
    # [Formats a frequency in Hz to a human-readable string.]
    current_function = inspect.currentframe().f_code.co_name
    
    # NOTE: The version and file name are omitted from the debug log to make this
    #       function truly globally available and not tied to a specific file's metadata.
    debug_log(f"Entering {current_function} with value: {hz_value}", function=current_function)
    
    try:
        hz_value = float(hz_value)
        if hz_value >= MHZ_TO_HZ:
            return f"{hz_value / MHZ_TO_HZ:.1f} MHz"
        elif hz_value >= KHZ_TO_HZ:
            return f"{hz_value / KHZ_TO_HZ:.0f} kHz"
        else:
            return f"{hz_value} Hz"
    except (ValueError, TypeError) as e:
        debug_log(f"Arrr, a scallywag's value be here! The error be: {e}", function=current_function)
        return "N/A"

#####################################
### File: OPEN-AIR\process_math\ploting_intermod_zones.py
#####################################
# process_math/ploting_intermod_zones.py
#
# This module provides a function for generating an interactive 3D Plotly plot
# of wireless microphone zones and optionally overlays intermodulation collisions.
# It visualizes the spatial arrangement of zones and highlights potential IMD issues.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
# Version 20250802.0115.1 (Refactored debug_print to debug_log; updated imports and flair.)

current_version = "20250802.0115.1" # this variable should always be defined below the header to make the debugging better
current_version_hash = 20250802 * 115 * 1 # Example hash, adjust as needed

import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from typing import Dict, List, Tuple
import inspect # For debug_log
import os # For path manipulation

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log # Added for console_print_func

# Define ZoneData type for clarity (needs to be consistent with calculate_intermod.py)
ZoneData = Dict[str, Tuple[List[Tuple[float, str]], Tuple[float, float]]]

def plot_zones(
    zones: ZoneData,
    imd_df: pd.DataFrame = None, # Pass the DataFrame directly
    html_filename: str = "zones_dashboard.html",
    color_code_severity: bool = True,
    console_print_func=None
) -> None:
    """
    Function Description:
    Plots wireless microphone zones and optionally overlays intermodulation collisions in 3D.

    Inputs:
    - zones (ZoneData): Dictionary mapping zone names to (list of (frequency, device_name) tuples, position tuple).
    - imd_df (pd.DataFrame): DataFrame containing intermodulation products,
                             including 'Frequency_MHz', 'Zone_1', 'Zone_2', 'Order', 'Severity',
                             'Device_1', 'Device_2', 'Parent_Freq1', 'Parent_Freq2'.
    - html_filename (str): Filename for the output HTML plot.
    - color_code_severity (bool): If True, color-code IMD collision annotations by severity.
    - console_print_func (function, optional): Function to print messages to the GUI console.
                                               Defaults to console_log if None.

    Process of this function:
    1. Prepares zone data for plotting (positions, frequencies).
    2. Creates a 3D scatter plot for zones, with device frequencies as text labels.
    3. If `imd_df` is provided:
       a. Filters IMD products by severity (High/Medium) if `color_code_severity` is True.
       b. Adds annotations for IMD collision points, color-coded by severity.
       c. Adds lines connecting parent zones for cross-zone IMDs.
    4. Configures the 3D plot layout (title, axes labels, camera).
    5. Saves the plot to an HTML file.
    6. Logs the plotting process and success/failure.

    Outputs of this function:
    - None. Generates and saves an HTML plot file.
    """
    console_print_func = console_print_func if console_print_func else console_log # Use console_log as default
    current_function = inspect.currentframe().f_code.co_name
    current_file = __file__
    debug_log(f"Entering {current_function}. Plotting intermodulation zones! Version: {current_version}",
                file=current_file, version=current_version, function=current_function)
    debug_log(f"HTML filename: {html_filename}, Color code severity: {color_code_severity}. Plot settings ready!",
                file=current_file, version=current_version, function=current_function)

    # Plot zone positions
    zone_data_for_df = []
    for z, (freq_device_pairs, pos) in zones.items():
        frequencies_only = [f[0] for f in freq_device_pairs]
        device_names = [f[1] for f in freq_device_pairs]
        
        # Create a combined label for all devices in the zone
        device_labels = "<br>".join([f"{f:.3f} MHz ({d})" for f, d in freq_device_pairs])

        zone_data_for_df.append({
            'Zone': z,
            'X': pos[0],
            'Y': pos[1],
            'Z': sum(frequencies_only) / len(frequencies_only) if frequencies_only else 0, # Average frequency for Z-axis
            'Text': f"<b>{z}</b><br>{device_labels}",
            'Size': max(5, len(frequencies_only) * 2) # Size based on number of devices
        })
    
    if not zone_data_for_df:
        console_print_func("No zone data provided for plotting. Cannot generate plot. Nothing to visualize!")
        debug_log("No zone data for plotting. Plotting aborted!",
                    file=current_file, version=current_version, function=current_function)
        return

    zones_df = pd.DataFrame(zone_data_for_df)
    debug_log(f"Zones DataFrame created. Shape: {zones_df.shape}. Zones prepared!",
                file=current_file, version=current_version, function=current_function)

    fig = px.scatter_3d(zones_df,
                        x='X', y='Y', z='Z',
                        text='Text',
                        size='Size', # Use the calculated size
                        size_max=30, # Max size for bubbles
                        color_discrete_sequence=px.colors.qualitative.Pastel,
                        title="Wireless Microphone Zones and Intermodulation Collisions")

    fig.update_traces(textposition='top center',
                      marker=dict(symbol='circle', opacity=0.8, line=dict(width=1, color='DarkSlateGrey')))

    # Add IMD collision points and annotations
    if imd_df is not None and not imd_df.empty:
        debug_log(f"IMD DataFrame provided. Shape: {imd_df.shape}. Overlaying IMD products!",
                    file=current_file, version=current_version, function=current_function)
        
        # Filter IMD products based on severity if color_code_severity is True
        if color_code_severity:
            imd_df_filtered = imd_df[imd_df['Severity'].isin(['High', 'Medium'])]
            debug_log(f"IMD DataFrame filtered by severity (High/Medium). Filtered count: {len(imd_df_filtered)}. Focusing on critical issues!",
                        file=current_file, version=current_version, function=current_function)
        else:
            imd_df_filtered = imd_df
            debug_log("IMD DataFrame not filtered by severity. Showing all IMDs!",
                        file=current_file, version=current_version, function=current_function)

        severity_colors = {
            "High": "red",
            "Medium": "orange",
            "Low": "yellow"
        }

        for _, row in imd_df_filtered.iterrows():
            imd_freq = row['Frequency_MHz']
            imd_order = row['Order']
            imd_type = row['Type']
            imd_severity = row['Severity']
            zone1_name = row['Zone_1']
            zone2_name = row['Zone_2']
            dist = row['Distance']
            dev1 = row['Device_1']
            dev2 = row['Device_2']
            parent_freq1 = row['Parent_Freq1']
            parent_freq2 = row['Parent_Freq2']

            # Find the position of Zone_1 (or Zone_2 if it's an intra-zone IMD)
            target_zone_name = zone1_name if imd_type == "Intra-Zone" else zone1_name # For cross-zone, use Zone_1's position for annotation
            
            if target_zone_name in zones:
                _, imd_pos = zones[target_zone_name]
                
                # Use the IMD frequency for the Z-axis position
                imd_z = imd_freq # Use actual frequency for Z-axis

                # Add IMD collision point
                fig.add_trace(go.Scatter3d(
                    x=[imd_pos[0]],
                    y=[imd_pos[1]],
                    z=[imd_z],
                    mode='markers',
                    marker=dict(
                        size=8,
                        color=severity_colors.get(imd_severity, 'grey'),
                        symbol='diamond',
                        opacity=0.9,
                        line=dict(width=1, color='black')
                    ),
                    name=f"IMD {imd_order} ({imd_severity})",
                    hoverinfo='text',
                    hovertext=f"<b>IMD Collision:</b> {imd_order}<br>"
                              f"Frequency: {imd_freq:.3f} MHz<br>"
                              f"Severity: {imd_severity}<br>"
                              f"Type: {imd_type}<br>"
                              f"Parent Freqs: {parent_freq1:.3f} MHz ({dev1}), {parent_freq2:.3f} MHz ({dev2})<br>"
                              f"Zone 1: {zone1_name}<br>"
                              f"Zone 2: {zone2_name}<br>"
                              f"Distance: {dist:.2f} m",
                    showlegend=False # Don't show legend for individual points
                ))
                debug_log(f"  Added IMD point: {imd_order} @ {imd_freq:.3f} MHz (Severity: {imd_severity}). Point placed!",
                            file=current_file, version=current_version, function=current_function)
            else:
                debug_log(f"  Skipping IMD point for {imd_order} at {imd_freq:.3f} MHz: Target zone '{target_zone_name}' not found. Zone missing!",
                            file=current_file, version=current_version, function=current_function)

            # Add lines connecting zones for cross-zone IMDs in 3D (only for high severity cross-zone IMDs)
            if imd_type == "Cross-Zone" and imd_severity in ["High", "Medium"]:
                if zone1_name in zones and zone2_name in zones:
                    x1, y1 = zones[zone1_name][1]
                    # Use the actual parent frequencies for Z-axis connections
                    z1 = parent_freq1
                    
                    x2, y2 = zones[zone2_name][1]
                    z2 = parent_freq2

                    fig.add_trace(go.Scatter3d(
                        x=[x1, x2],
                        y=[y1, y2],
                        z=[z1, z2],
                        mode='lines',
                        line=dict(color='lightgrey', width=2, dash='dot'),
                        name=f"Cross-Zone IMD Link ({imd_order})",
                        hoverinfo='text',
                        hovertext=f"<b>Cross-Zone Link:</b> {zone1_name} to {zone2_name}<br>"
                                  f"IMD: {imd_order} @ {imd_freq:.3f} MHz<br>"
                                  f"Distance: {dist:.2f} m",
                        showlegend=False
                    ))
                    debug_log(f"  Added cross-zone IMD link between {zone1_name} and {zone2_name} for {imd_order}. Link drawn!",
                                file=current_file, version=current_version, function=current_function)
                else:
                    debug_log(f"  Skipping cross-zone IMD link for {imd_order}: One or both zones ({zone1_name}, {zone2_name}) not found. Link missing!",
                                file=current_file, version=current_version, function=current_function)

    # Update layout for 3D plot
    fig.update_layout(
        scene=dict(
            xaxis_title='X Position (meters)',
            yaxis_title='Y Position (meters)',
            zaxis_title='Frequency (MHz)',
            bgcolor="#2e2e2e", # Dark background
            xaxis=dict(backgroundcolor="#3a3a3a", gridcolor="#4a4a4a"),
            yaxis=dict(backgroundcolor="#3a3a3a", gridcolor="#4a4a4a"),
            zaxis=dict(backgroundcolor="#3a3a3a", gridcolor="#4a4a4a"),
        ),
        font=dict(color="white"), # Font color for titles, labels, etc.
        title_font_color="white",
        paper_bgcolor="#2e2e2e", # Background of the entire plot area
        plot_bgcolor="#2e2e2e", # Background of the plotting area
        margin=dict(l=50, r=50, t=80, b=50),
        height=700, # Fixed height for better viewing
        width=1000, # Fixed width
        autosize=False, # Set to False when height/width are fixed
        showlegend=True # Show legend for zone types and IMD severity
    )
    debug_log("Plotly 3D layout updated. Aesthetics applied!",
                file=current_file, version=current_version, function=current_function)

    # Save the plot to HTML
    try:
        output_dir = os.path.dirname(html_filename)
        if output_dir and not os.path.exists(output_dir):
            os.makedirs(output_dir)
            console_print_func(f"Created directory for IMD plot: {output_dir}.")
            debug_log(f"Created directory for IMD plot: {output_dir}. Folder ready!",
                        file=current_file, version=current_version, function=current_function)
        
        fig.write_html(html_filename, auto_open=False)
        console_print_func(f"✅ 3D Intermod Zone plot saved to: {html_filename}. Success!")
        debug_log(f"3D Intermod Zone plot saved to: {html_filename}. File exported!",
                    file=current_file, version=current_version, function=current_function)
    except Exception as e:
        console_print_func(f"❌ Error saving 3D Intermod Zone plot to HTML: {e}. This is a disaster!")
        debug_log(f"Error saving 3D Intermod Zone plot to HTML: {e}. Export failed!",
                    file=current_file, version=current_version, function=current_function)
        # Re-raise the exception to be handled by the caller, or return None
        raise

    debug_log(f"Exiting {current_function}. IMD zone plotting complete! Version: {current_version}",
                file=current_file, version=current_version, function=current_function)


#####################################
### File: OPEN-AIR\process_math\scan_stitch.py
#####################################
# src/scan_stitch.py
#
# This module handles the processing, de-duplication, and stitching of raw scan data
# collected from multiple segments or bands into a single, coherent DataFrame.
# It ensures data integrity and prepares the final dataset for plotting and analysis.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
# Version 20250802.0125.1 (Refactored debug_print to debug_log; updated imports and flair.)

current_version = "20250802.0125.1" # this variable should always be defined below the header to make the debugging better
current_version_hash = 20250802 * 125 * 1 # Example hash, adjust as needed

import pandas as pd
import inspect
import os # Added for path manipulation
from datetime import datetime # Added for timestamping
import csv # Added for writing CSV

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log

from ref.ref_frequency_bands import MHZ_TO_HZ # Import for frequency conversion


def process_and_stitch_scan_data(raw_data, overall_start_freq_hz, overall_stop_freq_hz, console_print_func=None):
    """
    Function Description:
    Processes raw scan data (frequency and amplitude pairs) collected from multiple
    segments/bands to remove duplicates, sort by frequency, and ensure a contiguous range.
    This function is responsible for stitching together the individual scan segments.

    Inputs:
        raw_data (list): A list of (frequency_hz, amplitude_dbm) tuples collected
                         across all scan segments.
        overall_start_freq_hz (float): The absolute start frequency (in Hz) of the entire scan.
        overall_stop_freq_hz (float): The absolute stop frequency (in Hz) of the entire scan.
        console_print_func (function, optional): A function to use for printing messages
                                                 to the console. Defaults to console_log if None.

    Returns:
        pandas.DataFrame: A DataFrame with 'Frequency (MHz)' and 'Amplitude (dBm)' columns,
                          containing the stitched, de-duplicated, and sorted scan data.
                          Returns an empty DataFrame if no valid data is provided.
    """
    console_print_func = console_print_func if console_print_func else console_log # Use console_log as default
    current_function = inspect.currentframe().f_code.co_name
    current_file = __file__
    debug_log(f"Entering {current_function}. Stitching raw scan data. Let's make this coherent! Version: {current_version}",
                file=current_file, version=current_version, function=current_function)
    debug_log(f"Raw data points received: {len(raw_data) if raw_data else 0}. Overall range: {overall_start_freq_hz/MHZ_TO_HZ:.3f} MHz to {overall_stop_freq_hz/MHZ_TO_HZ:.3f} MHz. Processing!",
                file=current_file, version=current_version, function=current_function)

    if not raw_data:
        console_print_func("⚠️ No raw scan data provided to stitch. Returning empty DataFrame. Nothing to do!")
        debug_log("No raw data provided for stitching. Returning empty DataFrame.",
                    file=current_file, version=current_version, function=current_function)
        debug_log(f"Exiting {current_function} (no raw data). Stitching aborted! Version: {current_version}",
                    file=current_file, version=current_version, function=current_function)
        return pd.DataFrame(columns=['Frequency (MHz)', 'Amplitude (dBm)'])

    df = pd.DataFrame(raw_data, columns=['Frequency (Hz)', 'Amplitude (dBm)'])
    debug_log(f"Initial DataFrame created. Shape: {df.shape}. Data loaded!",
                file=current_file, version=current_version, function=current_function)

    # Remove duplicates based on frequency, keeping the first occurrence
    initial_rows = df.shape[0]
    df.drop_duplicates(subset=['Frequency (Hz)'], keep='first', inplace=True)
    rows_removed = initial_rows - df.shape[0]
    if rows_removed > 0:
        console_print_func(f"✂️ Removed {rows_removed} duplicate frequency points. Cleaning up!")
        debug_log(f"Removed {rows_removed} duplicate frequency points. DataFrame now has {df.shape[0]} unique points.",
                    file=current_file, version=current_version, function=current_function)
    else:
        debug_log("No duplicate frequency points found. Data is pristine!",
                    file=current_file, version=current_version, function=current_function)

    # Sort by frequency to ensure a continuous trace
    df.sort_values(by='Frequency (Hz)', inplace=True)
    debug_log("Data sorted by frequency. Trace ordered!",
                file=current_file, version=current_version, function=current_function)

    # Filter to the overall scan range to remove any stray points outside
    # This ensures the final data matches the requested scan boundaries
    df = df[(df['Frequency (Hz)'] >= overall_start_freq_hz) & (df['Frequency (Hz)'] <= overall_stop_freq_hz)]
    if console_print_func:
        console_print_func(f"✂️ Filtered data to overall range: {overall_start_freq_hz/MHZ_TO_HZ:.3f} MHz to {overall_stop_freq_hz/MHZ_TO_HZ:.3f} MHz. Trimmed to perfection!")
    debug_log(f"Filtered to overall range. New shape: {df.shape}. Data constrained!",
                file=current_file, version=current_version, function=current_function)

    # Convert Frequency to MHz for consistency in output/plotting
    df['Frequency (MHz)'] = df['Frequency (Hz)'] / MHZ_TO_HZ
    
    # Reorder columns to have MHz first
    df = df[['Frequency (MHz)', 'Amplitude (dBm)']]

    if console_print_func:
        console_print_func(f"✅ Stitched and processed {df.shape[0]} data points. All done!")
    debug_log(f"Processed data shape: {df.shape}. Stitching complete!",
                file=current_file, version=current_version, function=current_function)
    debug_log(f"Exiting {current_function}. Scan data stitched successfully! Version: {current_version}",
                file=current_file, version=current_version, function=current_function)
    return df


def stitch_and_save_scan_data(
    raw_scan_data_for_current_sweep,
    output_folder,
    scan_name,
    operator_name,
    venue_name,
    equipment_used,
    notes,
    postal_code,
    latitude,
    longitude,
    antenna_type,
    antenna_amplifier,
    console_print_func=None
):
    """
    Function Description:
    Stitches the raw scan data, adds metadata, and saves it to a CSV file
    within a timestamped subfolder.

    Inputs:
        raw_scan_data_for_current_sweep (list): List of (frequency_hz, amplitude_dbm) tuples.
        output_folder (str): Base directory for saving scan data.
        scan_name (str): Name of the scan.
        operator_name (str): Name of the operator.
        venue_name (str): Name of the venue.
        equipment_used (str): Description of equipment used.
        notes (str): General notes for the scan.
        postal_code (str): Postal code of the scan location.
        latitude (float/str): Latitude of the scan location.
        longitude (float/str): Longitude of the scan location.
        antenna_type (str): Type of antenna used.
        antenna_amplifier (str): Type of antenna amplifier used.
        console_print_func (function, optional): Function to print messages to the GUI console.
                                               Defaults to console_log if None.

    Returns:
        tuple: (pandas.DataFrame, str) - The stitched DataFrame and the full path to the saved CSV file.
               Returns (None, None) if an error occurs.
    """
    console_print_func = console_print_func if console_print_func else console_log # Use console_log as default
    current_function = inspect.currentframe().f_code.co_name
    current_file = __file__
    debug_log(f"Entering {current_function}. Preparing to stitch and save scan data. This is the grand finale! Version: {current_version}",
                file=current_file, version=current_version, function=current_function)

    if not raw_scan_data_for_current_sweep:
        console_print_func("⚠️ No raw scan data available to stitch and save. Nothing to write!")
        debug_log("No raw scan data for current sweep. Cannot stitch and save.",
                    file=current_file, version=current_version, function=current_function)
        return None, None

    # Determine overall start and stop frequencies for stitching
    overall_start_freq_hz = min(f for f, _ in raw_scan_data_for_current_sweep)
    overall_stop_freq_hz = max(f for f, _ in raw_scan_data_for_current_sweep)
    debug_log(f"Determined overall scan range: {overall_start_freq_hz/MHZ_TO_HZ:.3f} MHz to {overall_stop_freq_hz/MHZ_TO_HZ:.3f} MHz.",
                file=current_file, version=current_version, function=current_function)

    # Process and stitch the raw data
    stitched_df = process_and_stitch_scan_data(
        raw_scan_data_for_current_sweep,
        overall_start_freq_hz,
        overall_stop_freq_hz,
        console_print_func
    )

    if stitched_df.empty:
        console_print_func("❌ Stitched DataFrame is empty after processing. Cannot save. Data vanished!")
        debug_log("Stitched DataFrame is empty. Cannot save.",
                    file=current_file, version=current_version, function=current_function)
        return None, None

    # Create a timestamped subfolder for this scan
    timestamp_str = datetime.now().strftime("%Y%m%d_%H%M%S")
    scan_subfolder_name = f"{scan_name.replace(' ', '_')}_{timestamp_str}"
    full_output_dir = os.path.join(output_folder, scan_subfolder_name)

    try:
        os.makedirs(full_output_dir, exist_ok=True)
        console_print_func(f"Created scan output folder: {full_output_dir}.")
        debug_log(f"Created scan output folder: {full_output_dir}. Folder ready!",
                    file=current_file, version=current_version, function=current_function)
    except Exception as e:
        console_print_func(f"❌ Error creating output folder '{full_output_dir}': {e}. This is a disaster!")
        debug_log(f"Error creating output folder: {e}. Folder creation failed!",
                    file=current_file, version=current_version, function=current_function)
        return None, None

    # Define the CSV file path
    csv_file_name = f"{scan_name.replace(' ', '_')}_Scan_{timestamp_str}.csv"
    output_file_path = os.path.join(full_output_dir, csv_file_name)

    # Prepare metadata for the header
    metadata = [
        f"Scan Name: {scan_name}",
        f"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
        f"Operator: {operator_name}",
        f"Venue: {venue_name}",
        f"Equipment Used: {equipment_used}",
        f"Antenna Type: {antenna_type}",
        f"Antenna Amplifier: {antenna_amplifier}",
        f"Postal Code: {postal_code}",
        f"Latitude: {latitude}",
        f"Longitude: {longitude}",
        f"Notes: {notes.replace('\n', ' ')}" # Replace newlines for single-line CSV header
    ]
    debug_log(f"Metadata prepared for CSV header. Ready to write!",
                file=current_file, version=current_version, function=current_function)

    # Write to CSV
    try:
        with open(output_file_path, 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            for item in metadata:
                writer.writerow([f"# {item}"]) # Comment out metadata lines
            writer.writerow([]) # Empty row for separation
            
            # Write column headers for data
            writer.writerow(stitched_df.columns.tolist())
            
            # Write data rows
            for index, row in stitched_df.iterrows():
                writer.writerow([f"{row['Frequency (MHz)']:.3f}", f"{row['Amplitude (dBm)']:.3f}"])
        
        console_print_func(f"✅ Scan data and metadata saved to: {output_file_path}. All done!")
        debug_log(f"Scan data and metadata saved to: {output_file_path}. File exported!",
                    file=current_file, version=current_version, function=current_function)
        return stitched_df, output_file_path
    except Exception as e:
        console_print_func(f"❌ Error saving stitched scan data to CSV: {e}. This is a disaster!")
        debug_log(f"Error saving stitched scan data to CSV: {e}. Save failed!",
                    file=current_file, version=current_version, function=current_function)
        return None, None



#####################################
### File: OPEN-AIR\ref\__init__ .py
#####################################


#####################################
### File: OPEN-AIR\ref\ref_antenna_amplifier_type.py
#####################################
# ref/antenna_amplifier_type.py
#
# This file contains a Python list of dictionaries, each describing a type of antenna amplifier.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
#
#
# Version 1.0 (Initial version)

antenna_amplifier_types = [
    {
        "Type": "In-line Amplifier (Line Amplifier)",
        "Description": "Designed to boost signal strength directly in the cable run, often near the antenna or at various points in a long cable.",
        "Use": "Compensating for cable loss, boosting weak signals before they reach the receiver or distribution system."
    },
    {
        "Type": "Mast-Mounted Amplifier (Preamplifier)",
        "Description": "Installed as close as possible to the antenna (e.g., on the mast) to amplify weak signals before noise is added by the cable or receiver. Often includes filtering.",
        "Use": "Improving signal-to-noise ratio for very weak signals, especially in TV or radio reception, or for remote sensing applications."
    },
    {
        "Type": "Distribution Amplifier (Booster)",
        "Description": "Used to split and amplify a signal for distribution to multiple outlets or devices, ensuring adequate signal strength at each point.",
        "Use": "Home TV systems (multiple TVs from one antenna), large building distribution networks, commercial AV systems."
    },
    {
        "Type": "Broadband Amplifier",
        "Description": "Amplifies signals across a wide range of frequencies without significant filtering, useful for multi-band applications.",
        "Use": "General purpose signal boosting, systems where multiple frequency bands need amplification simultaneously."
    },
    {
        "Type": "Band-Specific Amplifier",
        "Description": "Designed to amplify signals only within a specific frequency band, often incorporating built-in filters to reject out-of-band interference.",
        "Use": "Targeted amplification for specific TV channels, cellular bands, or radio services, where interference from other bands is a concern."
    },
    {
        "Type": "Low Noise Amplifier (LNA)",
        "Description": "A type of amplifier designed to amplify very low-power signals without significantly degrading the signal-to-noise ratio. Typically used at the very front end of a receiver.",
        "Use": "Satellite receivers, radio astronomy, high-sensitivity communication systems, GPS."
    },
    {
        "Type": "Power Amplifier (PA)",
        "Description": "Designed to increase the power of a signal, typically for transmission. It's the final stage before the antenna in a transmitter.",
        "Use": "Radio transmitters, cellular base stations, radar systems, broadcast stations."
    }
]

def display_antenna_amplifier_types():
    """
    Prints the content of antenna_amplifier_types in a readable format.
    """
    print("\n--- ANTENNA AMPLIFIER TYPES ---")
    for amplifier in antenna_amplifier_types:
        print(f"Type: {amplifier['Type']}")
        print(f"  Description: {amplifier['Description']}")
        print(f"  Use: {amplifier['Use']}\n")

#####################################
### File: OPEN-AIR\ref\ref_antenna_type.py
#####################################
# ref/Antenna_type.py
#
# This file contains a Python list of dictionaries, each describing a type of antenna.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
#
#
# Version 1.0 (Initial version)

antenna_types = [
    {
        "Type": "Omnidirectional (Dipole)",
        "Description": "Radiates and receives signals equally well in all horizontal directions. Simple and widely used.",
        "Use": "FM radio, Wi-Fi routers, short-range communication, general broadcasting."
    },
    {
        "Type": "Omnidirectional (Ground Plane)",
        "Description": "A vertical radiator with horizontal radials acting as a ground plane, providing omnidirectional coverage.",
        "Use": "VHF/UHF communication, amateur radio, base stations for mobile radio."
    },
    {
        "Type": "Directional (Yagi-Uda)",
        "Description": "Consists of a driven element, a reflector, and one or more directors. Highly directional with good gain.",
        "Use": "TV reception, amateur radio, point-to-point communication, long-distance communication."
    },
    {
        "Type": "Directional (Parabolic Dish)",
        "Description": "A large, curved reflector that focuses electromagnetic waves to or from a feed antenna at its focal point, providing very high gain and narrow beamwidth.",
        "Use": "Satellite communication, radar, radio astronomy, microwave links."
    },
    {
        "Type": "Loop Antenna",
        "Description": "A closed-loop conductor. Can be small (resonant) or large (non-resonant), with varying directional properties depending on size and configuration.",
        "Use": "AM radio reception, RFID, direction finding, amateur radio (especially for lower frequencies)."
    },
    {
        "Type": "Patch Antenna",
        "Description": "A flat, rectangular or circular metal patch mounted over a ground plane. Compact and low-profile.",
        "Use": "GPS devices, mobile phones, satellite communication, Wi-Fi access points."
    },
    {
        "Type": "Horn Antenna",
        "Description": "A flared metal waveguide, used for directing radio waves in a beam. High gain and good impedance matching.",
        "Use": "Microwave communication, radar, satellite tracking, measurement systems."
    }
]

def display_antenna_types():
    """
    Prints the content of antenna_types in a readable format.
    """
    print("\n--- ANTENNA TYPES ---")
    for antenna in antenna_types:
        print(f"Type: {antenna['Type']}")
        print(f"  Description: {antenna['Description']}")
        print(f"  Use: {antenna['Use']}\n")

#####################################
### File: OPEN-AIR\ref\ref_file_paths.py
#####################################
# ref/ref_file_paths.py
#
# This file centralizes all file path definitions for the application, ensuring a
# single source of truth for file and folder locations. This is a core component
# for maintaining consistency and avoiding hard-coded paths.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.144000.1
# NEW: Created a new file to centralize all application file and folder paths.

import os

# --- Version Information ---
current_version = "20250821.144000.1"
current_version_hash = (20250821 * 144000 * 1)
current_file = f"{os.path.basename(__file__)}"

# --- File Paths ---

# ref/ref_file_paths.py
#
# This file centralizes all file path definitions for the application, ensuring a
# single source of truth for file and folder locations. This is a core component
# for maintaining consistency and avoiding hard-coded paths.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.144000.2
# NEW: Created a new file to centralize all application file and folder paths.

import os

# --- Version Information ---
current_version = "20250821.144000.2"
current_version_hash = (20250821 * 144000 * 2)
current_file = f"{os.path.basename(__file__)}"

# --- File Paths ---
# The base directory is assumed to be one level above this file's location.
# This ensures that the paths are relative to the project root.
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

# The main data folder where all configuration and data files are stored.
DATA_FOLDER_PATH = os.path.join(BASE_DIR, 'DATA')

# Specific file paths within the data folder.
CONFIG_FILE_PATH = os.path.join(DATA_FOLDER_PATH, 'config.ini')
PRESETS_FILE_PATH = os.path.join(DATA_FOLDER_PATH, 'PRESETS.csv')
MARKERS_FILE_PATH = os.path.join(DATA_FOLDER_PATH, 'MARKERS.csv')
# CORRECTED: This path now points to a .csv file as per your instructions.
VISA_COMMANDS_FILE_PATH = os.path.join(DATA_FOLDER_PATH, 'VISA_COMMANDS.csv')
DEBUG_COMMANDS_FILE_PATH = os.path.join(DATA_FOLDER_PATH, 'debug.log')

#####################################
### File: OPEN-AIR\ref\ref_frequency_bands.py
#####################################
# frequency_bands.py
#
# This module defines constants and data structures related to frequency bands
# relevant to RF spectrum analysis. It separates the bands used for instrument
# scanning from those used purely for plotting markers (e.g., TV channels,
# government/commercial bands), enhancing modularity and clarity.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
#
# Conversion factor from MHz to Hz
MHZ_TO_HZ = 1_000_000
KHZ_TO_HZ = 1_000

# Ratio for Video Bandwidth (VBW) to Resolution Bandwidth (RBW)
VBW_RBW_RATIO = 1/3

# Define the frequency bands to *SCAN* (User's specified bands for instrument operation)
# This list will be used by the scan_bands function.
# Each dictionary contains:
# - "Band Name": A human-readable name for the band.
# - "Start MHz": The starting frequency of the band in Megahertz.
# - "Stop MHz": The stopping frequency of the band in Megahertz.
SCAN_BAND_RANGES = [
    {"Band Name": "Low VHF+FM", "Start MHz": 50.000, "Stop MHz": 110.000},
    {"Band Name": "High VHF+216", "Start MHz": 170.000, "Stop MHz": 220.000},
    {"Band Name": "UHF 400-500", "Start MHz": 400.000, "Stop MHz": 500.000},
    {"Band Name": "UHF 500-600", "Start MHz": 500.000, "Stop MHz": 600.000},
    {"Band Name": "UHF 600-700", "Start MHz": 600.000, "Stop MHz": 700.000},
    {"Band Name": "UHF 700-800", "Start MHz": 700.000, "Stop MHz": 800.000},
    {"Band Name": "UHF 800-900", "Start MHz": 800.000, "Stop MHz": 900.000},
    {"Band Name": "ISM-STL 900-970", "Start MHz": 900.000, "Stop MHz": 970.000},
    {"Band Name": "AFTRCC 1430-1540", "Start MHz": 1430.000, "Stop MHz": 1540.000},
    {"Band Name": "DECT-ALL 1880-2000", "Start MHz": 1880.000, "Stop MHz": 2000.000},
    {"Band Name": "Cams Lower 2G-2.2G", "Start MHz": 2000.000, "Stop MHz": 2200.000},
    {"Band Name": "Cams Upper 2.4G-2.4G", "Start MHz": 2200.000, "Stop MHz": 2400.000},
]

# North American TV Channel Bands (for plotting)
# This list is used by the plotting functions to overlay visual markers
# on the spectrum plots, helping to identify common TV broadcast frequencies.
# Each dictionary contains:
# - "Band Name": The name of the TV channel.
# - "Start MHz": The starting frequency of the channel in Megahertz.
# - "Stop MHz": The stopping frequency of the channel in Megahertz.
TV_PLOT_BAND_MARKERS = [
    {"Band Name": "TV Channel 2", "Start MHz": 54, "Stop MHz": 60},
    {"Band Name": "TV Channel 3", "Start MHz": 60, "Stop MHz": 66},
    {"Band Name": "TV Channel 4", "Start MHz": 66, "Stop MHz": 72},
    {"Band Name": "TV Channel 5", "Start MHz": 76, "Stop MHz": 82},
    {"Band Name": "TV Channel 6", "Start MHz": 82, "Stop MHz": 88},
    {"Band Name": "TV Channel 7", "Start MHz": 174, "Stop MHz": 180},
    {"Band Name": "TV Channel 8", "Start MHz": 180, "Stop MHz": 186},
    {"Band Name": "TV Channel 9", "Start MHz": 186, "Stop MHz": 192},
    {"Band Name": "TV Channel 10", "Start MHz": 192, "Stop MHz": 198},
    {"Band Name": "TV Channel 11", "Start MHz": 198, "Stop MHz": 204},
    {"Band Name": "TV Channel 12", "Start MHz": 204, "Stop MHz": 210},
    {"Band Name": "TV Channel 13", "Start MHz": 210, "Stop MHz": 216},
    {"Band Name": "TV Channel 14", "Start MHz": 470, "Stop MHz": 476},
    {"Band Name": "TV Channel 15", "Start MHz": 476, "Stop MHz": 482},
    {"Band Name": "TV Channel 16", "Start MHz": 482, "Stop MHz": 488},
    {"Band Name": "TV Channel 17", "Start MHz": 488, "Stop MHz": 494},
    {"Band Name": "TV Channel 18", "Start MHz": 494, "Stop MHz": 500},
    {"Band Name": "TV Channel 19", "Start MHz": 500, "Stop MHz": 506},
    {"Band Name": "TV Channel 20", "Start MHz": 506, "Stop MHz": 512},
    {"Band Name": "TV Channel 21", "Start MHz": 512, "Stop MHz": 518},
    {"Band Name": "TV Channel 22", "Start MHz": 518, "Stop MHz": 524},
    {"Band Name": "TV Channel 23", "Start MHz": 524, "Stop MHz": 530},
    {"Band Name": "TV Channel 24", "Start MHz": 530, "Stop MHz": 536},
    {"Band Name": "TV Channel 25", "Start MHz": 536, "Stop MHz": 542},
    {"Band Name": "TV Channel 26", "Start MHz": 542, "Stop MHz": 548},
    {"Band Name": "TV Channel 27", "Start MHz": 548, "Stop MHz": 554},
    {"Band Name": "TV Channel 28", "Start MHz": 554, "Stop MHz": 560},
    {"Band Name": "TV Channel 29", "Start MHz": 560, "Stop MHz": 566},
    {"Band Name": "TV Channel 30", "Start MHz": 566, "Stop MHz": 572},
    {"Band Name": "TV Channel 31", "Start MHz": 572, "Stop MHz": 578},
    {"Band Name": "TV Channel 32", "Start MHz": 578, "Stop MHz": 584},
    {"Band Name": "TV Channel 33", "Start MHz": 584, "Stop MHz": 590},
    {"Band Name": "TV Channel 34", "Start MHz": 590, "Stop MHz": 596},
    {"Band Name": "TV Channel 35", "Start MHz": 596, "Stop MHz": 602},
    {"Band Name": "TV Channel 36", "Start MHz": 602, "Stop MHz": 608},
    {"Band Name": "TV Channel 37 (Radio Astronomy)", "Start MHz": 608, "Stop MHz": 614}, # Note for special use
    {"Band Name": "TV Channel 38", "Start MHz": 614, "Stop MHz": 620},
    {"Band Name": "TV Channel 39", "Start MHz": 620, "Stop MHz": 626},
    {"Band Name": "TV Channel 40", "Start MHz": 626, "Stop MHz": 632},
    {"Band Name": "TV Channel 41", "Start MHz": 632, "Stop MHz": 638},
    {"Band Name": "TV Channel 42", "Start MHz": 638, "Stop MHz": 644},
    {"Band Name": "TV Channel 43", "Start MHz": 644, "Stop MHz": 650},
    {"Band Name": "TV Channel 44", "Start MHz": 650, "Stop MHz": 656},
    {"Band Name": "TV Channel 45", "Start MHz": 656, "Stop MHz": 662},
    {"Band Name": "TV Channel 46", "Start MHz": 662, "Stop MHz": 668},
    {"Band Name": "TV Channel 47", "Start MHz": 668, "Stop MHz": 674},
    {"Band Name": "TV Channel 48", "Start MHz": 674, "Stop MHz": 680},
    {"Band Name": "TV Channel 49", "Start MHz": 680, "Stop MHz": 686},
    {"Band Name": "TV Channel 50", "Start MHz": 686, "Stop MHz": 692},
    {"Band Name": "TV Channel 51", "Start MHz": 692, "Stop MHz": 698},
]

EU_TV_BAND_MARKERS = [
    {"Band Name": "TV Channel E5", "Start MHz": 174, "Stop MHz": 181},
    {"Band Name": "TV Channel E6", "Start MHz": 181, "Stop MHz": 188},
    {"Band Name": "TV Channel E7", "Start MHz": 188, "Stop MHz": 195},
    {"Band Name": "TV Channel E8", "Start MHz": 195, "Stop MHz": 202},
    {"Band Name": "TV Channel E9", "Start MHz": 202, "Stop MHz": 209},
    {"Band Name": "TV Channel E10", "Start MHz": 209, "Stop MHz": 216},
    {"Band Name": "TV Channel E21", "Start MHz": 470, "Stop MHz": 478},
    {"Band Name": "TV Channel E22", "Start MHz": 478, "Stop MHz": 486},
    {"Band Name": "TV Channel E23", "Start MHz": 486, "Stop MHz": 494},
    {"Band Name": "TV Channel E24", "Start MHz": 494, "Stop MHz": 502},
    {"Band Name": "TV Channel E25", "Start MHz": 502, "Stop MHz": 510},
    {"Band Name": "TV Channel E26", "Start MHz": 510, "Stop MHz": 518},
    {"Band Name": "TV Channel E27", "Start MHz": 518, "Stop MHz": 526},
    {"Band Name": "TV Channel E28", "Start MHz": 526, "Stop MHz": 534},
    {"Band Name": "TV Channel E29", "Start MHz": 534, "Stop MHz": 542},
    {"Band Name": "TV Channel E30", "Start MHz": 542, "Stop MHz": 550},
    {"Band Name": "TV Channel E31", "Start MHz": 550, "Stop MHz": 558},
    {"Band Name": "TV Channel E32", "Start MHz": 558, "Stop MHz": 566},
    {"Band Name": "TV Channel E33", "Start MHz": 566, "Stop MHz": 574},
    {"Band Name": "TV Channel E34", "Start MHz": 574, "Stop MHz": 582},
    {"Band Name": "TV Channel E35", "Start MHz": 582, "Stop MHz": 590},
    {"Band Name": "TV Channel E36", "Start MHz": 590, "Stop MHz": 598},
    {"Band Name": "TV Channel E37", "Start MHz": 598, "Stop MHz": 606},
    {"Band Name": "TV Channel E38", "Start MHz": 606, "Stop MHz": 614},
    {"Band Name": "TV Channel E39", "Start MHz": 614, "Stop MHz": 622},
    {"Band Name": "TV Channel E40", "Start MHz": 622, "Stop MHz": 630},
    {"Band Name": "TV Channel E41", "Start MHz": 630, "Stop MHz": 638},
    {"Band Name": "TV Channel E42", "Start MHz": 638, "Stop MHz": 646},
    {"Band Name": "TV Channel E43", "Start MHz": 646, "Stop MHz": 654},
    {"Band Name": "TV Channel E44", "Start MHz": 654, "Stop MHz": 662},
    {"Band Name": "TV Channel E45", "Start MHz": 662, "Stop MHz": 670},
    {"Band Name": "TV Channel E46", "Start MHz": 670, "Stop MHz": 678},
    {"Band Name": "TV Channel E47", "Start MHz": 678, "Stop MHz": 686},
    {"Band Name": "TV Channel E48", "Start MHz": 686, "Stop MHz": 694},
]

# Common Resolution Bandwidth (RBW) options in Hz
RBW_OPTIONS = [10, 100, 1000, 3000, 10000, 30000, 100000, 300000, 1000000, 3000000]

# Common Video Bandwidth (VBW) to Resolution Bandwidth (RBW) ratio options
VBW_RBW_RATIO_OPTIONS = [0.001, 0.003, 0.01, 0.03, 0.1, 0.3, 1, 3, 10]

# Default Reference Level options in dBm
DEFAULT_REF_LEVEL_OPTIONS = [-100, -90, -80, -70, -60, -50, -40, -30, -20, -10, 0, 10, 20, 30]

# Default Frequency Shift options in Hz
DEFAULT_FREQ_SHIFT_OPTIONS = [0, 1000000, 2000000, 5000000, 10000000] # Example shifts

# Government/Commercial Plot Band Markers (for plotting)
# This list is used by the plotting functions to overlay visual markers
# on the spectrum plots for various government and commercial frequency allocations.
# Each dictionary contains:
# - "Band Name": A human-readable name for the band (e.g., "Public Safety 700 MHz").
# - "Start MHz": The starting frequency of the band in Megahertz.
# - "Stop MHz": The stopping frequency of the band in Megahertz.
GOV_PLOT_BAND_MARKERS = [
    {"Band Name": "Amateur Radio 6m", "Start MHz": 50, "Stop MHz": 54},
    {"Band Name": "FM Broadcast", "Start MHz": 88, "Stop MHz": 108},
    {"Band Name": "Air Traffic Control", "Start MHz": 108, "Stop MHz": 137},
    {"Band Name": "VHF Marine Radio", "Start MHz": 156, "Stop MHz": 162.025},
    {"Band Name": "Amateur Radio 2m", "Start MHz": 144, "Stop MHz": 148},
    {"Band Name": "Paging/Land Mobile", "Start MHz": 150, "Stop MHz": 174},
    {"Band Name": "Public Safety/Land Mobile", "Start MHz": 450, "Stop MHz": 470},
    {"Band Name": "Amateur Radio 70cm", "Start MHz": 420, "Stop MHz": 450},
    {"Band Name": "FRS/GMRS", "Start MHz": 462.5, "Stop MHz": 467.7625},
    {"Band Name": "LTE Band 13 (Uplink)", "Start MHz": 777, "Stop MHz": 787},
    {"Band Name": "LTE Band 13 (Downlink)", "Start MHz": 746, "Stop MHz": 756},
    {"Band Name": "Public Safety 700 MHz", "Start MHz": 764, "Stop MHz": 776},
    {"Band Name": "Public Safety 800 MHz", "Start MHz": 851, "Stop MHz": 869},
    {"Band Name": "LTE Band 5 (Uplink)", "Start MHz": 824, "Stop MHz": 849},
    {"Band Name": "LTE Band 5 (Downlink)", "Start MHz": 869, "Stop MHz": 894},
    {"Band Name": "GSM 850 (Uplink)", "Start MHz": 824, "Stop MHz": 849},
    {"Band Name": "GSM 850 (Downlink)", "Start MHz": 869, "Stop MHz": 894},
    {"Band Name": "Amateur Radio 33cm", "Start MHz": 902, "Stop MHz": 928},
    {"Band Name": "ISM 900 MHz", "Start MHz": 902, "Stop MHz": 928},
    {"Band Name": "LTE Band 2/25 (Uplink)", "Start MHz": 1850, "Stop MHz": 1915},
    {"Band Name": "LTE Band 2/25 (Downlink)", "Start MHz": 1930, "Stop MHz": 1995},
    {"Band Name": "PCS (Uplink)", "Start MHz": 1850, "Stop MHz": 1910},
    {"Band Name": "PCS (Downlink)", "Start MHz": 1930, "Stop MHz": 1990},
    {"Band Name": "LTE Band 4 (Uplink)", "Start MHz": 1710, "Stop MHz": 1755},
    {"Band Name": "LTE Band 4 (Downlink)", "Start MHz": 2110, "Stop MHz": 2155},
    {"Band Name": "AWS-1 (Uplink)", "Start MHz": 1710, "Stop MHz": 1755},
    {"Band Name": "AWS-1 (Downlink)", "Start MHz": 2110, "Stop MHz": 2155},
    {"Band Name": "Amateur Radio 23cm", "Start MHz": 1240, "Stop MHz": 1300},
    {"Band Name": "GPS L1", "Start MHz": 1575.42, "Stop MHz": 1575.42}, # Specific frequency
    {"Band Name": "GPS L2", "Start MHz": 1227.60, "Stop MHz": 1227.60}, # Specific frequency
    {"Band Name": "Bluetooth", "Start MHz": 2400, "Stop MHz": 2483.5},
    {"Band Name": "Wi-Fi 2.4 GHz", "Start MHz": 2400, "Stop MHz": 2483.5},
    {"Band Name": "ISM 2.4 GHz", "Start MHz": 2400, "Stop MHz": 2500},
    {"Band Name": "LTE Band 7 (Uplink)", "Start MHz": 2500, "Stop MHz": 2570},
    {"Band Name": "LTE Band 7 (Downlink)", "Start MHz": 2620, "Stop MHz": 2690},
    {"Band Name": "Amateur Radio 13cm", "Start MHz": 2300, "Stop MHz": 2450},
    {"Band Name": "Amateur Radio 13cm (cont)", "Start MHz": 2400, "Stop MHz": 2450}, # Overlap with ISM
]

def display_scan_band_ranges():
    """
    Prints the content of SCAN_BAND_RANGES in a readable format.
    """
    print("\n--- SCAN BAND RANGES ---")
    for band in SCAN_BAND_RANGES:
        print(f"Band Name: {band['Band Name']}, Start MHz: {band['Start MHz']}, Stop MHz: {band['Stop MHz']}")

def display_tv_plot_band_markers():
    """
    Prints the content of TV_PLOT_BAND_MARKERS in a readable format.
    """
    print("\n--- NORTH AMERICAN TV PLOT BAND MARKERS ---")
    for marker in TV_PLOT_BAND_MARKERS:
        print(f"Band Name: {marker['Band Name']}, Start MHz: {marker['Start MHz']}, Stop MHz: {marker['Stop MHz']}")

def display_eu_tv_band_markers():
    """
    Prints the content of EU_TV_BAND_MARKERS in a readable format.
    """
    print("\n--- EU TV PLOT BAND MARKERS ---")
    for marker in EU_TV_BAND_MARKERS:
        print(f"Band Name: {marker['Band Name']}, Start MHz: {marker['Start MHz']}, Stop MHz: {marker['Stop MHz']}")

def display_gov_plot_band_markers():
    """
    Prints the content of GOV_PLOT_BAND_MARKERS in a readable format.
    """
    print("\n--- GOVERNMENT/COMMERCIAL PLOT BAND MARKERS ---")
    for marker in GOV_PLOT_BAND_MARKERS:
        print(f"Band Name: {marker['Band Name']}, Start MHz: {marker['Start MHz']}, Stop MHz: {marker['Stop MHz']}")

def display_rbw_options():
    """
    Prints the content of RBW_OPTIONS in a readable format.
    """
    print("\n--- RBW OPTIONS (Hz) ---")
    for option in RBW_OPTIONS:
        print(f"RBW: {option} Hz")

def display_vbw_rbw_ratio_options():
    """
    Prints the content of VBW_RBW_RATIO_OPTIONS in a readable format.
    """
    print("\n--- VBW/RBW RATIO OPTIONS ---")
    for option in VBW_RBW_RATIO_OPTIONS:
        print(f"Ratio: {option}")

def display_default_ref_level_options():
    """
    Prints the content of DEFAULT_REF_LEVEL_OPTIONS in a readable format.
    """
    print("\n--- DEFAULT REFERENCE LEVEL OPTIONS (dBm) ---")
    for option in DEFAULT_REF_LEVEL_OPTIONS:
        print(f"Reference Level: {option} dBm")

def display_default_freq_shift_options():
    """
    Prints the content of DEFAULT_FREQ_SHIFT_OPTIONS in a readable format.
    """
    print("\n--- DEFAULT FREQUENCY SHIFT OPTIONS (Hz) ---")
    for option in DEFAULT_FREQ_SHIFT_OPTIONS:
        print(f"Frequency Shift: {option} Hz")

#####################################
### File: OPEN-AIR\ref\ref_program_default_values.py
#####################################
# src/settings_and_config/program_default_values.py
#
# This file contains the default configuration settings for the application.
# It defines the structure and initial values for the config.ini file,
# ensuring that the application has a valid configuration to start with.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.110500.1
# FIXED: The BASE_DIR calculation has been corrected to properly point to the
#        root 'OPEN-AIR' directory, resolving the 'config.ini' pathing error.
# UPDATED: Added new MarkerTab configuration keys for a more comprehensive default state.

import os
from datetime import datetime

# Import the main frequency bands data
from ref.ref_frequency_bands import SCAN_BAND_RANGES


# --- Version Information ---
w = 20250821
x_str = '110500'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"{w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = f"{os.path.basename(__file__)}"

# --- Global Paths ---


# --- Default Settings ---
DEFAULT_CONFIG = {
    'Application': {
        'geometry': '1600x900+100+100',
        'window_state': 'normal',
        'last_config_save_time': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        'paned_window_sash_position_percentage': '45',
    },
    'Debug': {
        'general_debug_enabled': 'True',
        'debug_to_gui_console': 'True',
        'debug_to_terminal': 'False',
        'debug_to_file': 'True',
        'include_console_messages_to_debug_file': 'True',
        'log_visa_commands_enabled': 'False',
        'log_truncation_enabled': 'True',
        'include_visa_messages_to_debug_file': 'True',
    },
    'Instrument': {
        'visa_resource': 'TCPIP0::192.168.1.100::inst0::INSTR',
    },
    'InstrumentSettings': {
        'center_freq_mhz': '1500',
        'span_freq_mhz': '3000',
        'start_freq_mhz': '0',
        'stop_freq_mhz': '3000',
        'rbw_mhz': '1',
        'vbw_mhz': '1',
        'vbw_auto_on': 'True',
        'initiate_continuous_on': 'True',
        'ref_level_dbm': '-30',
        'preamp_on': 'False',
        'power_attenuation_db': '10',
        'high_sensitivity_on': 'False',
        'trace1_mode': 'WRITE',
        'trace2_mode': 'MAXHOLD',
        'trace3_mode': 'BLANK',
        'trace4_mode': 'BLANK',
        'marker1_on': 'False',
        'marker2_on': 'False',
        'marker3_on': 'False',
        'marker4_on': 'False',
        'marker5_on': 'False',
        'marker6_on': 'False',
    },
    'MarkerTab': {
        'span_hz': '1000000',
        'rbw_hz': '100000',
        'trace_live': 'True',
        'trace_max_hold': 'False',
        'trace_min_hold': 'False',
        'buffer_mhz': '3.0',
        'poke_freq_mhz': '444.444444',
        'buffered_start_var': '0.0',
        'buffered_stop_var': '0.0',
        'zone_selected': 'None',
        'zone_zoom_button_selected_name': '',
        'zone_zoom_label': '',
        'zone_zoom_start': '',
        'zone_zoom_stop': '',
        'zone_device_count': '0',
        'zone_group_count': '0',
        'group_selected': 'None',
        'group_zoom_button_selected': '',
        'group_zoom_label': '',
        'group_zoom_start': '',
        'group_zoom_stop': '',
        'group_device_count': '0',
        'device_selected_name': '',
        'device_selected_device_type': '',
        'device_selected_center': '',
    },
    'Scan': {
        'output_folder': "c:\documents",
        'scan_name': 'DefaultScan',
        'rbw_step_size_hz': '20000',
        'num_scan_cycles': '1',
        'cycle_wait_time_seconds': '0',
        'maxhold_enabled': 'False',
        'maxhold_time_seconds': '10',
        'desired_default_focus_width': '5000000',
        'create_html': 'True',
        'open_html_after_complete': 'True',
        'include_markers': 'True',
        'include_gov_markers': 'True',
        'include_tv_markers': 'True',
        'include_scan_intermod_markers': 'True',
        'math_average': 'True',
        'math_median': 'True',
        'math_variance': 'True',
        'math_standard_deviation': 'True',
        'math_range': 'True',
        'math_psd': 'True',
        'last_scan_configuration__selected_bands_levels': ','.join(
            [f"{band['Band Name']}=1" for band in SCAN_BAND_RANGES]
        ),
    },
    'Antenna': {
        'selected_antenna_type': 'Generic',
        'antenna_description': 'Broadband Omni',
        'antenna_use': 'General Purpose',
        'antenna_mount': 'Tripod',
        'antenna_amplifier': 'None',
    },
    'Amplifier': {
        'selected_amplifier_type': 'Generic',
        'amplifier_description': 'Inline LNA',
        'amplifier_use': 'Compensate for cable loss',
    },
    'Report': {
        'operator_name': 'RF Technician',
        'operator_contact': 'tech@example.com',
        'venue_name': 'Default Venue',
        'address_field': '123 Main St',
        'city': 'Anytown',
        'province': 'ON',
        'venue_postal_code': 'A1B 2C3',
        'notes': 'This is a default report generated by the OPEN-AIR software.',
        'freq_shift': '0',
        'scanner_type': 'Generic RF Scanner',
    },
    'Plotting': {
        'current_style_theme': 'dark',
        'plot_grid_on': 'True',
        'plot_grid_alpha': '0.5',
        'plot_grid_color': 'gray',
    },
}

#####################################
### File: OPEN-AIR\ref\ref_scanner_setting_lists.py
#####################################
# ref/ref_scanner_setting_lists.py
#
# This file contains predefined lists of settings for various scanner parameters.
# These lists are used to populate dropdown menus in the GUI, providing users
# with a selection of common or recommended values along with descriptive text.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250816.224500.1
# UPDATED: Rebuilt the PRESET_BANDWIDTH_VIDEO list with a correct handler value.

current_version = "20250816.224500.1" # this variable should always be defined below the header to make the debugging better

# --- UI Constants ---
MHZ_TO_HZ = 1_000_000  # Assumed constant for converting MHz to Hz

PRESET_AMPLITUDE_REFERENCE_LEVEL = [
    {
        "value": -120,
        "label": "Extremely Low",
        "description": "The lowest possible reference level for hunting the weakest signals imaginable.",
        "handler": "set_reference_level"
    },
    {
        "value": -115,
        "label": "Very Low",
        "description": "Deep noise floor — ideal for weak signal hunting.",
        "handler": "set_reference_level"
    },
    {
        "value": -110,
        "label": "Very Low",
        "description": "Deep noise floor — ideal for weak signal hunting.",
        "handler": "set_reference_level"
    },
    {
        "value": -105,
        "label": "Low",
        "description": "Below typical ambient RF noise — for sensitive receivers.",
        "handler": "set_reference_level"
    },
    {
        "value": -100,
        "label": "Low",
        "description": "Below typical ambient RF noise — for sensitive receivers.",
        "handler": "set_reference_level"
    },
    {
        "value": -95,
        "label": "Low",
        "description": "Below typical ambient RF noise — for sensitive receivers.",
        "handler": "set_reference_level"
    },
    {
        "value": -90,
        "label": "Low",
        "description": "Below typical ambient RF noise — for sensitive receivers.",
        "handler": "set_reference_level"
    },
    {
        "value": -85,
        "label": "Medium Low",
        "description": "Quiet environment, low-level signals clearly visible.",
        "handler": "set_reference_level"
    },
    {
        "value": -80,
        "label": "Medium Low",
        "description": "Quiet environment, low-level signals clearly visible.",
        "handler": "set_reference_level"
    },
    {
        "value": -75,
        "label": "Medium Low",
        "description": "Quiet environment, low-level signals clearly visible.",
        "handler": "set_reference_level"
    },
    {
        "value": -70,
        "label": "Medium Low",
        "description": "Quiet environment, low-level signals clearly visible.",
        "handler": "set_reference_level"
    },
    {
        "value": -65,
        "label": "Medium",
        "description": "Good general-purpose reference level.",
        "handler": "set_reference_level"
    },
    {
        "value": -60,
        "label": "Medium",
        "description": "Good general-purpose reference level.",
        "handler": "set_reference_level"
    },
    {
        "value": -55,
        "label": "Medium",
        "description": "Good general-purpose reference level.",
        "handler": "set_reference_level"
    },
    {
        "value": -50,
        "label": "Medium",
        "description": "Good general-purpose reference level.",
        "handler": "set_reference_level"
    },
    {
        "value": -45,
        "label": "Medium High",
        "description": "Stronger signals, moderate local RF traffic.",
        "handler": "set_reference_level"
    },
    {
        "value": -40,
        "label": "Medium High",
        "description": "Stronger signals, moderate local RF traffic.",
        "handler": "set_reference_level"
    },
    {
        "value": -35,
        "label": "Medium High",
        "description": "Stronger signals, moderate local RF traffic.",
        "handler": "set_reference_level"
    },
    {
        "value": -30,
        "label": "Medium High",
        "description": "Stronger signals, moderate local RF traffic.",
        "handler": "set_reference_level"
    },
    {
        "value": -25,
        "label": "High",
        "description": "For strong broadcast transmitters or test signals.",
        "handler": "set_reference_level"
    },
    {
        "value": -20,
        "label": "High",
        "description": "For strong broadcast transmitters or test signals.",
        "handler": "set_reference_level"
    },
    {
        "value": -15,
        "label": "High",
        "description": "For strong broadcast transmitters or test signals.",
        "handler": "set_reference_level"
    },
    {
        "value": -10,
        "label": "High",
        "description": "For strong broadcast transmitters or test signals.",
        "handler": "set_reference_level"
    },
    {
        "value": -5,
        "label": "Very High",
        "description": "Max headroom — use with caution to avoid clipping.",
        "handler": "set_reference_level"
    },
    {
        "value": 0,
        "label": "Very High",
        "description": "Max headroom — use with caution to avoid clipping.",
        "handler": "set_reference_level"
    }
]

PRESET_AMPLITUDE_PREAMP_STATE = [
    {
        "value": "ON",
        "label": "PREAMP ON",
        "description": "Turns on the pre-amplifier. A monstrous gain for weak signals.",
        "handler": "toggle_preamp"
    },
    {
        "value": "OFF",
        "label": "PREAMP OFF",
        "description": "Turns off the pre-amplifier. The scanner returns to its natural, less monstrous state.",
        "handler": "toggle_preamp"
    }
]

PRESET_AMPLITUDE_HIGH_SENSITIVITY_STATE = [
    {
        "value": "ON",
        "label": "HIGH SENSITIVITY ON",
        "description": "Activates high-sensitivity mode. The scanner now listens for the whispers of the universe.",
        "handler": "toggle_high_sensitivity"
    },
    {
        "value": "OFF",
        "label": "HIGH SENSITIVITY OFF",
        "description": "Deactivates high-sensitivity mode. The scanner's ears are no longer superhuman.",
        "handler": "toggle_high_sensitivity"
    }
]

PRESET_AMPLITUDE_POWER_ATTENUATION = [
    {
        "value": 0,
        "label": "0 dB",
        "description": "No attenuation. Full power! Use with caution.",
        "handler": "set_power_attenuation"
    },
    {
        "value": 10,
        "label": "10 dB",
        "description": "A light filter, for when the signal is just a bit too spicy.",
        "handler": "set_power_attenuation"
    },
    {
        "value": 20,
        "label": "20 dB",
        "description": "A good, solid filter for moderate signals.",
        "handler": "set_power_attenuation"
    },
    {
        "value": 30,
        "label": "30 dB",
        "description": "A strong filter for powerful signals. Like wearing sunglasses to the beach.",
        "handler": "set_power_attenuation"
    },
    {
        "value": 40,
        "label": "40 dB",
        "description": "A heavy filter for blaringly strong signals. It's like wearing a blindfold on a sunny day.",
        "handler": "set_power_attenuation"
    },
    {
        "value": 50,
        "label": "50 dB",
        "description": "Extreme attenuation for signals that could damage the instrument.",
        "handler": "set_power_attenuation"
    }

]

PRESET_BANDWIDTH_RBW = [
    {
        "value": 1_000_000,
        "label": "Fast",
        "description": "Like a race car: fast sweep, low detail. Best for catching fleeting signals.",
        "handler": "set_resolution_bandwidth"
    },
    {
        "value": 300_000,
        "label": "Brisk",
        "description": "A jog through the spectrum; quick enough to see the sights without missing much.",
        "handler": "set_resolution_bandwidth"
    },
    {
        "value": 100_000,
        "label": "Deliberate",
        "description": "The perfect balance of speed and fidelity. Not too fast, not too slow.",
        "handler": "set_resolution_bandwidth"
    },
    {
        "value": 30_000,
        "label": "Steady",
        "description": "A calm stroll, giving you time to appreciate the finer signal details.",
        "handler": "set_resolution_bandwidth"
    },
    {
        "value": 10_000,
        "label": "Leisurely",
        "description": "A slow saunter through the noise floor, where every waveform is a work of art.",
        "handler": "set_resolution_bandwidth"
    },
    {
        "value": 3_000,
        "label": "Unhurried",
        "description": "For the patient scientist. You'll see things nobody else can, but it'll take a while.",
        "handler": "set_resolution_bandwidth"
    },
    {
        "value": 1_000,
        "label": "Slothlike",
        "description": "So slow you can practically see the electrons move. The highest fidelity, but you'll miss any quick events.",
        "handler": "set_resolution_bandwidth"
    },
    {
        "value": 300,
        "label": "Slothlike",
        "description": "So slow you can practically see the electrons move. The highest fidelity, but you'll miss any quick events.",
        "handler": "set_resolution_bandwidth"
    },
]



PRESET_BANDWIDTH_VIDEO = [
    {
        "value": 1_000_000,
        "label": "Ultra Fast",
        "description": "A lightning-fast sweep. Filters are wide open, letting everything through.",
        "handler": "set_video_bandwidth"
    },
    {
        "value": 300_000,
        "label": "Very Fast",
        "description": "A quick pass through the spectrum, ideal for fast-changing signals.",
        "handler": "set_video_bandwidth"
    },
    {
        "value": 100_000,
        "label": "Fast",
        "description": "A balanced speed for general purpose monitoring and signal capture.",
        "handler": "set_video_bandwidth"
    },
    {
        "value": 30_000,
        "label": "Normal",
        "description": "The standard filter setting for most common analysis tasks. Not too much, not too little.",
        "handler": "set_video_bandwidth"
    },
    {
        "value": 10_000,
        "label": "Slow",
        "description": "A gentle filter, giving you more time to appreciate the finer details of a waveform.",
        "handler": "set_video_bandwidth"
    },
    {
        "value": 3_000,
        "label": "Very Slow",
        "description": "For the meticulous scientist. You'll filter out fast noise and jitter, but at the cost of speed.",
        "handler": "set_video_bandwidth"
    },
    {
        "value": 1_000,
        "label": "Ultra Slow",
        "description": "A meditative pace. So slow you can practically see the electrons move, offering maximum stability and noise reduction.",
        "handler": "set_video_bandwidth"
    },
    {
        "value": 300,
        "label": "Glacial",
        "description": "A slow crawl. Good for very detailed analysis of continuous signals and filtering out transient noise.",
        "handler": "set_video_bandwidth"
    },
    {
        "value": 100,
        "label": "Glacial",
        "description": "A slow crawl. Good for very detailed analysis of continuous signals and filtering out transient noise.",
        "handler": "set_video_bandwidth"
    },
    {
        "value": 30,
        "label": "Sub-Glacial",
        "description": "The scanner cries, but it's worth it. Filters out almost all random noise, giving you a crystal-clear, steady line.",
        "handler": "set_video_bandwidth"
    },
    {
        "value": 10,
        "label": "Sub-Glacial",
        "description": "The scanner cries, but it's worth it. Filters out almost all random noise, giving you a crystal-clear, steady line.",
        "handler": "set_video_bandwidth"
    },
    {
        "value": 3,
        "label": "Crazy Slow",
        "description": "Time seems to stop. For the most patient scientists and signals with incredible stability. The ultimate low-pass filter.",
        "handler": "set_video_bandwidth"
    },
    {
        "value": 1,
        "label": "Crazy Slow",
        "description": "Time seems to stop. For the most patient scientists and signals with incredible stability. The ultimate low-pass filter.",
        "handler": "set_video_bandwidth"
    },
]



# REVERSED ORDERING. This is the way.
PRESET_FREQUENCY_SPAN = [
    {
        "value": 10_000,
        "label": "Microscope",
        "description": "So tight you'll feel like a cellular biologist examining a single-cell waveform.",
        "handler": "set_span_frequency"
    },
    {
        "value": 100_000,
        "label": "Tight",
        "description": "A narrow, focused view for getting up close and personal with signals.",
        "handler": "set_span_frequency"
    },
    {
        "value": 1_000_000,
        "label": "Normal",
        "description": "The standard span, a balanced diet for most common analysis.",
        "handler": "set_span_frequency"
    },
    {
        "value": 10_000_000,
        "label": "Wide",
        "description": "A broad, digestible view of the spectrum, great for general reconnaissance.",
        "handler": "set_span_frequency"
    },
    {
        "value": 100_000_000,
        "label": "Ultra Wide",
        "description": "A very broad span for finding signals over a large frequency range. It's like scanning with a wide-angle lens.",
        "handler": "set_span_frequency"
    },
        {
        "value": 500_000_000,
        "label": "From Space",
        "description": "A very broad span for finding signals over a large frequency range. It's like scanning with a wide-angle lens.",
        "handler": "set_span_frequency"
    },
            {
        "value": 1_000_000_000,
        "label": "From The Moon",
        "description": "A very broad span for finding signals over a large frequency range. It's like scanning with a wide-angle lens.",
        "handler": "set_span_frequency"
    },
]

PRESET_TRACE_MODES = [
    {
        "value": "WRITE",
        "label": "LIVE REALTIME",
        "description": "Captures and displays the trace in real time, like a hyperactive surveillance camera.",
        "handler": "handle_trace_modes_beg"
    },
    {
        "value": "MAXHOLD",
        "label": "MAX HOLD",
        "description": "Keeps the highest-level peaks on display, like a digital trophy case for signals.",
        "handler": "handle_trace_modes_beg"
    },
    {
        "value": "MINHOLD",
        "label": "MIN HOLD",
        "description": "Holds onto the lowest points, great for detecting signals that vanish in the noise.",
        "handler": "handle_trace_modes_beg"
    },
    {
        "value": "BLANK",
        "label": "BLANK",
        "description": "Clears the slate, preparing for a new scan. A zen state for the scanner.",
        "handler": "handle_trace_modes_beg"
    },
    {
        "value": "VIEW",
        "label": "VIEW",
        "description": "The standard mode, simply viewing the current sweep data.",
        "handler": "handle_trace_modes_beg"
    },
]

PRESET_CONTINUOUS_MODE = [
    {
        "value": "ON",
        "label": "CONTINUOUS ON",
        "description": "Turns on continuous sweep mode. The scanner never rests!",
        "handler": "set_continuous_initiate_mode"
    },
    {
        "value": "OFF",
        "label": "CONTINUOUS OFF",
        "description": "Turns off continuous sweep mode. The scanner will perform a single sweep and then rest.",
        "handler": "set_continuous_initiate_mode"
    }
]
PRESET_AVERAGING = [
    {
        "value": 0,
        "label": "Off",
        "description": "Just a raw, single sweep. Great for seeing fast changes and fleeting events, but the noise floor is high and the trace is very jittery.",
        "handler": "set_averaging"
    },
    {
        "value": 5,
        "label": "Light Filter",
        "description": "A very mild smoothing of the signal, removing some of the jitter. It’s like putting a slight damper on the noise, making the trace a little easier to read.",
        "handler": "set_averaging"
    },
    {
        "value": 10,
        "label": "Getting Clear",
        "description": "The trace becomes noticeably less fuzzy. The random spikes of the noise floor start to settle down, revealing more consistent signals.",
        "handler": "set_averaging"
    },
    {
        "value": 25,
        "label": "The Sweet Spot",
        "description": "A good balance of noise reduction and display speed. The noise floor is clean, and low-level, stable signals are clearly visible.",
        "handler": "set_averaging"
    },
    {
        "value": 50,
        "label": "Steady Hands",
        "description": "The noise floor is now very stable and appears as a thin line. You’re only seeing the most consistent signals and cutting out most of the random interference.",
        "handler": "set_averaging"
    },
    {
        "value": 75,
        "label": "Deep Dive",
        "description": "This setting is for serious analysis. It's a highly stable trace that filters out a large portion of the ambient RF noise, allowing for precise measurements of continuous signals.",
        "handler": "set_averaging"
    },
    {
        "value": 100,
        "label": "Scientific Grade",
        "description": "For when only the cleanest signal will do. This high level of averaging provides a virtually noise-free display, perfect for scientific or very low-level signal detection. 🔬",
        "handler": "set_averaging"
    },
    {
        "value": 200,
        "label": "Crystal Clear",
        "description": "A deep and thorough look at the spectrum. All but the most stable signals are averaged out, offering a truly pristine view of the fundamental RF environment.",
        "handler": "set_averaging"
    },
    {
        "value": 500,
        "label": "The Observer",
        "description": "An incredibly slow and deliberate pace. This is for long-term monitoring, allowing you to see the overall shape of the spectrum with almost all noise removed.",
        "handler": "set_averaging"
    },
    {
        "value": 1000,
        "label": "Meditative Mode",
        "description": "For the patient and the meticulous. This is the ultimate level of noise reduction, yielding an exceptionally smooth and stable trace for the most demanding analysis. 🧘‍♂️",
        "handler": "set_averaging"
    }
]

# ADDED: This preset dictionary was missing and is required for FrequencySettingsTab.
PRESET_FREQUENCY_SPAN_MHZ = {
    'Max': {
        'center_mhz': 1500.0,
        'span_mhz': 3000.0,
        'description': 'Sets a full frequency range from 0 to 3 GHz.'
    },
    'FM Radio': {
        'center_mhz': 98.0,
        'span_mhz': 20.0,
        'description': 'Tunes to the standard FM radio band (88-108 MHz).'
    },
    'UHF TV': {
        'center_mhz': 600.0,
        'span_mhz': 500.0,
        'description': 'Tuning to the UHF TV broadcast band (470-806 MHz).'
    }
}

#####################################
### File: OPEN-AIR\ref\ref_scanning_setting.py
#####################################
# ref/ref_scanning_setting.py
#
# This file contains predefined lists of settings that are primarily used
# for UI configuration and do not have a direct handler for instrument control.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250815.151240.13
# NEW: Created a new file to house UI-specific scanner presets.

current_version = "20250815.151240.13" # this variable should always be defined below the header to make the debugging better

PRESET_DISPLAY_GRAPH_QUALITY = [
    {
        "value": 1_000_000,
        "label": "Ultra Low",
        "description": "Blocky enough to be Minecraft.",
        "handler": None
    },
    {
        "value": 100_000,
        "label": "Low",
        "description": "VHS quality RF — nostalgic but fuzzy.",
        "handler": None
    },
    {
        "value": 50_000,
        "label": "Medium",
        "description": "Standard definition TV of frequency.",
        "handler": None
    },
    {
        "value": 25_000,
        "label": "Medium Well",
        "description": "Almost gourmet, but still quick-cook.",
        "handler": None
    },
    {
        "value": 10_000,
        "label": "High",
        "description": "RF with Wi-Fi smoothness.",
        "handler": None
    },
    {
        "value": 5_000,
        "label": "Ultra High",
        "description": "Retina display for radio.",
        "handler": None
    },
    {
        "value": 1_000,
        "label": "Ludacris",
        "description": "So fine, even Ludacris said “Damn.”",
        "handler": None
    },
    {
        "value": 500,
        "label": "Ridonkulous",
        "description": "“I can see the atoms in your waveform.”",
        "handler": None
    },
    {
        "value": 100,
        "label": "Quantum Foam",
        "description": "Where reality and noise floor blur.",
        "handler": None
    },
    {
        "value": 10,
        "label": "This is Fine",
        "description": "The scanner cries, but it's worth it. 🔥",
        "handler": None
    }
]

PRESET_CYCLE_WAIT_TIME = [
    {
        "value": 15,
        "label": "Hold Your Horses",
        "description": "Just a moment — enough time to sneeze twice.",
        "handler": None
    },
    {
        "value": 30,
        "label": "Wait-a-Second",
        "description": "Half a minute of suspense. Elevator music optional.",
        "handler": None
    },
    {
        "value": 60,
        "label": "Microwave Dinner",
        "description": "One full minute — perfect for impatient people.",
        "handler": None
    },
    {
        "value": 300,
        "label": "Coffee Break",
        "description": "Five minutes — time to stretch or grab caffeine.",
        "handler": None
    },
    {
        "value": 900,
        "label": "Quarter of Shame",
        "description": "15 minutes of contemplation. Or buffering.",
        "handler": None
    },
    {
        "value": 1800,
        "label": "Netflix Warmup",
        "description": "30 minutes — just long enough to not commit to a show.",
        "handler": None
    },
    {
        "value": 3600,
        "label": "Full Commitment",
        "description": "1 hour — a true test of patience and faith in the process.",
        "handler": None
    },
    {
        "value": 10800,
        "label": "Eternal Watcher",
        "description": "3 hours — were you expecting a callback?",
        "handler": None
    }
]

PRESET_FREQUENCY_SHIFT = [
    {
        "value": 0,
        "label": "No Shift",
        "description": "don't touch that dial — stay put.",
        "handler": None
    },
    {
        "value": 1_000,
        "label": "A Wee Bit",
        "description": "Just a nudge — like adjusting your hat slightly.",
        "handler": None
    },
    {
        "value": 5_000,
        "label": "A Nudge",
        "description": "A gentle push up or down the dial.",
        "handler": None
    },
    {
        "value": 10_000,
        "label": "A Whap",
        "description": "Noticeable thump — not subtle, not wild.",
        "handler": None
    },
    {
        "value": 25_000,
        "label": "A Scooch",
        "description": "Just enough to dodge interference or hop channels.",
        "handler": None
    },
    {
        "value": 50_000,
        "label": "A Chunk",
        "description": "A meaty move — shift the neighborhood.",
        "handler": None
    },
    {
        "value": 100_000,
        "label": "A Jump",
        "description": "You're not walking anymore — you're airborne.",
        "handler": None
    },
    {
        "value": 250_000,
        "label": "A Leap",
        "description": "Covering ground like a gazelle on caffeine.",
        "handler": None
    },
    {
        "value": 500_000,
        "label": "A Yeet",
        "description": "Full send across the spectrum — no regrets.",
        "handler": None
    },
    {
        "value": 1_000_000,
        "label": "A Warp",
        "description": "Fold space and reappear in another RF galaxy.",
        "handler": None
    }
]

PRESET_NUMBER_OF_SCANS = [
    {
        "value": 1,
        "label": "Just a Test",
        "description": "See how she goes — one and done.",
        "handler": None
    },
    {
        "value": 2,
        "label": "A Whiff",
        "description": "A quick sniff around the spectrum.",
        "handler": None
    },
    {
        "value": 10,
        "label": "A Bunch",
        "description": "Enough to get a good feel.",
        "handler": None
    },
    {
        "value": 50,
        "label": "A Bushel",
        "description": "A good harvest of data.",
        "handler": None
    },
    {
        "value": 75,
        "label": "A Shwack",
        "description": "A hefty pile — things are serious now.",
        "handler": None
    },
    {
        "value": 100,
        "label": "A Ton",
        "description": "A solid chunk of scanning.",
        "handler": None
    },
    {
        "value": 1_000,
        "label": "A Tone",
        "description": "A big, noisy tone of scans.",
        "handler": None
    },
    {
        "value": 99_999_999,
        "label": "Never-Ending Story",
        "description": "Until you say stop or the program crashes spectacularly.",
        "handler": None
    }
]

PRESET_SWEEP_TIME = [
    {
        "value": 0.5,
        "label": "Crazy Fast",
        "description": "Blink and you’ll miss it. Best for wideband sweeps with minimal detail.",
        "handler": "set_sweep_time" 
    },
    {
        "value": 1.0,
        "label": "Very Fast",
        "description": "Great for active scanning with basic detection.",
        "handler": "set_sweep_time"
    },
    {
        "value": 2.0,
        "label": "Standard",
        "description": "Balanced scan — enough time for most signals to show.",
        "handler": "set_sweep_time"
    },
    {
        "value": 3.0,
        "label": "Long",
        "description": "Allows time to catch short bursts or weak signals.",
        "handler": "set_sweep_time"
    },
    {
        "value": 5.0,
        "label": "Very Long",
        "description": "Camped out. Good for quiet bands or deep listening.",
        "handler": "set_sweep_time"
    },
    {
        "value": 10.0,
        "label": "Glacier Mode",
        "description": "For scientists, spies, and patient people. 🧊",
        "handler": "set_sweep_time"
    }
]


PRESET_SWEEP_TIME = [
    {
        "value": 0.5,
        "label": "Crazy Fast",
        "description": "Blink and you’ll miss it. Best for wideband sweeps with minimal detail.",
        "handler": "set_sweep_time" 
    },
    {
        "value": 1.0,
        "label": "Very Fast",
        "description": "Great for active scanning with basic detection.",
        "handler": "set_sweep_time"
    },
    {
        "value": 2.0,
        "label": "Standard",
        "description": "Balanced scan — enough time for most signals to show.",
        "handler": "set_sweep_time"
    },
    {
        "value": 3.0,
        "label": "Long",
        "description": "Allows time to catch short bursts or weak signals.",
        "handler": "set_sweep_time"
    },
    {
        "value": 5.0,
        "label": "Very Long",
        "description": "Camped out. Good for quiet bands or deep listening.",
        "handler": "set_sweep_time"
    },
    {
        "value": 10.0,
        "label": "Glacier Mode",
        "description": "For scientists, spies, and patient people. 🧊",
        "handler": "set_sweep_time"
    }
]



PRESET_AVERAGING = [
    {
        "value": "OFF",
        "label": "Off",
        "description": "Just a raw, single sweep. Great for seeing fast changes and fleeting events, but the noise floor is high and the trace is very jittery.",
        "handler": "set_averaging"
    },
    {
        "value": 5,
        "label": "Light Filter",
        "description": "A very mild smoothing of the signal, removing some of the jitter. It’s like putting a slight damper on the noise, making the trace a little easier to read.",
        "handler": "set_averaging"
    },
    {
        "value": 10,
        "label": "Getting Clear",
        "description": "The trace becomes noticeably less fuzzy. The random spikes of the noise floor start to settle down, revealing more consistent signals.",
        "handler": "set_averaging"
    },
    {
        "value": 25,
        "label": "The Sweet Spot",
        "description": "A good balance of noise reduction and display speed. The noise floor is clean, and low-level, stable signals are clearly visible.",
        "handler": "set_averaging"
    },
    {
        "value": 50,
        "label": "Steady Hands",
        "description": "The noise floor is now very stable and appears as a thin line. You’re only seeing the most consistent signals and cutting out most of the random interference.",
        "handler": "set_averaging"
    },
    {
        "value": 75,
        "label": "Deep Dive",
        "description": "This setting is for serious analysis. It's a highly stable trace that filters out a large portion of the ambient RF noise, allowing for precise measurements of continuous signals.",
        "handler": "set_averaging"
    },
    {
        "value": 100,
        "label": "Scientific Grade",
        "description": "For when only the cleanest signal will do. This high level of averaging provides a virtually noise-free display, perfect for scientific or very low-level signal detection. 🔬",
        "handler": "set_averaging"
    },
    {
        "value": 200,
        "label": "Crystal Clear",
        "description": "A deep and thorough look at the spectrum. All but the most stable signals are averaged out, offering a truly pristine view of the fundamental RF environment.",
        "handler": "set_averaging"
    },
    {
        "value": 500,
        "label": "The Observer",
        "description": "An incredibly slow and deliberate pace. This is for long-term monitoring, allowing you to see the overall shape of the spectrum with almost all noise removed.",
        "handler": "set_averaging"
    },
    {
        "value": 1000,
        "label": "Meditative Mode",
        "description": "For the patient and the meticulous. This is the ultimate level of noise reduction, yielding an exceptionally smooth and stable trace for the most demanding analysis. 🧘‍♂️",
        "handler": "set_averaging"
    }
]

#####################################
### File: OPEN-AIR\Scanning\TAB_SCANNING_PARENT.py
#####################################
# tabs/Scanning/TAB_SCANNING_PARENT.py
#
# This file defines the parent tab for Scanning-related functionalities.
# It acts as a container for child tabs such as "Scan Configuration",
# "Scan Bands", and "Scan Meta Data".
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250810.160100.3 (UPDATED: Added the new 'Scan Bands' tab and reordered the tabs.)

current_version = "20250810.160100.3"
current_version_hash = 20250810 * 160100 * 3 # Example hash, adjust as needed

import tkinter as tk
from tkinter import ttk
import inspect
import os

# Import the child tabs
from .tab_scanning_child_scan_configuration import ScanTab
from .tab_scanning_child_scan_meta_data import ScanMetaDataTab
from .tab_scanning_child_bands import BandsTab # NEW: Import the new BandsTab

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log

class TAB_SCANNING_PARENT(ttk.Frame):
    """
    A parent tab for Scanning-related functionalities.
    """
    def __init__(self, parent, app_instance, console_print_func):
        # This function description tells me what this function does
        # Initializes the parent tab for scanning. It sets up the notebook
        # and creates instances of the child tabs: Scan Configuration, BandsTab,
        # and Scan Meta Data.
        #
        # Inputs to this function
        #   parent (tk.Widget): The parent widget, typically a ttk.Notebook.
        #   app_instance (object): A reference to the main application instance.
        #   console_print_func (function): A function for printing to the console.
        #
        # Outputs of this function
        #   None. Initializes the Tkinter frame and its internal state.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Initializing TAB_SCANNING_PARENT.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)

        super().__init__(parent)
        self.app_instance = app_instance
        self.console_print_func = console_print_func

        # Use the specific, color-coded style for this child notebook
        self.child_notebook = ttk.Notebook(self, style='Scanning.Child.TNotebook')
        self.child_notebook.pack(expand=True, fill="both", padx=5, pady=5)

        self.scan_config_tab = ScanTab(self.child_notebook, self.app_instance, self.console_print_func)
        self.child_notebook.add(self.scan_config_tab, text="Scan Configuration")

        # NEW: Add the new BandsTab here
        self.scan_bands_tab = BandsTab(self.child_notebook, self.app_instance, self.console_print_func)
        self.child_notebook.add(self.scan_bands_tab, text="Bands")

        self.scan_meta_data_tab = ScanMetaDataTab(self.child_notebook, self.app_instance, self.console_print_func)
        self.child_notebook.add(self.scan_meta_data_tab, text="Scan Meta Data")

        self.child_notebook.bind("<<NotebookTabChanged>>", self._on_child_tab_selected)
        
        debug_log(f"TAB_SCANNING_PARENT initialized. Tabs are set up and ready!",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)


    def _on_child_tab_selected(self, event):
        # This function description tells me what this function does
        # Handles tab change events within this parent's child notebook by
        # delegating the event to the currently active child tab.
        #
        # Inputs to this function
        #   event (tkinter.Event): The event object that triggered the tab change.
        #
        # Outputs of this function
        #   None. Triggers a method call on a child tab.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Child tab selected in Scanning Parent. Checking for tab handler.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        selected_child_tab_id = self.child_notebook.select()
        if selected_child_tab_id:
            selected_child_tab_widget = self.child_notebook.nametowidget(selected_child_tab_id)
            if hasattr(selected_child_tab_widget, '_on_tab_selected'):
                selected_child_tab_widget._on_tab_selected(event)


    def _on_parent_tab_selected(self, event):
        # This function description tells me what this function does
        # Handles the event when this parent tab is selected by delegating
        # the event to the currently active child tab.
        #
        # Inputs to this function
        #   event (tkinter.Event): The event object from the parent notebook.
        #
        # Outputs of this function
        #   None.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Scanning Parent tab selected. Initializing child tab handlers.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        self._on_child_tab_selected(event)


#####################################
### File: OPEN-AIR\Scanning\tab_scanning_child_bands.py
#####################################
# tabs/Scanning/tab_scanning_child_bands.py
#
# This file defines the BandsTab, a Tkinter Frame that contains the UI for
# selecting and deselecting frequency bands for a scan. It has been
# refactored to allow multi-state selection (Low, Medium, High importance)
# and now includes a table and a bar chart to visualize the selected bands.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250810.220100.5 (FIXED: Removed redundant save_program_config  call from _on_tab_selected to prevent overwriting saved settings on app startup.)

current_version = "20250810.220100.5"
current_version_hash = 20250810 * 220100 * 5 # Example hash, adjust as needed

import tkinter as tk
from tkinter import ttk
import inspect
import os
import numpy as np
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

from display.debug_logic import debug_log
from display.console_logic import console_log
from settings_and_config.config_manager_save import save_program_config 

class BandsTab(ttk.Frame):
    """
    A Tkinter Frame that provides the user interface for selecting frequency bands to scan.
    """
    def __init__(self, master=None, app_instance=None, console_print_func=None, **kwargs):
        # This function description tells me what this function does
        # Initializes the BandsTab, creating the UI for multi-state band selection,
        # a summary table, and a visual bar chart of the selected bands.
        #
        # Inputs to this function
        #   master (tk.Widget): The parent widget, typically a ttk.Notebook.
        #   app_instance (object): A reference to the main application instance.
        #   console_print_func (function): A function for printing to the console.
        #   **kwargs: Arbitrary keyword arguments.
        #
        # Outputs of this function
        #   None. Initializes the Tkinter frame and its internal state.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Initializing BandsTab...",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func
        self.bands_inner_frame_id = None
        self.band_chart_fig = None
        self.band_chart_ax = None
        self.band_chart_canvas = None

        self._create_widgets()
        # The call to _on_tab_selected here is crucial, but it shouldn't save the config!
        self.after(100, self._on_tab_selected)

        debug_log(f"BandsTab initialized. All the band buttons are ready to be toggled!",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)

    def _create_widgets(self):
        # This function description tells me what this function does
        # Creates and arranges all widgets in the tab, including the control buttons,
        # the frame for the band buttons, the summary table, and the bar chart.
        #
        # Inputs to this function
        #   None.
        #
        # Outputs of this function
        #   None. Populates the tab with GUI elements.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Creating BandsTab widgets.",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)

        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(1, weight=0) # Band buttons frame
        self.grid_rowconfigure(2, weight=1) # Table frame
        self.grid_rowconfigure(3, weight=1) # Chart frame

        # --- Band Selection Buttons ---
        band_button_frame = ttk.Frame(self, style='Dark.TFrame')
        band_button_frame.grid(row=0, column=0, pady=5, padx=10, sticky="ew")
        band_button_frame.grid_columnconfigure(0, weight=1)
        band_button_frame.grid_columnconfigure(1, weight=1)
        
        ttk.Button(band_button_frame, text="Select All", command=self._select_all_bands, style='Blue.TButton').grid(row=0, column=0, padx=5, sticky="ew")
        ttk.Button(band_button_frame, text="Deselect All", command=self._deselect_all_bands, style='Blue.TButton').grid(row=0, column=1, padx=5, sticky="ew")

        # Frame for all Band Buttons
        self.bands_inner_frame = ttk.Frame(self, style='Dark.TFrame')
        self.bands_inner_frame.grid(row=1, column=0, padx=10, pady=5, sticky="nsew")
        self.bands_inner_frame.grid_columnconfigure(0, weight=1)
        self.bands_inner_frame.grid_columnconfigure(1, weight=1)

        # --- Selected Bands Table (Treeview) ---
        table_frame = ttk.Frame(self, style='Dark.TFrame')
        table_frame.grid(row=2, column=0, sticky="nsew", padx=10, pady=5)
        table_frame.grid_columnconfigure(0, weight=1)
        table_frame.grid_rowconfigure(0, weight=1)

        self.band_table = ttk.Treeview(table_frame, columns=("Name", "Start", "Stop", "Level"), show="headings")
        self.band_table.heading("Name", text="Name")
        self.band_table.heading("Start", text="Start (MHz)")
        self.band_table.heading("Stop", text="Stop (MHz)")
        self.band_table.heading("Level", text="Level")
        self.band_table.grid(row=0, column=0, sticky="nsew")
        
        # --- Band Importance Chart (Matplotlib) ---
        chart_frame = ttk.Frame(self, style='Dark.TFrame')
        chart_frame.grid(row=3, column=0, sticky="nsew", padx=10, pady=5)
        chart_frame.grid_columnconfigure(0, weight=1)
        chart_frame.grid_rowconfigure(0, weight=1)

        self.band_chart_fig = Figure(figsize=(5, 3), dpi=100, facecolor='#2b2b2b')
        self.band_chart_ax = self.band_chart_fig.add_subplot(111, facecolor='#1e1e1e')
        self.band_chart_canvas = FigureCanvasTkAgg(self.band_chart_fig, master=chart_frame)
        self.band_chart_canvas.get_tk_widget().grid(row=0, column=0, sticky="nsew")
        
        debug_log(f"BandsTab widgets created.",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)

    def _populate_band_buttons(self):
        # This function description tells me what this function does
        # Populates the scrollable frame with band selection buttons, dynamically
        # creating a button for each band defined in the application's band_vars.
        #
        # Inputs to this function
        #   None.
        #
        # Outputs of this function
        #   None. Populates the `bands_inner_frame` with buttons.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Populating band buttons.",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        for widget in self.bands_inner_frame.winfo_children():
            widget.destroy()
        
        self.bands_inner_frame.grid_columnconfigure(0, weight=1)
        self.bands_inner_frame.grid_columnconfigure(1, weight=1)

        for i, band_item in enumerate(self.app_instance.band_vars):
            band = band_item["band"]
            level = band_item.get("level", 0) # Get level, default to 0
            
            button_text = f"{band['Band Name']}\nStart: {band['Start MHz']:.3f} MHz\nStop: {band['Stop MHz']:.3f} MHz"
            
            btn = ttk.Button(self.bands_inner_frame, text=button_text)
            band_item['widget'] = btn # Store widget reference
            
            btn.configure(command=lambda bi=band_item: self._on_band_button_toggle(bi))
            
            self._update_button_style(btn, level)

            row, col = divmod(i, 2)
            btn.grid(row=row, column=col, sticky="ew", padx=2, pady=2)
            
        debug_log(f"Band buttons populated. Ready to toggle!",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)


    def _update_button_style(self, button, level):
        # This function description tells me what this function does
        # Updates the style of a band button based on its importance level.
        #
        # Inputs to this function
        #   button (ttk.Button): The button widget to style.
        #   level (int): The importance level (0=unselected, 1=low, 2=medium, 3=high).
        #
        # Outputs of this function
        #   None. Modifies the appearance of the button.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Updating button style for level {level}.",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        if level == 1:
            button.configure(style="Band.Low.TButton")
        elif level == 2:
            button.configure(style="Band.Medium.TButton")
        elif level == 3:
            button.configure(style="Band.High.TButton")
        else:
            button.configure(style="Band.TButton")


    def _on_band_button_toggle(self, band_item):
        # This function description tells me what this function does
        # Cycles the importance level of a band when its button is clicked and
        # updates the button's style. It then updates the table, chart, and saves the config.
        #
        # Inputs to this function
        #   band_item (dict): The dictionary containing the band's info, level, and widget.
        #
        # Outputs of this function
        #   None. Updates internal state, saves config, and refreshes the UI.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Toggling band importance. Current level: {band_item.get('level', 0)}",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        current_level = band_item.get("level", 0)
        new_level = (current_level + 1) % 4
        band_item["level"] = new_level
        
        self._update_button_style(band_item["widget"], new_level)
        
        # This is the correct place to save the config, AFTER a user action.
        save_program_config (self.app_instance.config, self.app_instance.CONFIG_FILE_PATH, self.console_print_func, self.app_instance)
        
        self._update_band_table()
        self._update_band_chart()


    def _update_band_table(self):
        # This function description tells me what this function does
        # Updates the Treeview table to display all bands with a non-zero importance level.
        #
        # Inputs to this function
        #   None.
        #
        # Outputs of this function
        #   None. Refreshes the content of the `band_table` Treeview.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Updating band table with selected bands.",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)

        # Clear existing entries
        for item in self.band_table.get_children():
            self.band_table.delete(item)

        importance_map = {1: "Low", 2: "Medium", 3: "High"}
        for band_item in self.app_instance.band_vars:
            level = band_item.get("level", 0)
            if level > 0:
                band = band_item["band"]
                self.band_table.insert("", "end", values=(
                    band['Band Name'],
                    f"{band['Start MHz']:.3f}",
                    f"{band['Stop MHz']:.3f}",
                    importance_map.get(level, "Unknown")
                ))

        self.band_table.update_idletasks()
        console_log("Band importance table updated.", function=current_function)
        
    def _update_band_chart(self):
        # This function description tells me what this function does
        # Creates or updates a Matplotlib bar chart to visually represent the selected
        # bands, their frequency ranges, and their importance levels.
        #
        # Inputs to this function
        #   None.
        #
        # Outputs of this function
        #   None. Renders the chart to the Tkinter canvas.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Updating band chart.",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)

        self.band_chart_ax.clear()
        self.band_chart_ax.set_facecolor('#1e1e1e')
        self.band_chart_ax.tick_params(axis='x', colors='white')
        self.band_chart_ax.tick_params(axis='y', colors='white')
        self.band_chart_ax.spines['bottom'].set_color('white')
        self.band_chart_ax.spines['top'].set_color('white')
        self.band_chart_ax.spines['left'].set_color('white')
        self.band_chart_ax.spines['right'].set_color('white')
        self.band_chart_ax.set_title("Band Importance Levels", color='white')
        self.band_chart_ax.set_xlabel("Frequency (MHz)", color='white')
        self.band_chart_ax.set_ylabel("Importance", color='white')

        # Map importance levels to Y values
        importance_y_map = {0: -10, 1: 25, 2: 50, 3: 100}

        selected_bands = []
        for band_item in self.app_instance.band_vars:
            level = band_item.get("level", 0)
            band = band_item["band"]
            selected_bands.append({
                'name': band['Band Name'],
                'start': band['Start MHz'],
                'stop': band['Stop MHz'],
                'level': level
            })

        if not selected_bands:
            debug_log(f"No bands selected to plot.",
                        file=os.path.basename(__file__),
                        version=current_version,
                        function=current_function)
            self.band_chart_canvas.draw()
            return
            
        min_freq = min(b['start'] for b in selected_bands)
        max_freq = max(b['stop'] for b in selected_bands)
        if min_freq == max_freq:
            min_freq -= 1
            max_freq += 1
        
        self.band_chart_ax.set_xlim(min_freq, max_freq)
        self.band_chart_ax.set_ylim(-20, 110)

        for band in selected_bands:
            color = 'gray'
            if band['level'] == 1:
                color = 'yellow'
            elif band['level'] == 2:
                color = 'orange'
            elif band['level'] == 3:
                color = 'red'
            
            self.band_chart_ax.bar(
                x=(band['start'] + band['stop']) / 2,
                height=importance_y_map.get(band['level'], -10),
                width=band['stop'] - band['start'],
                color=color,
                edgecolor='white'
            )

        self.band_chart_canvas.draw()
        console_log("Band importance chart updated.", function=current_function)


    def _update_all_band_button_styles(self):
        # This function description tells me what this function does
        # Iterates through all band buttons and updates their visual style
        # to match the current state of their associated importance level.
        #
        # Inputs to this function
        #   None.
        #
        # Outputs of this function
        #   None. Modifies the appearance of buttons.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Updating all band button styles.",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        for band_item in self.app_instance.band_vars:
            widget = band_item.get("widget")
            level = band_item.get("level", 0)
            if widget:
                self._update_button_style(widget, level)


    def _select_all_bands(self):
        # This function description tells me what this function does
        # Sets all band importance levels to High (3) and updates the UI.
        # It then saves the new configuration.
        #
        # Inputs to this function
        #   None.
        #
        # Outputs of this function
        #   None. Updates internal state and saves config.
        current_function = inspect.currentframe().f_code.co_name
        console_log("Selecting all bands for scan.", function=current_function)
        debug_log(f"Selecting all bands and saving config.",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        for band_item in self.app_instance.band_vars:
            band_item["level"] = 3 # High importance
        
        self._update_all_band_button_styles()
        save_program_config (self.app_instance.config, self.app_instance.CONFIG_FILE_PATH, self.console_print_func, self.app_instance)
        self._update_band_table()
        self._update_band_chart()


    def _deselect_all_bands(self):
        # This function description tells me what this function does
        # Sets all band importance levels to 0 (unselected) and updates the UI.
        # It then saves the new configuration.
        #
        # Inputs to this function
        #   None.
        #
        # Outputs of this function
        #   None. Updates internal state and saves config.
        current_function = inspect.currentframe().f_code.co_name
        console_log("Deselecting all bands for scan.", function=current_function)
        debug_log(f"Deselecting all bands and saving config.",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        for band_item in self.app_instance.band_vars:
            band_item["level"] = 0 # Unselected
        
        self._update_all_band_button_styles()
        save_program_config (self.app_instance.config, self.app_instance.CONFIG_FILE_PATH, self.console_print_func, self.app_instance)
        self._update_band_table()
        self._update_band_chart()


    def _on_tab_selected(self, event=None):
        # This function description tells me what this function does
        # Is called when the tab is selected. It ensures the UI elements
        # are populated and their styles are updated to reflect the current state.
        #
        # Inputs to this function
        #   event (tkinter.Event, optional): The event object.
        #
        # Outputs of this function
        #   None. Refreshes the UI.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"BandsTab selected. Populating and refreshing all widgets.",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        # We only want to populate the UI here, not save the config.
        # The save action is triggered by the user interacting with the buttons.
        self._populate_band_buttons()
        self._update_all_band_button_styles()
        self._update_band_table()
        self._update_band_chart()


#####################################
### File: OPEN-AIR\Scanning\tab_scanning_child_scan_configuration.py
#####################################
# tabs/Scanning/tab_scanning_child_scan_configuration.py
#
# This file defines the ScanTab, a Tkinter Frame that provides a user interface
# for configuring scanner settings such as frequency span, RBW, sweep time, etc.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250815.151740.3
# FIX: Corrected import names and paths after refactoring of preset lists.

current_version = "20250815.151740.3"
current_version_hash = (20250815 * 151740 * 3)

import tkinter as tk
from tkinter import ttk
import inspect
import os
import subprocess
import sys
from tkinter import filedialog


from display.debug_logic import debug_log
from display.console_logic import console_log
from settings_and_config.config_manager_save import save_program_config 

# Import presets that have associated handlers
from ref.ref_scanner_setting_lists import (
    
    PRESET_AMPLITUDE_REFERENCE_LEVEL,
    PRESET_AMPLITUDE_PREAMP_STATE,
    PRESET_AMPLITUDE_HIGH_SENSITIVITY_STATE,
    PRESET_AMPLITUDE_POWER_ATTENUATION,
    PRESET_BANDWIDTH_RBW,
    PRESET_FREQUENCY_SPAN,
    PRESET_TRACE_MODES,
    PRESET_CONTINUOUS_MODE
)

# Import presets for UI only
from ref.ref_scanning_setting import (
    PRESET_SWEEP_TIME,
    PRESET_DISPLAY_GRAPH_QUALITY,
    PRESET_CYCLE_WAIT_TIME,
    PRESET_FREQUENCY_SHIFT,
    PRESET_NUMBER_OF_SCANS,
)


class ScanTab(ttk.Frame):
    """
    The Scan Configuration child tab. Contains all UI elements for setting
    up a scan session.
    """
    def __init__(self, master, app_instance, console_print_func, **kwargs):
        # This function description tells me what this function does
        # Initializes the ScanTab, creating a frame to hold the main scan
        # configuration settings, such as output folder, scan name, and
        # instrument parameters.
        #
        # Inputs to this function
        #   master (tk.Widget): The parent widget, typically a ttk.Notebook.
        #   app_instance (object): A reference to the main application instance.
        #   console_print_func (function): A function to use for console output.
        #   **kwargs: Arbitrary keyword arguments.
        #
        # Outputs of this function
        #   None. Initializes the Tkinter frame and its internal state.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Initializing ScanTab...",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func

        self.setting_widgets = {}
        self._create_widgets()
        self.after(100, self._on_tab_selected)
        
        debug_log(f"ScanTab initialized. Scan configuration widgets are ready.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)


    def _create_widgets(self):
        # This function description tells me what this function does
        # Creates and arranges all widgets in the tab, including the output
        # settings frame and the instrument scan settings frame.
        #
        # Inputs to this function
        #   None.
        #
        # Outputs of this function
        #   None. Populates the tab with GUI elements.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Creating ScanTab widgets.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(2, weight=1)

        # --- Output Settings ---
        output_frame = ttk.LabelFrame(self, text="Output Settings", style='Dark.TLabelframe')
        output_frame.grid(row=0, column=0, padx=10, pady=10, sticky="ew")
        output_frame.grid_columnconfigure(1, weight=1)

        ttk.Label(output_frame, text="Scan Name:").grid(row=0, column=0, padx=5, pady=2, sticky="w")
        ttk.Entry(output_frame, textvariable=self.app_instance.scan_name_var).grid(row=0, column=1, padx=5, pady=2, sticky="ew")

        ttk.Label(output_frame, text="Output Folder:").grid(row=1, column=0, padx=5, pady=2, sticky="w")
        ttk.Entry(output_frame, textvariable=self.app_instance.output_folder_var, state="readonly").grid(row=1, column=1, padx=5, pady=2, sticky="ew")
        ttk.Button(output_frame, text="Browse", command=self._browse_output_folder, style='Blue.TButton').grid(row=1, column=2, padx=5, pady=2)
        ttk.Button(output_frame, text="Open Output Folder", command=self._open_output_folder, style='Blue.TButton').grid(row=2, column=0, columnspan=3, padx=5, pady=5, sticky="ew")

        # --- Scan Settings ---
        settings_frame = ttk.LabelFrame(self, text="Scan Settings", style='Dark.TLabelframe')
        settings_frame.grid(row=1, column=0, padx=10, pady=10, sticky="ew")
        settings_frame.grid_columnconfigure(2, weight=1)

        row_idx = 0
        # self._create_setting_row(settings_frame, row_idx, "graph_quality", "Graph Quality:", self.app_instance.rbw_step_size_hz_var, graph_quality_drop_down, "Hz"); row_idx += 1
        # self._create_setting_row(settings_frame, row_idx, "dwell_time", "DWELL (s):", self.app_instance.maxhold_time_seconds_var, dwell_time_drop_down, "s"); row_idx += 1
        # self._create_setting_row(settings_frame, row_idx, "max_hold_time", "Max Hold Time (s):", self.app_instance.cycle_wait_time_seconds_var, cycle_wait_time_presets, "s"); row_idx += 1
        # self._create_setting_row(settings_frame, row_idx, "scan_rbw", "Scan RBW (Hz):", self.app_instance.scan_rbw_hz_var, rbw_presets, "Hz"); row_idx += 1
        # self._create_setting_row(settings_frame, row_idx, "reference_level", "Reference Level (dBm):", self.app_instance.reference_level_dbm_var, reference_level_drop_down, "dBm"); row_idx += 1
        # self._create_setting_row(settings_frame, row_idx, "frequency_shift", "Frequency Shift (Hz):", self.app_instance.freq_shift_var, frequency_shift_presets, "Hz"); row_idx += 1
        # self._create_setting_row(settings_frame, row_idx, "num_scan_cycles", "Number of Scan Cycles:", self.app_instance.num_scan_cycles_var, number_of_scans_presets, "cycles"); row_idx += 1

        # # Boolean settings
        # ttk.Label(settings_frame, text="High Sensitivity:").grid(row=row_idx, column=0, padx=5, pady=2, sticky="w");
        # hs_combo = ttk.Combobox(settings_frame, values=["Yes", "No"], state="readonly", width=35); hs_combo.grid(row=row_idx, column=1, padx=5, pady=2, sticky="w")
        # hs_combo.bind("<<ComboboxSelected>>", lambda e, v=self.app_instance.high_sensitivity_var: self._on_boolean_combobox_select(e, v)); self.setting_widgets['high_sensitivity'] = {'widget': hs_combo, 'var': self.app_instance.high_sensitivity_var}; row_idx += 1
        #
        # ttk.Label(settings_frame, text="Preamplifier ON:").grid(row=row_idx, column=0, padx=5, pady=2, sticky="w");
        # pa_combo = ttk.Combobox(settings_frame, values=["Yes", "No"], state="readonly", width=35); pa_combo.grid(row=row_idx, column=1, padx=5, pady=2, sticky="w")
        # pa_combo.bind("<<ComboboxSelected>>", lambda e, v=self.app_instance.preamp_on_var: self._on_boolean_combobox_select(e, v)); self.setting_widgets['preamp_on'] = {'widget': pa_combo, 'var': self.app_instance.preamp_on_var}; row_idx += 1
        #
        # # --- ADDED BACK: Simple Entry fields ---
        # ttk.Label(settings_frame, text="Scan RBW Segmentation (Hz):").grid(row=row_idx, column=0, padx=5, pady=2, sticky="w")
        # ttk.Entry(settings_frame, textvariable=self.app_instance.scan_rbw_segmentation_var).grid(row=row_idx, column=1, sticky="ew", columnspan=2, padx=5, pady=2)
        # row_idx += 1
        # ttk.Label(settings_frame, text="Default Focus Width (Hz):").grid(row=row_idx, column=0, padx=5, pady=2, sticky="w")
        # ttk.Entry(settings_frame, textvariable=self.app_instance.desired_default_focus_width_var).grid(row=row_idx, column=1, sticky="ew", columnspan=2, padx=5, pady=2)
        # row_idx += 1

        debug_log(f"ScanTab widgets created.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
    def _create_setting_row(self, parent, row, key, label_text, app_var, data_list, unit=""):
        """Generic function to create and store a labeled combobox row for a setting."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Creating setting row for {key}.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        ttk.Label(parent, text=label_text).grid(row=row, column=0, padx=5, pady=2, sticky="w")
        display_values = [f"{item['value']} {unit}".strip() + f" - {item['label']}" for item in data_list]
        combo = ttk.Combobox(parent, values=display_values, state="readonly", width=35)
        combo.grid(row=row, column=1, padx=5, pady=2, sticky="w")
        description_var = tk.StringVar(self)
        ttk.Label(parent, textvariable=description_var, wraplength=400, justify="left").grid(row=row, column=2, padx=5, pady=2, sticky="w")
        combo.bind("<<ComboboxSelected>>", lambda e, v=app_var, d=data_list, dv=description_var, u=unit: self._on_combobox_select(e, v, d, dv, u))
        self.setting_widgets[key] = {'widget': combo, 'var': app_var, 'data': data_list, 'desc_var': description_var, 'unit': unit}

    def _on_combobox_select(self, event, app_var, data_list, description_var, unit):
        """Generic event handler for our settings comboboxes."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Combobox selected. Updating value and description.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        selected_display = event.widget.get()
        found_item = None
        for item in data_list:
            item_display = f"{item['value']} {unit}".strip() + f" - {item['label']}"
            if selected_display == item_display:
                found_item = item
                break
        if found_item:
            app_var.set(found_item['value'])
            description_var.set(found_item['description'])
            save_program_config (self.app_instance.config, self.app_instance.CONFIG_FILE_PATH, self.console_print_func, self.app_instance)

    def _on_boolean_combobox_select(self, event, app_var):
        """Handler specifically for 'Yes'/'No' comboboxes."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Boolean combobox selected. Updating value.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        is_yes = event.widget.get() == "Yes"
        app_var.set(is_yes)
        save_program_config (self.app_instance.config, self.app_instance.CONFIG_FILE_PATH, self.console_print_func, self.app_instance)

    def _set_combobox_display_from_value(self, key):
        """Helper to find and set the display text and description for a given raw value."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Setting combobox display from value for {key}.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        widget_info = self.setting_widgets.get(key)
        if not widget_info: return
        combo, app_var, data_list, desc_var, unit = widget_info['widget'], widget_info['var'], widget_info['data'], widget_info['desc_var'], widget_info['unit']
        current_value = app_var.get()
        found_item = None
        for item in data_list:
            if isinstance(current_value, float) and abs(float(item['value']) - current_value) < 1e-9:
                found_item = item
                break
            elif str(item['value']) == str(current_value):
                found_item = item
                break
        if found_item:
            display_text = f"{found_item['value']} {unit}".strip() + f" - {found_item['label']}"
            combo.set(display_text)
            desc_var.set(found_item['description'])
        else:
            combo.set(f"{current_value} {unit}".strip() + " - Custom")
            desc_var.set("Custom value not in presets.")

    def _load_settings_into_ui(self):
        """Populates all UI elements with values from the app_instance variables."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Loading settings into UI.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        for key in self.setting_widgets:
            if key in ['high_sensitivity', 'preamp_on']:
                widget_info = self.setting_widgets[key]
                widget_info['widget'].set("Yes" if widget_info['var'].get() else "No")
            else:
                self._set_combobox_display_from_value(key)

    def _browse_output_folder(self):
        # This function description tells me what this function does
        # Opens a file dialog for the user to select an output folder and saves
        # the selected path to the `output_folder_var` in the main application instance.
        #
        # Inputs to this function
        #   None.
        #
        # Outputs of this function
        #   None. Updates a Tkinter variable and saves the config.
        current_function = inspect.currentframe().f_code.co_name
        console_log("Browse for output folder...", self.console_print_func, function=current_function)
        debug_log(f"Opening file dialog to select output folder.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        folder = filedialog.askdirectory()
        if folder:
            self.app_instance.output_folder_var.set(folder)
            save_program_config (self.app_instance.config, self.app_instance.CONFIG_FILE_PATH, self.console_print_func, self.app_instance)

    def _open_output_folder(self):
        # This function description tells me what this function does
        # Opens the currently selected output folder using the default file explorer
        # for the operating system. It handles different OS commands and logs errors.
        #
        # Inputs to this function
        #   None.
        #
        # Outputs of this function
        #   None. Opens a file explorer window.
        current_function = inspect.currentframe().f_code.co_name
        path = self.app_instance.output_folder_var.get()
        debug_log(f"Attempting to open output folder: {path}",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        if os.path.isdir(path):
            try:
                if sys.platform == "win32":
                    os.startfile(path)
                elif sys.platform == "darwin":
                    subprocess.Popen(["open", path])
                else:
                    subprocess.Popen(["xdg-open", path])
                console_log(f"✅ Opened output folder: {path}", self.console_print_func, function=current_function)
            except Exception as e:
                console_log(f"❌ Error opening folder: {e}", self.console_print_func, function=current_function)
        else:
            console_log(f"❌ Folder not found: {path}", self.console_print_func, function=current_function)

    def _on_tab_selected(self, event=None):
        """Called when the tab is selected, ensures UI is synced with config."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"ScanTab selected. Refreshing UI from config.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        self._load_settings_into_ui()


#####################################
### File: OPEN-AIR\Scanning\tab_scanning_child_scan_meta_data.py
#####################################
# tabs/Scanning/tab_scanning_child_scan_meta_data.py
#
# This file defines the ScanMetaDataTab, a Tkinter Frame that contains the Scan Meta Data settings.
# This includes operator, venue, equipment, and general notes. It provides interactive elements
# like a postal code lookup and dynamic updates for antenna and amplifier descriptions.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250802.0011.3 (Fixed TclError: unknown option "-style_obj" by explicitly filtering it from kwargs.)

current_version = "20250802.0011.3" # this variable should always be defined below the header to make the debugging better
current_version_hash = 20250802 * 11 * 3 # Example hash, adjust as needed

import tkinter as tk
from tkinter import ttk, scrolledtext
import inspect
import os # For os.path.exists and os.makedirs
import subprocess # For opening folders

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log

from settings_and_config.config_manager_save import save_program_config 

# Import new modules for functionality - CORRECTED PATHS
from process_math.google_maps_lookup import get_location_from_google_maps
from ref.ref_antenna_type import antenna_types
from ref.ref_antenna_amplifier_type import antenna_amplifier_types


class ScanMetaDataTab(ttk.Frame):
    """
    A Tkinter Frame that contains the Scan Meta Data settings.
    This includes operator, venue, equipment, and general notes.
    """
    def __init__(self, master=None, app_instance=None, console_print_func=None, style_obj=None, **kwargs):
        # This function description tells me what this function does
        # Initializes the ScanMetaDataTab, setting up the UI frame,
        # linking to the main application instance, and preparing
        # Tkinter variables for meta data fields.
        #
        # Inputs to this function
        #   master (tk.Widget): The parent widget, typically a ttk.Notebook.
        #   app_instance (object): Reference to the main application instance
        #                          to access shared variables and methods.
        #   console_print_func (function): A function to print messages to the
        #                                  application's console output.
        #   style_obj (ttk.Style): The ttk.Style object for applying styles.
        #   **kwargs: Arbitrary keyword arguments passed to the ttk.Frame constructor.
        #
        # Process of this function
        #   1. Calls the superclass constructor (ttk.Frame).
        #   2. Stores references to app_instance, console_print_func, and style_obj.
        #   3. Initializes new Tkinter StringVars for postal code, address, province,
        #      selected antenna type, antenna description, antenna use, antenna mount,
        #      and selected amplifier type, amplifier description, and amplifier use.
        #   4. Calls _create_widgets to build the UI.
        #
        # Outputs of this function
        #   None. Initializes the Tkinter frame and its internal state.
        #
        # (2025-07-30) Change: Initialized new StringVars for regrouped fields, including new amplifier description/use.
        # (20250801.2330.1) Change: Refactored debug_print to use debug_log and console_log.
        # (20250802.0011.1) Change: Added missing widget attributes to allow external configuration.
        # (20250802.0011.2) Change: Fixed TclError by correctly handling style_obj in __init__.
        # (20250802.0011.3) Change: Fixed TclError by explicitly filtering style_obj from kwargs.
        
        # Filter out 'style_obj' from kwargs before passing to super().__init__
        filtered_kwargs = {k: v for k, v in kwargs.items() if k != 'style_obj'}
        super().__init__(master, style='Dark.TFrame', **filtered_kwargs) # Pass style string, and filtered kwargs

        self.app_instance = app_instance
        self.console_print_func = console_print_func if console_print_func else console_log # Use console_log as default
        self.style_obj = style_obj # Store the style object

        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Initializing ScanMetaDataTab. Version: {current_version}. Setting up meta data fields!",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        self._create_widgets()

        debug_log(f"ScanMetaDataTab initialized. Version: {current_version}. Meta data interface ready!",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    def _create_widgets(self):
        # This function description tells me what this function does
        # Creates and arranges the widgets for the Scan Meta Data tab,
        # grouping them into Personnel, Location, Equipment Used, and Notes sections.
        # It includes interactive elements like a postal code lookup button and
        # dropdowns for antenna and amplifier types with dynamic description updates.
        #
        # Inputs to this function
        #   None (operates on self).
        #
        # Process of this function
        #   1. Prints a debug message.
        #   2. Creates main LabelFrames for Personnel, Location, Equipment Used, and Notes.
        #   3. Populates each frame with appropriate Labels, Entry widgets,
        #      Buttons, and Comboboxes, linking them to app_instance variables.
        #   4. Configures grid layouts for each section to ensure proper alignment and resizing.
        #   5. Binds events for the postal code lookup button and Combobox selections
        #      to their respective handler methods.
        #   6. Initializes the notes ScrolledText widget and binds its key release event.
        #
        # Outputs of this function
        #   None. Modifies the Tkinter frame by adding and arranging widgets.
        #
        # (2025-07-30) Change: Made location fields editable; added amplifier description/use fields.
        # (2025-07-30) Change: Made antenna/amplifier description/use fields editable.
        # (20250801.2330.1) Change: Refactored debug_print to use debug_log and console_log.
        # (20250802.0011.1) Change: Assigned widgets to self attributes for external access.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Creating ScanMetaDataTab widgets... Building the meta data input form! Version: {current_version}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        # Main grid configuration for the tab
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(0, weight=0) # Personnel
        self.grid_rowconfigure(1, weight=0) # Location
        self.grid_rowconfigure(2, weight=0) # Equipment
        self.grid_rowconfigure(3, weight=1) # Notes (allow to expand)


        # --- Personnel Box ---
        personnel_frame = ttk.LabelFrame(self, text="Personnel", style='Dark.TLabelframe')
        personnel_frame.grid(row=0, column=0, padx=10, pady=5, sticky="ew")
        personnel_frame.grid_columnconfigure(1, weight=1) # Allow entry widgets to expand

        ttk.Label(personnel_frame, text="Operator Name:", style='TLabel').grid(row=0, column=0, padx=5, pady=2, sticky="w")
        self.operator_name_entry = ttk.Entry(personnel_frame, textvariable=self.app_instance.operator_name_var, style='TEntry')
        self.operator_name_entry.grid(row=0, column=1, padx=5, pady=2, sticky="ew")

        ttk.Label(personnel_frame, text="Operator Contact:", style='TLabel').grid(row=1, column=0, padx=5, pady=2, sticky="w")
        self.operator_contact_entry = ttk.Entry(personnel_frame, textvariable=self.app_instance.operator_contact_var, style='TEntry')
        self.operator_contact_entry.grid(row=1, column=1, padx=5, pady=2, sticky="ew")


        # --- Location Box ---
        location_frame = ttk.LabelFrame(self, text="Location", style='Dark.TLabelframe')
        location_frame.grid(row=1, column=0, padx=10, pady=5, sticky="ew")
        location_frame.grid_columnconfigure(1, weight=1) # Allow entry widgets to expand

        ttk.Label(location_frame, text="Venue Name:", style='TLabel').grid(row=0, column=0, padx=5, pady=2, sticky="w")
        self.venue_name_entry = ttk.Entry(location_frame, textvariable=self.app_instance.venue_name_var, style='TEntry')
        self.venue_name_entry.grid(row=0, column=1, padx=5, pady=2, sticky="ew")

        ttk.Label(location_frame, text="Venue Postal Code:", style='TLabel').grid(row=1, column=0, padx=5, pady=2, sticky="w")
        self.postal_code_entry = ttk.Entry(location_frame, textvariable=self.app_instance.venue_postal_code_var, style='TEntry')
        self.postal_code_entry.grid(row=1, column=1, padx=5, pady=2, sticky="ew")
        # Button for calling the postal code lookup function
        self.lookup_location_button = ttk.Button(location_frame, text="Lookup Location", command=self._lookup_postal_code, style='Blue.TButton')
        self.lookup_location_button.grid(row=1, column=2, padx=5, pady=2, sticky="e")

        ttk.Label(location_frame, text="Address Field:", style='TLabel').grid(row=2, column=0, padx=5, pady=2, sticky="w")
        # CHANGED: Removed state='readonly'
        self.address_field_entry = ttk.Entry(location_frame, textvariable=self.app_instance.address_field_var, style='TEntry')
        self.address_field_entry.grid(row=2, column=1, columnspan=2, padx=5, pady=2, sticky="ew")

        ttk.Label(location_frame, text="City:", style='TLabel').grid(row=3, column=0, padx=5, pady=2, sticky="w")
        # CHANGED: Removed state='readonly'
        self.city_entry = ttk.Entry(location_frame, textvariable=self.app_instance.city_var, style='TEntry')
        self.city_entry.grid(row=3, column=1, columnspan=2, padx=5, pady=2, sticky="ew")

        ttk.Label(location_frame, text="Province:", style='TLabel').grid(row=4, column=0, padx=5, pady=2, sticky="w")
        # CHANGED: Removed state='readonly'
        self.province_entry = ttk.Entry(location_frame, textvariable=self.app_instance.province_var, style='TEntry')
        self.province_entry.grid(row=4, column=1, columnspan=2, padx=5, pady=2, sticky="ew")


        # --- Equipment Used Box ---
        equipment_frame = ttk.LabelFrame(self, text="Equipment Used", style='Dark.TLabelframe')
        equipment_frame.grid(row=2, column=0, padx=10, pady=5, sticky="ew")
        equipment_frame.grid_columnconfigure(1, weight=1) # Allow entry/combobox to expand

        ttk.Label(equipment_frame, text="Scanner Type:", style='TLabel').grid(row=0, column=0, padx=5, pady=2, sticky="w")
        # Renamed to equipment_used_entry to match scan_logic.py's expectation
        self.equipment_used_entry = ttk.Entry(equipment_frame, textvariable=self.app_instance.scanner_type_var, style='TEntry')
        self.equipment_used_entry.grid(row=0, column=1, padx=5, pady=2, sticky="ew")

        ttk.Label(equipment_frame, text="Antenna Type:", style='TLabel').grid(row=1, column=0, padx=5, pady=2, sticky="w")
        # Renamed to antenna_type_dropdown to match scan_logic.py's expectation
        self.antenna_type_dropdown = ttk.Combobox(
            equipment_frame,
            textvariable=self.app_instance.selected_antenna_type_var,
            values=[ant["Type"] for ant in antenna_types],
            state="readonly", # This remains readonly as it's a selection from a predefined list
            style='TCombobox'
        )
        self.antenna_type_dropdown.grid(row=1, column=1, padx=5, pady=2, sticky="ew")
        self.antenna_type_dropdown.bind("<<ComboboxSelected>>", self._on_antenna_type_selected)

        ttk.Label(equipment_frame, text="Antenna Description:", style='TLabel').grid(row=2, column=0, padx=5, pady=2, sticky="w")
        # CHANGED: state='readonly' to state='normal'
        self.antenna_description_entry = ttk.Entry(equipment_frame, textvariable=self.app_instance.antenna_description_var, state='normal', style='TEntry')
        self.antenna_description_entry.grid(row=2, column=1, padx=5, pady=2, sticky="ew")

        ttk.Label(equipment_frame, text="Antenna Use:", style='TLabel').grid(row=3, column=0, padx=5, pady=2, sticky="w")
        # CHANGED: state='readonly' to state='normal'
        self.antenna_use_entry = ttk.Entry(equipment_frame, textvariable=self.app_instance.antenna_use_var, state='normal', style='TEntry')
        self.antenna_use_entry.grid(row=3, column=1, padx=5, pady=2, sticky="ew")

        ttk.Label(equipment_frame, text="Antenna Mount:", style='TLabel').grid(row=4, column=0, padx=5, pady=2, sticky="w")
        self.antenna_mount_entry = ttk.Entry(equipment_frame, textvariable=self.app_instance.antenna_mount_var, style='TEntry')
        self.antenna_mount_entry.grid(row=4, column=1, padx=5, pady=2, sticky="ew")

        # Spacer
        ttk.Separator(equipment_frame, orient='horizontal').grid(row=5, column=0, columnspan=2, pady=5, sticky="ew")

        ttk.Label(equipment_frame, text="Antenna Amplifier Type:", style='TLabel').grid(row=6, column=0, padx=5, pady=2, sticky="w")
        # Renamed to antenna_amplifier_dropdown to match scan_logic.py's expectation
        self.antenna_amplifier_dropdown = ttk.Combobox(
            equipment_frame,
            textvariable=self.app_instance.selected_amplifier_type_var,
            values=[amp["Type"] for amp in antenna_amplifier_types],
            state="readonly", # This remains readonly as it's a selection from a predefined list
            style='TCombobox'
        )
        self.antenna_amplifier_dropdown.grid(row=6, column=1, padx=5, pady=2, sticky="ew")
        self.antenna_amplifier_dropdown.bind("<<ComboboxSelected>>", self._on_amplifier_type_selected)

        # NEW: Amplifier Description and Use fields
        ttk.Label(equipment_frame, text="Amplifier Description:", style='TLabel').grid(row=7, column=0, padx=5, pady=2, sticky="w")
        # CHANGED: state='readonly' to state='normal'
        self.amplifier_description_entry = ttk.Entry(equipment_frame, textvariable=self.app_instance.amplifier_description_var, state='normal', style='TEntry')
        self.amplifier_description_entry.grid(row=7, column=1, padx=5, pady=2, sticky="ew")

        ttk.Label(equipment_frame, text="Amplifier Use:", style='TLabel').grid(row=8, column=0, padx=5, pady=2, sticky="w")
        # CHANGED: state='readonly' to state='normal'
        self.amplifier_use_entry = ttk.Entry(equipment_frame, textvariable=self.app_instance.amplifier_use_var, state='normal', style='TEntry')
        self.amplifier_use_entry.grid(row=8, column=1, padx=5, pady=2, sticky="ew")


        # --- Notes ---
        notes_frame = ttk.LabelFrame(self, text="Notes", style='Dark.TLabelframe')
        notes_frame.grid(row=3, column=0, padx=10, pady=5, sticky="nsew")
        notes_frame.grid_columnconfigure(0, weight=1) # Allow notes widget to expand
        notes_frame.grid_rowconfigure(0, weight=1) # Allow notes widget to expand

        # Renamed to notes_text to match scan_logic.py's expectation
        self.notes_text = scrolledtext.ScrolledText(notes_frame, wrap=tk.WORD, width=40, height=5)
        self.notes_text.grid(row=0, column=0, padx=5, pady=2, sticky="nsew")
        self.notes_text.bind("<KeyRelease>", self._on_notes_change)

        debug_log(f"ScanMetaDataTab widgets created. Meta data form is complete! Version: {current_version}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    def _on_notes_change(self, event=None):
        # This function description tells me what this function does
        # Updates the Tkinter notes_var from the ScrolledText widget and saves config.
        #
        # Inputs to this function
        #   event (tkinter.Event, optional): The event object that triggered the call.
        #
        # Process of this function
        #   1. Retrieves the current text from the ScrolledText widget.
        #   2. Sets the `app_instance.notes_var` with the retrieved text.
        #   3. Prints a debug message with the updated notes.
        #   4. Calls `save_program_config ` to persist the changes.
        #
        # Outputs of this function
        #   None. Updates an internal Tkinter variable and saves application configuration.
        #
        # (2025-07-30) Change: No functional change, just updated header.
        # (20250801.2330.1) Change: Refactored debug_print to use debug_log and console_log.
        # (20250802.0011.1) Change: Updated to use self.notes_text.
        """Updates the Tkinter notes_var from the ScrolledText widget and saves config."""
        self.app_instance.notes_var.set(self.notes_text.get("1.0", tk.END).strip())
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Notes updated: {self.app_instance.notes_var.get()}. Version: {current_version}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        # Corrected call to save_program_config  with all required arguments
        save_program_config (self.app_instance.config, self.app_instance.CONFIG_FILE_PATH, self.console_print_func, self.app_instance)


    def _on_tab_selected(self, event):
        # This function description tells me what this function does
        # Called when this tab is selected in the notebook.
        # This can be used to refresh data or update UI elements specific to this tab.
        #
        # Inputs to this function
        #   event (tkinter.Event): The event object that triggered the call.
        #
        # Process of this function
        #   1. Prints a debug message indicating the tab selection.
        #   2. Ensures the notes widget reflects the current value of `app_instance.notes_var`.
        #   3. Populates the `antenna_type_dropdown` and `antenna_amplifier_dropdown`
        #      with their respective values from `app_instance` if they are set.
        #   4. Triggers the update of antenna description and use based on the current selection.
        #   5. Explicitly populates all other text entry fields from their `app_instance` variables
        #      to ensure they reflect the loaded config values when the tab is selected.
        #
        # Outputs of this function
        #   None. Refreshes the UI elements on tab selection.
        #
        # (2025-07-30) Change: Added logic to refresh comboboxes and associated fields on tab selection.
        # (2025-07-30) Change: Added explicit population of all text entry fields from app_instance variables.
        # (20250801.2330.1) Change: Refactored debug_print to use debug_log and console_log.
        # (20250802.0011.1) Change: Updated to use new widget attribute names.
        """
        Called when this tab is selected in the notebook.
        This can be used to refresh data or update UI elements specific to this tab.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Scan Meta Data Tab selected. Refreshing all fields! Version: {current_version}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        # When the tab is selected, ensure the notes widget reflects the app_instance's variable
        self.notes_text.delete("1.0", tk.END)
        self.notes_text.insert("1.0", self.app_instance.notes_var.get())

        # Explicitly set the values for all Entry widgets from their associated StringVars
        # This is a robust way to ensure the UI is in sync with the model (app_instance variables)
        self.operator_name_entry.config(textvariable=self.app_instance.operator_name_var)
        self.operator_contact_entry.config(textvariable=self.app_instance.operator_contact_var)
        self.venue_name_entry.config(textvariable=self.app_instance.venue_name_var)
        self.postal_code_entry.config(textvariable=self.app_instance.venue_postal_code_var)
        self.address_field_entry.config(textvariable=self.app_instance.address_field_var)
        self.city_entry.config(textvariable=self.app_instance.city_var)
        self.province_entry.config(textvariable=self.app_instance.province_var)
        self.equipment_used_entry.config(textvariable=self.app_instance.scanner_type_var) # Corrected
        self.antenna_mount_entry.config(textvariable=self.app_instance.antenna_mount_var)
        
        # For comboboxes, set their value and then trigger their selection handler
        # This will ensure their associated description/use fields are also updated
        if self.app_instance.selected_antenna_type_var.get():
            self.antenna_type_dropdown.set(self.app_instance.selected_antenna_type_var.get())
            self._on_antenna_type_selected(None) # Trigger update of description/use
        else: # If no antenna type is selected, clear the description/use fields
            self.app_instance.antenna_description_var.set("")
            self.app_instance.antenna_use_var.set("")

        if self.app_instance.selected_amplifier_type_var.get():
            self.antenna_amplifier_dropdown.set(self.app_instance.selected_amplifier_type_var.get())
            self._on_amplifier_type_selected(None) # Trigger update of amplifier description/use
        else: # If no amplifier type is selected, clear the description/use fields
            self.app_instance.amplifier_description_var.set("")
            self.app_instance.amplifier_use_var.set("")

        debug_log(f"Scan Meta Data Tab refreshed. All fields are up-to-date! Version: {current_version}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    def _lookup_postal_code(self):
        # This function description tells me what this function does
        # Initiates a lookup of the venue postal code using the Google Maps Geocoding API.
        # It retrieves the postal code from the associated Tkinter variable,
        # calls the `get_location_from_google_maps` function, and updates the
        # address, city, and province Tkinter variables with the results.
        #
        # Inputs to this function
        #   None (operates on self).
        #
        # Process of this function
        #   1. Prints a debug message.
        #   2. Retrieves the postal code from `app_instance.venue_postal_code_var`.
        #   3. Checks if the postal code is empty. If so, prints a warning and clears fields.
        #   4. Calls `get_location_from_google_maps` with the postal code.
        #   5. Updates `app_instance.address_field_var`, `app_instance.city_var`,
        #      and `app_instance.province_var` with the returned values.
        #   6. Calls `save_program_config ` to persist the updated location data.
        #
        # Outputs of this function
        #   None. Updates Tkinter variables and saves configuration.
        #
        # (2025-07-30) Change: Updated to use `get_location_from_google_maps`.
        # (20250801.2330.1) Change: Refactored debug_print to use debug_log and console_log.
        # (20250802.0011.1) Change: No functional changes.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Attempting postal code lookup using Google Maps API. Let's find this location! Version: {current_version}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        postal_code = self.app_instance.venue_postal_code_var.get().strip()
        if not postal_code:
            self.console_print_func("⚠️ Please enter a postal code to look up. Don't leave it blank!")
            self.app_instance.address_field_var.set("")
            self.app_instance.city_var.set("")
            self.app_instance.province_var.set("")
            # Corrected call to save_program_config  with all required arguments
            save_program_config (self.app_instance.config, self.app_instance.CONFIG_FILE_PATH, self.console_print_func, self.app_instance)
            debug_log(f"Postal code was empty. Lookup aborted. Version: {current_version}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        # CHANGED: Call get_location_from_google_maps instead of get_location_from_text
        city, province, street_address = get_location_from_google_maps(postal_code, self.console_print_func)

        self.app_instance.address_field_var.set(street_address if street_address else "") # Changed N/A to empty string
        self.app_instance.city_var.set(city if city else "") # Changed N/A to empty string
        self.app_instance.province_var.set(province if province else "") # Changed N/A to empty string
        
        # Corrected call to save_program_config  with all required arguments
        save_program_config (self.app_instance.config, self.app_instance.CONFIG_FILE_PATH, self.console_print_func, self.app_instance)
        self.console_print_func("✅ Postal code lookup complete and fields updated. Location found!")
        debug_log(f"Postal code lookup complete and fields updated. Version: {current_version}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    def _on_antenna_type_selected(self, event):
        # This function description tells me what this function does
        # Event handler for when an antenna type is selected from the dropdown.
        # It updates the 'Antenna Description' and 'Antenna Use' text boxes
        # based on the selected antenna type's data from `antenna_types`.
        #
        # Inputs to this function
        #   event (tkinter.Event): The event object that triggered the call.
        #
        # Process of this function
        #   1. Prints a debug message.
        #   2. Retrieves the currently selected antenna type from `selected_antenna_type_var`.
        #   3. Iterates through the `antenna_types` list to find a matching entry.
        #   4. If a match is found, updates `antenna_description_var` and `antenna_use_var`
        #      with the corresponding description and use.
        #   5. If no match is found, clears the description and use fields.
        #   6. Calls `save_program_config ` to persist the selected antenna type.
        #
        # Outputs of this function
        #   None. Updates Tkinter variables and saves configuration.
        #
        # (2025-07-30) Change: No functional change, just updated header.
        # (20250801.2330.1) Change: Refactored debug_print to use debug_log and console_log.
        # (20250802.0011.1) Change: No functional changes.
        """
        Event handler for when an antenna type is selected from the dropdown.
        It updates the 'Antenna Description' and 'Antenna Use' text boxes
        based on the selected antenna type's data from `antenna_types`.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Antenna type selected. Updating description and use! Version: {current_version}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        selected_type = self.app_instance.selected_antenna_type_var.get()
        found_antenna = next((ant for ant in antenna_types if ant["Type"] == selected_type), None)

        if found_antenna:
            self.app_instance.antenna_description_var.set(found_antenna["Description"])
            self.app_instance.antenna_use_var.set(found_antenna["Use"])
            debug_log(f"Updated antenna description and use for: {selected_type}. Details loaded!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        else:
            self.app_instance.antenna_description_var.set("")
            self.app_instance.antenna_use_var.set("")
            debug_log(f"No description/use found for selected antenna type: {selected_type}. Fields cleared!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        
        # Corrected call to save_program_config  with all required arguments
        save_program_config (self.app_instance.config, self.app_instance.CONFIG_FILE_PATH, self.console_print_func, self.app_instance)
        debug_log(f"Antenna type updated and config saved. Version: {current_version}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    def _on_amplifier_type_selected(self, event):
        # This function description tells me what this function does
        # Event handler for when an amplifier type is selected from the dropdown.
        # It updates the `app_instance.antenna_amplifier_var` to reflect the
        # selected amplifier type, and also populates the `Amplifier Description`
        # and `Amplifier Use` text boxes based on the selected type's data.
        #
        # Inputs to this function
        #   event (tkinter.Event): The event object that triggered the call.
        #
        # Process of this function
        #   1. Prints a debug message.
        #   2. Retrieves the currently selected amplifier type from `selected_amplifier_type_var`.
        #   3. Sets the `app_instance.antenna_amplifier_var` with the selected type.
        #   4. Iterates through the `antenna_amplifier_types` list to find a matching entry.
        #   5. If a match is found, updates `amplifier_description_var` and `amplifier_use_var`
        #      with the corresponding description and use.
        #   6. If no match is found, clears the description and use fields.
        #   7. Calls `save_program_config ` to persist the selected amplifier type and its details.
        #
        # Outputs of this function
        #   None. Updates Tkinter variables and saves configuration.
        #
        # (2025-07-30) Change: Populated amplifier description and use fields, and updated header.
        # (20250801.2330.1) Change: Refactored debug_print to use debug_log and console_log.
        # (20250802.0011.1) Change: No functional changes.
        """
        Event handler for when an amplifier type is selected from the dropdown.
        It updates the `app_instance.antenna_amplifier_var` to reflect the
        selected amplifier type, and also populates the `Amplifier Description`
        and `Amplifier Use` text boxes based on the selected type's data.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Amplifier type selected. Getting details for this amplifier! Version: {current_version}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        selected_type = self.app_instance.selected_amplifier_type_var.get()
        # The original antenna_amplifier_var was an Entry, now it's effectively linked to the Combobox selection
        self.app_instance.antenna_amplifier_var.set(selected_type)
        
        # NEW: Populate amplifier description and use
        found_amplifier = next((amp for amp in antenna_amplifier_types if amp["Type"] == selected_type), None)

        if found_amplifier:
            self.app_instance.amplifier_description_var.set(found_amplifier["Description"])
            self.app_instance.amplifier_use_var.set(found_amplifier["Use"])
            debug_log(f"Updated amplifier description and use for: {selected_type}. Details loaded!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        else:
            self.app_instance.amplifier_description_var.set("")
            self.app_instance.amplifier_use_var.set("")
            debug_log(f"No description/use found for selected amplifier type: {selected_type}. Fields cleared!",
                        file=__file__,
                        version=current_version,
                        function=current_function)

        # Corrected call to save_program_config  with all required arguments
        save_program_config (self.app_instance.config, self.app_instance.CONFIG_FILE_PATH, self.console_print_func, self.app_instance)
        debug_log(f"Updated antenna amplifier to: {selected_type}. Config saved! Version: {current_version}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


#####################################
### File: OPEN-AIR\Scanning\utils_scan_instrument.py
#####################################
# tabs/Scanning/utils_scan_instrument.py
#
# Core logic for controlling the spectrum analyzer to perform frequency sweeps.
# Handles instrument communication, trace data acquisition, and saving to CSV.
# This module also contains the logic for initiating and running the scan thread.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250813.160010.1

import pyvisa
import time
import numpy as np
import re
import datetime
import os
import inspect
import threading
import pandas as pd

from display.debug_logic import debug_log, log_visa_command
from display.console_logic import console_log
from process_math.scan_stitch import stitch_and_save_scan_data
from src.connection_status_logic import update_connection_status_logic

from utils.utils_csv_writer import write_scan_data_to_csv
from ref.ref_frequency_bands import MHZ_TO_HZ, VBW_RBW_RATIO

current_version = "20250813.160010.1"
current_version_hash = (20250813 * 160010 * 1)

def initiate_scan_thread(app_instance, console_print_func, stop_event, pause_event, update_progress_func):
    """
    Function Description:
    Initiates the spectrum scan in a separate thread. This is the main entry point
    called by the Orchestrator GUI to start the scanning process.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Entering {current_function}", file=os.path.basename(__file__), version=current_version, function=current_function)
    
    if app_instance.scan_thread and app_instance.scan_thread.is_alive():
        console_print_func("⚠️ Process already running.")
        return False

    if not app_instance.is_connected.get():
        console_print_func("❌ Instrument not connected. Cannot start.")
        return False

    selected_bands = [band_item["band"] for band_item in app_instance.band_vars if band_item["level"] > 0]
    if not selected_bands:
        console_print_func("⚠️ No bands selected for scan.")
        return False

    stop_event.clear()
    pause_event.clear()
    app_instance.is_paused_by_user = False

    app_instance.scan_thread = threading.Thread(
        target=_scan_thread_target,
        args=(app_instance, selected_bands, stop_event, pause_event, console_print_func, update_progress_func)
    )
    app_instance.scan_thread.daemon = True
    app_instance.scan_thread.start()
    debug_log(f"Scan thread started successfully.", file=os.path.basename(__file__), version=current_version, function=current_function)
    return True

def _scan_thread_target(app_instance, selected_bands, stop_event, pause_event, console_print_func, update_progress_func):
    """
    The main function executed in the scanning thread. It orchestrates the scan process.
    """
    current_function = inspect.currentframe().f_code.co_name
    console_print_func("--- Initiating Spectrum Scan ---")
    try:
      #  from Instrument.utils_instrument_initialization import initialize_instrument_logic
        
        raw_scan_data, markers_data = scan_bands(
            app_instance_ref=app_instance,
            inst=app_instance.inst,
            selected_bands=selected_bands,
            rbw_hz=float(app_instance.scan_rbw_hz_var.get()),
            ref_level_dbm=float(app_instance.reference_level_dbm_var.get()),
            freq_shift_hz=float(app_instance.freq_shift_hz_var.get()),
            maxhold_enabled=bool(app_instance.maxhold_enabled_var.get()),
            high_sensitivity=app_instance.high_sensitivity_var.get(),
            preamp_on=app_instance.preamp_on_var.get(),
            rbw_step_size_hz=float(app_instance.rbw_step_size_hz_var.get()),
            max_hold_time_seconds=float(app_instance.maxhold_time_seconds_var.get()),
            scan_name=app_instance.scan_name_var.get(),
            output_folder=app_instance.output_folder_var.get(),
            stop_event=stop_event,
            pause_event=pause_event,
            log_visa_commands_enabled=app_instance.log_visa_commands_enabled_var.get(),
            general_debug_enabled=app_instance.general_debug_enabled_var.get(),
            app_console_update_func=console_print_func,
           # initialize_instrument_func=initialize_instrument_logic
        )

        if not stop_event.is_set():
            console_print_func("\n--- Stitching and saving scan data ---")
            stitch_and_save_scan_data(
                raw_scan_data_for_current_sweep=raw_scan_data,
                output_folder=app_instance.output_folder_var.get(),
                scan_name=app_instance.scan_name_var.get(),
                operator_name=app_instance.operator_name_var.get(),
                venue_name=app_instance.venue_name_var.get(),
                equipment_used=app_instance.scanner_type_var.get(),
                notes=app_instance.notes_var.get(),
                postal_code=app_instance.venue_postal_code_var.get(),
                latitude="N/A", # Placeholder
                longitude="N/A", # Placeholder
                antenna_type=app_instance.selected_antenna_type_var.get(),
                antenna_amplifier=app_instance.selected_amplifier_type_var.get(),
                console_print_func=console_print_func
            )
            console_print_func("--- Scan process finished. ---")
        else:
            console_print_func("--- Scan process stopped by user. ---")

    except Exception as e:
        console_print_func(f"❌ An error occurred during scan: {e}")
        debug_log(f"Error in scan thread target: {e}",
                    file=os.path.basename(__file__), function="_scan_thread_target")
    finally:
        # Update button states via the orchestrator_gui attribute
        app_instance.orchestrator_gui.is_running = False
        app_instance.orchestrator_gui.is_paused = False
        app_instance.after(0, lambda: app_instance.orchestrator_gui._update_button_states())
        app_instance.after(0, lambda: update_connection_status_logic(app_instance, app_instance.is_connected.get(), False, console_print_func))

def write_safe(inst, command, app_instance_ref, app_console_update_func):
    """Safely writes a SCPI command to the instrument."""
    # ... (function content is unchanged)
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Attempting to write command: {command}",
                file=f"{os.path.basename(__file__)} - {current_version}",
                version=current_version,
                function=current_function)
    if not inst:
        app_instance_ref.after(0, lambda: app_console_update_func("⚠️ Warning: Instrument not connected. Cannot write command. What the hell?!"))
        debug_log("Instrument not connected. Fucking useless!",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        return False
    try:
        inst.write(command)
        log_visa_command(command, "SENT")
        return True
    except Exception as e:
        app_instance_ref.after(0, lambda: app_console_update_func(f"❌ Error writing command '{command}': {e}. This thing is a pain in the ass!"))
        debug_log(f"Error writing command '{command}': {e}. What a mess!",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        return False

def query_safe(inst, command, app_instance_ref, app_console_update_func):
    """Safely queries the instrument and returns the response."""
    # ... (function content is unchanged)
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Attempting to query command: {command}",
                file=f"{os.path.basename(__file__)} - {current_version}",
                version=current_version,
                function=current_function)
    if not inst:
        app_instance_ref.after(0, lambda: app_console_update_func("⚠️ Warning: Instrument not connected. Cannot query command. What the hell?!"))
        debug_log("Instrument not connected. Fucking useless!",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        return None
    try:
        response = inst.query(command).strip()
        log_visa_command(command, "SENT")
        log_visa_command(response, "RECEIVED")
        return response
    except Exception as e:
        app_instance_ref.after(0, lambda: app_console_update_func(f"❌ Error querying command '{command}': {e}. This goddamn thing is broken!"))
        debug_log(f"Error querying command '{command}': {e}. What a pain!",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        return None


def configure_instrument_for_scan(inst, center_freq_hz, span_hz, rbw_hz, ref_level_dbm,
                                  freq_shift_hz, high_sensitivity_on, preamp_on,
                                  app_instance_ref, app_console_update_func):
    """Configures the spectrum analyzer with specified settings for a scan segment."""
    # ... (function content is unchanged)
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Configuring instrument for scan. Center: {center_freq_hz/MHZ_TO_HZ:.3f} MHz, Span: {span_hz/MHZ_TO_HZ:.3f} MHz, RBW: {rbw_hz} Hz. Let's get this machine ready!",
                file=f"{os.path.basename(__file__)} - {current_version}",
                version=current_version,
                function=current_function)

    if not inst:
        app_instance_ref.after(0, lambda: app_console_update_func("⚠️ Warning: Instrument not connected. Cannot configure for scan. Connect the damn thing first!"))
        debug_log("Instrument not connected for configuration. Fucking useless!",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        return False

    success = True
    if not write_safe(inst, "*RST", app_instance_ref, app_console_update_func): success = False
    time.sleep(0.1)
    if not write_safe(inst, ":SENSe:AVERage:COUNt 1", app_instance_ref, app_console_update_func): success = False
    if not write_safe(inst, ":SENSe:SWEep:POINts 1001", app_instance_ref, app_console_update_func): success = False
    if not write_safe(inst, f":SENSe:FREQuency:CENTer {center_freq_hz}", app_instance_ref, app_console_update_func): success = False
    time.sleep(0.05)
    if not write_safe(inst, f":SENSe:FREQuency:SPAN {span_hz}", app_instance_ref, app_console_update_func): success = False
    time.sleep(0.05)
    if not write_safe(inst, f":SENSe:BANDwidth:RESolution {rbw_hz}", app_instance_ref, app_console_update_func): success = False
    time.sleep(0.05)
    if not write_safe(inst, f":DISPlay:WINDow:TRACe:Y:RLEVel {ref_level_dbm}DBM", app_instance_ref, app_console_update_func): success = False
    time.sleep(0.05)
    if not write_safe(inst, f":SENSe:FREQuency:RFShift {freq_shift_hz}", app_instance_ref, app_console_update_func): success = False
    time.sleep(0.05)
    high_sensitivity_cmd = ":SENSe:POWer:RF:HSENs ON" if high_sensitivity_on else ":SENSe:POWer:RF:HSENs OFF"
    if not write_safe(inst, high_sensitivity_cmd, app_instance_ref, app_console_update_func): success = False
    time.sleep(0.05)
    preamp_cmd = ":SENSe:POWer:RF:GAIN ON" if preamp_on else ":SENSe:POWer:RF:GAIN OFF"
    if not write_safe(inst, preamp_cmd, app_instance_ref, app_console_update_func): success = False
    time.sleep(0.05)

    if success:
        app_instance_ref.after(0, lambda: app_console_update_func("✅ Instrument configured successfully for scan. Ready for data!"))
    else:
        app_instance_ref.after(0, lambda: app_console_update_func("❌ Failed to fully configure instrument for scan. This is a disaster!"))
    return success

def perform_single_sweep(inst, app_instance_ref, app_console_update_func):
    """Triggers a single sweep and retrieves trace data."""
    # ... (function content is unchanged)
    current_function = inspect.currentframe().f_code.co_name
    debug_log("Performing single sweep... Getting that juicy data!",
                file=f"{os.path.basename(__file__)} - {current_version}",
                version=current_version,
                function=current_function)

    if not inst:
        app_instance_ref.after(0, lambda: app_console_update_func("⚠️ Warning: Instrument not connected. Cannot perform sweep. Connect the damn thing first!"))
        return None, None

    try:
        if not write_safe(inst, ":INITiate:CONTinuous OFF", app_instance_ref, app_console_update_func): return None, None
        time.sleep(0.1)
        if not write_safe(inst, ":INITiate:IMMediate; *WAI", app_instance_ref, app_console_update_func): return None, None
        time.sleep(0.5)

        freq_response = query_safe(inst, ":TRACe:X:VALues?", app_instance_ref, app_console_update_func)
        if freq_response is None:
            app_instance_ref.after(0, lambda: app_console_update_func("❌ Failed to query frequency data. This is a disaster!"))
            return None, None
        frequencies_hz = [float(f) for f in freq_response.split(',')]

        trace_response = query_safe(inst, ":TRACe:DATA? TRACE1", app_instance_ref, app_console_update_func)
        if trace_response is None:
            app_instance_ref.after(0, lambda: app_console_update_func("❌ Failed to query trace data. This is frustrating!"))
            return None, None
        power_dbm = [float(p) for p in trace_response.split(',')]

        if len(frequencies_hz) != len(power_dbm):
            app_instance_ref.after(0, lambda: app_console_update_func("❌ Mismatch between frequency and power data points. Data corrupted!"))
            return None, None

        app_instance_ref.after(0, lambda: app_console_update_func(f"✅ Single sweep complete. Collected {len(frequencies_hz)} data points. Success!"))
        return frequencies_hz, power_dbm

    except Exception as e:
        app_instance_ref.after(0, lambda: app_console_update_func(f"❌ Error during single sweep: {e}. This is a disaster!"))
        return None, None

def perform_segment_sweep(inst, segment_start_freq_hz, segment_stop_freq_hz, maxhold_enabled, max_hold_time, app_instance_ref, pause_event, stop_event, segment_counter, total_segments_in_band, band_name, app_console_update_func, current_segment_start_freq_hz):
    """Performs a single frequency sweep segment on the instrument and retrieves data."""
    # ... (function content is unchanged, but I must add the missing `current_segment_start_freq_hz` to the signature)
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Entering {current_function} function. Segment {segment_counter}/{total_segments_in_band}",
                file=f"{os.path.basename(__file__)} - {current_version}",
                version=current_version,
                function=current_function)

    while pause_event.is_set():
        app_instance_ref.after(0, lambda: app_console_update_func("Scan Paused. Click Resume to continue."))
        time.sleep(0.1)
        if stop_event.is_set():
            app_instance_ref.after(0, lambda: app_console_update_func(f"Scan for {band_name} interrupted during pause in max hold for segment {segment_counter}."))
            return []
    if stop_event.is_set():
        app_instance_ref.after(0, lambda: app_console_update_func(f"Scan for {band_name} interrupted during segment {segment_counter}."))
        return []

    if not write_safe(inst, f":SENS:FREQ:STAR {segment_start_freq_hz};:SENS:FREQ:STOP {segment_stop_freq_hz}", app_instance_ref, app_console_update_func):
        app_instance_ref.after(0, lambda: app_console_update_func(f"❌ Error: Failed to set frequency range for segment {segment_counter}."))
        return []

    if not write_safe(inst, ":TRAC1:MODE BLANk;:TRAC2:MODE BLANk;:TRAC3:MODE BLANk", app_instance_ref, app_console_update_func):
        app_instance_ref.after(0, lambda: app_console_update_func(f"❌ Error: Failed to blank traces for segment {segment_counter}."))
    if maxhold_enabled:
        if not write_safe(inst, ":TRAC2:MODE MAXHold;", app_instance_ref, app_console_update_func):
            app_instance_ref.after(0, lambda: app_console_update_func(f"❌ Error: Failed to set Max Hold mode for segment {segment_counter}."))

    app_instance_ref.after(0, lambda: app_console_update_func("💬 Initiating single sweep for segment..."))
    if not write_safe(inst, ":INITiate:CONTinuous OFF", app_instance_ref, app_console_update_func): return []
    if not write_safe(inst, ":INITiate:IMMediate; *WAI", app_instance_ref, app_console_update_func): return []
    
    if maxhold_enabled and max_hold_time > 0:
        for _ in range(int(max_hold_time * 10)):
            while pause_event.is_set():
                app_instance_ref.after(0, lambda: app_console_update_func("Scan Paused. Click Resume to continue."))
                time.sleep(0.1)
            if stop_event.is_set():
                app_instance_ref.after(0, lambda: app_console_update_func(f"Scan for {band_name} interrupted during pause in max hold for segment {segment_counter}."))
                return []
            if stop_event.is_set():
                app_instance_ref.after(0, lambda: app_console_update_func(f"Scan for {band_name} interrupted during max hold for segment {segment_counter}."))
                return []
            if _ % 10 == 0:
                sec_remaining = int(max_hold_time - (_ / 10))
            time.sleep(0.1)

    if stop_event.is_set():
        app_instance_ref.after(0, lambda: app_console_update_func(f"Scan for {band_name} interrupted after max hold for segment {segment_counter}."))
        return []

    progress_percentage = (segment_counter / total_segments_in_band)
    bar_length = 20
    filled_length = int(round(bar_length * progress_percentage))
    progressbar = '█' * filled_length + '-' * (bar_length - filled_length)
    progress_message = f"{progressbar}🔍 Span:📊{(segment_stop_freq_hz - segment_start_freq_hz)/MHZ_TO_HZ:.3f} MHz--📈{current_segment_start_freq_hz/MHZ_TO_HZ:.3f} MHz to 📉{segment_stop_freq_hz/MHZ_TO_HZ:.3f} MHz   ✅{segment_counter} of {total_segments_in_band} "
    app_instance_ref.after(0, lambda msg=progress_message: app_console_update_func(msg))
    
    segment_raw_data = []
    # (rest of the logic from original file...)
    try:
        instrument_model = app_instance_ref.connected_instrument_model.get()
        if instrument_model == "N9340B":
            trace_data_str = query_safe(inst, ":TRAC2:DATA?", app_instance_ref, app_console_update_func)
        else: # Default/N9342CN
            trace_data_str = query_safe(inst, ":TRACe:DATA? TRACe2", app_instance_ref, app_console_update_func)

        if trace_data_str is None or not trace_data_str.strip():
            app_instance_ref.after(0, lambda: app_console_update_func("🚫 No valid trace data string received for this segment."))
            return []

        match = re.match(r'#\d+\d+(.*)', trace_data_str)
        data_part = match.group(1) if match else trace_data_str

        if data_part:
            amplitudes_dbm = [float(val) for val in data_part.split(',') if val.strip()]
            num_points = len(amplitudes_dbm)
            if num_points > 1:
                frequencies_hz = np.linspace(segment_start_freq_hz, segment_stop_freq_hz, num_points)
                if len(amplitudes_dbm) == len(frequencies_hz):
                    segment_raw_data.extend(zip(frequencies_hz, amplitudes_dbm))
    except Exception as e:
        app_instance_ref.after(0, lambda: app_console_update_func(f"🚨 Error in segment sweep: {e}"))
        return []
    
    return segment_raw_data


def scan_bands(app_instance_ref, inst, selected_bands, rbw_hz, ref_level_dbm, freq_shift_hz, maxhold_enabled, high_sensitivity, preamp_on, rbw_step_size_hz, max_hold_time_seconds, scan_name, output_folder, stop_event, pause_event, log_visa_commands_enabled, general_debug_enabled, app_console_update_func, initialize_instrument_func):
    """Orchestrates a full frequency scan across multiple specified bands."""
    # ... (function content is unchanged)
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Entering {current_function} function. Starting scan_bands.",
                file=f"{os.path.basename(__file__)} - {current_version}",
                version=current_version,
                function=current_function)

    overall_start_freq_hz = min(band["Start MHz"] for band in selected_bands) * MHZ_TO_HZ
    overall_stop_freq_hz = max(band["Stop MHz"] for band in selected_bands) * MHZ_TO_HZ
    
    app_instance_ref.after(0, lambda: app_console_update_func(f"Scanning from {overall_start_freq_hz / MHZ_TO_HZ:.3f} MHz to {overall_stop_freq_hz / MHZ_TO_HZ:.3f} MHz..."))

  #  if not initialize_instrument_logic(
        #inst,
       # model_match=app_instance_ref.connected_instrument_model.get(),
       # ref_level_dbm=ref_level_dbm,
      #  high_sensitivity_on=high_sensitivity,
     #   preamp_on=preamp_on,
    #    rbw_config_val=rbw_hz,
   #     vbw_config_val=rbw_hz * VBW_RBW_RATIO,
  #      app_instance_ref=app_instance_ref,
 #       console_print_func=app_console_update_func
#    ):
        #app_instance_ref.after(0, lambda: app_console_update_func("❌ Error: Failed to initialize instrument for scan. Aborting."))
        #return -1, None, None

    # (rest of setup commands...)

    timestamp_hm = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    csv_filename_current_cycle = os.path.join(output_folder, f"{scan_name}_RBW{int(rbw_hz/1000)}K_HOLD{int(max_hold_time_seconds)}_Offset{int(freq_shift_hz)}_{timestamp_hm}.csv")

    raw_scan_data_for_current_sweep = []
    last_successful_band_index = -1
    markers_data_from_scan = []

    app_instance_ref.after(0, lambda: app_console_update_func("\n--- 📡 Starting Band Scan ---"))

    for i, band in enumerate(selected_bands):
        if stop_event.is_set():
            break

        band_name = band["Band Name"]
        band_start_freq_hz = (band["Start MHz"] * MHZ_TO_HZ) + freq_shift_hz
        band_stop_freq_hz = (band["Stop MHz"] * MHZ_TO_HZ) + freq_shift_hz

        app_instance_ref.after(0, lambda: app_console_update_func(f"\n📈 Processing Band: {band_name}"))

        # (segment calculation logic...)
        full_band_span_hz = band_stop_freq_hz - band_start_freq_hz
        total_segments_in_band = 1
        if full_band_span_hz > 0:
            expected_sweep_points = 461 if "N9340B" in app_instance_ref.connected_instrument_model.get() else 501
            total_segments_in_band = int(np.ceil(full_band_span_hz / (rbw_step_size_hz * (expected_sweep_points - 1))))
        
        if total_segments_in_band <= 0: total_segments_in_band = 1
        optimal_segment_span_hz = full_band_span_hz / total_segments_in_band

        current_segment_start_freq_hz = band_start_freq_hz
        segment_counter = 0

        while current_segment_start_freq_hz < band_stop_freq_hz:
            segment_counter += 1
            segment_stop_freq_hz_current = current_segment_start_freq_hz + optimal_segment_span_hz
            if segment_stop_freq_hz_current > band_stop_freq_hz:
                segment_stop_freq_hz_current = band_stop_freq_hz
            
            segment_raw_data = perform_segment_sweep(
                inst,
                current_segment_start_freq_hz,
                segment_stop_freq_hz_current,
                maxhold_enabled,
                max_hold_time_seconds,
                app_instance_ref,
                pause_event,
                stop_event,
                segment_counter,
                total_segments_in_band,
                band_name,
                app_console_update_func,
                current_segment_start_freq_hz
            )

            if stop_event.is_set():
                break

            if segment_raw_data:
                raw_scan_data_for_current_sweep.extend(segment_raw_data)
                
                # Write to CSV
                csv_data_to_write = [(f / MHZ_TO_HZ, amp) for f, amp in segment_raw_data]
                write_scan_data_to_csv(
                    csv_filename_current_cycle,
                    header=None,
                    data=csv_data_to_write,
                    app_instance_ref=app_instance_ref,
                    append_mode=True,
                    console_print_func=app_console_update_func
                )
            
            current_segment_start_freq_hz = segment_stop_freq_hz_current
            last_successful_band_index = i

        if stop_event.is_set():
            break

    app_instance_ref.after(0, lambda: app_console_update_func("\n--- 🎉 Band Scan Data Collection Complete! ---"))
    return last_successful_band_index, raw_scan_data_for_current_sweep, markers_data_from_scan

#####################################
### File: OPEN-AIR\settings_and_config\config_manager_application.py
#####################################
# FolderName/config_manager_application.py
#
# This file provides the backend logic for saving application-level settings like
# window geometry and state to the configuration file. It is designed to be
# modular and self-contained, handling only its specific domain.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.093800.6
# REFACTORED: The save_application_settings function was updated to correctly reference
#             the geometry and window state from the main app instance.

import os
import inspect
from configparser import ConfigParser
from datetime import datetime
from display.debug_logic import debug_log
from display.console_logic import console_log

# --- Versioning ---
w = 20250821
x_str = '093800'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 6
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = f"{os.path.basename(__file__)}"

def _save_application_settings(config, app_instance, console_print_func):
    """Saves application-level settings like window geometry and state."""
    current_function = inspect.currentframe().f_code.co_name
    changed_count = 0
    section = 'Application'
    if not config.has_section(section):
        config.add_section(section)

    try:
        # FIXED: Corrected the variables to correctly get the window geometry and state.
        # The app.geometry() and app.state() methods return the current values.
        current_geometry = app_instance.geometry()
        current_state = app_instance.state()
        
        # Check and save geometry
        new_value = current_geometry
        if config.get(section, 'geometry', fallback=None) != new_value:
            config.set(section, 'geometry', new_value)
            debug_log(f"🔧💾📝 {section} - Changed 'geometry' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
            changed_count += 1
        
        # Check and save window state
        new_value = current_state
        if config.get(section, 'window_state', fallback=None) != new_value:
            config.set(section, 'window_state', new_value)
            debug_log(f"🔧💾📝 {section} - Changed 'window_state' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
            changed_count += 1
        
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        config.set(section, 'last_config_save_time', current_time)
        debug_log(f"🔧💾📝 {section} - Updated 'last_config_save_time' to '{current_time}' from {current_function}", file=current_file, version=current_version, function=current_function)
        if hasattr(app_instance, 'last_config_save_time_var'):
            app_instance.last_config_save_time_var.set(current_time)
        changed_count += 1

        if hasattr(app_instance, 'paned_window') and app_instance.paned_window and app_instance.winfo_width() > 0:
            sash_pos = app_instance.paned_window.sashpos(0)
            sash_pos_percentage = int((sash_pos / app_instance.winfo_width()) * 100)
            sash_pos_percentage_str = str(sash_pos_percentage)
            # FIX: Removed the conditional check to ensure the value is always saved.
            config.set(section, 'paned_window_sash_position_percentage', sash_pos_percentage_str)
            debug_log(f"🔧💾📝 {section} - Set 'paned_window_sash_position_percentage' to '{sash_pos_percentage_str}' from {current_function}", file=current_file, version=current_version, function=current_function)
            changed_count += 1

        if changed_count > 0:
            debug_log(f"🔧💾🔧💾✅ Application settings saved.", file=current_file, version=current_version, function=current_function)
        else:
            debug_log(f"🔧💾😴 No changes to save in Application settings.", file=current_file, version=current_version, function=current_function)
            
    except Exception as e:
        debug_log(f"🔧💾❌ Error saving {section} settings: {e}", file=current_file, version=current_version, function=current_function)

#####################################
### File: OPEN-AIR\settings_and_config\config_manager_debug.py
#####################################
# src/settings_and_config/config_manager_debug.py
#
# This file provides the backend logic for saving debug-related settings.
# It is designed to be modular and self-contained, handling only its specific domain.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.093800.1
# REFACTORED: Created a new, dedicated module for saving debug settings.

import os
import inspect
from configparser import ConfigParser
from display.debug_logic import debug_log
from display.console_logic import console_log

# --- Versioning ---
w = 20250821
x_str = '093800'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = f"{os.path.basename(__file__)}"


def _save_debug_settings(config, app_instance, console_print_func):
    """Saves debug-related settings."""
    current_function = inspect.currentframe().f_code.co_name
    changed_count = 0
    section = 'Debug'
    if not config.has_section(section):
        config.add_section(section)

    try:
        if hasattr(app_instance, 'general_debug_enabled_var'):
            new_value = str(app_instance.general_debug_enabled_var.get())
            if config.get(section, 'general_debug_enabled', fallback=None) != new_value:
                config.set(section, 'general_debug_enabled', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'general_debug_enabled' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'debug_to_gui_console_var'):
            new_value = str(app_instance.debug_to_gui_console_var.get())
            if config.get(section, 'debug_to_gui_console', fallback=None) != new_value:
                config.set(section, 'debug_to_gui_console', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'debug_to_gui_console' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'debug_to_terminal_var'):
            new_value = str(app_instance.debug_to_terminal_var.get())
            if config.get(section, 'debug_to_terminal', fallback=None) != new_value:
                config.set(section, 'debug_to_terminal', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'debug_to_terminal' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'debug_to_file_var'):
            new_value = str(app_instance.debug_to_file_var.get())
            if config.get(section, 'debug_to_file', fallback=None) != new_value:
                config.set(section, 'debug_to_file', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'debug_to_file' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'include_console_messages_to_debug_file_var'):
            new_value = str(app_instance.include_console_messages_to_debug_file_var.get())
            if config.get(section, 'include_console_messages_to_debug_file', fallback=None) != new_value:
                config.set(section, 'include_console_messages_to_debug_file', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'include_console_messages_to_debug_file' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'log_visa_commands_enabled_var'):
            new_value = str(app_instance.log_visa_commands_enabled_var.get())
            if config.get(section, 'log_visa_commands_enabled', fallback=None) != new_value:
                config.set(section, 'log_visa_commands_enabled', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'log_visa_commands_enabled' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1

        if changed_count > 0:
            debug_log(f"🔧💾🔧💾✅ Debug settings saved.", file=current_file, version=current_version, function=current_function)
        else:
            debug_log(f"🔧💾😴 No changes to save in Debug settings.", file=current_file, version=current_version, function=current_function)
    except Exception as e:
        debug_log(f"🔧💾❌ Error saving {section} settings: {e}", file=current_file, version=current_version, function=current_function)

#####################################
### File: OPEN-AIR\settings_and_config\config_manager_instruments.py
#####################################
# src/settings_and_config/config_manager_instruments.py
#
# This file provides the backend logic for saving instrument-related settings.
# It is designed to be modular and self-contained, handling only its specific domain.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.135600.2
# FIXED: Updated the variable name from 'visa_resource_var' to 'instrument_visa_resource_var'
#        to align with the new modular variable system, preventing an AttributeError.

import os
import inspect
from configparser import ConfigParser
from display.debug_logic import debug_log
from display.console_logic import console_log

# --- Versioning ---
w = 20250821
x_str = '135600'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 2
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = f"{os.path.basename(__file__)}"


def _save_instrument_settings(config, app_instance, console_print_func):
    """Saves Instrument and InstrumentSettings section."""
    current_function = inspect.currentframe().f_code.co_name
    changed_count = 0
    section_inst = 'Instrument'
    section_settings = 'InstrumentSettings'
    if not config.has_section(section_inst):
        config.add_section(section_inst)
    if not config.has_section(section_settings):
        config.add_section(section_settings)
    
    try:
        # Save Instrument values
        # FIXED: Corrected variable name from visa_resource_var
        if hasattr(app_instance, 'instrument_visa_resource_var'):
            new_value = str(app_instance.instrument_visa_resource_var.get())
            if config.get(section_inst, 'visa_resource', fallback=None) != new_value:
                config.set(section_inst, 'visa_resource', new_value)
                debug_log(f"🔧💾📝 {section_inst} - Changed 'visa_resource' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        
        # Save InstrumentSettings values
        if hasattr(app_instance, 'center_freq_mhz_var'):
            new_value = str(app_instance.center_freq_mhz_var.get())
            if config.get(section_settings, 'center_freq_mhz', fallback=None) != new_value:
                config.set(section_settings, 'center_freq_mhz', new_value)
                debug_log(f"🔧💾📝 {section_settings} - Changed 'center_freq_mhz' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        
        if hasattr(app_instance, 'span_freq_mhz_var'):
            new_value = str(app_instance.span_freq_mhz_var.get())
            if config.get(section_settings, 'span_freq_mhz', fallback=None) != new_value:
                config.set(section_settings, 'span_freq_mhz', new_value)
                debug_log(f"🔧💾📝 {section_settings} - Changed 'span_freq_mhz' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
                
        if hasattr(app_instance, 'start_freq_mhz_var'):
            new_value = str(app_instance.start_freq_mhz_var.get())
            if config.get(section_settings, 'start_freq_mhz', fallback=None) != new_value:
                config.set(section_settings, 'start_freq_mhz', new_value)
                debug_log(f"🔧💾📝 {section_settings} - Changed 'start_freq_mhz' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1

        if hasattr(app_instance, 'stop_freq_mhz_var'):
            new_value = str(app_instance.stop_freq_mhz_var.get())
            if config.get(section_settings, 'stop_freq_mhz', fallback=None) != new_value:
                config.set(section_settings, 'stop_freq_mhz', new_value)
                debug_log(f"🔧💾📝 {section_settings} - Changed 'stop_freq_mhz' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        
        if hasattr(app_instance, 'rbw_mhz_var'):
            new_value = str(app_instance.rbw_mhz_var.get())
            if config.get(section_settings, 'rbw_mhz', fallback=None) != new_value:
                config.set(section_settings, 'rbw_mhz', new_value)
                debug_log(f"🔧💾📝 {section_settings} - Changed 'rbw_mhz' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1

        if hasattr(app_instance, 'vbw_mhz_var'):
            new_value = str(app_instance.vbw_mhz_var.get())
            if config.get(section_settings, 'vbw_mhz', fallback=None) != new_value:
                config.set(section_settings, 'vbw_mhz', new_value)
                debug_log(f"🔧💾📝 {section_settings} - Changed 'vbw_mhz' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        
        if hasattr(app_instance, 'vbw_auto_on_var'):
            new_value = str(app_instance.vbw_auto_on_var.get())
            if config.get(section_settings, 'vbw_auto_on', fallback=None) != new_value:
                config.set(section_settings, 'vbw_auto_on', new_value)
                debug_log(f"🔧💾📝 {section_settings} - Changed 'vbw_auto_on' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1

        if hasattr(app_instance, 'initiate_continuous_on_var'):
            new_value = str(app_instance.initiate_continuous_on_var.get())
            if config.get(section_settings, 'initiate_continuous_on', fallback=None) != new_value:
                config.set(section_settings, 'initiate_continuous_on', new_value)
                debug_log(f"🔧💾📝 {section_settings} - Changed 'initiate_continuous_on' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1

        if hasattr(app_instance, 'ref_level_dbm_var'):
            new_value = str(app_instance.ref_level_dbm_var.get())
            if config.get(section_settings, 'ref_level_dbm', fallback=None) != new_value:
                config.set(section_settings, 'ref_level_dbm', new_value)
                debug_log(f"🔧💾📝 {section_settings} - Changed 'ref_level_dbm' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1

        if hasattr(app_instance, 'preamp_on_var'):
            new_value = str(app_instance.preamp_on_var.get())
            if config.get(section_settings, 'preamp_on', fallback=None) != new_value:
                config.set(section_settings, 'preamp_on', new_value)
                debug_log(f"🔧💾📝 {section_settings} - Changed 'preamp_on' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
                
        if hasattr(app_instance, 'power_attenuation_db_var'):
            new_value = str(app_instance.power_attenuation_db_var.get())
            if config.get(section_settings, 'power_attenuation_db', fallback=None) != new_value:
                config.set(section_settings, 'power_attenuation_db', new_value)
                debug_log(f"🔧💾📝 {section_settings} - Changed 'power_attenuation_db' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
                
        if hasattr(app_instance, 'high_sensitivity_on_var'):
            new_value = str(app_instance.high_sensitivity_on_var.get())
            if config.get(section_settings, 'high_sensitivity_on', fallback=None) != new_value:
                config.set(section_settings, 'high_sensitivity_on', new_value)
                debug_log(f"🔧💾📝 {section_settings} - Changed 'high_sensitivity_on' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1

        if changed_count > 0:
            debug_log(f"🔧💾🔧💾✅ Instrument settings saved.", file=current_file, version=current_version, function=current_function)
        else:
            debug_log(f"🔧💾😴 No changes to save in Instrument settings.", file=current_file, version=current_version, function=current_function)
    except Exception as e:
        debug_log(f"🔧💾❌ Error saving {section_inst} or {section_settings} settings: {e}", file=current_file, version=current_version, function=current_function)


def _save_antenna_settings(config, app_instance, console_print_func):
    """Saves antenna settings."""
    current_function = inspect.currentframe().f_code.co_name
    changed_count = 0
    section = 'Antenna'
    if not config.has_section(section):
        config.add_section(section)
    
    try:
        if hasattr(app_instance, 'antenna_type_var'):
            new_value = str(app_instance.antenna_type_var.get())
            if config.get(section, 'selected_antenna_type', fallback=None) != new_value:
                config.set(section, 'selected_antenna_type', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'selected_antenna_type' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'antenna_description_var'):
            new_value = str(app_instance.antenna_description_var.get())
            if config.get(section, 'antenna_description', fallback=None) != new_value:
                config.set(section, 'antenna_description', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'antenna_description' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'antenna_use_var'):
            new_value = str(app_instance.antenna_use_var.get())
            if config.get(section, 'antenna_use', fallback=None) != new_value:
                config.set(section, 'antenna_use', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'antenna_use' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'antenna_mount_var'):
            new_value = str(app_instance.antenna_mount_var.get())
            if config.get(section, 'antenna_mount', fallback=None) != new_value:
                config.set(section, 'antenna_mount', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'antenna_mount' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'antenna_amplifier_var'):
            new_value = str(app_instance.antenna_amplifier_var.get())
            if config.get(section, 'antenna_amplifier', fallback=None) != new_value:
                config.set(section, 'antenna_amplifier', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'antenna_amplifier' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        
        if changed_count > 0:
            debug_log(f"🔧💾🔧💾✅ Antenna settings saved.", file=current_file, version=current_version, function=current_function)
        else:
            debug_log(f"🔧💾😴 No changes to save in Antenna settings.", file=current_file, version=current_version, function=current_function)
    except Exception as e:
        debug_log(f"🔧💾❌ Error saving {section} settings: {e}", file=current_file, version=current_version, function=current_function)

def _save_amplifier_settings(config, app_instance, console_print_func):
    """Saves amplifier settings."""
    current_function = inspect.currentframe().f_code.co_name
    changed_count = 0
    section = 'Amplifier'
    if not config.has_section(section):
        config.add_section(section)
        
    try:
        if hasattr(app_instance, 'amplifier_type_var'):
            new_value = str(app_instance.amplifier_type_var.get())
            if config.get(section, 'selected_amplifier_type', fallback=None) != new_value:
                config.set(section, 'selected_amplifier_type', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'selected_amplifier_type' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'amplifier_description_var'):
            new_value = str(app_instance.amplifier_description_var.get())
            if config.get(section, 'amplifier_description', fallback=None) != new_value:
                config.set(section, 'amplifier_description', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'amplifier_description' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'amplifier_use_var'):
            new_value = str(app_instance.amplifier_use_var.get())
            if config.get(section, 'amplifier_use', fallback=None) != new_value:
                config.set(section, 'amplifier_use', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'amplifier_use' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        
        if changed_count > 0:
            debug_log(f"🔧💾🔧💾✅ Amplifier settings saved.", file=current_file, version=current_version, function=current_function)
        else:
            debug_log(f"🔧💾😴 No changes to save in Amplifier settings.", file=current_file, version=current_version, function=current_function)
    except Exception as e:
        debug_log(f"🔧💾❌ Error saving {section} settings: {e}", file=current_file, version=current_version, function=current_function)

#####################################
### File: OPEN-AIR\settings_and_config\config_manager_marker.py
#####################################
# src/settings_and_config/config_manager_marker.py
#
# This file provides the backend logic for saving MarkerTab settings.
# It is designed to be modular and self-contained, handling only its specific domain.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.093800.1
# REFACTORED: Created a new, dedicated module for saving MarkerTab settings.

import os
import inspect
from configparser import ConfigParser
from display.debug_logic import debug_log
from display.console_logic import console_log

# --- Versioning ---
w = 20250821
x_str = '093800'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = f"{os.path.basename(__file__)}"


def _save_marker_tab_settings(config, app_instance, console_print_func):
    """Saves all state variables related to the MarkerTab."""
    current_function = inspect.currentframe().f_code.co_name
    changed_count = 0
    section = 'MarkerTab'
    if not hasattr(app_instance, 'showtime_parent_tab'):
        debug_log("Config object: 'showtime_parent_tab' not available. Skipping MarkerTab save.", file=current_file, version=current_version, function=current_function)
        return
        
    showtime_tab = app_instance.showtime_parent_tab
    if not config.has_section(section):
        config.add_section(section)

    try:
        if hasattr(showtime_tab, 'span_var'):
            new_value = str(showtime_tab.span_var.get())
            if config.get(section, 'span_hz', fallback=None) != new_value:
                config.set(section, 'span_hz', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'span_hz' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        
        if hasattr(showtime_tab, 'rbw_var'):
            new_value = str(showtime_tab.rbw_var.get())
            if config.get(section, 'rbw_hz', fallback=None) != new_value:
                config.set(section, 'rbw_hz', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'rbw_hz' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
                
        if hasattr(showtime_tab, 'trace_modes'):
            for trace_type in ['live', 'max', 'min']:
                trace_key = f'trace_{trace_type}'
                if trace_key in showtime_tab.trace_modes and hasattr(showtime_tab.trace_modes[trace_type], 'get'):
                    new_value = str(showtime_tab.trace_modes[trace_type].get())
                    if config.get(section, trace_key, fallback=None) != new_value:
                        config.set(section, trace_key, new_value)
                        debug_log(f"🔧💾📝 {section} - Changed '{trace_key}' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                        changed_count += 1
                        
        if hasattr(showtime_tab, 'buffer_var'):
            new_value = str(showtime_tab.buffer_var.get())
            if config.get(section, 'buffer_mhz', fallback=None) != new_value:
                config.set(section, 'buffer_mhz', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'buffer_mhz' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1

        if hasattr(showtime_tab, 'poke_freq_var'):
            new_value = str(showtime_tab.poke_freq_var.get())
            if config.get(section, 'poke_freq_mhz', fallback=None) != new_value:
                config.set(section, 'poke_freq_mhz', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'poke_freq_mhz' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        
        if changed_count > 0:
            debug_log(f"🔧💾🔧💾✅ Showtime state successfully written to config.", file=current_file, version=current_version, function=current_function)
        else:
            debug_log(f"🔧💾😴 No changes to save in MarkerTab settings.", file=current_file, version=current_version, function=current_function)

    except Exception as e:
        debug_log(f"🔧💾❌ Error saving {section} settings: {e}", file=current_file, version=current_version, function=current_function)

#####################################
### File: OPEN-AIR\settings_and_config\config_manager_plotting.py
#####################################
# src/settings_and_config/config_manager_plotting.py
#
# This file provides the backend logic for saving plotting-related settings.
# It is designed to be modular and self-contained, handling only its specific domain.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.093800.1
# REFACTORED: Created a new, dedicated module for saving plotting settings.

import os
import inspect
from configparser import ConfigParser
from display.debug_logic import debug_log
from display.console_logic import console_log

# --- Versioning ---
w = 20250821
x_str = '093800'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = f"{os.path.basename(__file__)}"


def _save_plotting_settings(config, app_instance, console_print_func):
    """Saves plotting-related settings."""
    current_function = inspect.currentframe().f_code.co_name
    changed_count = 0
    section = 'Plotting'
    if not config.has_section(section):
        config.add_section(section)
    
    try:
        if hasattr(app_instance, 'current_style_theme_var'):
            new_value = str(app_instance.current_style_theme_var.get())
            if config.get(section, 'current_style_theme', fallback=None) != new_value:
                config.set(section, 'current_style_theme', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'current_style_theme' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        
        if hasattr(app_instance, 'plot_grid_on_var'):
            new_value = str(app_instance.plot_grid_on_var.get())
            if config.get(section, 'plot_grid_on', fallback=None) != new_value:
                config.set(section, 'plot_grid_on', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'plot_grid_on' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
                
        if hasattr(app_instance, 'plot_grid_alpha_var'):
            new_value = str(app_instance.plot_grid_alpha_var.get())
            if config.get(section, 'plot_grid_alpha', fallback=None) != new_value:
                config.set(section, 'plot_grid_alpha', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'plot_grid_alpha' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        
        if hasattr(app_instance, 'plot_grid_color_var'):
            new_value = str(app_instance.plot_grid_color_var.get())
            if config.get(section, 'plot_grid_color', fallback=None) != new_value:
                config.set(section, 'plot_grid_color', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'plot_grid_color' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        
        if changed_count > 0:
            debug_log(f"🔧💾🔧💾✅ Plotting settings saved.", file=current_file, version=current_version, function=current_function)
        else:
            debug_log(f"🔧💾😴 No changes to save in Plotting settings.", file=current_file, version=current_version, function=current_function)

    except Exception as e:
        debug_log(f"🔧💾❌ Error saving {section} settings: {e}", file=current_file, version=current_version, function=current_function)

#####################################
### File: OPEN-AIR\settings_and_config\config_manager_report.py
#####################################
# src/settings_and_config/config_manager_report.py
#
# This file provides the backend logic for saving report-related settings.
# It is designed to be modular and self-contained, handling only its specific domain.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.093800.1
# REFACTORED: Created a new, dedicated module for saving report settings.

import os
import inspect
from configparser import ConfigParser
from display.debug_logic import debug_log
from display.console_logic import console_log

# --- Versioning ---
w = 20250821
x_str = '093800'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = f"{os.path.basename(__file__)}"


def _save_report_settings(config, app_instance, console_print_func):
    """Saves report-related settings."""
    current_function = inspect.currentframe().f_code.co_name
    changed_count = 0
    section = 'Report'
    if not config.has_section(section):
        config.add_section(section)
    
    try:
        if hasattr(app_instance, 'operator_name_var'):
            new_value = str(app_instance.operator_name_var.get())
            if config.get(section, 'operator_name', fallback=None) != new_value:
                config.set(section, 'operator_name', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'operator_name' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'operator_contact_var'):
            new_value = str(app_instance.operator_contact_var.get())
            if config.get(section, 'operator_contact', fallback=None) != new_value:
                config.set(section, 'operator_contact', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'operator_contact' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'venue_name_var'):
            new_value = str(app_instance.venue_name_var.get())
            if config.get(section, 'venue_name', fallback=None) != new_value:
                config.set(section, 'venue_name', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'venue_name' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'address_field_var'):
            new_value = str(app_instance.address_field_var.get())
            if config.get(section, 'address_field', fallback=None) != new_value:
                config.set(section, 'address_field', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'address_field' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'city_var'):
            new_value = str(app_instance.city_var.get())
            if config.get(section, 'city', fallback=None) != new_value:
                config.set(section, 'city', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'city' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'province_var'):
            new_value = str(app_instance.province_var.get())
            if config.get(section, 'province', fallback=None) != new_value:
                config.set(section, 'province', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'province' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'venue_postal_code_var'):
            new_value = str(app_instance.venue_postal_code_var.get())
            if config.get(section, 'venue_postal_code', fallback=None) != new_value:
                config.set(section, 'venue_postal_code', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'venue_postal_code' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'notes_var'):
            new_value = str(app_instance.notes_var.get())
            if config.get(section, 'notes', fallback=None) != new_value:
                config.set(section, 'notes', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'notes' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1

        if changed_count > 0:
            debug_log(f"🔧💾🔧💾✅ Report settings saved.", file=current_file, version=current_version, function=current_function)
        else:
            debug_log(f"🔧💾😴 No changes to save in Report settings.", file=current_file, version=current_version, function=current_function)
    except Exception as e:
        debug_log(f"🔧💾❌ Error saving {section} settings: {e}", file=current_file, version=current_version, function=current_function)

#####################################
### File: OPEN-AIR\settings_and_config\config_manager_restore.py
#####################################
# settings_and_config/config_manager_restore.py
#
# This file contains the core logic for managing application settings,
# including restoring default settings, restoring last-used settings,
# and resetting the visual indicators of changed settings in the GUI.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
# Version 20250821.212500.1 (FIXED: Replaced debug_log with print for startup safety)

import tkinter as tk
import inspect
import os
from configparser import ConfigParser
from datetime import datetime

# --- REMOVED: debug_log import to prevent circular dependency on startup ---
# from display.debug_logic import debug_log 
from display.console_logic import console_log

# Import the correct, renamed config management functions
from settings_and_config.config_manager_save import load_program_config, save_program_config


# --- Versioning ---
w = 20250821
x_str = '212500'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_file = f"{os.path.basename(__file__)}"


def restore_default_settings(app_instance, console_print_func):
    """
    Resets the application settings to their factory default values.
    
    Args:
        app_instance: The main application instance containing the state variables.
        console_print_func: A function to print messages to the GUI console.
    """
    current_function = inspect.currentframe().f_code.co_name
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    # --- FIXED: Use print() for startup-critical logging ---
    print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - ⚙️🟢 Entering function to restore default settings.")
    
    console_print_func("⚠️ Restoring all settings to factory defaults.")
    
    from ref.ref_program_default_values import DEFAULT_CONFIG

    try:
        default_config = ConfigParser()
        default_config.read_dict(DEFAULT_CONFIG)
        
        save_program_config(default_config)
        
        app_instance.program_config = load_program_config()
        restore_last_used_settings(app_instance, console_print_func)

        console_print_func("✅ All settings have been restored to their factory defaults.")
        print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - ✅ Default settings restoration completed.")
        
    except Exception as e:
        error_msg = f"❌ An error occurred while restoring default settings: {e}"
        console_print_func(error_msg)
        print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - {error_msg}")

def restore_last_used_settings(app_instance, console_print_func):
    """
    Loads and restores the application settings from the last-used configuration file.
    
    Args:
        app_instance: The main application instance containing the state variables.
        console_print_func: A function to print messages to the GUI console.
    """
    current_function = inspect.currentframe().f_code.co_name
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

    # --- FIXED: Use print() for startup-critical logging ---
    print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - ⚙️🟢 Entering function to restore last used settings.")
    
    console_print_func("✅ Attempting to restore last used settings...")
    
    try:
        config = app_instance.program_config
        
        # Restore MarkerTab settings
        if 'MarkerTab' in config and hasattr(app_instance, 'showtime_parent_tab') and app_instance.showtime_parent_tab is not None:
            showtime_tab = app_instance.showtime_parent_tab

            if config.has_option('MarkerTab', 'poke_freq_mhz'):
                poke_freq_str = config.get('MarkerTab', 'poke_freq_mhz')
                showtime_tab.poke_freq_var.set(poke_freq_str)
            
            for trace_type in ['live', 'max', 'min']:
                trace_key = f'trace_{trace_type}'
                if config.has_option('MarkerTab', trace_key):
                    trace_state = config.getboolean('MarkerTab', trace_key)
                    if hasattr(showtime_tab, 'trace_modes') and trace_type in showtime_tab.trace_modes:
                        showtime_tab.trace_modes[trace_type].set(trace_state)

            if config.has_option('MarkerTab', 'span_hz'):
                showtime_tab.span_var.set(config.get('MarkerTab', 'span_hz'))
            if config.has_option('MarkerTab', 'rbw_hz'):
                showtime_tab.rbw_var.set(config.get('MarkerTab', 'rbw_hz'))
            if config.has_option('MarkerTab', 'buffer_mhz'):
                showtime_tab.buffer_var.set(config.get('MarkerTab', 'buffer_mhz'))

        console_print_func("✅ All settings restored to last used values.")
        print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - ✅ Last used settings restored.")
            
    except Exception as e:
        error_msg = f"❌ An error occurred while restoring last used settings: {e}."
        console_print_func(error_msg)
        print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - {error_msg}")


#####################################
### File: OPEN-AIR\settings_and_config\config_manager_save.py
#####################################
# settings_and_config/config_manager.py
#
# This file handles loading and saving application settings to 'config.ini'.
# It now uses primitive print statements for logging during initialization.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.212000.1 (FIXED: Removed duplicate function)

import os
import inspect
import configparser
from datetime import datetime
import tkinter as tk

# Assuming these ref files exist and are correct
from ref.ref_file_paths import CONFIG_FILE_PATH, DATA_FOLDER_PATH
from ref.ref_program_default_values import DEFAULT_CONFIG

# --- Version Information ---
current_version = "20250821.212000.1"
current_file = os.path.basename(__file__)

def load_program_config():
    """
    Loads configuration from config.ini. If the file doesn't exist, or if it's
    missing sections/keys, it creates/updates it with default values from
    DEFAULT_CONFIG, preserving existing user settings.
    """
    current_function = inspect.currentframe().f_code.co_name
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - 🔧 🟢 Loading configuration.")
    
    config = configparser.ConfigParser()
    config.read_dict(DEFAULT_CONFIG)
    
    try:
        if not os.path.exists(DATA_FOLDER_PATH):
            os.makedirs(DATA_FOLDER_PATH)
            print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - ✅ Created settings directory: {DATA_FOLDER_PATH}")

        if os.path.exists(CONFIG_FILE_PATH):
            config.read(CONFIG_FILE_PATH)
            print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - ✅ Configuration loaded from {CONFIG_FILE_PATH}.")
        else:
            print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - 🟡 Config file not found. A new one will be created with default values.")

        with open(CONFIG_FILE_PATH, 'w') as configfile:
            config.write(configfile)
        print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - ✅ Configuration file is up-to-date.")

    except Exception as e:
        print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - ❌ Error loading/healing configuration: {e}. Falling back to in-memory defaults.")
        config.read_dict(DEFAULT_CONFIG)

    return config

def save_program_config(config):
    """Saves the provided configuration object to the config.ini file."""
    current_function = inspect.currentframe().f_code.co_name
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    try:
        with open(CONFIG_FILE_PATH, 'w') as configfile:
            config.write(configfile)
        print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - ✅ Configuration saved to {CONFIG_FILE_PATH}.")
    except Exception as e:
        print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - ❌ Error saving configuration: {e}.")

# --- REMOVED ---
# The restore_last_used_settings function has been removed from this file
# to prevent circular dependencies and duplicate definitions. Its sole location
# is now in 'restore_settings_logic.py'.


#####################################
### File: OPEN-AIR\settings_and_config\config_manager_scan.py
#####################################
# src/settings_and_config/config_manager_scan.py
#
# This file provides the backend logic for saving scan-related settings.
# It is designed to be modular and self-contained, handling only its specific domain.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.093800.1
# REFACTORED: Created a new, dedicated module for saving scan settings.

import os
import inspect
from configparser import ConfigParser
from display.debug_logic import debug_log
from display.console_logic import console_log

# --- Versioning ---
w = 20250821
x_str = '093800'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = f"{os.path.basename(__file__)}"


def _save_scan_info_settings(config, app_instance, console_print_func):
    """Saves scan-related settings."""
    current_function = inspect.currentframe().f_code.co_name
    changed_count = 0
    section = 'ScanConfiguration'
    if not config.has_section(section):
        config.add_section(section)

    try:
        if hasattr(app_instance, 'output_folder_var'):
            new_value = str(app_instance.output_folder_var.get())
            if config.get(section, 'output_folder', fallback=None) != new_value:
                config.set(section, 'output_folder', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'output_folder' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'scan_name_var'):
            new_value = str(app_instance.scan_name_var.get())
            if config.get(section, 'scan_name', fallback=None) != new_value:
                config.set(section, 'scan_name', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'scan_name' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'rbw_step_size_var'):
            new_value = str(app_instance.rbw_step_size_var.get())
            if config.get(section, 'rbw_step_size_hz', fallback=None) != new_value:
                config.set(section, 'rbw_step_size_hz', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'rbw_step_size_hz' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'num_scan_cycles_var'):
            new_value = str(app_instance.num_scan_cycles_var.get())
            if config.get(section, 'num_scan_cycles', fallback=None) != new_value:
                config.set(section, 'num_scan_cycles', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'num_scan_cycles' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'cycle_wait_time_seconds_var'):
            new_value = str(app_instance.cycle_wait_time_seconds_var.get())
            if config.get(section, 'cycle_wait_time_seconds', fallback=None) != new_value:
                config.set(section, 'cycle_wait_time_seconds', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'cycle_wait_time_seconds' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'maxhold_enabled_var'):
            new_value = str(app_instance.maxhold_enabled_var.get())
            if config.get(section, 'maxhold_enabled', fallback=None) != new_value:
                config.set(section, 'maxhold_enabled', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'maxhold_enabled' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'maxhold_time_seconds_var'):
            new_value = str(app_instance.maxhold_time_seconds_var.get())
            if config.get(section, 'maxhold_time_seconds', fallback=None) != new_value:
                config.set(section, 'maxhold_time_seconds', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'maxhold_time_seconds' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'desired_default_focus_width_var'):
            new_value = str(app_instance.desired_default_focus_width_var.get())
            if config.get(section, 'desired_default_focus_width', fallback=None) != new_value:
                config.set(section, 'desired_default_focus_width', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'desired_default_focus_width' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'create_html_report_var'):
            new_value = str(app_instance.create_html_report_var.get())
            if config.get(section, 'create_html', fallback=None) != new_value:
                config.set(section, 'create_html', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'create_html' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'open_html_after_complete_var'):
            new_value = str(app_instance.open_html_after_complete_var.get())
            if config.get(section, 'open_html_after_complete', fallback=None) != new_value:
                config.set(section, 'open_html_after_complete', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'open_html_after_complete' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'include_markers_var'):
            new_value = str(app_instance.include_markers_var.get())
            if config.get(section, 'include_markers', fallback=None) != new_value:
                config.set(section, 'include_markers', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'include_markers' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'include_gov_markers_var'):
            new_value = str(app_instance.include_gov_markers_var.get())
            if config.get(section, 'include_gov_markers', fallback=None) != new_value:
                config.set(section, 'include_gov_markers', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'include_gov_markers' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'include_tv_markers_var'):
            new_value = str(app_instance.include_tv_markers_var.get())
            if config.get(section, 'include_tv_markers', fallback=None) != new_value:
                config.set(section, 'include_tv_markers', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'include_tv_markers' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'include_scan_intermod_markers_var'):
            new_value = str(app_instance.include_scan_intermod_markers_var.get())
            if config.get(section, 'include_scan_intermod_markers', fallback=None) != new_value:
                config.set(section, 'include_scan_intermod_markers', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'include_scan_intermod_markers' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'math_average_var'):
            new_value = str(app_instance.math_average_var.get())
            if config.get(section, 'math_average', fallback=None) != new_value:
                config.set(section, 'math_average', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'math_average' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'math_median_var'):
            new_value = str(app_instance.math_median_var.get())
            if config.get(section, 'math_median', fallback=None) != new_value:
                config.set(section, 'math_median', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'math_median' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'math_variance_var'):
            new_value = str(app_instance.math_variance_var.get())
            if config.get(section, 'math_variance', fallback=None) != new_value:
                config.set(section, 'math_variance', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'math_variance' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'math_standard_deviation_var'):
            new_value = str(app_instance.math_standard_deviation_var.get())
            if config.get(section, 'math_standard_deviation', fallback=None) != new_value:
                config.set(section, 'math_standard_deviation', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'math_standard_deviation' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'math_range_var'):
            new_value = str(app_instance.math_range_var.get())
            if config.get(section, 'math_range', fallback=None) != new_value:
                config.set(section, 'math_range', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'math_range' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        if hasattr(app_instance, 'math_psd_var'):
            new_value = str(app_instance.math_psd_var.get())
            if config.get(section, 'math_psd', fallback=None) != new_value:
                config.set(section, 'math_psd', new_value)
                debug_log(f"🔧💾📝 {section} - Changed 'math_psd' to '{new_value}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1
        
        if hasattr(app_instance, 'band_vars') and app_instance.band_vars:
            selected_bands_with_levels = [f"{item['band']['Band Name']}={item.get('level', 0)}" for item in app_instance.band_vars]
            selected_bands_str = ",".join(selected_bands_with_levels)
            if config.get(section, 'last_scan_configuration__selected_bands_levels', fallback=None) != selected_bands_str:
                config.set(section, 'last_scan_configuration__selected_bands_levels', selected_bands_str)
                debug_log(f"🔧💾📝 {section} - Changed 'last_scan_configuration__selected_bands_levels' to '{selected_bands_str}' from {current_function}", file=current_file, version=current_version, function=current_function)
                changed_count += 1

        if changed_count > 0:
            debug_log(f"🔧💾🔧💾✅ Scan settings saved.", file=current_file, version=current_version, function=current_function)
        else:
            debug_log(f"🔧💾😴 No changes to save in Scan settings.", file=current_file, version=current_version, function=current_function)
    except Exception as e:
        debug_log(f"🔧💾❌ Error saving {section} settings: {e}", file=current_file, version=current_version, function=current_function)

#####################################
### File: OPEN-AIR\src\TABS_PARENT.py
#####################################
# tabs/TABS_PARENT.py
#
# This file defines the TABS_PARENT class, which serves as a master container for all the main
# functional tabs of the application, ensuring a clean, consolidated UI component.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.204500.2 (FIXED: Loads real tab components)

import tkinter as tk
from tkinter import ttk
from functools import partial
import inspect
import os
from datetime import datetime

# --- FIXED: Import REAL Tab Content ---
# Note: Adjust these import paths if your directory structure is different.
from Instrument.TAB_INSTRUMENT_PARENT import TAB_INSTRUMENT_PARENT
from Markers.TAB_MARKERS_PARENT import TAB_MARKERS_PARENT
from Scanning.TAB_SCANNING_PARENT import TAB_SCANNING_PARENT
from Plotting.TAB_PLOTTING_PARENT import TAB_PLOTTING_PARENT
from Presets.TAB_PRESETS_PARENT import TAB_PRESETS_PARENT
from Experiments.TAB_EXPERIMENTS_PARENT import ExperimentsParentTab as TAB_EXPERIMENTS_PARENT

# --- Version Information ---
current_version = "20250821.204500.2"
current_file = os.path.basename(__file__)

class TABS_PARENT(ttk.Frame):
    """
    The main tab container widget for the application's left pane.
    Manages tab switching and content display.
    """
    def __init__(self, parent, app_instance, console_print_func):
        super().__init__(parent)
        self.app_instance = app_instance
        self.parent = parent
        self.console_print_func = console_print_func
        self.active_tab_name = None
        
        self.configure(style='App.TFrame')
        self.grid_rowconfigure(1, weight=1)
        self.grid_columnconfigure(0, weight=1)

        self.tab_buttons = {}
        self.tab_content_frames = {}

        self._create_widgets()

    def _create_widgets(self):
        """Creates the tab buttons and content frames."""
        current_function = inspect.currentframe().f_code.co_name
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - 📘 🟢 Creating parent tab widgets.")

        button_frame = ttk.Frame(self, style='App.TFrame')
        button_frame.grid(row=0, column=0, sticky='ew', padx=5, pady=5)

        # --- Use real tab classes ---
        tab_classes = {
            "Instruments": TAB_INSTRUMENT_PARENT,
            "Markers": TAB_MARKERS_PARENT,
            "Scanning": TAB_SCANNING_PARENT,
            "Plotting": TAB_PLOTTING_PARENT,
            "Presets": TAB_PRESETS_PARENT,
            "Experiments": TAB_EXPERIMENTS_PARENT
        }

        for i, (name, TabClass) in enumerate(tab_classes.items()):
            button = ttk.Button(
                button_frame,
                text=name,
                command=partial(self.switch_tab, name),
                style=f'{name}.Inactive.TButton'
            )
            button.grid(row=0, column=i, sticky='ew', padx=2)
            button_frame.grid_columnconfigure(i, weight=1)
            self.tab_buttons[name] = button

            # Create content frame and instantiate the real tab class
            content_container = ttk.Frame(self, style='App.TFrame')
            content_container.grid(row=1, column=0, sticky='nsew')
            
            # Pass the required arguments to the tab's constructor
            if name == "Experiments":
                content = TabClass(content_container, self.app_instance, self.console_print_func, self.app_instance.style_obj)
            else:
                content = TabClass(content_container, self.app_instance, self.console_print_func)

            content.pack(expand=True, fill='both')
            self.tab_content_frames[name] = content_container 

        self.after(100, lambda: self.switch_tab("Instruments"))
        print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - 📘 ✅ Parent tab widgets created.")

    def switch_tab(self, new_tab_name):
        """Handles switching the visible tab content and updating button styles."""
        current_function = inspect.currentframe().f_code.co_name
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

        if self.active_tab_name == new_tab_name:
            return

        print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - 📘 🔵 Switching to tab: {new_tab_name}")
        
        self.active_tab_name = new_tab_name

        for name, button in self.tab_buttons.items():
            content_frame = self.tab_content_frames[name]
            if name == new_tab_name:
                button.config(style=f'{name}.Active.TButton')
                content_frame.tkraise()
                # Call the new tab's selection handler
                new_tab_content = content_frame.winfo_children()[0]
                if hasattr(new_tab_content, '_on_parent_tab_selected'):
                    new_tab_content._on_parent_tab_selected(None)
            else:
                button.config(style=f'{name}.Inactive.TButton')


#####################################
### File: OPEN-AIR\src\connection_status_logic.py
#####################################
# src/connection_status_logic.py
#
# This file contains the core logic for updating the graphical user interface (GUI)
# elements based on the instrument's connection status and the current running state.
# It acts as a centralized function to enable or disable buttons and other widgets
# across various tabs, ensuring the UI accurately reflects the application's status.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250813.163700.1

import tkinter as tk
import inspect
import os

from display.debug_logic import debug_log
from display.console_logic import console_log

# --- Version Information ---
current_version = "20250813.163700.1"
current_version_hash = (20250813 * 163700 * 1)


def update_connection_status_logic(app_instance, is_connected, is_running, console_print_func):
    """
    Updates the state (enabled/disabled) of various GUI elements across different tabs
    based on the instrument's connection status and the current running state.
    This function acts as a central dispatcher for UI state changes.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Updating connection status. Connected: {is_connected}, Running: {is_running}. Version: {current_version}",
                file=f"{os.path.basename(__file__)} - {current_version}",
                version=current_version,
                function=current_function)

    # --- Instrument Tab ---
    if hasattr(app_instance, 'instrument_parent_tab') and hasattr(app_instance.instrument_parent_tab, 'instrument_settings_tab'):
        instrument_tab = app_instance.instrument_parent_tab.instrument_settings_tab
        if hasattr(instrument_tab, '_update_ui_state'):
            instrument_tab._update_ui_state()

    # --- Orchestrator GUI ---
    # CHANGED: Reference the new orchestrator_gui attribute
    if hasattr(app_instance, 'orchestrator_gui'):
        app_instance.orchestrator_gui._update_button_states()
        debug_log("Orchestrator GUI buttons updated.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
    else:
        debug_log("Orchestrator GUI instance not found during status update.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)

    # --- Presets Tab ---
    if hasattr(app_instance, 'presets_parent_tab') and hasattr(app_instance.presets_parent_tab, 'device_presets_tab'):
        device_presets_tab = app_instance.presets_parent_tab.device_presets_tab
        if hasattr(device_presets_tab, 'handle_connection_status_change_event'):
            device_presets_tab.handle_connection_status_change_event()
            debug_log("Device Presets Tab notified of connection change.",
                        file=f"{os.path.basename(__file__)} - {current_version}",
                        version=current_version,
                        function=current_function)

    debug_log("Finished updating all UI elements based on connection status. UI is now responsive!",
                file=f"{os.path.basename(__file__)} - {current_version}",
                version=current_version,
                function=current_function)

#####################################
### File: OPEN-AIR\src\gui_elements.py
#####################################
# src/gui_elements.py
#
# This module defines common GUI elements and utilities, such as a TextRedirector
# for routing stdout/stderr to a Tkinter scrolled text widget, and the application's
# splash screen.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250803.2215.0 (REFACTORED: Removed all parent tab imports to finally kill the circular dependency.)
# Version 20250803.0147.1 (Added call to clear_console before each ASCII art display.)

current_version = "20250803.2215.0"

import tkinter as tk
import sys
import time
from tkinter import scrolledtext, TclError
import inspect

from display.debug_logic import debug_log
from display.console_logic import console_log, clear_console

#
# REMOVED ALL 'from tabs... import TAB_..._PARENT' LINES.
# This file is a low-level utility and must not import high-level UI components.
# This was the source of the circular import error.
#

class TextRedirector(object):
    """
    A class to redirect stdout/stderr to a Tkinter scrolled text widget.
    """
    def __init__(self, widget, tag="stdout"):
        self.widget = widget
        self.tag = tag
        self._buffer = ""
        self._last_flush_time = 0

    def write(self, text):
        self._buffer += text
        current_time = time.time()
        if current_time - self._last_flush_time > 0.1 or len(self._buffer) > 1000:
            self.flush()

    def flush(self):
        if self._buffer:
            try:
                self.widget.insert(tk.END, self._buffer, (self.tag,))
                self.widget.see(tk.END)
                self._buffer = ""
                self._last_flush_time = time.time()
            except TclError:
                pass

def _print_open_air_ascii(console_print_func):
    """Prints the 'OPEN AIR' ASCII art to the console."""
    clear_console()
    lines = [
        " ░▒▓██████▓▒░ ░▒▓███████▓▒░ ░▒▓████████▓▒ ░▒▓███████▓▒░        ░▒▓██████▓▒░ ░▒▓█▓▒░ ▒▓███████▓▒░  ",
        "░▒▓█▓▒░░▒▓█▓▒ ░▒▓█▓▒░░▒▓█▓▒ ░▒▓█▓▒░       ░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒ ░▒▓█▓▒░ ▒▓█▓▒░░▒▓█▓▒░ ",
        "░▒▓█▓▒░░▒▓█▓▒ ░▒▓█▓▒░░▒▓█▓▒ ░▒▓█▓▒░       ░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒ ░▒▓█▓▒░ ▒▓█▓▒░░▒▓█▓▒░ ",
        "░▒▓█▓▒░░▒▓█▓▒ ░▒▓███████▓▒░ ░▒▓██████▓▒░  ░▒▓█▓▒░░▒▓█▓▒░      ░▒▓████████▓▒ ░▒▓█▓▒░ ▒▓███████▓▒░  ",
        "░▒▓█▓▒░░▒▓█▓▒ ░▒▓█▓▒░       ░▒▓█▓▒░       ░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒ ░▒▓█▓▒░ ▒▓█▓▒░░▒▓█▓▒░ ",
        "░▒▓█▓▒░░▒▓█▓▒ ░▒▓█▓▒░       ░▒▓█▓▒░       ░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒ ░▒▓█▓▒░ ▒▓█▓▒░░▒▓█▓▒░ ",
        " ░▒▓██████▓▒░ ░▒▓█▓▒░       ░▒▓████████▓▒ ░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒ ░▒▓█▓▒░ ▒▓█▓▒░░▒▓█▓▒░ "
    ]
    for line in lines:
        console_print_func(line)

def _print_collaboration_ascii(console_print_func):
    """Prints the collaboration ASCII art to the console."""
    clear_console()
    # ... (rest of ASCII functions are unchanged) ...
    lines = [
        "                                               #              #####                     ## ####",
        "                                               ###            ##   ######               ##  ## ",
        "                                               ####           ##         #####          ## ##  ",
        "                                  ##           ## ##          ##             #####      ####   ",
        "                       ############            ##  ###        #                  ###    ####   ",
        "             #########        ###              ##   ###      ##                    ##   ###    ",
        "   #########               ###                 ##     ##     ##                ####     ##     ",
        "                         ###                   ###########   ##          ######         ##     ",
        "                       ###                     ##       ###  #  ########                #      ",
        "                     ###                       ##         #####                                ",
        "                   ###                         ##           ##                        # ##     ",
        "                 ###                #######                 ##                        ###      ",
        "              ####            ######                        ##                  ##########     ",
        "            ###        #######                                   ##############                ",
        "          ###   #######                             ###########                                ",
        "        ########                  ########             ####                                    ",
        "      ###              ##########  ####              ########                                  ",
        "           ###########          ###         ########                                           ",
        " ##########                  ###    ########                                                   ",
        "                         ##########                                                            ",
        "                      #####                        "
    ]
    for line in lines:
        console_print_func(line)

def _print_inst_ascii(console_print_func):
    """Prints the 'INST' ASCII art to the console."""
    clear_console()
    lines = [
        "INST",
        "░▒▓█▓▒░▒▓███████▓▒░ ░▒▓███████▓▒░▒▓████████▓▒░ ",
        "░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░         ░▒▓█▓▒░     ",
        "░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░         ░▒▓█▓▒░     ",
        "░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░░▒▓██████▓▒░   ░▒▓█▓▒░     ",
        "░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░  ░▒▓█▓▒░     ",
        "░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░  ░▒▓█▓▒░     ",
        "░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓███████▓▒░   ░▒▓█▓▒░     "
    ]
    for line in lines:
        console_print_func(line)

def _print_scan_ascii(console_print_func):
    """Prints the 'SCAN' ASCII art to the console."""
    clear_console()
    lines = [
        "SCAN",
        " ░▒▓███████▓▒░ ░▒▓██████▓▒░  ░▒▓██████▓▒░ ░▒▓███████▓▒░  ",
        "░▒▓█▓▒░       ░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░ ",
        "░▒▓█▓▒░       ░▒▓█▓▒░       ░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░ ",
        " ░▒▓██████▓▒░ ░▒▓█▓▒░       ░▒▓████████▓▒░░▒▓█▓▒░░▒▓█▓▒░ ",
        "       ░▒▓█▓▒░░▒▓█▓▒░       ░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░ ",
        "       ░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░ ",
        "░▒▓███████▓▒░  ░▒▓██████▓▒░ ░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░ "
    ]
    for line in lines:
        console_print_func(line)

def _print_plot_ascii(console_print_func):
    """Prints the 'PLOT' ASCII art to the console."""
    clear_console()
    lines = [
        "PLOT:                                                   ",
        "░▒▓███████▓▒░ ░▒▓█▓▒░       ░▒▓██████▓▒░░▒▓████████▓▒░ ",
        "░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░     ",
        "░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░     ",
        "░▒▓███████▓▒░ ░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░     ",
        "░▒▓█▓▒░       ░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░     ",
        "░▒▓█▓▒░       ░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░  ░▒▓█▓▒░     ",
        "░▒▓█▓▒░       ░▒▓████████▓▒░░▒▓██████▓▒░   ░▒▓█▓▒░     "
    ]
    for line in lines:
        console_print_func(line)

def _print_marks_ascii(console_print_func):
    """Prints the 'MARKS' ASCII art to the console."""
    clear_console()
    lines = [
        "MARKS:                                                                                                                ",
        "░▒▓██████████████▓▒░  ░▒▓██████▓▒░ ░▒▓███████▓▒░ ░▒▓█▓▒░░▒▓█▓▒░ ",
        "░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░ ",
        "░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░ ",
        "░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓████████▓▒░░▒▓███████▓▒░ ░▒▓███████▓▒░  ",
        "░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░ ",
        "░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░ ",
        "░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░ "
    ]
    for line in lines:
        console_print_func(line)

def _print_presets_ascii(console_print_func):
    """Prints the 'PRESETS.CSV' ASCII art to the console."""
    clear_console()
    lines = [
        "PRESETS.CSV is a file that contains user-defined presets for the application.",
        "                                                                ",
        "░▒▓███████▓▒░ ░▒▓███████▓▒░ ░▒▓████████▓▒░ ░▒▓███████▓▒░░▒▓████████▓▒░░▒▓████████▓▒░ ",
        "░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░       ░▒▓█▓▒░       ░▒▓█▓▒░          ░▒▓█▓▒░     ",
        "░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░       ░▒▓█▓▒░       ░▒▓█▓▒░          ░▒▓█▓▒░     ",
        "░▒▓███████▓▒░ ░▒▓███████▓▒░ ░▒▓██████▓▒░   ░▒▓██████▓▒░ ░▒▓██████▓▒░     ░▒▓█▓▒░     ",
        "░▒▓█▓▒░       ░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░              ░▒▓█▓▒░░▒▓█▓▒░          ░▒▓█▓▒░     ",
        "░▒▓█▓▒░       ░▒▓█▓▒░░▒▓█▓▒░░▒▓█▓▒░              ░▒▓█▓▒░░▒▓█▓▒░          ░▒▓█▓▒░     ",
        "░▒▓█▓▒░       ░▒▓█▓▒░░▒▓█▓▒░░▒▓████████▓▒░░▒▓███████▓▒░ ░▒▓████████▓▒░   ░▒▓█▓▒░     "
    ]
    for line in lines:
        console_print_func(line)

def _print_xxx_ascii(console_print_func):
    """Prints the 'XXX' ASCII art to the console."""
    clear_console()
    lines = [
        "XXX",
        "░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░      ",
        "░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░      ",
        "░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░      ",
        " ░▒▓██████▓▒░        ░▒▓██████▓▒░        ░▒▓██████▓▒░       ",
        "░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░      ",
        "░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░      ",
        "░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░      ░▒▓█▓▒░░▒▓█▓▒░      "
    ]
    for line in lines:
        console_print_func(line)

def display_splash_screen():
    """
    Prints a stylized ASCII art splash screen to the terminal.
    """
    console_log("")
    _print_open_air_ascii(console_log)
    console_log("")
    _print_collaboration_ascii(console_log)
    console_log("")
    console_log("A Colaboration betweeen Ike Zimbel and Anthony P. Kuzub")
    console_log("")
    console_log("https://zimbelaudio.com/ike-zimbel/    ")
    console_log("https://www.like.audio/")
    console_log("")

#####################################
### File: OPEN-AIR\src\program_check_dependancies.py
#####################################
# src/program_check_dependancies.py
#
# This file checks for and installs necessary Python dependencies, and now
# includes an option to upgrade existing packages to their latest versions.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
# Version 20250821.200300.4

import subprocess
import sys
import inspect
import os
from datetime import datetime

# --- Version Information ---
current_version = "20250821.200300.4"
current_version_hash = 20250821 * 200300 * 4
current_file = os.path.basename(__file__)

def check_and_install_dependencies():
    """
    Checks for necessary packages, installs missing ones, and provides an
    option to upgrade existing packages.
    """
    current_function = inspect.currentframe().f_code.co_name
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - 🟢 Checking for required Python packages.")

    required_dependencies = {
        "numpy": "numpy",
        "pandas": "pandas",
        "scipy": "scipy",
        "pyvisa": "pyvisa",
        "matplotlib": "matplotlib",
        "plotly": "plotly",
        "openpyxl": "openpyxl",
        "pyserial": "serial",
        "Pillow": "PIL",
        "tk": "tk"
    }
    
    missing_dependencies = []
    installed_dependencies = []
    
    for package_name, import_name in required_dependencies.items():
        try:
            if import_name == "tk":
                __import__("tkinter")
            else:
                __import__(import_name)
            
            # Don't add 'tk' to the list for pip operations
            if package_name != "tk":
                installed_dependencies.append(package_name)
                
            print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - ✅ Dependency '{package_name}' found.")
        except ImportError:
            missing_dependencies.append(package_name)
            print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - ❌ Dependency '{package_name}' missing.")

    # --- Step 1: Install any missing dependencies ---
    if missing_dependencies:
        missing_str = ", ".join(missing_dependencies)
        
        print(f"\n--- Missing Dependencies ---")
        print(f"The following Python packages are missing: {missing_str}.")
        response = input("Do you want to install them now? (yes/no): ").strip().lower()

        if response == 'yes':
            try:
                print(f"Attempting to install missing packages: {missing_str}. Hold on tight!")
                subprocess.check_call([sys.executable, "-m", "pip", "install", *missing_dependencies])
                print("Required packages installed successfully. Please restart the application.")
                sys.exit(0)
            except Exception as e:
                print(f"\n--- Installation Failed ---")
                print(f"Failed to install packages: {e}. Please install them manually and try again.")
                sys.exit(1)
        else:
            print("\n--- Dependencies Missing ---")
            print("Application cannot continue without required packages. Exiting.")
            sys.exit(1)
    
    # --- Step 2: [NEW] Optional Upgrade Check for installed dependencies ---
    else:
        print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - ✅ All required dependencies are installed.")
        
        upgrade_response = input("Do you want to check for new versions of these packages? (yes/no): ").strip().lower()
        
        if upgrade_response == 'yes':
            try:
                print(f"Checking for updates for: {', '.join(installed_dependencies)}. This may take a moment...")
                # The --upgrade flag tells pip to fetch the latest versions
                subprocess.check_call([sys.executable, "-m", "pip", "install", "--upgrade", *installed_dependencies])
                print("✅ All packages are now up to date. Fantastic!")
            except Exception as e:
                print(f"\n--- Upgrade Failed ---")
                print(f"Failed to upgrade packages: {e}. The old versions will be used.")

#####################################
### File: OPEN-AIR\src\program_gui_utils.py
#####################################
# src/program_gui_utils.py
#
# This file provides utility functions for creating and managing the main application GUI layout,
# including the main window layout, the tab container, and other top-level widgets.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.204500.1 (FIXED: Instantiates real UI components)

import os
import tkinter as tk
from tkinter import ttk
import inspect
from datetime import datetime

# --- FIXED: Import the real parent components ---
# Note: Adjust these import paths if your directory structure is different.
from .TABS_PARENT import TABS_PARENT
from display.DISPLAY_PARENT import DISPLAY_PARENT

# --- Version Information ---
current_version = "20250821.204500.1"
current_file = os.path.basename(__file__)

def create_main_layout(app_instance, style_obj):
    """
    Creates and configures the main GUI layout, including the paned window
    that separates the control tabs from the display area.
    """
    current_function = inspect.currentframe().f_code.co_name
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - ⚙️ 🟢 Entering {current_function}")
    
    try:
        main_paned_window = ttk.PanedWindow(app_instance, orient=tk.HORIZONTAL)
        main_paned_window.pack(fill=tk.BOTH, expand=True)

        # --- NEW LOGIC: Instantiate real components in the correct order ---

        # 1. Create the display parent first to get the console function.
        display_parent = DISPLAY_PARENT(main_paned_window, app_instance, style_obj)
        
        # 2. Get the console print function from the now-created widget.
        #    This is crucial for breaking the circular dependency.
        console_print_func = display_parent.console_tab.console_output_widget.insert_and_scroll
        
        # 3. Create the tabs parent, passing the real console function to it.
        tabs_parent = TABS_PARENT(main_paned_window, app_instance, console_print_func)

        # 4. Add the fully initialized components to the paned window.
        main_paned_window.add(tabs_parent, weight=1)
        main_paned_window.add(display_parent, weight=4)

        print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - ✅ Main layout created successfully with real components.")
        
        return main_paned_window, tabs_parent, display_parent
    
    except Exception as e:
        print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - ❌ Error creating main layout: {e}")
        raise

def apply_saved_geometry(app_instance):
    """
    Applies the last saved window geometry and state from the config file.
    """
    current_function = inspect.currentframe().f_code.co_name
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - ⚙️ 🟢 Entering {current_function}")
    
    try:
        if hasattr(app_instance, 'program_config') and app_instance.program_config.has_option('Application', 'geometry'):
            geometry = app_instance.program_config.get('Application', 'geometry')
            app_instance.geometry(geometry)
            print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - ✅ Applied saved geometry: {geometry}")
        
        if hasattr(app_instance, 'program_config') and app_instance.program_config.has_option('Application', 'window_state'):
            window_state = app_instance.program_config.get('Application', 'window_state')
            if window_state:
                app_instance.state(window_state)
                print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - ✅ Applied saved window state: {window_state}")
                          
        print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - ⚙️ ✅ Exiting {current_function}")
    
    except Exception as e:
        print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - ❌ Error applying saved geometry: {e}")


#####################################
### File: OPEN-AIR\src\program_initialization.py
#####################################
# src/program_initialization.py
#
# This file contains the primary initialization sequence for the application, handling
# folder creation, configuration loading, and initial state setup.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.200453.1

import os
import inspect
import tkinter as tk
from datetime import datetime

# Local application imports
from settings_and_config.config_manager_save import load_program_config
from settings_and_config.config_manager_restore import restore_last_used_settings
from src.program_shared_values import setup_shared_values
from ref.ref_file_paths import DATA_FOLDER_PATH

# --- Version Information ---
current_version = "20250821.200453.1"
current_version_hash = 20250821 * 200453 * 1
current_file = os.path.basename(__file__)

def initialize_application(app_instance):
    """
    Main function to orchestrate the application's initialization sequence.
    """
    current_function = inspect.currentframe().f_code.co_name
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - 🚀 🟢 Starting application initialization sequence.")
    
    try:
        _create_required_folders()
        
        # --- FIXED LINE ---
        # The function is now called correctly without any arguments.
        app_instance.program_config = load_program_config()
        print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - ✅ Configuration loaded.")
        
        # Setup shared Tkinter variables
        _setup_initial_settings(app_instance)
        print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - ✅ Shared values initialized.")
        
        # Restore settings from the last session
        restore_last_used_settings(app_instance)
        print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - ✅ Last used settings restored.")

        print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - 🚀 ✅ Application initialization complete! All systems go!")
    
    except Exception as e:
        print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - ❌ A critical error occurred during initialization: {e}")
        # Optionally, decide how to handle a failed init, e.g., show a simple tk error window or exit.
        raise # Re-raise to halt execution if the error is fatal

def _create_required_folders():
    """
    Ensures that all necessary data and configuration folders exist.
    """
    current_function = inspect.currentframe().f_code.co_name
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - 📂 🟢 Checking for required folders.")
    
    folders_to_create = [DATA_FOLDER_PATH]
    
    try:
        for folder_path in folders_to_create:
            if not os.path.exists(folder_path):
                os.makedirs(folder_path)
                print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - ✅ Created folder: {folder_path}")
            else:
                print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - 👍 Folder already exists: {folder_path}")
    except Exception as e:
        print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - ❌ Error creating folders: {e}")
                
def _setup_initial_settings(app_instance):
    """
    Sets up the initial Tkinter variables and default values for the application.
    """
    current_function = inspect.currentframe().f_code.co_name
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - ⚙️ 🟢 Setting up initial application settings.")
                
    setup_shared_values(app_instance)
    
    app_instance.showtime_parent_tab = None
    
    print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - ⚙️ ✅ Initial settings configured.")

#####################################
### File: OPEN-AIR\src\program_shared_values.py
#####################################
# variables/program_shared_values.py
#
# This module centralizes the definition and initialization of all Tkinter variables
# used throughout the application, providing a single source for managing state.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.194400.3

import tkinter as tk
import inspect
import os
from datetime import datetime
from tkinter import StringVar

# Assuming these ref files exist and are correct
# from ref.ref_frequency_bands import SCAN_BAND_RANGES
# from ref.ref_program_default_values import DEFAULT_CONFIG

# --- Version Information ---
current_version = "20250821.194400.3"
current_version_hash = 20250821 * 194400 * 3
current_file = os.path.basename(__file__)

def setup_shared_values(app_instance):
    """
    Initializes all the shared Tkinter variables for the application.
    This function should be called once during program initialization.

    Args:
        app_instance: The main application instance (tk.Tk()).
    """
    current_function = inspect.currentframe().f_code.co_name
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - ⚙️ 🟢 Setting up shared values with the force! ✨")

    # --- Application & Debugging ---
    app_instance.debug_mode_var = tk.BooleanVar(value=False)
    app_instance.log_visa_commands_var = tk.BooleanVar(value=False)
    app_instance.debug_to_file_var = tk.BooleanVar(value=False)
    app_instance.include_console_messages_to_debug_file_var = tk.BooleanVar(value=False)
    app_instance.log_truncation_var = tk.BooleanVar(value=True)
    app_instance.include_visa_messages_to_debug_file_var = tk.BooleanVar(value=False)
    app_instance.app_update_available = tk.StringVar(value="Update Available")
    app_instance.app_version_string = tk.StringVar(value=f"Version: {current_version}")

    # --- Instrument & Connection ---
    app_instance.instrument_brand_var = tk.StringVar(value="Keysight")
    app_instance.instrument_series_var = tk.StringVar(value="E440xB")
    app_instance.instrument_visa_resource_var = tk.StringVar(value="")
    app_instance.connected_instrument_instance = None # Placeholder for the instrument object

    # --- Markers Tab ---
    app_instance.marker_count_var = tk.StringVar(value="1")
    app_instance.marker_vars = {
        i: {'freq_mhz': tk.StringVar(value=""), 'selected': tk.BooleanVar(value=False)}
        for i in range(1, 11)
    }

    # --- Scan Configuration ---
    app_instance.scan_config_start_freq_mhz_var = tk.StringVar(value="100")
    app_instance.scan_config_stop_freq_mhz_var = tk.StringVar(value="1000")
    app_instance.scan_config_step_freq_khz_var = tk.StringVar(value="100")
    app_instance.scan_config_dwell_time_ms_var = tk.StringVar(value="100")

    # --- Report Metadata ---
    app_instance.report_meta_author_var = tk.StringVar(value="Anthony Peter Kuzub")
    app_instance.report_meta_location_var = tk.StringVar(value="Whitby, ON, Canada")
    app_instance.report_meta_notes_var = tk.StringVar(value="Initial scan.")

    # --- Plotting & Data ---
    app_instance.plotting_selected_scan_var = tk.StringVar(value="")
    app_instance.collected_scans_dataframes = {} # To store pandas DataFrames

    print(f"💻 [{timestamp}]-[{current_version}]-[{current_file}]-[{current_function}] - ✅ Shared values have been initialized successfully.")

#####################################
### File: OPEN-AIR\src\program_style.py
#####################################
# src/program_style.py
#
# This file centralizes the Tkinter `ttk.Style` configurations for the application.
# It defines custom styles for various widgets, including buttons, labels, entries,
# and especially the nested notebook tabs, ensuring a consistent and modern dark theme.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-runner/
# Source Code: https://github.com/APKaudio/
#
#
# Version 20250821.110100.3 (FIXED: Added check for debug_log_func to prevent TypeError on startup.)

current_version = "20250821.110100.3"
current_version_hash = (20250821 * 110100 * 3)

import tkinter as tk
from tkinter import ttk, TclError
import inspect
import os

from display.debug_logic import debug_log

COLOR_PALETTE = {
    'background': '#2b2b2b',
    'foreground': 'white',
    'input_bg': '#3c3c3c',
    'input_fg': 'white',
    'select_bg': '#007acc',
    'select_fg': 'white',
    'active_bg': '#606060',
    'disabled_bg': '#3a3a3a',
    'disabled_fg': '#808080',
    'green_btn': '#4CAF50',
    'green_btn_active': '#66BB6A',
    'red_btn': '#F44336',
    'red_btn_active': '#EF5350',
    'orange_btn': '#FF9800',
    'orange_btn_active': '#FFA726',
    'blue_btn': '#2196F3',
    'blue_btn_active': '#64B5F6',
    'purple_btn': '#673AB7',
    'purple_btn_active': '#7E57C2',
    'value_fg': '#ADD8E6',
    'grey_btn': '#707070',
    'grey_btn_active': '#858585',
    'white': 'white', # Explicit white for clarity
    'black': 'black', # Explicit black for clarity
    'yellow_btn': '#FFEB3B',
    'yellow_btn_active': '#FFF176',
    'dark_grey_slider': '#1F1F1F',
}

COLOR_PALETTE_TABS = {
    'Instruments': {'active': '#d13438', 'fg': 'white'},
    'Markers': {'active': '#ff8c00', 'fg': 'black'},
    'Presets': {'active': '#ffb900', 'fg': 'black'},
    'Scanning': {'active': '#00b294', 'fg': 'white'},
    'Plotting': {'active': '#0078d4', 'fg': 'white'},
    'Experiments': {'active': '#8a2be2', 'fg': 'white'},
}

def _get_dark_color(hex_color):
    """Calculates a 50% darker version of a hex color."""
    hex_color = hex_color.lstrip('#')
    r, g, b = tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
    r = int(r * 0.5); g = int(g * 0.5); b = int(b * 0.5)
    return f'#{r:02x}{g:02x}{b:02x}'
    
def _revert_to_default_styles(style):
    """
    Reverts to the default Tkinter styles if a TclError occurs.
    """
    style.configure('.', background=COLOR_PALETTE['background'], foreground=COLOR_PALETTE['foreground'])
    style.configure('TFrame', background=COLOR_PALETTE['background'])
    style.configure('TLabelFrame', background=COLOR_PALETTE['background'], foreground=COLOR_PALETTE['foreground'])
    style.configure('TLabel', background=COLOR_PALETTE['background'], foreground=COLOR_PALETTE['foreground'])
    style.configure('TButton', background='lightgrey', foreground='black')
    style.configure('TCheckbutton', background=COLOR_PALETTE['background'], foreground=COLOR_PALETTE['foreground'])
    style.configure('TEntry', fieldbackground='white', foreground='black')
    style.configure('TCombobox', fieldbackground='white', foreground='black')
    style.configure('TPanedwindow', background=COLOR_PALETTE['background'])
    style.configure('Treeview', background='white', foreground='black', fieldbackground='white')
    style.configure('Treeview.Heading', background='lightgrey', foreground='black')
    style.configure('Vertical.TScrollbar', troughcolor='lightgrey', background='darkgrey')
    style.configure('Horizontal.TScrollbar', troughcolor='lightgrey', background='darkgrey')
    style.map('TButton', background=[('active', 'gray')])
    style.map('TCheckbutton', background=[('active', 'gray')])
    style.map('TEntry', fieldbackground=[('disabled', 'lightgrey')], foreground=[('disabled', 'darkgrey')])

def apply_styles(style, debug_log_func, current_app_version):
    """Applies custom Tkinter ttk styles for a consistent dark theme."""
    current_function = inspect.currentframe().f_code.co_name
    if debug_log_func:
        debug_log_func(f"Entering {current_function}. Applying all application-wide widget styles. 🎨",
                       file=f"{os.path.basename(__file__)} - {current_app_version}",
                       version=current_app_version,
                       function=current_function, special=True)
    else:
        # Use standard print as fallback if debug_log_func is not provided
        print(f"Entering {current_function}. Applying all application-wide widget styles. 🎨")

    try:
        try:
            style.theme_use('clam')
        except TclError:
            style.theme_use('default')

    except TclError as e:
        if debug_log_func:
             debug_log_func(f"❌ TclError: {e}. Reverting to default styles.",
                            file=f"{os.path.basename(__file__)} - {current_app_version}",
                            version=current_app_version,
                            function=current_function)
        else:
            print(f"❌ TclError: {e}. Reverting to default styles.")
        _revert_to_default_styles(style)
        
    style.configure('.', background=COLOR_PALETTE['background'], foreground=COLOR_PALETTE['foreground'])
    style.configure('.', background=COLOR_PALETTE['background'], foreground=COLOR_PALETTE['foreground'])

    # --- General Styles ---
    style.configure('TFrame', background=COLOR_PALETTE['background'])
    style.configure('Dark.TFrame', background=COLOR_PALETTE['background'])
    
    style.configure('TLabelframe', background=COLOR_PALETTE['background'], foreground=COLOR_PALETTE['foreground'])
    style.configure('Dark.TLabelframe', background=COLOR_PALETTE['background'], foreground=COLOR_PALETTE['foreground'])
    
    style.configure('TLabelframe.Label', background=COLOR_PALETTE['background'], foreground=COLOR_PALETTE['foreground'], font=('Helvetica', 13, 'bold'))

    style.configure('TLabel', background=COLOR_PALETTE['background'], foreground=COLOR_PALETTE['foreground'], font=('Helvetica', 9))
    
    try:
        tlabel_layout = style.layout('TLabel')
        if tlabel_layout:
            style.layout('Dark.TLabel.Value', tlabel_layout)
            style.layout('Red.TLabel.Value', tlabel_layout)
    except TclError as e:
        if debug_log_func:
            debug_log_func(f"CRITICAL ERROR: Failed to copy TLabel layout: {e}", file=os.path.basename(__file__), version=current_app_version, function="apply_styles")
        else:
            print(f"CRITICAL ERROR: Failed to copy TLabel layout: {e}")

    style.configure('Dark.TLabel.Value', background=COLOR_PALETTE['background'], foreground=COLOR_PALETTE['value_fg'], font=('Helvetica', 10, 'bold'))
    style.configure('Red.TLabel.Value', background=COLOR_PALETTE['background'], foreground=COLOR_PALETTE['red_btn'], font=('Helvetica', 10, 'bold'))
    
    style.configure('Dark.TLabel.Success', background=COLOR_PALETTE['background'], foreground=COLOR_PALETTE['green_btn'], font=('Helvetica', 10, 'bold'))
    style.configure('Dark.TLabel.Error', background=COLOR_PALETTE['background'], foreground=COLOR_PALETTE['red_btn'], font=('Helvetica', 10, 'bold'))
    style.configure('Disconnected.TLabel', background=COLOR_PALETTE['red_btn'], foreground=COLOR_PALETTE['white'], font=('Helvetica', 10, 'bold'))

    # REVERTED: The custom 'Dark.TLabel.Result' style and its layout have been removed.
    # The label will now use the default 'TLabel' style.


    # UPDATED: Changed font size for Entry widgets to 14pt AND added selectbackground
    style.configure('TEntry', fieldbackground=COLOR_PALETTE['input_bg'], foreground='white', borderwidth=1, relief="solid", font=('Helvetica', 14))
    style.map('TEntry', fieldbackground=[('focus', COLOR_PALETTE['active_bg'])])
    style.map('TEntry', selectbackground=[('selected', COLOR_PALETTE['select_bg'])])

    style.configure('TCheckbutton', background=COLOR_PALETTE['background'], foreground=COLOR_PALETTE['foreground'], font=('Helvetica', 9))
    style.map('TCheckbutton',
        background=[('active', COLOR_PALETTE['background'])],
        foreground=[('disabled', COLOR_PALETTE['disabled_fg'])])

    # UPDATED: Changed font size for Combobox widgets to 14pt
    style.configure('TCombobox',
                     fieldbackground=COLOR_PALETTE['input_bg'],
                     selectbackground=COLOR_PALETTE['select_bg'],
                     foreground=COLOR_PALETTE['input_fg'],
                     selectforeground=COLOR_PALETTE['select_fg'],
                     background=COLOR_PALETTE['input_bg'],
                     font=('Helvetica', 14))
    style.map('TCombobox',
              fieldbackground=[('readonly', COLOR_PALETTE['input_bg'])],
              foreground=[('disabled', COLOR_PALETTE['disabled_fg'])],
              selectbackground=[('readonly', COLOR_PALETTE['select_bg'])],
              selectforeground=[('readonly', COLOR_PALETTE['select_fg'])])

    # --- New Slider Style ---
    # Define the layout for the new custom slider style based on the stock clam theme's layout
    # FIXED: Layout corrected to build on the stock clam theme's layout.
    style.layout('Horizontal.InteractionBars.TScale',
        [('Horizontal.Scale.trough',
          {'sticky': 'nswe'}),
         ('Horizontal.Scale.slider',
          {'side': 'left', 'sticky': 'ew'})])

    style.layout('Vertical.InteractionBars.TScale',
        [('Vertical.Scale.trough',
          {'sticky': 'nswe'}),
         ('Vertical.Scale.slider',
          {'side': 'top', 'sticky': 'ns'})])

    style.configure('InteractionBars.TScale',
                     background=COLOR_PALETTE['background'],
                     troughcolor=COLOR_PALETTE['dark_grey_slider'],
                     sliderrelief='flat',
                     sliderthickness=15,
                     borderwidth=0)
    
    # --- Custom Tab Button Styles (Parents) & Child Notebook Styles ---
    for name, config in COLOR_PALETTE_TABS.items():
        active_color = config['active']
        inactive_color = _get_dark_color(active_color)
        
        # UPDATED: Changed font size for active parent buttons to 13pt
        style.configure(f'{name}.Active.TButton', background=active_color, foreground=config['fg'], font=('Helvetica', 13, 'bold'), relief='flat')
        style.map(f'{name}.Active.TButton', background=[('active', active_color)])
        
        # UPDATED: Changed font size for inactive parent buttons to 13pt
        style.configure(f'{name}.Inactive.TButton', background=inactive_color, foreground=COLOR_PALETTE['foreground'], font=('Helvetica', 13, 'bold'), relief='flat')
        style.map(f'{name}.Inactive.TButton', background=[('active', active_color)])

        child_style_name = f'{name}.Child.TNotebook'
        child_tab_style_name = f'{child_style_name}.Tab'
        
        style.configure(child_style_name, background=COLOR_PALETTE['background'], borderwidth=1)
        # UPDATED: Changed font size for child tabs to 13pt
        style.configure(child_tab_style_name, background=inactive_color, foreground=COLOR_PALETTE['foreground'], padding=[8, 4], font=('Helvetica', 13, 'bold'))
        style.map(child_tab_style_name, background=[('selected', active_color)], foreground=[('selected', config['fg'])])

    # --- Device Buttons (Markers Tab) ---
    # UPDATED: Changed font size for device buttons to 13pt
    style.configure('DeviceButton.Inactive.TButton', 
                     background=COLOR_PALETTE['active_bg'], 
                     foreground=COLOR_PALETTE['foreground'], 
                     font=('Helvetica', 13),
                     padding=5,
                     anchor='center',
                     justify='center')
    style.map('DeviceButton.Inactive.TButton', background=[('active', COLOR_PALETTE['select_bg'])])
    
    # UPDATED: Changed font size for active device buttons to 13pt
    style.configure('DeviceButton.Active.TButton',
                     background=COLOR_PALETTE['orange_btn'],
                     foreground='black',
                     font=('Helvetica', 13, 'bold'),
                     padding=5,
                     anchor='center',
                     justify='center')
    style.map('DeviceButton.Active.TButton', background=[('active', COLOR_PALETTE['orange_btn_active'])])

    # UPDATED: Changed font size for blinking device buttons to 13pt
    style.configure('DeviceButton.Blinking.TButton',
                     background=COLOR_PALETTE['red_btn'],
                     foreground='white',
                     font=('Helvetica', 13, 'bold'),
                     padding=5,
                     anchor='center',
                     justify='center')
    style.map('DeviceButton.Blinking.TButton', background=[('active', COLOR_PALETTE['red_btn_active'])])


    # --- Styles for Control Buttons (Markers Tab) ---
    # UPDATED: Changed font size for control buttons to 13pt
    style.configure('ControlButton.Inactive.TButton',
                     background=COLOR_PALETTE['grey_btn'],
                     foreground=COLOR_PALETTE['foreground'],
                     font=('Helvetica', 13),
                     padding=5,
                     anchor='center',
                     justify='center')
    style.map('ControlButton.Inactive.TButton',
              background=[('active', COLOR_PALETTE['grey_btn_active'])])
    
    # UPDATED: Changed font size for active control buttons to 13pt
    style.configure('ControlButton.Active.TButton',
                     background=COLOR_PALETTE['orange_btn'],
                     foreground='black',
                     font=('Helvetica', 13, 'bold'),
                     padding=[5, 5],
                     anchor='center',
                     justify='center')
    style.map('ControlButton.Active.TButton',
              background=[('active', COLOR_PALETTE['orange_btn_active'])])

    # --- Styles for Band Selection Buttons (Running Tab) ---
    # UPDATED: Changed font size for band buttons to 13pt
    style.configure('Band.TButton',
                     background=COLOR_PALETTE['grey_btn'],
                     foreground='white',
                     font=('Helvetica', 13),
                     padding=[5, 5],
                     anchor='center',
                     justify='center',
                     relief='flat',
                     borderwidth=1)
    style.map('Band.TButton',
              background=[('active', COLOR_PALETTE['grey_btn_active'])])

    # UPDATED: Changed font size for low band buttons to 13pt
    style.configure('Band.Low.TButton',
                     background=COLOR_PALETTE['yellow_btn'],
                     foreground='black',
                     font=('Helvetica', 13, 'bold'),
                     padding=[5, 5],
                     anchor='center',
                     justify='center',
                     relief='raised',
                     borderwidth=2)
    style.map('Band.Low.TButton',
              background=[('active', COLOR_PALETTE['yellow_btn_active'])])

    # UPDATED: Changed font size for medium band buttons to 13pt
    style.configure('Band.Medium.TButton',
                     background=COLOR_PALETTE['orange_btn'],
                     foreground='black',
                     font=('Helvetica', 13, 'bold'),
                     padding=[5, 5],
                     anchor='center',
                     justify='center',
                     relief='raised',
                     borderwidth=2)
    style.map('Band.Medium.TButton',
              background=[('active', COLOR_PALETTE['orange_btn_active'])])

    # UPDATED: Changed font size for high band buttons to 13pt
    style.configure('Band.High.TButton',
                     background=COLOR_PALETTE['red_btn'],
                     foreground='white',
                     font=('Helvetica', 13, 'bold'),
                     padding=[5, 5],
                     anchor='center',
                     justify='center',
                     relief='raised',
                     borderwidth=2)
    style.map('Band.High.TButton',
              background=[('active', COLOR_PALETTE['red_btn_active'])])

    # --- Run Control Buttons (Start, Pause, Stop) ---
    # UPDATED: Changed font size for scan control buttons to 13pt
    style.configure('StartScan.TButton',
                     background=COLOR_PALETTE['green_btn'],
                     foreground='white',
                     font=('Helvetica', 13, 'bold'),
                     padding=[10, 5])
    style.map('StartScan.TButton',
              background=[('active', COLOR_PALETTE['green_btn_active']),
                          ('disabled', COLOR_PALETTE['disabled_bg'])],
              foreground=[('disabled', COLOR_PALETTE['disabled_fg'])])

    # UPDATED: Changed font size for scan control buttons to 13pt
    style.configure('PauseScan.TButton',
                     background=COLOR_PALETTE['orange_btn'],
                     foreground='black',
                     font=('Helvetica', 13, 'bold'),
                     padding=[10, 5])
    style.map('PauseScan.TButton',
              background=[('active', COLOR_PALETTE['orange_btn_active']),
                          ('disabled', COLOR_PALETTE['disabled_bg'])],
              foreground=[('disabled', COLOR_PALETTE['disabled_fg'])])

    # UPDATED: Changed font size for scan control buttons to 13pt
    style.configure('StopScan.TButton',
                     background=COLOR_PALETTE['red_btn'],
                     foreground='white',
                     font=('Helvetica', 13, 'bold'),
                     padding=[10, 5])
    style.map('StopScan.TButton',
              background=[('active', COLOR_PALETTE['red_btn_active']),
                          ('disabled', COLOR_PALETTE['disabled_bg'])],
              foreground=[('disabled', COLOR_PALETTE['disabled_fg'])])
    
    # UPDATED: Changed font size for scan control buttons to 13pt
    style.configure('ResumeScan.Blink.TButton',
                     background=COLOR_PALETTE['select_bg'],
                     foreground='white',
                     font=('Helvetica', 13, 'bold'),
                     padding=[10, 5])
    style.map('ResumeScan.Blink.TButton',
              background=[('active', COLOR_PALETTE['blue_btn_active'])])


    # --- Other Generic Buttons ---
    # UPDATED: Changed font size for generic buttons to 13pt
    style.configure('Green.TButton', background=COLOR_PALETTE['green_btn'], foreground='white', font=('Helvetica', 13))
    style.map('Green.TButton', background=[('active', COLOR_PALETTE['green_btn_active'])])
    # UPDATED: Changed font size for generic buttons to 13pt
    style.configure('Red.TButton', background=COLOR_PALETTE['red_btn'], foreground='white', font=('Helvetica', 13))
    style.map('Red.TButton', background=[('active', COLOR_PALETTE['red_btn_active'])])
    # UPDATED: Changed font size for generic buttons to 13pt
    style.configure('Blue.TButton', background=COLOR_PALETTE['blue_btn'], foreground='white', font=('Helvetica', 13))
    style.map('Blue.TButton', background=[('active', COLOR_PALETTE['blue_btn_active'])])
    # UPDATED: Changed font size for generic buttons to 13pt
    style.configure('Orange.TButton', background=COLOR_PALETTE['orange_btn'], foreground='black', font=('Helvetica', 13))
    style.map('Orange.TButton', background=[('active', COLOR_PALETTE['orange_btn_active'])])
    # UPDATED: Changed font size for generic buttons to 13pt
    style.configure('Purple.TButton', background=COLOR_PALETTE['purple_btn'], foreground='white', font=('Helvetica', 13))
    style.map('Purple.TButton', background=[('active', COLOR_PALETTE['purple_btn_active'])])

    # --- Treeview ---
    # UPDATED: Changed font size for Treeview to 13pt
    style.configure("Treeview", background=COLOR_PALETTE['input_bg'], foreground=COLOR_PALETTE['foreground'], fieldbackground=COLOR_PALETTE['input_bg'], font=("Helvetica", 13))
    style.map("Treeview", background=[('selected', COLOR_PALETTE['select_bg'])], foreground=[('selected', COLOR_PALETTE['select_fg'])])
    # UPDATED: Changed font size for Treeview headings to 13pt
    style.configure("Treeview.Heading", font=("Helvetica", 13, "bold"), background=COLOR_PALETTE['active_bg'], foreground=COLOR_PALETTE['foreground'], relief="flat")
    style.map("Treeview.Heading", background=[('active', COLOR_PALETTE['active_bg'])])

    if debug_log_func:
        debug_log_func(f"✅ Exiting {current_function}. All widget styles have been applied.",
                         file=f"{os.path.basename(__file__)} - {current_app_version}",
                         version=current_app_version,
                         function=current_function, special=True)
    else:
        print(f"✅ Exiting {current_function}. All widget styles have been applied.")


#####################################
### File: OPEN-AIR\utils\utils_csv_writer.py
#####################################
# csv_utils.py
#
# This module provides utility functions for writing spectrum scan data to CSV files.
# It encapsulates the logic for handling file paths, directory creation, and data formatting
# for CSV output, ensuring consistent data storage for analysis and historical tracking.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
# Version 20250810.134500.1 (FIXED: Added app_instance_ref parameter and wrapped console calls with after() to prevent GIL errors.)

current_version = "20250810.134500.1" # this variable should always be defined below the header to make the debugging better
current_version_hash = 20250810 * 134500 * 1 # Example hash, adjust as needed

import csv
import os
import inspect # Import inspect module

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log

def write_scan_data_to_csv(file_path, header, data, app_instance_ref, append_mode=False, console_print_func=None):
    """
    Writes scan data to a CSV file. This function is designed to write raw frequency
    and amplitude data collected from the spectrum analyzer. It handles creating
    the necessary directory structure if it doesn't exist and conditionally writes
    the header.

    Inputs:
        file_path (str): The full path to the CSV file where the data will be written.
        header (list or None): A list of strings representing the CSV header row.
                               If None, no header will be written.
        data (list): A list of lists or tuples, where each inner list/tuple represents
                     a row of data (e.g., [frequency_mhz, level_dbm]).
        app_instance_ref (object): A reference to the main application instance.
        append_mode (bool): If True, data will be appended to the file if it exists.
                            If False, the file will be overwritten.
        console_print_func (function, optional): Function to use for console output.
                                                  Defaults to console_log if None.
    Raises:
        IOError: If there is an issue writing to the file.
    """
    console_print_func = console_print_func if console_print_func else console_log # Use console_log as default
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Attempting to write scan data to CSV: {file_path}, append_mode={append_mode}. Let's save this data!",
                file=__file__,
                version=current_version,
                function=current_function)

    # Ensure the directory exists
    output_dir = os.path.dirname(file_path)
    if output_dir and not os.path.exists(output_dir):
        try:
            os.makedirs(output_dir)
            debug_log(f"Created directory: {output_dir}. Path cleared!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        except OSError as e:
            error_msg = f"❌ Error creating directory '{output_dir}': {e}. This is a disaster!"
            # WRAPPED WITH after() to prevent cross-thread access
            app_instance_ref.after(0, lambda: console_print_func(error_msg))
            debug_log(error_msg,
                        file=__file__,
                        version=current_version,
                        function=current_function)
            raise IOError(f"Failed to create directory {output_dir}") from e

    try:
        # Determine the mode and if header needs to be written
        file_exists = os.path.exists(file_path)
        
        # If not in append_mode, or if in append_mode but file doesn't exist, open in write mode.
        # Otherwise, open in append mode.
        mode = 'a' if append_mode and file_exists else 'w'
        
        # Flag to indicate if header needs to be written
        # Write header ONLY if header is not None and we are creating a new file or overwriting
        write_header = (header is not None) and (mode == 'w')

        with open(file_path, mode, newline='') as csv_file:
            csv_writer = csv.writer(csv_file)
            
            if write_header:
                csv_writer.writerow(header)
                debug_log(f"Wrote header to CSV file: {file_path}. Header added!",
                            file=__file__,
                            version=current_version,
                            function=current_function)
            
            # Write data rows
            for freq_mhz, level_dbm in data:
                csv_writer.writerow([f"{freq_mhz:.3f}", f"{level_dbm:.3f}"])
        # WRAPPED WITH after() to prevent cross-thread access
        app_instance_ref.after(0, lambda: console_print_func(f"✅ Scan data written to CSV: {file_path}. Data saved!"))
        debug_log(f"Scan data written to CSV: {file_path}. Mission accomplished!",
                    file=__file__,
                    version=current_version,
                    function=current_function)
    except IOError as e:
        error_msg = f"❌ I/O Error writing to CSV file {file_path}: {e}. This is a disaster!"
        # WRAPPED WITH after() to prevent cross-thread access
        app_instance_ref.after(0, lambda: console_print_func(error_msg))
        debug_log(error_msg,
                    file=__file__,
                    version=current_version,
                    function=current_function)
        raise # Re-raise to allow higher-level error handling
    except Exception as e:
        error_msg = f"❌ An unexpected error occurred while writing to CSV file {file_path}: {e}. What a mess!"
        # WRAPPED WITH after() to prevent cross-thread access
        app_instance_ref.after(0, lambda: console_print_func(error_msg))
        debug_log(error_msg,
                    file=__file__,
                    version=current_version,
                    function=current_function)
        raise # Re-raise to allow higher-level error handling


#####################################
### File: OPEN-AIR\variables\vars_app_and_debug.py
#####################################
# variables/vars_app_and_debug.py
#
# This module defines and initializes Tkinter variables for application-wide
# settings, including window state and debug controls.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.220500.1
# NEW: Created a new file to house application-wide and debugging variables.

import tkinter as tk
import inspect
import os
from datetime import datetime
from display.debug_logic import debug_log
from ref.ref_program_default_values import DEFAULT_CONFIG

# --- Version Information ---
current_version = "20250821.220500.1"
current_version_hash = (20250821 * 220500 * 1)
current_file = f"{os.path.basename(__file__)}"

def setup_app_and_debug_vars(app_instance):
    """
    Initializes application and debugging-related Tkinter variables.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"⚙️ 🟢 Entering {current_function} to set up application and debug variables.",
                file=current_file,
                version=current_version,
                function=current_function)

    # --- Application Variables ---
    app_instance.is_connected = tk.BooleanVar(app_instance, value=False)
    app_instance.is_running = tk.BooleanVar(app_instance, value=False)
    app_instance.last_config_save_time_var = tk.StringVar(app_instance, value="")
    app_instance.geometry_string = DEFAULT_CONFIG['Application']['geometry']
    app_instance.window_state_string = DEFAULT_CONFIG['Application']['window_state']
    app_instance.paned_window_sash_position_percentage_var = tk.StringVar(app_instance, value=DEFAULT_CONFIG['Application']['paned_window_sash_position_percentage'])
    app_instance.last_config_save_time_var.set(DEFAULT_CONFIG['Application']['last_config_save_time'])
    
    # --- Debugging Variables ---
    app_instance.general_debug_enabled_var = tk.BooleanVar(app_instance, value=DEFAULT_CONFIG['Debug']['general_debug_enabled'] == 'True')
    app_instance.debug_to_gui_console_var = tk.BooleanVar(app_instance, value=DEFAULT_CONFIG['Debug']['debug_to_gui_console'] == 'True')
    app_instance.debug_to_terminal_var = tk.BooleanVar(app_instance, value=DEFAULT_CONFIG['Debug']['debug_to_terminal'] == 'True')
    app_instance.debug_to_file_var = tk.BooleanVar(app_instance, value=DEFAULT_CONFIG['Debug']['debug_to_file'] == 'True')
    app_instance.include_console_messages_to_debug_file_var = tk.BooleanVar(app_instance, value=DEFAULT_CONFIG['Debug']['include_console_messages_to_debug_file'] == 'True')
    app_instance.log_visa_commands_enabled_var = tk.BooleanVar(app_instance, value=DEFAULT_CONFIG['Debug']['log_visa_commands_enabled'] == 'True')
    app_instance.log_truncation_enabled_var = tk.BooleanVar(app_instance, value=DEFAULT_CONFIG['Debug']['log_truncation_enabled'] == 'True')
    app_instance.include_visa_messages_to_debug_file_var = tk.BooleanVar(app_instance, value=DEFAULT_CONFIG['Debug']['include_visa_messages_to_debug_file'] == 'True')
    
    debug_log(f"⚙️ ✅ Exiting {current_function}",
                file=current_file,
                version=current_version,
                function=current_function)

#####################################
### File: OPEN-AIR\variables\vars_instrument.py
#####################################
# variables/vars_instrument.py
#
# This module defines and initializes Tkinter variables for instrument and
# instrument-settings configurations.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.220500.1
# NEW: Created a new file to house instrument variables.

import tkinter as tk
import inspect
import os
from display.debug_logic import debug_log
from ref.ref_program_default_values import DEFAULT_CONFIG
from ref.ref_frequency_bands import MHZ_TO_HZ

# --- Version Information ---
current_version = "20250821.220500.1"
current_version_hash = (20250821 * 220500 * 1)
current_file = f"{os.path.basename(__file__)}"

def setup_instrument_vars(app_instance):
    """
    Initializes all the Tkinter variables for the Instrument tab.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"⚙️ 🟢 Entering {current_function} to set up instrument variables. 🎸",
                file=current_file,
                version=current_version,
                function=current_function)

    # --- Instrument Variables ---
    app_instance.connected_instrument_manufacturer = tk.StringVar(app_instance, value="N/A")
    app_instance.connected_instrument_model = tk.StringVar(app_instance, value="N/A")
    app_instance.connected_instrument_serial = tk.StringVar(app_instance, value="N/A")
    app_instance.connected_instrument_version = tk.StringVar(app_instance, value="N/A")
    app_instance.instrument_visa_resource_var = tk.StringVar(app_instance, value=DEFAULT_CONFIG['Instrument']['visa_resource'])
    app_instance.center_freq_mhz_var = tk.DoubleVar(app_instance, value=float(DEFAULT_CONFIG['InstrumentSettings']['center_freq_mhz']))
    app_instance.span_freq_mhz_var = tk.DoubleVar(app_instance, value=float(DEFAULT_CONFIG['InstrumentSettings']['span_freq_mhz']))
    app_instance.start_freq_mhz_var = tk.DoubleVar(app_instance, value=float(DEFAULT_CONFIG['InstrumentSettings']['start_freq_mhz']))
    app_instance.stop_freq_mhz_var = tk.DoubleVar(app_instance, value=float(DEFAULT_CONFIG['InstrumentSettings']['stop_freq_mhz']))
    app_instance.rbw_mhz_var = tk.DoubleVar(app_instance, value=float(DEFAULT_CONFIG['InstrumentSettings']['rbw_mhz']))
    app_instance.vbw_mhz_var = tk.DoubleVar(app_instance, value=float(DEFAULT_CONFIG['InstrumentSettings']['vbw_mhz']))
    app_instance.vbw_auto_on_var = tk.BooleanVar(app_instance, value=DEFAULT_CONFIG['InstrumentSettings']['vbw_auto_on'] == 'True')
    app_instance.initiate_continuous_on_var = tk.BooleanVar(app_instance, value=DEFAULT_CONFIG['InstrumentSettings']['initiate_continuous_on'] == 'True')
    app_instance.ref_level_dbm_var = tk.DoubleVar(app_instance, value=float(DEFAULT_CONFIG['InstrumentSettings']['ref_level_dbm']))
    app_instance.preamp_on_var = tk.BooleanVar(app_instance, value=DEFAULT_CONFIG['InstrumentSettings']['preamp_on'] == 'True')
    app_instance.power_attenuation_db_var = tk.DoubleVar(app_instance, value=float(DEFAULT_CONFIG['InstrumentSettings']['power_attenuation_db']))
    app_instance.high_sensitivity_on_var = tk.BooleanVar(app_instance, value=DEFAULT_CONFIG['InstrumentSettings']['high_sensitivity_on'] == 'True')

    debug_log(f"⚙️ ✅ Exiting {current_function}",
                file=current_file,
                version=current_version,
                function=current_function)

#####################################
### File: OPEN-AIR\variables\vars_marker_tab.py
#####################################
# variables/vars_marker_tab.py
#
# This module defines and initializes Tkinter variables for the Marker tab,
# including state variables for selections, displays, and controls.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.220500.1
# NEW: Created a new file to house Marker tab variables.

import tkinter as tk
import inspect
import os
from display.debug_logic import debug_log
from ref.ref_program_default_values import DEFAULT_CONFIG

# --- Version Information ---
current_version = "20250821.220500.1"
current_version_hash = (20250821 * 220500 * 1)
current_file = f"{os.path.basename(__file__)}"

def setup_marker_tab_vars(app_instance):
    """
    Initializes all the Tkinter variables for the Marker tab.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"⚙️ 🟢 Entering {current_function} to set up Marker tab variables. 🗺️",
                file=current_file,
                version=current_version,
                function=current_function)

    # --- Marker Tab Variables ---
    app_instance.span_var = tk.StringVar(app_instance, value=DEFAULT_CONFIG['MarkerTab']['span_hz'])
    app_instance.rbw_var = tk.StringVar(app_instance, value=DEFAULT_CONFIG['MarkerTab']['rbw_hz'])
    app_instance.buffer_var = tk.StringVar(app_instance, value=DEFAULT_CONFIG['MarkerTab']['buffer_mhz'])
    app_instance.poke_freq_var = tk.DoubleVar(app_instance, value=float(DEFAULT_CONFIG['MarkerTab']['poke_freq_mhz']))
    app_instance.trace_modes = {
        'live': tk.BooleanVar(app_instance, value=DEFAULT_CONFIG['MarkerTab']['trace_live'] == 'True'),
        'max': tk.BooleanVar(app_instance, value=DEFAULT_CONFIG['MarkerTab']['trace_max_hold'] == 'True'),
        'min': tk.BooleanVar(app_instance, value=DEFAULT_CONFIG['MarkerTab']['trace_min_hold'] == 'True'),
    }
    app_instance.buffered_start_var = tk.DoubleVar(app_instance, value=float(DEFAULT_CONFIG['MarkerTab']['buffered_start_var']))
    app_instance.buffered_stop_var = tk.DoubleVar(app_instance, value=float(DEFAULT_CONFIG['MarkerTab']['buffered_stop_var']))
    
    app_instance.selected_zone = None
    app_instance.selected_zone_info = {}
    app_instance.selected_group = None
    app_instance.selected_group_info = {}
    app_instance.selected_device_info = None
    app_instance.last_selected_type = None

    app_instance.zone_zoom_label_left_var = tk.StringVar(app_instance, value="")
    app_instance.zone_zoom_label_center_var = tk.StringVar(app_instance, value="N/A")
    app_instance.zone_zoom_label_right_var = tk.StringVar(app_instance, value="")
    
    debug_log(f"⚙️ ✅ Exiting {current_function}",
                file=current_file,
                version=current_version,
                function=current_function)

#####################################
### File: OPEN-AIR\variables\vars_plotting.py
#####################################
# variables/vars_plotting.py
#
# This module defines and initializes Tkinter variables for plotting-related
# settings and configurations.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.220500.1
# NEW: Created a new file to house plotting variables.

import tkinter as tk
import inspect
import os
from display.debug_logic import debug_log
from ref.ref_program_default_values import DEFAULT_CONFIG

# --- Version Information ---
current_version = "20250821.220500.1"
current_version_hash = (20250821 * 220500 * 1)
current_file = f"{os.path.basename(__file__)}"

def setup_plotting_vars(app_instance):
    """
    Initializes all the Tkinter variables for plotting settings.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"⚙️ 🟢 Entering {current_function} to set up plotting variables. 📈",
                file=current_file,
                version=current_version,
                function=current_function)

    # --- Plotting Variables ---
    app_instance.current_style_theme_var = tk.StringVar(app_instance, value=DEFAULT_CONFIG['Plotting']['current_style_theme'])
    app_instance.plot_grid_on_var = tk.BooleanVar(app_instance, value=DEFAULT_CONFIG['Plotting']['plot_grid_on'] == 'True')
    app_instance.plot_grid_alpha_var = tk.DoubleVar(app_instance, value=float(DEFAULT_CONFIG['Plotting']['plot_grid_alpha']))
    app_instance.plot_grid_color_var = tk.StringVar(app_instance, value=DEFAULT_CONFIG['Plotting']['plot_grid_color'])
    
    debug_log(f"⚙️ ✅ Exiting {current_function}",
                version=current_version,
                function=current_function)

#####################################
### File: OPEN-AIR\variables\vars_report_meta.py
#####################################
# variables/vars_report_meta.py
#
# This module defines and initializes Tkinter variables for scan report metadata,
# including operator, venue, and location details.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.220500.1
# NEW: Created a new file to house report and metadata variables.

import tkinter as tk
import inspect
import os
from display.debug_logic import debug_log
from ref.ref_program_default_values import DEFAULT_CONFIG

# --- Version Information ---
current_version = "20250821.220500.1"
current_version_hash = (20250821 * 220500 * 1)
current_file = f"{os.path.basename(__file__)}"

def setup_report_meta_vars(app_instance):
    """
    Initializes all the Tkinter variables for scan report metadata.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"⚙️ 🟢 Entering {current_function} to set up report meta variables. 📝",
                file=current_file,
                version=current_version,
                function=current_function)

    # --- Report Variables ---
    app_instance.operator_name_var = tk.StringVar(app_instance, value=DEFAULT_CONFIG['Report']['operator_name'])
    app_instance.operator_contact_var = tk.StringVar(app_instance, value=DEFAULT_CONFIG['Report']['operator_contact'])
    app_instance.venue_name_var = tk.StringVar(app_instance, value=DEFAULT_CONFIG['Report']['venue_name'])
    app_instance.address_field_var = tk.StringVar(app_instance, value=DEFAULT_CONFIG['Report']['address_field'])
    app_instance.city_var = tk.StringVar(app_instance, value=DEFAULT_CONFIG['Report']['city'])
    app_instance.province_var = tk.StringVar(app_instance, value=DEFAULT_CONFIG['Report']['province'])
    app_instance.venue_postal_code_var = tk.StringVar(app_instance, value=DEFAULT_CONFIG['Report']['venue_postal_code'])
    app_instance.notes_var = tk.StringVar(app_instance, value=DEFAULT_CONFIG['Report']['notes'])
    app_instance.scanner_type_var = tk.StringVar(app_instance, value=DEFAULT_CONFIG['Report']['scanner_type'])
    
    # --- Antenna Variables ---
    app_instance.selected_antenna_type_var = tk.StringVar(app_instance, value=DEFAULT_CONFIG['Antenna']['selected_antenna_type'])
    app_instance.antenna_description_var = tk.StringVar(app_instance, value=DEFAULT_CONFIG['Antenna']['antenna_description'])
    app_instance.antenna_use_var = tk.StringVar(app_instance, value=DEFAULT_CONFIG['Antenna']['antenna_use'])
    app_instance.antenna_mount_var = tk.StringVar(app_instance, value=DEFAULT_CONFIG['Antenna']['antenna_mount'])
    app_instance.antenna_amplifier_var = tk.StringVar(app_instance, value=DEFAULT_CONFIG['Antenna']['antenna_amplifier'])

    # --- Amplifier Variables ---
    app_instance.selected_amplifier_type_var = tk.StringVar(app_instance, value=DEFAULT_CONFIG['Amplifier']['selected_amplifier_type'])
    app_instance.amplifier_description_var = tk.StringVar(app_instance, value=DEFAULT_CONFIG['Amplifier']['amplifier_description'])
    app_instance.amplifier_use_var = tk.StringVar(app_instance, value=DEFAULT_CONFIG['Amplifier']['amplifier_use'])
    
    debug_log(f"⚙️ ✅ Exiting {current_function}",
                file=current_file,
                version=current_version,
                function=current_function)

#####################################
### File: OPEN-AIR\variables\vars_scan_config.py
#####################################
# variables/vars_scan_config.py
#
# This module defines and initializes Tkinter variables for scan-related
# settings and configurations.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.220500.1
# NEW: Created a new file to house scan configuration variables.

import tkinter as tk
import inspect
import os
from display.debug_logic import debug_log
from ref.ref_program_default_values import DEFAULT_CONFIG
from ref.ref_frequency_bands import SCAN_BAND_RANGES

# --- Version Information ---
current_version = "20250821.220500.1"
current_version_hash = (20250821 * 220500 * 1)
current_file = f"{os.path.basename(__file__)}"


def setup_scan_config_vars(app_instance):
    """
    Initializes all the Tkinter variables for scan configuration settings.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"⚙️ 🟢 Entering {current_function} to set up scan configuration variables. ⚡",
                file=current_file,
                version=current_version,
                function=current_function)

    # --- Scan Configuration Variables ---
    app_instance.scan_name_var = tk.StringVar(app_instance, value=DEFAULT_CONFIG['Scan']['scan_name'])
    app_instance.output_folder_var = tk.StringVar(app_instance, value=DEFAULT_CONFIG['Scan']['output_folder'])
    app_instance.rbw_step_size_var = tk.DoubleVar(app_instance, value=float(DEFAULT_CONFIG['Scan']['rbw_step_size_hz']))
    app_instance.num_scan_cycles_var = tk.IntVar(app_instance, value=int(DEFAULT_CONFIG['Scan']['num_scan_cycles']))
    app_instance.cycle_wait_time_seconds_var = tk.DoubleVar(app_instance, value=float(DEFAULT_CONFIG['Scan']['cycle_wait_time_seconds']))
    app_instance.maxhold_enabled_var = tk.BooleanVar(app_instance, value=DEFAULT_CONFIG['Scan']['maxhold_enabled'] == 'True')
    app_instance.maxhold_time_seconds_var = tk.DoubleVar(app_instance, value=float(DEFAULT_CONFIG['Scan']['maxhold_time_seconds']))
    app_instance.desired_default_focus_width_var = tk.DoubleVar(app_instance, value=float(DEFAULT_CONFIG['Scan']['desired_default_focus_width']))
    app_instance.create_html_report_var = tk.BooleanVar(app_instance, value=DEFAULT_CONFIG['Scan']['create_html'] == 'True')
    app_instance.open_html_after_complete_var = tk.BooleanVar(app_instance, value=DEFAULT_CONFIG['Scan']['open_html_after_complete'] == 'True')
    app_instance.include_markers_var = tk.BooleanVar(app_instance, value=DEFAULT_CONFIG['Scan']['include_markers'] == 'True')
    app_instance.include_gov_markers_var = tk.BooleanVar(app_instance, value=DEFAULT_CONFIG['Scan']['include_gov_markers'] == 'True')
    app_instance.include_tv_markers_var = tk.BooleanVar(app_instance, value=DEFAULT_CONFIG['Scan']['include_tv_markers'] == 'True')
    app_instance.include_scan_intermod_markers_var = tk.BooleanVar(app_instance, value=DEFAULT_CONFIG['Scan']['include_scan_intermod_markers'] == 'True')
    app_instance.math_average_var = tk.BooleanVar(app_instance, value=DEFAULT_CONFIG['Scan']['math_average'] == 'True')
    app_instance.math_median_var = tk.BooleanVar(app_instance, value=DEFAULT_CONFIG['Scan']['math_median'] == 'True')
    app_instance.math_variance_var = tk.BooleanVar(app_instance, value=DEFAULT_CONFIG['Scan']['math_variance'] == 'True')
    app_instance.math_standard_deviation_var = tk.BooleanVar(app_instance, value=DEFAULT_CONFIG['Scan']['math_standard_deviation'] == 'True')
    app_instance.math_range_var = tk.BooleanVar(app_instance, value=DEFAULT_CONFIG['Scan']['math_range'] == 'True')
    app_instance.math_psd_var = tk.BooleanVar(app_instance, value=DEFAULT_CONFIG['Scan']['math_psd'] == 'True')

    debug_log(f"⚙️ ✅ Exiting {current_function}",
                file=current_file,
                version=current_version,
                function=current_function)

#####################################
### File: OPEN-AIR\yak\Yakety_Yak.py
#####################################
# tabs/Instrument/Yakety_Yak.py
#
# This file provides a high-level interface for executing VISA commands
# by a user-defined type, model, and manufacturer. It acts as a wrapper
# for the low-level `execute_visa_command` function, ensuring the correct
# command is sent based on the provided parameters. It also manages the
# loading of the `visa_commands.csv` file.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.210502.1
# FIXED: The YakNab function now returns the raw response string without parsing it, as this should be handled by the specific handler function that knows the data structure.
# UPDATED: All debug messages now include the required 🐐 emoji at the start.

import csv
import os
import inspect
import pyvisa
import time
from tkinter import messagebox
from display.debug_logic import debug_log, log_visa_command
from display.console_logic import console_log
from ref.ref_file_paths import VISA_COMMANDS_FILE_PATH

# FIXED: Import the low-level read/write functions from the correct location
from yak.utils_yak_visa import write_safe, query_safe

# --- User-configurable variables ---
VISA_COMMAND_DELAY_SECONDS = 0.05
MAX_RETRY_ATTEMPTS = 3

# Global variable to store loaded commands to avoid re-reading the file
_visa_commands_data = []
_last_file_modification_time = 0

# --- Versioning ---
w = 20250821
x_str = '210502'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"


def _load_commands_from_file(file_path):
    # Function Description:
    # Loads or reloads the VISA commands from the specified CSV file.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 Entering {current_function}. File: {file_path}",
                file=current_file,
                version=current_version,
                function=current_function)

    global _visa_commands_data, _last_file_modification_time

    try:
        if not os.path.exists(file_path):
            debug_log(f"🐐 ❌ File not found: {file_path}. Aborting load. �",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return False

        current_mod_time = os.path.getmtime(file_path)
        if current_mod_time <= _last_file_modification_time:
            debug_log(f"🐐 😴 File '{file_path}' has not been modified since last load. Skipping. 😴",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return True

        with open(file_path, 'r', newline='', encoding='utf-8') as f:
            reader = csv.reader(f)
            header = next(reader)
            _visa_commands_data = [row for row in reader]

        _last_file_modification_time = current_mod_time
        debug_log(f"🐐 ✅ Successfully loaded {len(_visa_commands_data)} commands from file. 🎉",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return True

    except Exception as e:
        debug_log(f"🐐 💥 Error loading commands from file: {e}. This is a goddamn mess! 💥",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        _visa_commands_data = []
        return False

def _find_command(command_type, action_type, model):
    # Function Description:
    # Finds the correct VISA command from the loaded data based on the command type,
    # action type, and instrument model.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🔍 Searching for command. Type: '{command_type}', Action: '{action_type}', Model: '{model}'. Let's find it! 🕵️‍♀️",
                file=current_file,
                version=current_version,
                function=current_function)

    upper_command_type = command_type.upper()
    upper_action_type = action_type.upper()
    upper_model = model.upper()
    
    if not _visa_commands_data:
        debug_log("🐐 ❌ No command data loaded. What a disaster!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return None, None, None

    for row in _visa_commands_data:
        if row[2].upper() == upper_command_type and row[3].upper() == upper_action_type and row[1].upper() == upper_model:
            debug_log(f"🐐 ✅ Found an exact match! Command: '{upper_command_type}', Action: '{upper_action_type}', Model: '{upper_model}'. This is fucking brilliant! ✅",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return row[3], row[4], row[5]

    for row in _visa_commands_data:
        if row[2].upper() == upper_command_type and row[3].upper() == upper_action_type and row[1] == '*':
            debug_log(f"🐐 🔎 Found a wildcard match! Command: '{upper_command_type}', Action: '{upper_action_type}', Model: '*'. Not perfect, but it'll do. 😉",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return row[3], row[4], row[5]

    debug_log(f"🐐 ❌ No matching command found for Type: '{upper_command_type}', Action: '{upper_action_type}', Model: '{upper_model}'. This is a fucking waste of time! 🤯",
                file=current_file,
                version=current_version,
                function=current_function)
    return None, None, None

def YakRig(app_instance, command_type, console_print_func, *variable_values):
    """
    Function Description:
    Executes a 'RIG' VISA command by combining a template command string
    with up to 8 provided variable values. This is designed for single-line
    configuration commands that set multiple parameters at once.

    Inputs:
    - app_instance (object): A reference to the main application instance.
    - command_type (str): The name of the 'RIG' command from the CSV (e.g., "MARKER/PLACE/ALL").
    - console_print_func (function): A function to print messages to the GUI console.
    - variable_values (str...): Up to 8 values to be substituted into the command template.
                                These will replace the placeholders 111, 222, etc.

    Outputs:
    - "PASSED" if the command is executed successfully, "FAILED" otherwise.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🟢 Entering YakRig. command_type: {command_type}, variable_values: {variable_values}",
                file=current_file,
                version=current_version,
                function=current_function)

    _load_commands_from_file(app_instance.VISA_COMMANDS_FILE_PATH)
    
    model = app_instance.connected_instrument_model.get()
    
    action, command_template, _ = _find_command(command_type, "RIG", model)

    if action == "RIG" and command_template:
        full_command = command_template
        placeholders = ["111", "222", "333", "444", "555", "666", "777", "888"]
        
        # Replace placeholders with provided values
        for i, value in enumerate(variable_values):
            if i < len(placeholders):
                full_command = full_command.replace(placeholders[i], str(value))
        
        console_log(f"💬 Rigging command: {full_command}")
        debug_log(f"🐐 📝 Rigged command string: {full_command}",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        if write_safe(app_instance.inst, full_command, console_print_func):
            console_print_func("✅ Rig command executed successfully.")
            debug_log("🐐 ✅ Rig command executed successfully.",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return "PASSED"
        else:
            console_print_func("❌ Rig command execution failed.")
            debug_log("🐐 ❌ Rig command execution failed. What the hell went wrong?!",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return "FAILED"
    else:
        console_log(f"❌ Could not find a matching RIG command for '{command_type}'.")
        debug_log(f"🐐 🚫 No matching RIG command found for '{command_type}'. Fucking useless!",
                   file=current_file,
                    version=current_version,
                    function=current_function)
        return "FAILED"

def YakBeg(app_instance, command_type, console_print_func, *variable_values):
    """
    Function Description:
    Executes a 'BEG' (Beg) VISA command by combining a SET command with a GET query.
    This is an atomic action designed for configuring a setting and immediately
    verifying its value from the instrument.

    Inputs:
    - app_instance (object): A reference to the main application instance.
    - command_type (str): The name of the 'BEG' command from the CSV.
    - console_print_func (function): A function to print messages to the GUI console.
    - variable_values (str...): Up to 8 values to be substituted into the command template.
                                These will replace the placeholders 111, 222, etc.

    Outputs:
    - The response string from the GET command if successful, or "FAILED" otherwise.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🟢 Entering YakBeg. command_type: {command_type}, variable_values: {variable_values}",
                file=current_file,
                version=current_version,
                function=current_function)
    
    _load_commands_from_file(app_instance.VISA_COMMANDS_FILE_PATH)
    
    model = app_instance.connected_instrument_model.get()
    
    action, command_template, _ = _find_command(command_type, "BEG", model)

    if action == "BEG" and command_template:
        full_command = command_template
        placeholders = ["111", "222", "333", "444", "555", "666", "777", "888"]
        
        # Replace placeholders with provided values
        for i, value in enumerate(variable_values):
            if i < len(placeholders):
                full_command = full_command.replace(placeholders[i], str(value))

        console_log(f"💬 Begging for a response with command: {full_command}")
        debug_log(f"🐐 📝 Beg command string: {full_command}",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        # The BEG command is a single string with both set and get queries.
        # We use query_safe to send the entire string and get the response.
        response = query_safe(app_instance.inst, full_command, console_print_func)
    
        if response is not None:
            console_print_func(f"✅ Beg Response: {response}")
            debug_log(f"🐐 ✅ Beg query response: {response}. Fucking finally!",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return response
        else:
            console_print_func("❌ No response received or query failed.")
            debug_log("🐐 ❌ Beg query failed or no response. What the hell happened?!",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return "FAILED"
    else:
        console_log(f"❌ Could not find a matching BEG command for '{command_type}'.")
        debug_log(f"🐐 🚫 No matching BEG command found for '{command_type}'. Fucking useless!",
                   file=current_file,
                    version=current_version,
                    function=current_function)
        return "FAILED"

def YakGet(app_instance, command_type, console_print_func):
    # Function Description:
    # Executes a 'GET' or a new 'NAB' VISA command for a given command type.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🟢 Entering YakGet. command_type: {command_type}",
                file=current_file,
                version=current_version,
                function=current_function)
    
    _load_commands_from_file(VISA_COMMANDS_FILE_PATH)
    
    manufacturer = app_instance.connected_instrument_manufacturer.get()
    model = app_instance.connected_instrument_model.get()
    
    action, command, variable = _find_command(command_type, "GET", model)
    if not action:
        action, command, variable = _find_command(command_type, "NAB", model)
    
    if action and command:
        return execute_visa_command(app_instance, action, command, variable, console_print_func)
    else:
        console_print_func(f"❌ Could not find a matching GET or NAB command for '{command_type}'.")
        debug_log(f"🐐 🚫 No matching GET or NAB command found for '{command_type}'. Fucking useless!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return "FAILED"
  
def YakNab(app_instance, command_type, console_print_func):
    """
    Function Description:
    Executes a 'NAB' (multi-query) VISA command for a given command type.
    
    Inputs:
    - app_instance (object): A reference to the main application instance.
    - command_type (str): The name of the 'NAB' command from the CSV.
    - console_print_func (function): A function to print messages to the GUI console.
    
    Outputs:
    - The response string from the GET command if successful, or a list of parsed strings otherwise.
      "FAILED" on failure.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🟢 Entering YakNab. command_type: {command_type}",
                file=current_file,
                version=current_version,
                function=current_function)

    _load_commands_from_file(app_instance.VISA_COMMANDS_FILE_PATH)
    
    manufacturer = app_instance.connected_instrument_manufacturer.get()
    model = app_instance.connected_instrument_model.get()

    action, command, num_reads_str = _find_command(command_type, "NAB", model)

    if action == "NAB" and command:
        try:
            response_string = query_safe(app_instance.inst, command, console_print_func)
        except (ValueError, IndexError):
            console_print_func("❌ NAB command variable for num_reads is not a valid integer.")
            debug_log("🐐 🤷‍♀️ NAB command variable for num_reads is not a valid integer. Defaulting to 1. 🤷‍♀️",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            response_string = query_safe(app_instance.inst, command, console_print_func)
        
        if response_string is not None:
            values = [val.strip() for val in response_string.split(';') if val.strip()]
            console_print_func(f"✅ NAB Response: {values}")
            debug_log(f"🐐 ✅ NAB Query response: {response_string}. Fucking finally!",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return values
        else:
            return "FAILED"
    else:
        console_print_func(f"❌ Could not find a matching NAB command for '{command_type}'.")
        debug_log(f"🐐 🚫 No matching NAB command found for '{command_type}'. Fucking useless!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return "FAILED"


def YakSet(app_instance, command_type, variable_value, console_print_func):
    # Function Description:
    # Executes a 'SET' VISA command with a specific value.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🟢 Entering YakSet. command_type: {command_type}, variable_value: {variable_value}",
                file=current_file,
                version=current_version,
                function=current_function)

    _load_commands_from_file(app_instance.VISA_COMMANDS_FILE_PATH)
    
    manufacturer = app_instance.connected_instrument_manufacturer.get()
    model = app_instance.connected_instrument_model.get()
    
    action, command, _ = _find_command(command_type, "SET", model)
    
    if action == "SET" and command:
        return execute_visa_command(app_instance, action, command, variable_value, console_print_func)
    else:
        console_print_func(f"❌ Could not find a matching SET command for '{command_type}'.")
        debug_log(f"🐐 🚫 No matching SET command found for '{command_type}'. Fucking useless!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return "FAILED"

def YakDo(app_instance, command_type, console_print_func):
    # Function Description:
    # Executes a 'DO' VISA command.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🟢 Entering YakDo. command_type: {command_type}",
                file=current_file,
                version=current_version,
                function=current_function)

    _load_commands_from_file(VISA_COMMANDS_FILE_PATH)
    
    manufacturer = app_instance.connected_instrument_manufacturer.get()
    model = app_instance.connected_instrument_model.get()
    
    action, command, variable = _find_command(command_type, "DO", model)
    
    if action == "DO" and command:
        return execute_visa_command(app_instance, action, command, variable, console_print_func)
    else:
        console_print_func(f"❌ Could not find a matching DO command for '{command_type}'.")
        debug_log(f"🐐 🚫 No matching DO command found for '{command_type}'. Fucking useless!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return "FAILED"

def execute_visa_command(app_instance, action_type, visa_command, variable_value, console_print_func, num_reads=1):
    # Function Description:
    # Executes a given VISA command based on its action type and variable value.
    current_function = inspect.currentframe().f_code.co_name
    inst = app_instance.inst

    if not inst:
        console_print_func("❌ No instrument connected. Cannot execute VISA command.")
        debug_log("🐐 ❌ No instrument connected for execute_visa_command. Fucking useless!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return "FAILED"

    try:
        if action_type == "GET":
            full_command = f"{visa_command}{variable_value}" if variable_value and variable_value.strip() == "?" else visa_command
            debug_log(f"🐐 📝 Prepared command string for GET: {full_command}",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            response = query_safe(inst, full_command, console_print_func)
            if response is not None:
                console_print_func(f"✅ Response: {response}")
                debug_log(f"🐐 ✅ Query response: {response}. Finally!",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return response
            else:
                console_print_func("❌ No response received or query failed.")
                debug_log("🐐 ❌ Query failed or no response. What the hell happened?!",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return "FAILED"
        elif action_type == "NAB":
            full_command = visa_command
            
            response_string = query_safe(inst, full_command, console_print_func)
            
            if response_string is not None:
                values = [val.strip() for val in response_string.split(';') if val.strip()]
                console_print_func(f"✅ NAB Response: {values}")
                debug_log(f"🐐 ✅ NAB Query response: {response_string}. Fucking finally!",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return values
            else:
                return "FAILED"

        elif action_type == "DO":
            if variable_value and variable_value.strip():
                full_command = f"{visa_command} {variable_value}"
            else:
                full_command = visa_command
            
            debug_log(f"🐐 📝 Prepared command string for DO: {full_command}",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            if write_safe(inst, full_command, console_print_func):
                console_print_func("✅ Command executed successfully.")
                debug_log("🐐 ✅ Command executed successfully.",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return "PASSED"
            else:
                console_print_func("❌ Command execution failed.")
                debug_log("🐐 ❌ DO command execution failed. What the hell went wrong?!",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return "FAILED"
        elif action_type == "SET":
            try:
                float_value = float(variable_value)
                int_value = int(float_value)
                if float_value == int_value:
                    full_command = f"{visa_command} {int_value}"
                else:
                    full_command = f"{visa_command} {float_value}"
            except (ValueError, TypeError):
                full_command = f"{visa_command} {variable_value}"
            
            debug_log(f"🐐 📝 Prepared command string for SET: {full_command}",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            if write_safe(inst, full_command, console_print_func):
                console_print_func("✅ Command executed successfully.")
                debug_log("🐐 ✅ Command executed successfully.",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return "PASSED"
            else:
                console_print_func("❌ Command execution failed.")
                debug_log("🐐 ❌ SET command execution failed. What the hell went wrong?!",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return "FAILED"
        elif action_type == "RIG":
            full_command = visa_command
            
            debug_log(f"🐐 📝 Prepared command string for RIG: {full_command}",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            if write_safe(inst, full_command, console_print_func):
                console_print_func("✅ Rig command executed successfully.")
                debug_log("🐐 ✅ Rig command executed successfully.",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return "PASSED"
            else:
                console_print_func("❌ Rig command execution failed.")
                debug_log("🐐 ❌ Rig command execution failed. What the hell went wrong?!",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return "FAILED"
        elif action_type == "BEG":
            full_command = visa_command
            debug_log(f"🐐 📝 Prepared command string for BEG: {full_command}",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            response_string = query_safe(inst, visa_command, console_print_func)
            if response_string is not None:
                return response_string
            else:
                return "FAILED"
        else:
            console_print_func(f"⚠️ Unknown action type '{action_type}'. Cannot execute command.")
            debug_log(f"🐐 ❌ Unknown action type '{action_type}' for command: {visa_command}. This is a goddamn mess!",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return "FAILED"
    except Exception as e:
        console_print_func(f"❌ Error during VISA command execution: {e}")
        debug_log(f"🐐 🧨 Error executing VISA command '{visa_command}': {e}. This thing is a pain in the ass!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return "FAILED"


#####################################
### File: OPEN-AIR\yak\utils_yak_setting_handler.py
#####################################
# yak/utils_yak_setting_handler.py
#
# This file provides a high-level interface for executing and managing all VISA commands.
# It acts as a central handler, exposing public API functions for the GUI to use,
# and internally calling the low-level Yak functions to communicate with the instrument.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.210502.1
# FIXED: Removed incorrect MHz-to-Hz conversion from set_resolution_bandwidth and set_video_bandwidth functions.
# UPDATED: Corrected debug log messages to accurately reflect the units being processed.
# NEW: Added a new handler function to toggle trace averaging on a per-trace basis.
# UPDATED: All debug messages now include the required 🐐 emoji at the start.

import os
import inspect
import numpy as np
import threading
import time

from display.debug_logic import debug_log
from display.console_logic import console_log

# NEW: Import the Yak functions from Yakety_Yak.py
from yak.Yakety_Yak import YakGet, YakSet, YakDo, YakNab

# --- Versioning ---
w = 20250821
x_str = '210502'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"


# Conversion constant from Megahertz to Hertz
MHZ_TO_HZ_CONVERSION = 1_000_000

# =========================================================================
# PUBLIC API FOR CONTROLLING SETTINGS - GUI should call these functions
# =========================================================================
def refresh_all_from_instrument(app_instance, console_print_func):
    # This is a new public API for the GUI to call
    # Queries all settings from the instrument and returns a dictionary of values.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🟢 API call to refresh all settings from the instrument.",
              file=current_file,
              version=current_version,
              function=current_function)

    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot refresh settings.")
        return None

    settings = {}
    try:
        settings['center_freq_hz'] = YakGet(app_instance, "FREQUENCY/CENTER", console_print_func)
        settings['span_hz'] = YakGet(app_instance, "FREQUENCY/SPAN", console_print_func)
        settings['start_freq_hz'] = YakGet(app_instance, "FREQUENCY/START", console_print_func)
        settings['stop_freq_hz'] = YakGet(app_instance, "FREQUENCY/STOP", console_print_func)

        settings['rbw_hz'] = YakGet(app_instance, "BANDWIDTH/RESOLUTION", console_print_func)
        settings['vbw_hz'] = YakGet(app_instance, "BANDWIDTH/VIDEO", console_print_func)
        settings['vbw_auto_on'] = YakGet(app_instance, "BANDWIDTH/VIDEO/AUTO", console_print_func) in ["ON", "1"]

        settings['initiate_continuous_on'] = YakGet(app_instance, "INITIATE/CONTINUOUS", console_print_func) in ["ON", "1"]

        settings['ref_level_dbm'] = YakGet(app_instance, "AMPLITUDE/REFERENCE LEVEL", console_print_func)
        settings['power_attenuation_db'] = YakGet(app_instance, "AMPLITUDE/POWER/ATTENUATION", console_print_func)
        settings['preamp_on'] = YakGet(app_instance, "AMPLITUDE/POWER/GAIN", console_print_func) in ["ON", "1"]
        settings['high_sensitivity_on'] = YakGet(app_instance, "AMPLITUDE/POWER/HIGH SENSITIVE", console_print_func) in ["ON", "1"]

        settings['trace1_mode'] = YakGet(app_instance, "TRACE/1/MODE", console_print_func)
        settings['trace2_mode'] = YakGet(app_instance, "TRACE/2/MODE", console_print_func)
        settings['trace3_mode'] = YakGet(app_instance, "TRACE/3/MODE", console_print_func)
        settings['trace4_mode'] = YakGet(app_instance, "TRACE/4/MODE", console_print_func)

        for i in range(6):
            settings[f'marker{i+1}_on'] = YakGet(app_instance, f"MARKER/{i+1}/CALCULATE/STATE", console_print_func) in ["ON", "1"]

        # NEW: Get averaging state and count for all traces
        for i in range(1, 5):
            avg_status, avg_count = get_trace_averaging_settings(app_instance, i, console_print_func)
            settings[f'trace{i}_average_on'] = avg_status
            settings[f'trace{i}_average_count'] = avg_count

        debug_log(f"🐐 ✅ Retrieved all settings: {settings}", file=current_file, version=current_version, function=current_function)
        return settings
    except Exception as e:
        console_print_func(f"❌ Failed to retrieve settings from instrument: {e}.")
        debug_log(f"🐐 ❌ Error retrieving settings from instrument: {e}. What a mess!",
                  file=current_file,
                  version=current_version,
                  function=current_function)
        return None

def _trigger_gui_refresh(app_instance):
    # Function Description:
    # Safely calls the refresh method on the correct GUI object from the main thread.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🔄 Attempting to refresh GUI from within handler. 🔄",
              file=current_file,
              version=current_version,
              function=current_function)
    
    try:
        # CORRECTED PATH: Navigate through the `tabs_parent` dictionary to find the right object
        instrument_parent_tab = app_instance.tabs_parent.tab_content_frames['Instruments']
        settings_tab = instrument_parent_tab.settings_tab
        # FIXED: Corrected the function call to the existing method
        settings_tab.refresh_all_child_tabs()
    except AttributeError as e:
        debug_log(f"🐐 💥 CRITICAL ERROR: Failed to find the GUI refresh method. Path traversal failed. Error: {e} 💥",
                  file=current_file,
                  version=current_version,
                  function=current_function)
    except Exception as e:
        debug_log(f"🐐 🤯 An unexpected error occurred during GUI refresh: {e}. 🤯",
                  file=current_file,
                  version=current_version,
                  function=current_function)

def set_center_frequency(app_instance, value, console_print_func):
    """
    Sets the center frequency on the instrument and triggers a GUI refresh.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to set center frequency: {value} MHz.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot set frequency.")
        return False
    
    try:
        hz_value = int(float(value) * MHZ_TO_HZ_CONVERSION)
        if YakSet(app_instance, "FREQUENCY/CENTER", str(hz_value), console_print_func) == "PASSED":
            app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
            return True
    except ValueError:
        console_print_func(f"❌ Invalid frequency value: '{value}'. Please enter a number.")
    return False

def set_span_frequency(app_instance, value, console_print_func):
    """
    Sets the span frequency on the instrument and triggers a GUI refresh.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to set span: {value} MHz.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot set span.")
        return False
        
    try:
        hz_value = int(float(value) * MHZ_TO_HZ_CONVERSION)
        if YakSet(app_instance, "FREQUENCY/SPAN", str(hz_value), console_print_func) == "PASSED":
            app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
            return True
    except ValueError:
        console_print_func(f"❌ Invalid span value: '{value}'. Please enter a number.")
    return False

def set_start_frequency(app_instance, value, console_print_func):
    """
    Sets the start frequency on the instrument and triggers a GUI refresh.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to set start frequency: {value} MHz.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot set start frequency.")
        return False
        
    try:
        hz_value = int(float(value) * MHZ_TO_HZ_CONVERSION)
        if YakSet(app_instance, "FREQUENCY/START", str(hz_value), console_print_func) == "PASSED":
            app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
            return True
    except ValueError:
        console_print_func(f"❌ Invalid start frequency value: '{value}'. Please enter a number.")
    return False

def set_stop_frequency(app_instance, value, console_print_func):
    """
    Sets the stop frequency on the instrument and triggers a GUI refresh.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to set stop frequency: {value} MHz.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot set stop frequency.")
        return False
        
    try:
        hz_value = int(float(value) * MHZ_TO_HZ_CONVERSION)
        if YakSet(app_instance, "FREQUENCY/STOP", str(hz_value), console_print_func) == "PASSED":
            app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
            return True
    except ValueError:
        console_print_func(f"❌ Invalid stop frequency value: '{value}'. Please enter a number.")
    return False

def set_resolution_bandwidth(app_instance, value, console_print_func):
    """
    Sets the resolution bandwidth on the instrument and triggers a GUI refresh.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to set resolution bandwidth: {value} Hz.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot set RBW.")
        return False
    
    try:
        hz_value = int(float(value))
        if YakSet(app_instance, "BANDWIDTH/RESOLUTION", str(hz_value), console_print_func) == "PASSED":
            app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
            return True
    except ValueError:
        console_print_func(f"❌ Invalid RBW value: '{value}'. Please enter a number.")
    return False
    
def set_video_bandwidth(app_instance, value, console_print_func):
    """
    Sets the video bandwidth on the instrument and triggers a GUI refresh.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to set video bandwidth: {value} Hz.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot set VBW.")
        return False
        
    try:
        hz_value = int(float(value))
        if YakSet(app_instance, "BANDWIDTH/VIDEO", str(hz_value), console_print_func) == "PASSED":
            app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
            return True
    except ValueError:
        console_print_func(f"❌ Invalid VBW value: '{value}'. Please enter a number.")
    return False
    
def toggle_vbw_auto(app_instance, console_print_func):
    """
    Toggles the automatic VBW setting on the instrument and triggers a GUI refresh.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to toggle VBW auto.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot toggle VBW Auto.")
        return False
    
    current_state = app_instance.vbw_auto_on_var.get()
    new_state = "OFF" if current_state else "ON"
    
    if YakDo(app_instance, f"BANDWIDTH/VIDEO/AUTO/{new_state}", console_print_func=console_print_func) == "PASSED":
        app_instance.vbw_auto_on_var.set(not current_state)
        app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
        return True
    return False
    
def set_continuous_initiate_mode(app_instance, mode, console_print_func):
    """
    Sets the continuous initiate mode on the instrument and triggers a GUI refresh.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to set continuous initiate mode: {mode}.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot set continuous initiate mode.")
        return False
    
    mode_str = "ON" if mode else "OFF"
    if YakDo(app_instance, f"INITIATE/CONTINUOUS/{mode_str}", console_print_func=console_print_func) == "PASSED":
        app_instance.initiate_continuous_on_var.set(mode)
        app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
        return True
    return False
    
def do_immediate_initiate(app_instance, console_print_func):
    """
    Initiates an immediate sweep on the instrument and triggers a GUI refresh.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to initiate immediate scan.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot initiate immediate scan.")
        return False
    
    if YakDo(app_instance, "INITIATE/IMMEDIATE", console_print_func=console_print_func) == "PASSED":
        console_print_func("✅ Immediate scan initiated successfully.")
        app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
        return True
    return False
    
def set_reference_level(tab_instance, app_instance, value, console_print_func):
    """
    Sets the reference level on the instrument and triggers a GUI refresh.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to set reference level: {value} dBm.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot set reference level.")
        return False
    
    try:
        int_value = int(float(value))
        if YakDo(app_instance, f"AMPLITUDE/REFERENCE LEVEL/{int_value}", console_print_func=console_print_func) == "PASSED":
            app_instance.ref_level_dbm_var.set(value)
            app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
            return True
        else:
            return False
    except (ValueError, TypeError) as e:
        console_print_func(f"❌ Invalid reference level value: '{value}'. Please enter a number. Error: {e}")
        debug_log(f"🐐 ❌ ValueError: could not convert reference level to int. Failed to parse data. Error: {e}",
                  file=current_file,
                  version=current_version,
                  function=current_function, special=True)
        return False
    except Exception as e:
        console_print_func(f"❌ An unexpected error occurred while setting the reference level: {e}")
        debug_log(f"🐐 🧨 An unexpected error occurred: {e}",
                  file=current_file,
                  version=current_version,
                  function=current_function, special=True)
        return False


def toggle_preamp(tab_instance, app_instance, console_print_func):
    """
    Toggles the preamp on or off and updates the UI state.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to toggle the preamp switch! ⚡",
              file=current_file,
              version=current_version,
              function=current_function)
    
    try:
        is_on = app_instance.preamp_on_var.get()
        if is_on:
            YakDo(app_instance, "AMPLITUDE/POWER/GAIN/OFF", console_print_func=console_print_func)
            app_instance.preamp_on_var.set(False)
            console_print_func("✅ Preamp turned OFF.")
            if app_instance.high_sensitivity_on_var.get():
                debug_log(f"🐐 Preamp turned off, automatically turning off high sensitivity. 🕵️‍♀️",
                        file=current_file,
                        version=current_version,
                        function=current_function)
                toggle_high_sensitivity(tab_instance=tab_instance, app_instance=app_instance, console_print_func=console_print_func)
        else:
            YakDo(app_instance, "AMPLITUDE/POWER/GAIN/ON", console_print_func=console_print_func)
            app_instance.preamp_on_var.set(True)
            console_print_func("✅ Preamp turned ON.")

        tab_instance._update_toggle_button_style(button=tab_instance.preamp_toggle_button, state=app_instance.preamp_on_var.get())
        app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))

    except Exception as e:
        console_print_func(f"❌ Error toggling preamp: {e}")
        debug_log(f"🐐 🧨 Arrr, the code be capsized! Error toggling preamp: {e} 🏴‍☠️",
                  file=current_file,
                  version=current_version,
                  function=current_function)


def toggle_high_sensitivity(tab_instance, app_instance, console_print_func):
    """
    Toggles the high sensitivity mode on or off and updates the UI state.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to toggle the high sensitivity switch! 🔬",
              file=current_file,
              version=current_version,
              function=current_function)

    try:
        is_on = app_instance.high_sensitivity_on_var.get()
        if is_on:
            YakDo(app_instance, "AMPLITUDE/POWER/HIGH SENSITIVE/OFF", console_print_func=console_print_func)
            app_instance.high_sensitivity_on_var.set(False)
            console_print_func("✅ High Sensitivity turned OFF.")
        else:
            YakDo(app_instance, "AMPLITUDE/POWER/HIGH SENSITIVE/ON", console_print_func=console_print_func)
            app_instance.high_sensitivity_on_var.set(True)
            console_print_func("✅ High Sensitivity turned ON.")

        tab_instance._update_toggle_button_style(button=tab_instance.hs_toggle_button, state=app_instance.high_sensitivity_on_var.get())
        
        results = YakNab(app_instance, "AMPLITUDE/POWER/HIGH SENSITIVE", console_print_func=console_print_func)
        if results is not None and len(results) >= 3:
            ref_level_dbm, attenuation_db, preamp_on = results
            app_instance.ref_level_dbm_var.set(float(ref_level_dbm))
            app_instance.power_attenuation_db_var.set(float(attenuation_db))
            app_instance.preamp_on_var.set(int(preamp_on) == 1)
            tab_instance._set_ui_initial_state()
            console_print_func("✅ Updated UI with new values from instrument.")
        
    except Exception as e:
        console_print_func(f"❌ Error toggling high sensitivity: {e}")
        debug_log(f"🐐 🧨 Arrr, the code be capsized! The error be: {e} 🏴‍☠️",
                  file=current_file,
                  version=current_version,
                  function=current_function)


def set_power_attenuation(tab_instance, app_instance, value, console_print_func):
    """
    Sets the power attenuation on the instrument and triggers a GUI refresh.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to set power attenuation: {value} dB.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot set power attenuation.")
        return False
    
    if YakDo(app_instance, f"AMPLITUDE/POWER/ATTENUATION/{value}DB", console_print_func=console_print_func) == "PASSED":
        app_instance.power_attenuation_db_var.set(value)
        app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
        return True
    return False
    
    
def set_trace_mode(app_instance, trace_number, mode, console_print_func):
    """
    Sets the trace mode for a specific trace on the instrument and triggers a GUI refresh.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to set trace {trace_number} mode: {mode}.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot set trace mode.")
        return False
    
    if YakDo(app_instance, f"TRACE/{trace_number}/MODE/{mode}", console_print_func=console_print_func) == "PASSED":
        trace_var = getattr(app_instance, f"trace{trace_number}_mode_var")
        trace_var.set(mode)
        app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
        return True
    return False
    
def do_turn_all_markers_on(app_instance, console_print_func):
    """
    Turns on all markers on the instrument and triggers a GUI refresh.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to turn on all markers.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot turn on markers.")
        return False
    
    if YakDo(app_instance, "MARKER/All/CALCULATE/STATE/ON", console_print_func=console_print_func) == "PASSED":
        app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
        return True
    return False
    
def toggle_marker_state(app_instance, marker_number, state, console_print_func):
    """
    Toggles the state of a specific marker on the instrument and triggers a GUI refresh.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to toggle marker {marker_number} state to {state}.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot set marker state.")
        return False
        
    new_state = "ON" if state else "OFF"
    if YakDo(app_instance, f"MARKER/{marker_number}/CALCULATE/STATE/{new_state}", console_print_func=console_print_func) == "PASSED":
        app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
        return True
    return False
    
def do_peak_search(app_instance, console_print_func):
    """
    Performs a peak search on the instrument and triggers a GUI refresh.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to perform peak search.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot perform peak search.")
        return False
    
    if YakDo(app_instance, "MARKER/PEAK/SEARCH", console_print_func=console_print_func) == "PASSED":
        console_print_func("✅ Peak search command sent successfully.")
        app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
        return True
    return False

def toggle_trace_averaging(app_instance, trace_number, is_on, console_print_func):
    """
    Function Description:
    Toggles the averaging state for a specific trace and triggers a GUI refresh.
    
    Inputs:
    - app_instance (object): A reference to the main application instance.
    - trace_number (int): The number of the trace to toggle (1-4).
    - is_on (bool): The desired state for averaging (True for ON, False for OFF).
    - console_print_func (function): A function to print messages to the GUI console.
    
    Outputs:
    - bool: True if the command is executed successfully, False otherwise.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to toggle trace averaging for trace {trace_number} to {is_on}.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot toggle trace averaging.")
        return False

    state_str = "ON" if is_on else "OFF"
    command_type = f"AVERAGE/{state_str}"
    
    if YakDo(app_instance, command_type, console_print_func) == "PASSED":
        console_print_func(f"✅ Trace {trace_number} averaging turned {state_str}.")
        app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
        return True
    
    return False

def set_trace_averaging_count(app_instance, trace_number, count, console_print_func):
    """
    Function Description:
    Sets the averaging count for a specific trace and triggers a GUI refresh.
    
    Inputs:
    - app_instance (object): A reference to the main application instance.
    - trace_number (int): The number of the trace to set (1-4).
    - count (int): The desired averaging count.
    - console_print_func (function): A function to print messages to the GUI console.
    
    Outputs:
    - bool: True if the command is executed successfully, False otherwise.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to set trace averaging count for trace {trace_number} to {count}.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot set trace averaging count.")
        return False
        
    command_type = f"AVERAGE"
    variable_value = count
    
    if YakSet(app_instance, command_type, variable_value, console_print_func) == "PASSED":
        console_print_func(f"✅ Trace {trace_number} averaging count set to {count}.")
        app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
        return True
    
    return False

def get_trace_averaging_settings(app_instance, trace_number, console_print_func) -> (bool, int):
    """
    Function Description:
    Retrieves the averaging state and count for a specific trace using a single NAB command.
    
    Inputs:
    - app_instance (object): A reference to the main application instance.
    - trace_number (int): The number of the trace to query (1-4).
    - console_print_func (function): A function to print messages to the GUI console.
    
    Outputs:
    - (bool, int): A tuple containing the averaging state (True/False) and the count, or (None, None) on failure.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to retrieve averaging settings for trace {trace_number}.",
              file=current_file,
              version=current_version,
              function=current_function)
              
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot retrieve averaging settings.")
        return None, None

    command_type = "AVERAGE"
    
    response = YakNab(app_instance, command_type, console_print_func)
    
    if response and isinstance(response, list) and len(response) >= 2:
        try:
            state_str = response[0]
            count_str = response[1]
            
            is_on = state_str in ["ON", "1"]
            count = int(float(count_str))
            
            return is_on, count
        except (ValueError, IndexError, TypeError) as e:
            console_print_func(f"❌ Failed to parse averaging settings. Error: {e}")
            debug_log(f"🐐 ❌ Arrr, the response be gibberish! Error: {e}",
                      file=current_file,
                      version=current_version,
                      function=current_function)
    
    return None, None

def _process_trace_data(raw_data_string, start_freq_hz, end_freq_hz, console_print_func):
    """
    Function Description:
    Processes a raw comma-separated string of trace amplitude data into
    a list of (frequency, amplitude) pairs.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 Processing raw trace data into frequency/amplitude pairs. This is a crucial step.",
              file=current_file,
              version=current_version,
              function=current_function)

    if not raw_data_string or "FAILED" in raw_data_string:
        console_print_func("❌ Received invalid data from the instrument. Cannot process trace.")
        return None

    try:
        amplitudes_dbm = [float(val) for val in raw_data_string.split(',')]
        
        num_points = len(amplitudes_dbm)
        if num_points <= 1:
            console_print_func("⚠️ Received insufficient data points from the instrument. Cannot create a meaningful trace.")
            return None
            
        freq_points = np.linspace(start_freq_hz, end_freq_hz, num_points)
        
        processed_data = list(zip(freq_points / MHZ_TO_HZ_CONVERSION, amplitudes_dbm))

        debug_log(f"🐐 ✅ Successfully processed trace data. First 5 points: {processed_data[:5]}...",
                  file=current_file,
                  version=current_version,
                  function=current_function)
        
        return processed_data

    except ValueError as e:
        console_print_func(f"❌ Failed to parse trace data string. Error: {e}")
        debug_log(f"🐐 ❌ ValueError: could not convert string to float. Failed to parse data string. Error: {e}",
                  file=current_file,
                  version=current_version,
                  function=current_function, special=True)
        return None
    except Exception as e:
        console_print_func(f"❌ An unexpected error occurred while processing trace data: {e}")
        debug_log(f"🐐 🧨 An unexpected error occurred: {e}",
                  file=current_file,
                  version=current_version,
                  function=current_function, special=True)
        return None


def get_trace_data_logic(app_instance, console_print_func):
    """
    Function Description:
    Retrieves trace data for all active traces from the instrument.
    This function has been refactored to be more robust, checking for valid data and
    handling different trace modes with a simple update cycle counter.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 Getting trace data from the instrument.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot get trace data.")
        return False
    
    all_trace_data = []

    center_freq_hz = float(YakGet(app_instance, "FREQUENCY/CENTER", console_print_func))
    span_hz = float(YakGet(app_instance, "FREQUENCY/SPAN", console_print_func))
    start_freq_hz = center_freq_hz - (span_hz / 2)
    end_freq_hz = center_freq_hz + (span_hz / 2)

    for i in range(1, 5):
        command_type = f"TRACE/{i}/DATA"
        raw_data_string = YakGet(app_instance, command_type.upper(), console_print_func)
        
        if raw_data_string is not None and raw_data_string != "FAILED":
            processed_data = _process_trace_data(raw_data_string, start_freq_hz, end_freq_hz, console_print_func)
            if processed_data:
                all_trace_data.append(processed_data)
                console_print_func(f"✅ Trace {i} data received and processed.")
            else:
                all_trace_data.append(None)
                console_print_func(f"❌ Failed to process Trace {i} data.")
        else:
            all_trace_data.append(None)
            console_print_func(f"❌ Failed to retrieve Trace {i} data.")
    
    return all_trace_data
    
def do_power_cycle(app_instance, console_print_func):
    """
    Sends a power cycle command to the instrument and handles the disconnection state.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to power cycle the device.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot power cycle device.")
        return False

    console_print_func("⚠️ Initiating device power cycle. Connection will be lost for ~20 seconds. Please wait to reconnect.")
    
    if YakDo(app_instance, "POWER/RESET", console_print_func=console_print_func) == "PASSED":
        app_instance.is_connected.set(False)
        return True
        
    return False

def get_all_marker_values_logic(app_instance, console_print_func):
    """
    Retrieves and returns the X and Y values for all active markers.
    Returns a list of tuples: [(x1, y1), (x2, y2), ...]
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 Getting all marker values from the instrument.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot read markers.")
        return None
    
    marker_values = []
    for i in range(1, 7):
        marker_state = YakGet(app_instance, f"MARKER/{i}/CALCULATE/STATE", console_print_func)
        if marker_state in ["ON", "1"]:
            x_value = YakGet(app_instance, f"MARKER/{i}/CALCULATE/X", console_print_func)
            y_value = YakGet(app_instance, f"MARKER/{i}/CALCULATE/Y", console_print_func)

            try:
                x_value_mhz = float(x_value) / MHZ_TO_HZ_CONVERSION
                y_value_dbm = float(y_value)
                marker_values.append((x_value_mhz, y_value_dbm))
            except (ValueError, TypeError):
                console_print_func(f"⚠️ Could not parse marker {i} values.")
                debug_log(f"🐐 ❌ Failed to parse marker {i} values. What a mess!",
                          file=current_file,
                          version=current_version,
                          function=current_function)
                marker_values.append((None, None))
    
    return marker_values


def reset_device(app_instance, console_print_func):
    """
    Sends a soft reset command to the instrument.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to reset the device.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot reset device.")
        return False
    
    if YakDo(app_instance, "SYSTEM/RESET", console_print_func=console_print_func) == "PASSED":
        return True
    return False


#####################################
### File: OPEN-AIR\yak\utils_yak_visa.py
#####################################
# tabs/Instrument/utils_yak_visa.py
#
# This file provides utility functions for safe and standardized execution of
# VISA commands (GET, SET, DO) on connected instruments. It wraps PyVISA operations
# with error handling and integrates with the application's debug logging.
# NOTE: The high-level command execution logic (e.g., `execute_visa_command`) has been
# moved to the new `Yakety_Yak.py` file to separate concerns and improve modularity.
# This file now focuses exclusively on low-level, safe read/write operations.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.210502.1
# UPDATED: All debug messages now include the required 🐐 emoji at the start.

import inspect
import pyvisa
import time
import os

# Updated imports for new logging functions
from display.debug_logic import debug_log, log_visa_command
from display.console_logic import console_log

# --- Versioning ---
w = 20250821
x_str = '210502'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"


def _reset_device(inst, console_print_func):
    """
    Function Description:
    Sends a soft reset command to the instrument to restore a known state after an error.
    This is a last resort to recover from a bad state. It's a fucking miracle worker!

    Inputs to this function:
    - inst: The PyVISA instrument instance.
    - console_print_func: The function to print messages to the GUI console.

    Process of this function:
    1. Sends the '*RST' command using write_safe.
    2. Logs the attempt and the result to the debug and console.
    
    Outputs of this function:
    - bool: True if the reset command was sent, False otherwise.
    """
    current_function = inspect.currentframe().f_code.co_name
    console_print_func("⚠️ Command failed. Attempting to reset the instrument with '*RST'...")
    debug_log(f"🐐 🟡 Command failed. Attempting to send reset command '*RST' to the instrument.",
                file=current_file,
                version=current_version,
                function=current_function)
    # Use the write_safe function to send the reset command
    reset_success = write_safe(inst, "*RST", console_print_func)
    if reset_success:
        console_print_func("✅ Device reset command sent successfully.")
        debug_log("🐐 ✅ Reset command sent. Goddamn, that felt good!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
    else:
        console_print_func("❌ Failed to send reset command.")
        debug_log("🐐 ❌ Failed to send reset command. This is a goddamn mess!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
    return reset_success


def write_safe(inst, command, console_print_func):
    # Function Description:
    # Safely writes a SCPI command to the instrument.
    # Logs the command and handles potential errors.
    #
    # Inputs to this function:
    # - inst (pyvisa.resources.Resource): The PyVISA instrument object.
    # - command (str): The SCPI command string to write.
    # - console_print_func (function): Function to print messages to the GUI console.
    #
    # Process of this function:
    # 1. Checks if the instrument is connected.
    # 2. Attempts to write the command.
    # 3. Logs success or failure to the console and debug log.
    #
    # Outputs of this function:
    # - bool: True if the command was written successfully, False otherwise.
    #
    # (2025-08-01) Change: Refactored to use new logging.
    # (2025-08-11) Change: No changes.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 📝 Attempting to write command: {command}",
                file=current_file,
                version=current_version,
                function=current_function)
    if not inst:
        console_print_func("⚠️ Warning: Instrument not connected. Cannot write command.")
        debug_log("🐐 ❌ Instrument not connected. Fucking useless!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return False
    try:
        inst.write(command)
        log_visa_command(command, "SENT") # Log the VISA command
        return True
    except Exception as e:
        console_print_func(f"❌ Error writing command '{command}': {e}")
        debug_log(f"🐐 🧨 Error writing command '{command}': {e}. This thing is a pain in the ass!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        _reset_device(inst, console_print_func)
        return False

def query_safe(inst, command, console_print_func):
    # Function Description:
    # Safely queries the instrument with a SCPI command and returns the response.
    # Logs the command and response, and handles potential errors.
    #
    # Inputs to this function:
    # - inst (pyvisa.resources.Resource): The PyVISA instrument object.
    # - command (str): The full SCPI command string to query.
    # - console_print_func (function): Function to print messages to the GUI console.
    #
    # Process of this function:
    # 1. Checks if the instrument is connected.
    # 2. Attempts to query the instrument.
    # 3. Logs the command, response, and handles errors.
    #
    # Outputs of this function:
    # - str or None: The instrument's response if successful, None otherwise.
    #
    # (2025-08-01) Change: Refactored to use new logging.
    # (2025-08-11) Change: No changes.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 📝 Attempting to query command: {command}",
                file=current_file,
                version=current_version,
                function=current_function)
    if not inst:
        console_print_func("⚠️ Warning: Instrument not connected. Cannot query command.")
        debug_log("🐐 ❌ Instrument not connected. Fucking useless!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return None
    try:
        response = inst.query(command).strip()
        log_visa_command(command, "SENT") # Log the VISA command
        log_visa_command(response, "RECEIVED") # Log the VISA response
        return response
    except Exception as e:
        console_print_func(f"❌ Error querying command '{command}': {e}")
        debug_log(f"🐐 🧨 Error querying command '{command}': {e}. This goddamn thing is broken!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        _reset_device(inst, console_print_func)
        return None

def set_safe(inst, command, value, console_print_func):
    """
    Function Description:
    Safely writes a SET command to the instrument with a specified value.

    Inputs to this function:
    - inst: The PyVISA instrument instance.
    - command (str): The base VISA command string (e.g., ":SENSe:FREQuency:CENTer").
    - value: The value to set (will be converted to string).
    - console_print_func (function): Function to print messages to the GUI console.

    Process of this function:
    1. Constructs the full command string.
    2. Calls write_safe to send the command.

    Outputs of this function:
    - bool: True if the command was written successfully, False otherwise.
    """
    current_function = inspect.currentframe().f_code.co_name
    full_command = f"{command} {value}"
    debug_log(f"🐐 📝 Attempting to SET: {full_command}",
                file=current_file,
                version=current_version,
                function=current_function)
    return write_safe(inst, full_command, console_print_func)

def _wait_for_opc(inst, console_print_func, timeout=5):

    """
    Function Description:
    Waits for the instrument's Operation Complete (OPC) flag by querying *OPC?.
    This is a blocking function that handles timeouts.

    Inputs to this function:
    - inst: The PyVISA instrument instance.
    - console_print_func: The function to print messages to the GUI console.
    - timeout (int): The maximum time to wait for a response in seconds.

    Outputs of this function:
    - str: "PASSED" if the operation completes, "TIME FAILED" on timeout,
      or "FAILED" for other errors.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🟠 Waiting for Operation Complete (*OPC?) with a timeout of {timeout} seconds. Let's see if this thing is done!",
                file=current_file,
                version=current_version,
                function=current_function)

    original_timeout = inst.timeout
    inst.timeout = timeout * 1000 # PyVISA timeout is in milliseconds

    try:
        response = inst.query("*OPC?").strip()
        inst.timeout = original_timeout # Restore original timeout
        log_visa_command("*OPC?", "SENT")
        log_visa_command(response, "RECEIVED")

        if response == "1":
            console_print_func("✅ Operation Complete. Fucking brilliant!")
            debug_log("🐐 ✅ OPC query successful. Fucking brilliant!",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return "PASSED"
        else:
            console_print_func("❌ Operation failed to complete or returned an unexpected value.")
            debug_log(f"🐐 ❌ OPC query returned '{response}', not '1'. What the hell?!",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            _reset_device(inst, console_print_func)
            return "FAILED"

    except pyvisa.errors.VisaIOError as e:
        inst.timeout = original_timeout # Restore original timeout
        console_print_func(f"❌ Operation Complete query timed out after {timeout} seconds.")
        debug_log(f"🐐 ❌ OPC query failed with a timeout: {e}. This thing is a stubborn bastard!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        _reset_device(inst, console_print_func)
        return "TIME FAILED"
    except Exception as e:
        inst.timeout = original_timeout # Restore original timeout
        console_print_func(f"❌ Error during Operation Complete query: {e}")
        debug_log(f"🐐 🧨 Error during OPC query: {e}. This bugger is being problematic!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        _reset_device(inst, console_print_func)
        return "FAILED"


#####################################
### File: OPEN-AIR\yak\utils_yakbeg_handler.py
#####################################
# yak/utils_yaknab_handler.py
#
# This file provides handler functions for new "NAB" commands. These commands
# are designed for efficient, single-query retrieval of multiple instrument settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.210502.1
# UPDATED: Added new handler for Amplitude settings.
# FIXED: Corrected the parsing logic to handle both float and string responses for boolean-like settings.
# UPDATED: The function now handles a 5th return value for Sweep Time.
# NEW: Implemented a new handler for the TRACE/ALL/ONETWOTHREE NAB command, designed to handle multiple reads for large data sets.
# UPDATED: All debug messages now include the required 🐐 emoji at the start.

import inspect
import os
import numpy as np
from typing import Optional, List, Dict

from yak.Yakety_Yak import YakBeg, YakNab
from display.debug_logic import debug_log
from display.console_logic import console_log

# --- Versioning ---
w = 20250821
x_str = '210502'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"


# Helper conversion function
MHZ_TO_HZ = 1000000

def handle_freq_start_stop_beg(app_instance, start_freq, stop_freq, console_print_func):
    # Function Description:
    # Handles the extended YakBeg command for FREQUENCY/START-STOP.
    # It now returns start, stop, center, and span frequencies.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🟢 Entering {current_function}. Arrr, a treasure map for frequencies! 🗺️",
                file=current_file,
                version=current_version,
                function=current_function)
    
    # We send start and stop, and get back start, stop, span, and center
    response = YakBeg(app_instance, "FREQUENCY/START-STOP", console_print_func, start_freq, stop_freq)
    
    if response and response != "FAILED":
        try:
            # Response is a semicolon-separated string of four values
            parts = response.split(';')
            if len(parts) == 4:
                start = float(parts[0])
                stop = float(parts[1])
                span = float(parts[2])
                center = float(parts[3])
                debug_log(f"🐐 ✅ Processed response: start={start}, stop={stop}, span={span}, center={center}",
                        file=current_file,
                        version=current_version,
                        function=current_function)
                return start, stop, span, center
        except (ValueError, IndexError) as e:
            console_print_func(f"❌ Failed to parse response from instrument for multiple traces. Error: {e}")
            debug_log(f"🐐 ❌ Arrr, the response be gibberish! Error: {e}",
                        file=current_file,
                        version=current_version,
                        function=current_function)
    return None, None, None, None

def handle_freq_center_span_beg(app_instance, center_freq, span_freq, console_print_func):
    # Function Description:
    # Handles the extended YakBeg command for FREQUENCY/CENTER-SPAN.
    # It now returns center, span, start, and stop frequencies.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🟢 Entering {current_function}. Plotting a course to the center! 🧭",
                file=current_file,
                version=current_version,
                function=current_function)
    
    # We send center and span, and get back span, center, start, and stop
    response = YakBeg(app_instance, "FREQUENCY/CENTER-SPAN", console_print_func, center_freq, span_freq)
    
    if response and response != "FAILED":
        try:
            # Response is a semicolon-separated string of four values
            parts = response.split(';')
            if len(parts) == 4:
                # FIXED: Correct parsing order to match the VISA response
                span = float(parts[0])
                center = float(parts[1])
                start = float(parts[2])
                stop = float(parts[3])
                debug_log(f"🐐 ✅ Processed response: center={center}, span={span}, start={start}, stop={stop}",
                        file=current_file,
                        version=current_version,
                        function=current_function)
                return center, span, start, stop
        except (ValueError, IndexError) as e:
            console_print_func(f"❌ Failed to parse response from instrument for multiple traces. Error: {e}")
            debug_log(f"🐐 ❌ Arrr, the response be gibberish! Error: {e}",
                        file=current_file,
                        version=current_version,
                        function=current_function)
    return None, None, None, None

def handle_marker_place_all_beg(app_instance, marker_freqs_mhz, console_print_func):
    # Function Description:
    # Handles the YakBeg command for MARKER/PLACE/ALL.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🟢 Entering {current_function}. Parameters: marker_freqs_mhz={marker_freqs_mhz}",
                file=current_file,
                version=current_version,
                function=current_function)
    
    if not app_instance.inst:
        console_print_func("❌ No instrument connected. Cannot set markers.")
        debug_log("🐐 ❌ No instrument connected. Aborting marker operation.",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return "FAILED"

    marker_freqs_hz = []
    for freq in marker_freqs_mhz:
        try:
            marker_freqs_hz.append(int(float(freq) * MHZ_TO_HZ))
        except ValueError:
            console_print_func(f"❌ Invalid marker frequency entered: '{freq}'. Must be a number.")
            debug_log(f"🐐 🚫 Invalid marker frequency entered: '{freq}'. Aborting YakBeg.",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return "FAILED"

    response = YakBeg(app_instance, "MARKER/PLACE/ALL", console_print_func, *marker_freqs_hz)
    
    debug_log(f"🐐 ✅ Marker operation complete. Response: {response}. ✅",
                file=current_file,
                version=current_version,
                function=current_function)
    return response

def handle_trace_modes_beg(app_instance, trace_modes, console_print_func):
    # Function Description:
    # Handles the YakBeg command for TRACE/MODES.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🟢 Entering {current_function}",
                file=current_file,
                version=current_version,
                function=current_function)
    response = YakBeg(app_instance, "TRACE/MODES", console_print_func, *trace_modes)
    debug_log(f"🐐 ✅ Trace mode operation complete. Response: {response}. ✅",
                file=current_file,
                version=current_version,
                function=current_function)
    return response

def handle_trace_data_beg(app_instance, trace_number, start_freq_mhz, stop_freq_mhz, console_print_func):
    # Function Description:
    # Handles the YakBeg command for TRACE/DATA, including parsing and returning data.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🟢 Entering {current_function}",
                file=current_file,
                version=current_version,
                function=current_function)
    
    command_type = f"TRACE/{trace_number}/DATA"
    start_freq_hz = int(start_freq_mhz * MHZ_TO_HZ)
    stop_freq_hz = int(stop_freq_mhz * MHZ_TO_HZ)

    response_string = YakBeg(app_instance, command_type, console_print_func, start_freq_hz, stop_freq_hz)

    if response_string and response_string != "FAILED":
        try:
            values = [float(val.strip()) for val in response_string.split(',') if val.strip()]
            num_points = len(values)
            if num_points > 0:
                frequencies = np.linspace(start_freq_hz, stop_freq_hz, num_points)
                debug_log(f"🐐 ✅ Successfully parsed {num_points} data points from trace response.",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return list(zip(frequencies / MHZ_TO_HZ, values))
        except (ValueError, IndexError, TypeError) as e:
            console_print_func(f"❌ Failed to parse trace data: {e}. What a disaster!")
            debug_log(f"🐐 ❌ Failed to parse trace data string. Error: {e}",
                        file=current_file,
                        version=current_version,
                        function=current_function)
    return None


#####################################
### File: OPEN-AIR\yak\utils_yaknab_handler.py
#####################################
# yak/utils_yaknab_handler.py
#
# This file provides handler functions for new "NAB" commands. These commands
# are designed for efficient, single-query retrieval of multiple instrument settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.210502.1
# UPDATED: Added new handler for Amplitude settings.
# FIXED: Corrected the parsing logic to handle both float and string responses for boolean-like settings.
# UPDATED: The function now handles a 5th return value for Sweep Time.
# NEW: Implemented a new handler for the TRACE/ALL/ONETWOTHREE NAB command, designed to handle multiple reads for large data sets.
# UPDATED: All debug messages now include the required 🐐 emoji at the start.

import inspect
import os
import numpy as np
from typing import Optional, List, Dict

from yak.Yakety_Yak import YakBeg, YakNab
from display.debug_logic import debug_log
from display.console_logic import console_log


# --- Versioning ---
w = 20250821
x_str = '210502'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"


# Helper conversion function
MHZ_TO_HZ = 1000000

def handle_bandwidth_settings_nab(app_instance, console_print_func) -> Optional[Dict]:
    """
    Function Description:
    Executes the "BANDWIDTH/SETTINGS" NAB command to retrieve multiple bandwidth
    settings in a single query. It returns a dictionary of the retrieved values.
    
    The corresponding NAB command can be found in `visa_commands.csv`.

    Inputs:
    - app_instance (object): A reference to the main application instance.
    - console_print_func (function): A function to print messages to the GUI console.

    Outputs:
    - dict: A dictionary containing the fetched settings, or None on failure.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🟢 Entering {current_function}. Retrieving all bandwidth settings with a single NAB command. Let's make this snappy! ⚡",
              file=current_file,
              version=current_version,
              function=current_function)
    
    response = YakNab(app_instance, "BANDWIDTH/SETTINGS", console_print_func)

    if response and isinstance(response, list) and len(response) == 5:
        try:
            vbw_auto_on_value = response[2]
            continuous_mode_on_value = response[3]
            
            settings = {
                "RBW_Hz": float(response[0]),
                "VBW_Hz": float(response[1]),
                "VBW_Auto_On": vbw_auto_on_value == 'ON' or vbw_auto_on_value == '1' or float(vbw_auto_on_value) == 1.0,
                "Continuous_Mode_On": continuous_mode_on_value == 'ON' or continuous_mode_on_value == '1' or float(continuous_mode_on_value) == 1.0,
                "Sweep_Time_s": float(response[4])
            }
            console_print_func("✅ Successfully retrieved all bandwidth settings.")
            debug_log(f"🐐 ✅ Successfully retrieved bandwidth settings: {settings}. A truly magnificent feat! ✨",
                      file=current_file,
                      version=current_version,
                      function=current_function)
            return settings
        except (ValueError, IndexError) as e:
            console_print_func(f"❌ Failed to parse response from instrument for bandwidth settings. Error: {e}")
            debug_log(f"🐐 ❌ Arrr, the response be gibberish! Error: {e}",
                      file=current_file,
                      version=current_version,
                      function=current_function)
            return None
    
    console_log("❌ Failed to retrieve all bandwidth settings from instrument.")
    return None


def handle_amplitude_settings_nab(app_instance, console_print_func) -> Optional[Dict]:
    """
    Function Description:
    Executes a NAB command to retrieve multiple amplitude settings in a single query.
    It retrieves the Reference Level, Power Attenuation, and Preamp state.
    
    The corresponding NAB command can be found in `visa_commands.csv`.

    Inputs:
    - app_instance (object): A reference to the main application instance.
    - console_print_func (function): A function to print messages to the GUI console.

    Outputs:
    - dict: A dictionary containing the fetched settings, or None on failure.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🟢 Entering {current_function}. Retrieving all amplitude settings with a single NAB command. A treasure hunt for data! 🗺️",
              file=current_file,
              version=current_version,
              function=current_function)
    
    response = YakNab(app_instance, "AMPLITUDE/SETTINGS", console_print_func)

    if response and isinstance(response, list) and len(response) == 3:
        try:
            settings = {
                "Ref_Level_dBm": float(response[0]),
                "Attenuation_dB": float(response[1]),
                "Preamp_On": response[2].upper() == 'ON' or response[2] == '1'
            }
            console_print_func("✅ Successfully retrieved all amplitude settings.")
            debug_log(f"🐐 ✅ Successfully retrieved amplitude settings: {settings}. A truly magnificent feat! ✨",
                      file=current_file,
                      version=current_version,
                      function=current_function)
            return settings
        except (ValueError, IndexError) as e:
            console_print_func(f"❌ Failed to parse response from instrument for amplitude settings. Error: {e}")
            debug_log(f"🐐 ❌ Arrr, the response be gibberish! Error: {e}",
                      file=current_file,
                      version=current_version,
                      function=current_function)
            return None
    
    console_log("❌ Failed to retrieve all amplitude settings from instrument.")
    return None


def handle_all_traces_nab(app_instance, console_print_func) -> Optional[Dict]:
    """
    Function Description:
    This handler executes the "TRACE/ALL/ONETWOTHREE" NAB command.
    It retrieves the start/stop frequencies, trace modes, and data for traces 1, 2, and 3
    in a single, efficient query. It then processes the complex response string into
    a structured dictionary of data and modes suitable for plotting or display.

    Inputs:
    - app_instance: The main application instance.
    - console_print_func: A function to print messages to the GUI console.

    Outputs:
    - Optional[Dict]: A dictionary with keys for "TraceData", "StartFreq", "StopFreq",
                      and "TraceModes" if successful.
                      Returns None on failure.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🟢 Entering {current_function}. Retrieving multiple traces with a single NAB command.",
              file=current_file,
              version=current_version,
              function=current_function)

    response_list = YakNab(app_instance, "TRACE/ALL/ONETWOTHREE", console_print_func)

    if response_list and isinstance(response_list, list) and len(response_list) == 8:
        try:
            start_freq_hz = float(response_list[0])
            stop_freq_hz = float(response_list[1])

            trace_modes = {
                "Trace1": response_list[2],
                "Trace2": response_list[3],
                "Trace3": response_list[4],
            }

            trace_data = {}
            for i in range(1, 4):
                trace_string = response_list[i + 4]
                values = [float(val.strip()) for val in trace_string.split(',') if val.strip()]
                num_points = len(values)

                if num_points > 0:
                    frequencies = np.linspace(start_freq_hz, stop_freq_hz, num_points)
                    trace_data[f"Trace{i}"] = list(zip(frequencies / MHZ_TO_HZ, values))
                else:
                    trace_data[f"Trace{i}"] = []

            console_log("✅ Successfully retrieved and parsed data for three traces.")
            debug_log(f"🐐 ✅ Successfully retrieved traces. What a haul! 🎣",
                      file=current_file,
                      version=current_version,
                      function=current_function)

            return {
                "TraceData": trace_data,
                "StartFreq": start_freq_hz,
                "StopFreq": stop_freq_hz,
                "TraceModes": trace_modes
            }

        except (ValueError, IndexError, TypeError) as e:
            console_log(f"❌ Failed to parse response from instrument for multiple traces. Error: {e}")
            debug_log(f"🐐 ❌ Arrr, the response be gibberish! Error: {e}",
                      file=current_file,
                      version=current_version,
                      function=current_function)
    return None


