# └── OPEN-AIR 2/
#├── DATA/
#├── agents/
#├── configuration/
#├── datasets/
#├── display/
#├── utils/
#├── workers/
#├── debug.log (Lines: 63478)
#└── main.py (Lines: 158)
#        |   -> Import: datasets.logging
#        |   -> Import: datetime
#        |   -> Import: display.gui_display
#        |   -> Import: inspect
#        |   -> Import: os
#        |   -> Import: pathlib
#        |   -> Import: sys
#        |   -> Function: action_check_configuration()
#        |   -> Function: action_check_dependancies()
#        |   -> Function: action_open_display()
#        |   -> Function: main()
#└── agents/
#    └── yak/
#    └── yak/
#        ├── Yakety_Yak.py (Lines: 568)
#                |   -> Import: csv
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: pyvisa
#                |   -> Import: ref.ref_file_paths
#                |   -> Import: time
#                |   -> Import: tkinter
#                |   -> Import: yak.utils_yak_visa
#                |   -> Function: YakBeg(app_instance, command_type, console_print_func)
#                |   -> Function: YakDo(app_instance, command_type, console_print_func)
#                |   -> Function: YakGet(app_instance, command_type, console_print_func)
#                |   -> Function: YakNab(app_instance, command_type, console_print_func)
#                |   -> Function: YakRig(app_instance, command_type, console_print_func)
#                |   -> Function: YakSet(app_instance, command_type, variable_value, console_print_func)
#                |   -> Function: _find_command(command_type, action_type, model)
#                |   -> Function: _load_commands_from_file(file_path)
#                |   -> Function: execute_visa_command(app_instance, action_type, visa_command, variable_value, console_print_func, num_reads)
#        ├── utils_yak_setting_handler.py (Lines: 833)
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: numpy
#                |   -> Import: os
#                |   -> Import: threading
#                |   -> Import: time
#                |   -> Import: yak.Yakety_Yak
#                |   -> Function: _process_trace_data(raw_data_string, start_freq_hz, end_freq_hz, console_print_func)
#                |   -> Function: _trigger_gui_refresh(app_instance)
#                |   -> Function: do_immediate_initiate(app_instance, console_print_func)
#                |   -> Function: do_peak_search(app_instance, console_print_func)
#                |   -> Function: do_power_cycle(app_instance, console_print_func)
#                |   -> Function: do_turn_all_markers_on(app_instance, console_print_func)
#                |   -> Function: get_all_marker_values_logic(app_instance, console_print_func)
#                |   -> Function: get_trace_averaging_settings(app_instance, trace_number, console_print_func)
#                |   -> Function: get_trace_data_logic(app_instance, console_print_func)
#                |   -> Function: refresh_all_from_instrument(app_instance, console_print_func)
#                |   -> Function: reset_device(app_instance, console_print_func)
#                |   -> Function: set_center_frequency(app_instance, value, console_print_func)
#                |   -> Function: set_continuous_initiate_mode(app_instance, mode, console_print_func)
#                |   -> Function: set_power_attenuation(tab_instance, app_instance, value, console_print_func)
#                |   -> Function: set_reference_level(tab_instance, app_instance, value, console_print_func)
#                |   -> Function: set_resolution_bandwidth(app_instance, value, console_print_func)
#                |   -> Function: set_span_frequency(app_instance, value, console_print_func)
#                |   -> Function: set_start_frequency(app_instance, value, console_print_func)
#                |   -> Function: set_stop_frequency(app_instance, value, console_print_func)
#                |   -> Function: set_trace_averaging_count(app_instance, trace_number, count, console_print_func)
#                |   -> Function: set_trace_mode(app_instance, trace_number, mode, console_print_func)
#                |   -> Function: set_video_bandwidth(app_instance, value, console_print_func)
#                |   -> Function: toggle_high_sensitivity(tab_instance, app_instance, console_print_func)
#                |   -> Function: toggle_marker_state(app_instance, marker_number, state, console_print_func)
#                |   -> Function: toggle_preamp(tab_instance, app_instance, console_print_func)
#                |   -> Function: toggle_trace_averaging(app_instance, trace_number, is_on, console_print_func)
#                |   -> Function: toggle_vbw_auto(app_instance, console_print_func)
#        ├── utils_yak_visa.py (Lines: 264)
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: pyvisa
#                |   -> Import: time
#                |   -> Function: _reset_device(inst, console_print_func)
#                |   -> Function: _wait_for_opc(inst, console_print_func, timeout)
#                |   -> Function: query_safe(inst, command, console_print_func)
#                |   -> Function: set_safe(inst, command, value, console_print_func)
#                |   -> Function: write_safe(inst, command, console_print_func)
#        ├── utils_yakbeg_handler.py (Lines: 201)
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: numpy
#                |   -> Import: os
#                |   -> Import: typing
#                |   -> Import: yak.Yakety_Yak
#                |   -> Function: handle_freq_center_span_beg(app_instance, center_freq, span_freq, console_print_func)
#                |   -> Function: handle_freq_start_stop_beg(app_instance, start_freq, stop_freq, console_print_func)
#                |   -> Function: handle_marker_place_all_beg(app_instance, marker_freqs_mhz, console_print_func)
#                |   -> Function: handle_trace_data_beg(app_instance, trace_number, start_freq_mhz, stop_freq_mhz, console_print_func)
#                |   -> Function: handle_trace_modes_beg(app_instance, trace_modes, console_print_func)
#        └── utils_yaknab_handler.py (Lines: 215)
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: numpy
#                |   -> Import: os
#                |   -> Import: typing
#                |   -> Import: yak.Yakety_Yak
#                |   -> Function: handle_all_traces_nab(app_instance, console_print_func)
#                |   -> Function: handle_amplitude_settings_nab(app_instance, console_print_func)
#                |   -> Function: handle_bandwidth_settings_nab(app_instance, console_print_func)
#└── configuration/
#└── DATA/
#└── datasets/
#    ├── dataset_devices.json (Lines: 4062)
#    ├── dataset_devices_amplifier_type.json (Lines: 40)
#    ├── dataset_devices_antenna_type.json (Lines: 40)
#    ├── dataset_file_paths.json (Lines: 12)
#    ├── dataset_frequency_bands_of_interest.json (Lines: 681)
#    ├── dataset_frequency_government.json (Lines: 191)
#    ├── dataset_frequency_tv_bands.json (Lines: 427)
#    ├── dataset_publisher.py (Lines: 76)
#            |   -> Import: os
#            |   -> Import: sys
#            |   -> Import: workers.mqtt_controller_util
#            |   -> Function: log_treeview_func(message)
#            |   -> Function: main()
#            |   -> Function: print_to_gui_func(message)
#    ├── dataset_scanning_presets.json (Lines: 329)
#    ├── dataset_spectrum_analyzer_setting_lists.json (Lines: 522)
#    ├── datasets_constants.json (Lines: 56)
#    ├── logging.py (Lines: 72)
#            |   -> Import: datetime
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Function: console_log(message)
#            |   -> Function: debug_log(message, file, version, function, console_print_func)
#    └── north star - ref_program_default_values.py (Lines: 103)
#            - No functions, classes, or imports found.
#└── display/
#    ├── left_60/
#    ├── prototype/
#    ├── right_40/
#    ├── styling/
#    ├── base_gui_component_rebuilt.py (Lines: 96)
#            |   -> Import: datasets.logging
#            |   -> Import: inspect
#            |   -> Import: json
#            |   -> Import: os
#            |   -> Import: pathlib
#            |   -> Import: styling.style
#            |   -> Import: tkinter
#            |   -> Import: workers.mqtt_controller_util
#            |   -> Class: BaseGUIFrame
#            |   -> Function: __init__(self, parent, mqtt_util, console_print_func)
#            |   -> Function: _apply_styles(self, theme_name)
#            |   -> Function: _get_topic_prefix(self)
#            |   -> Function: _publish_value(self, element_name, value)
#    ├── debug.log (Lines: 0)
#    └── gui_display.py (Lines: 588)
#            |   -> Import: datasets.logging
#            |   -> Import: datetime
#            |   -> Import: display.styling.style
#            |   -> Import: importlib.util
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: pathlib
#            |   -> Import: sys
#            |   -> Import: tkinter
#            |   -> Import: workers.mqtt_controller_util
#            |   -> Class: Application
#            |   -> Function: __init__(self)
#            |   -> Function: _apply_styles(self, theme_name)
#            |   -> Function: _build_child_container(self, path, parent_widget)
#            |   -> Function: _build_from_directory(self, path, parent_widget)
#            |   -> Function: _on_tab_change(self, event)
#            |   -> Function: _re_attach_tab(self, frame)
#            |   -> Function: _tear_off_tab(self, event)
#    └── left_60/
#        └── top_100/
#        └── top_100/
#            ├── tab_1_instrument/
#            ├── tab_2_markers/
#            ├── tab_3_presets/
#            ├── tab_4_intermod/
#            ├── tab_5_sweeping/
#            ├── tab_6_graphing/
#            └── tab_7_exepriment/
#            └── tab_1_instrument/
#                ├── sub_tab_1_connection/
#                ├── sub_tab_2_settings/
#                └── sub_tab_3_translator/
#                └── sub_tab_1_connection/
#                    └── gui_connection.py (Lines: 300)
#                            |   -> Import: collections
#                            |   -> Import: datasets.logging
#                            |   -> Import: datetime
#                            |   -> Import: display.styling.style
#                            |   -> Import: inspect
#                            |   -> Import: json
#                            |   -> Import: os
#                            |   -> Import: paho.mqtt.client
#                            |   -> Import: threading
#                            |   -> Import: tkinter
#                            |   -> Import: workers.mqtt_controller_util
#                            |   -> Class: InstrumentTab
#                            |   -> Class: MockMqttUtil
#                            |   -> Function: __init__(self)
#                            |   -> Function: __init__(self, master, mqtt_util)
#                            |   -> Function: _apply_styles(self, theme_name)
#                            |   -> Function: _create_widgets(self)
#                            |   -> Function: _on_message(self, topic, payload)
#                            |   -> Function: _publish_test_message(self, button_id)
#                            |   -> Function: _toggle_connection(self)
#                            |   -> Function: _update_button_style(self, button_id, value)
#                            |   -> Function: _update_connection_status(self, is_connected)
#                            |   -> Function: add_subscriber(self, topic_filter, callback_func)
#                            |   -> Function: publish_message(self, topic, subtopic, value)
#                └── sub_tab_2_settings/
#                    ├── sub_tab_1_frequency/
#                    ├── sub_tab_2_bandwidth/
#                    ├── sub_tab_3_amplitude/
#                    ├── sub_tab_4_markers/
#                    └── sub_tab_5_traces/
#                    └── sub_tab_1_frequency/
#                        └── gui_frequency.py (Lines: 197)
#                                |   -> Import: collections
#                                |   -> Import: datasets.logging
#                                |   -> Import: datetime
#                                |   -> Import: inspect
#                                |   -> Import: json
#                                |   -> Import: os
#                                |   -> Import: pathlib
#                                |   -> Import: styling.style
#                                |   -> Import: threading
#                                |   -> Import: tkinter
#                                |   -> Import: workers.mqtt_controller_util
#                                |   -> Class: FrequencySettingsTab
#                                |   -> Class: MockMqttUtil
#                                |   -> Function: __init__(self, parent_frame, mqtt_util)
#                                |   -> Function: _apply_styles(self, theme_name)
#                                |   -> Function: _create_span_preset_buttons(self, parent_frame)
#                                |   -> Function: _create_widgets(self)
#                                |   -> Function: _get_topic_prefix(self)
#                                |   -> Function: _publish_value(self, element_name, value)
#                                |   -> Function: add_subscriber(self, topic_filter, callback_func)
#                                |   -> Function: publish_message(self, topic, subtopic, value)
#                    └── sub_tab_2_bandwidth/
#                        └── gui_bandwidth.py (Lines: 336)
#                                |   -> Import: collections
#                                |   -> Import: datetime
#                                |   -> Import: display.styling.style
#                                |   -> Import: inspect
#                                |   -> Import: json
#                                |   -> Import: os
#                                |   -> Import: paho.mqtt.client
#                                |   -> Import: re
#                                |   -> Import: threading
#                                |   -> Import: tkinter
#                                |   -> Class: BandwidthSettingsTab
#                                |   -> Class: MockMqttUtil
#                                |   -> Function: __init__(self)
#                                |   -> Function: __init__(self, master, mqtt_util)
#                                |   -> Function: _apply_styles(self, theme_name)
#                                |   -> Function: _create_widgets(self)
#                                |   -> Function: _on_message(self, topic, payload)
#                                |   -> Function: _publish_test_message(self, event, button_id)
#                                |   -> Function: _update_button_style(self, button_id, value)
#                                |   -> Function: add_subscriber(self, topic_filter, callback_func)
#                                |   -> Function: console_log(message)
#                                |   -> Function: debug_log(message, file, version, function, console_print_func)
#                                |   -> Function: publish_message(self, topic, subtopic, value)
#                    └── sub_tab_3_amplitude/
#                        └── gui_amplitude.py (Lines: 390)
#                                |   -> Import: collections
#                                |   -> Import: datasets.logging
#                                |   -> Import: datetime
#                                |   -> Import: display.styling.style
#                                |   -> Import: inspect
#                                |   -> Import: json
#                                |   -> Import: numpy
#                                |   -> Import: os
#                                |   -> Import: paho.mqtt.client
#                                |   -> Import: threading
#                                |   -> Import: tkinter
#                                |   -> Import: workers.mqtt_controller_util
#                                |   -> Class: AmplitudeSettingsTab
#                                |   -> Function: __init__(self, master, mqtt_util)
#                                |   -> Function: _apply_styles(self, theme_name)
#                                |   -> Function: _create_widgets(self)
#                                |   -> Function: _find_closest_preset_value(self, value, preset_list)
#                                |   -> Function: _on_message(self, topic, payload)
#                                |   -> Function: _on_toggle_button_press(self, button_id)
#                                |   -> Function: _publish_test_message(self, button_id)
#                                |   -> Function: _update_button_style(self, button_id, value)
#                                |   -> Function: _update_descriptions(self, value, preset_list, label, var)
#                                |   -> Function: _update_toggle_button_style(self, button, state)
#                    └── sub_tab_4_markers/
#                        └── gui_markers.py (Lines: 188)
#                                |   -> Import: collections
#                                |   -> Import: datasets.logging
#                                |   -> Import: datetime
#                                |   -> Import: display.styling.style
#                                |   -> Import: inspect
#                                |   -> Import: json
#                                |   -> Import: numpy
#                                |   -> Import: os
#                                |   -> Import: paho.mqtt.client
#                                |   -> Import: threading
#                                |   -> Import: tkinter
#                                |   -> Import: workers.mqtt_controller_util
#                                |   -> Class: MarkerSettingsTab
#                                |   -> Function: __init__(self, master, mqtt_util)
#                                |   -> Function: _apply_styles(self, theme_name)
#                                |   -> Function: _create_widgets(self)
#                                |   -> Function: _on_message(self, topic, payload)
#                                |   -> Function: _publish_test_message(self, button_id)
#                                |   -> Function: _update_button_style(self, button_id, value)
#                    └── sub_tab_5_traces/
#                        └── gui_traces.py (Lines: 279)
#                                |   -> Import: collections
#                                |   -> Import: datetime
#                                |   -> Import: display.styling.style
#                                |   -> Import: inspect
#                                |   -> Import: json
#                                |   -> Import: os
#                                |   -> Import: paho.mqtt.client
#                                |   -> Import: pandas
#                                |   -> Import: threading
#                                |   -> Import: tkinter
#                                |   -> Class: MockMqttUtil
#                                |   -> Class: TraceSettingsTab
#                                |   -> Function: __init__(self)
#                                |   -> Function: __init__(self, master, mqtt_util)
#                                |   -> Function: _apply_styles(self, theme_name)
#                                |   -> Function: _create_widgets(self)
#                                |   -> Function: _on_message(self, topic, payload)
#                                |   -> Function: _publish_test_message(self, button_id)
#                                |   -> Function: _update_button_style(self, button_id, value)
#                                |   -> Function: add_subscriber(self, topic_filter, callback_func)
#                                |   -> Function: console_log(message)
#                                |   -> Function: debug_log(message, file, version, function, console_print_func)
#                                |   -> Function: publish_message(self, topic, subtopic, value)
#                └── sub_tab_3_translator/
#                    └── gui_translator.py (Lines: 186)
#                            |   -> Import: collections
#                            |   -> Import: datasets.logging
#                            |   -> Import: datetime
#                            |   -> Import: inspect
#                            |   -> Import: json
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: styling.style
#                            |   -> Import: threading
#                            |   -> Import: tkinter
#                            |   -> Import: workers.mqtt_controller_util
#                            |   -> Class: MockMqttUtil
#                            |   -> Class: VisaInterpreterTab
#                            |   -> Function: __init__(self, parent_frame, mqtt_util)
#                            |   -> Function: _apply_styles(self, theme_name)
#                            |   -> Function: _create_widgets(self)
#                            |   -> Function: _get_topic_prefix(self)
#                            |   -> Function: _load_data_to_treeview(self)
#                            |   -> Function: _publish_value(self, element_name, value)
#                            |   -> Function: add_subscriber(self, topic_filter, callback_func)
#                            |   -> Function: publish_message(self, topic, subtopic, value)
#            └── tab_2_markers/
#                ├── sub_tab_1_showtime/
#                └── sub_tab_2_editor/
#                └── sub_tab_1_showtime/
#                    └── gui_child_1_showtime.py (Lines: 190)
#                            |   -> Import: collections
#                            |   -> Import: datasets.logging
#                            |   -> Import: datetime
#                            |   -> Import: inspect
#                            |   -> Import: json
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: styling.style
#                            |   -> Import: threading
#                            |   -> Import: tkinter
#                            |   -> Import: workers.mqtt_controller_util
#                            |   -> Class: MockMqttUtil
#                            |   -> Class: ZoneGroupsDevicesFrame
#                            |   -> Function: __init__(self)
#                            |   -> Function: __init__(self, parent_frame, mqtt_util)
#                            |   -> Function: _apply_styles(self, theme_name)
#                            |   -> Function: _create_widgets(self)
#                            |   -> Function: _get_topic_prefix(self)
#                            |   -> Function: _make_device_buttons(self, zone_name, group_name)
#                            |   -> Function: _make_group_buttons(self, zone_name)
#                            |   -> Function: _make_zone_buttons(self)
#                            |   -> Function: _publish_value(self, element_name, value)
#                            |   -> Function: add_subscriber(self, topic_filter, callback_func)
#                            |   -> Function: publish_message(self, topic, subtopic, value)
#                └── sub_tab_2_editor/
#                    └── gui_child_2_editor.py (Lines: 361)
#                            |   -> Import: datasets.logging
#                            |   -> Import: datetime
#                            |   -> Import: display.styling.style
#                            |   -> Import: inspect
#                            |   -> Import: json
#                            |   -> Import: os
#                            |   -> Import: paho.mqtt.client
#                            |   -> Import: pathlib
#                            |   -> Import: sys
#                            |   -> Import: tkinter
#                            |   -> Import: workers.mqtt_controller_util
#                            |   -> Class: BaseGUIFrame
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _apply_styles(self, theme_name)
#                            |   -> Function: _on_mqtt_message(self, topic, payload)
#                            |   -> Function: _publish_custom_message(self)
#                            |   -> Function: _publish_version_message(self)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#            └── tab_3_presets/
#                ├── sub_tab_1_pusher/
#                ├── sub_tab_2_editor/
#                └── sub_tab_3_collector/
#                └── sub_tab_1_pusher/
#                    └── gui_child_1_pusher.py (Lines: 71)
#                            |   -> Import: datasets.logging
#                            |   -> Import: display.base_gui_component_rebuilt
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: tkinter
#                            |   -> Import: workers.mqtt_controller_util
#                            |   -> Class: LocalPresetsTab
#                            |   -> Function: __init__(self, master, mqtt_util)
#                            |   -> Function: _create_widgets(self)
#                └── sub_tab_2_editor/
#                    └── gui_child_2_editor.py (Lines: 90)
#                            |   -> Import: datasets.logging
#                            |   -> Import: display.base_gui_component_rebuilt
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: tkinter
#                            |   -> Import: workers.mqtt_controller_util
#                            |   -> Class: PresetEditorTab
#                            |   -> Function: __init__(self, master, mqtt_util)
#                            |   -> Function: _create_widgets(self)
#                            |   -> Function: on_double_click(event)
#                └── sub_tab_3_collector/
#                    └── gui_child_3_collector.py (Lines: 233)
#                            |   -> Import: collections
#                            |   -> Import: datasets.logging
#                            |   -> Import: datetime
#                            |   -> Import: display.styling.style
#                            |   -> Import: inspect
#                            |   -> Import: json
#                            |   -> Import: os
#                            |   -> Import: paho.mqtt.client
#                            |   -> Import: threading
#                            |   -> Import: tkinter
#                            |   -> Import: workers.mqtt_controller_util
#                            |   -> Class: DevicePresetsTab
#                            |   -> Class: MockMqttUtil
#                            |   -> Function: __init__(self)
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _apply_styles(self, theme_name)
#                            |   -> Function: _on_message(self, topic, payload)
#                            |   -> Function: _publish_test_message(self, event, button_id)
#                            |   -> Function: add_subscriber(self, topic_filter, callback_func)
#                            |   -> Function: create_widgets(self)
#                            |   -> Function: publish_message(self, topic, subtopic, value)
#                            |   -> Function: setup_layout(self)
#            └── tab_4_intermod/
#                ├── sub_tab_1_calculator/
#                └── sub_tab_2_future/
#                └── sub_tab_1_calculator/
#                    └── gui_child_1_calculator.py (Lines: 361)
#                            |   -> Import: datasets.logging
#                            |   -> Import: datetime
#                            |   -> Import: display.styling.style
#                            |   -> Import: inspect
#                            |   -> Import: json
#                            |   -> Import: os
#                            |   -> Import: paho.mqtt.client
#                            |   -> Import: pathlib
#                            |   -> Import: sys
#                            |   -> Import: tkinter
#                            |   -> Import: workers.mqtt_controller_util
#                            |   -> Class: BaseGUIFrame
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _apply_styles(self, theme_name)
#                            |   -> Function: _on_mqtt_message(self, topic, payload)
#                            |   -> Function: _publish_custom_message(self)
#                            |   -> Function: _publish_version_message(self)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#                └── sub_tab_2_future/
#                    ├── gui_1_top.py (Lines: 361)
#                            |   -> Import: datasets.logging
#                            |   -> Import: datetime
#                            |   -> Import: display.styling.style
#                            |   -> Import: inspect
#                            |   -> Import: json
#                            |   -> Import: os
#                            |   -> Import: paho.mqtt.client
#                            |   -> Import: pathlib
#                            |   -> Import: sys
#                            |   -> Import: tkinter
#                            |   -> Import: workers.mqtt_controller_util
#                            |   -> Class: BaseGUIFrame
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _apply_styles(self, theme_name)
#                            |   -> Function: _on_mqtt_message(self, topic, payload)
#                            |   -> Function: _publish_custom_message(self)
#                            |   -> Function: _publish_version_message(self)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#                    ├── gui_2_bottom copy.py (Lines: 361)
#                            |   -> Import: datasets.logging
#                            |   -> Import: datetime
#                            |   -> Import: display.styling.style
#                            |   -> Import: inspect
#                            |   -> Import: json
#                            |   -> Import: os
#                            |   -> Import: paho.mqtt.client
#                            |   -> Import: pathlib
#                            |   -> Import: sys
#                            |   -> Import: tkinter
#                            |   -> Import: workers.mqtt_controller_util
#                            |   -> Class: BaseGUIFrame
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _apply_styles(self, theme_name)
#                            |   -> Function: _on_mqtt_message(self, topic, payload)
#                            |   -> Function: _publish_custom_message(self)
#                            |   -> Function: _publish_version_message(self)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#                    └── gui_44_last.py (Lines: 361)
#                            |   -> Import: datasets.logging
#                            |   -> Import: datetime
#                            |   -> Import: display.styling.style
#                            |   -> Import: inspect
#                            |   -> Import: json
#                            |   -> Import: os
#                            |   -> Import: paho.mqtt.client
#                            |   -> Import: pathlib
#                            |   -> Import: sys
#                            |   -> Import: tkinter
#                            |   -> Import: workers.mqtt_controller_util
#                            |   -> Class: BaseGUIFrame
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _apply_styles(self, theme_name)
#                            |   -> Function: _on_mqtt_message(self, topic, payload)
#                            |   -> Function: _publish_custom_message(self)
#                            |   -> Function: _publish_version_message(self)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#            └── tab_5_sweeping/
#                ├── sub_tab_0_bands/
#                ├── sub_tab_0_configuration/
#                ├── sub_tab_1_single/
#                ├── sub_tab_2_meta_data/
#                ├── sub_tab_2_statistical/
#                ├── sub_tab_3_averaging/
#                └── gui_child_1_single.py (Lines: 84)
#                        |   -> Import: datasets.logging
#                        |   -> Import: display.styling.style
#                        |   -> Import: os
#                        |   -> Import: pathlib
#                        |   -> Import: tkinter
#                        |   -> Import: workers.mqtt_controller_util
#                        |   -> Class: Plotting3DTab
#                        |   -> Function: __init__(self, master, mqtt_util)
#                        |   -> Function: _apply_styles(self, theme_name)
#                        |   -> Function: _create_widgets(self)
#                        |   -> Function: _get_topic_prefix(self)
#                        |   -> Function: _publish_value(self, element_name, value)
#                └── sub_tab_0_bands/
#                    └── gui_bands.py (Lines: 361)
#                            |   -> Import: datasets.logging
#                            |   -> Import: datetime
#                            |   -> Import: display.styling.style
#                            |   -> Import: inspect
#                            |   -> Import: json
#                            |   -> Import: os
#                            |   -> Import: paho.mqtt.client
#                            |   -> Import: pathlib
#                            |   -> Import: sys
#                            |   -> Import: tkinter
#                            |   -> Import: workers.mqtt_controller_util
#                            |   -> Class: BaseGUIFrame
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _apply_styles(self, theme_name)
#                            |   -> Function: _on_mqtt_message(self, topic, payload)
#                            |   -> Function: _publish_custom_message(self)
#                            |   -> Function: _publish_version_message(self)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#                └── sub_tab_0_configuration/
#                    └── gui_configureation.py (Lines: 97)
#                            |   -> Import: datasets.logging
#                            |   -> Import: display.base_gui_component_rebuilt
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: tkinter
#                            |   -> Import: workers.mqtt_controller_util
#                            |   -> Class: ScanTab
#                            |   -> Function: __init__(self, master, mqtt_util)
#                            |   -> Function: _create_setting_row(self, parent, row, key, label_text, data_list, mqtt_topic_suffix)
#                            |   -> Function: _create_widgets(self)
#                └── sub_tab_1_single/
#                    └── gui_child_1_single.py (Lines: 97)
#                            |   -> Import: datasets.logging
#                            |   -> Import: display.styling.style
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: tkinter
#                            |   -> Import: workers.mqtt_controller_util
#                            |   -> Class: PlottingTab
#                            |   -> Function: __init__(self, master, mqtt_util)
#                            |   -> Function: _apply_styles(self, theme_name)
#                            |   -> Function: _create_widgets(self)
#                            |   -> Function: _get_topic_prefix(self)
#                            |   -> Function: _publish_value(self, element_name, value)
#                └── sub_tab_2_meta_data/
#                    └── gui_metadata.py (Lines: 73)
#                            |   -> Import: datasets.logging
#                            |   -> Import: display.base_gui_component_rebuilt
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: tkinter
#                            |   -> Import: workers.mqtt_controller_util
#                            |   -> Class: BandsTab
#                            |   -> Function: __init__(self, master, mqtt_util)
#                            |   -> Function: _create_widgets(self)
#                └── sub_tab_2_statistical/
#                    └── gui_child_2_statistical.py (Lines: 361)
#                            |   -> Import: datasets.logging
#                            |   -> Import: datetime
#                            |   -> Import: display.styling.style
#                            |   -> Import: inspect
#                            |   -> Import: json
#                            |   -> Import: os
#                            |   -> Import: paho.mqtt.client
#                            |   -> Import: pathlib
#                            |   -> Import: sys
#                            |   -> Import: tkinter
#                            |   -> Import: workers.mqtt_controller_util
#                            |   -> Class: BaseGUIFrame
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _apply_styles(self, theme_name)
#                            |   -> Function: _on_mqtt_message(self, topic, payload)
#                            |   -> Function: _publish_custom_message(self)
#                            |   -> Function: _publish_version_message(self)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#                └── sub_tab_3_averaging/
#                    └── gui_averaging.py (Lines: 128)
#                            |   -> Import: datasets.logging
#                            |   -> Import: display.styling.style
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: tkinter
#                            |   -> Import: workers.mqtt_controller_util
#                            |   -> Class: AveragingTab
#                            |   -> Function: __init__(self, master, mqtt_util)
#                            |   -> Function: _apply_styles(self, theme_name)
#                            |   -> Function: _create_widgets(self)
#                            |   -> Function: _get_topic_prefix(self)
#                            |   -> Function: _publish_value(self, element_name, value)
#            └── tab_6_graphing/
#                ├── sub_tab_1_from_file/
#                └── sub_tab_2_3d/
#                └── sub_tab_1_from_file/
#                    └── gui_child1_from_file.py (Lines: 361)
#                            |   -> Import: datasets.logging
#                            |   -> Import: datetime
#                            |   -> Import: display.styling.style
#                            |   -> Import: inspect
#                            |   -> Import: json
#                            |   -> Import: os
#                            |   -> Import: paho.mqtt.client
#                            |   -> Import: pathlib
#                            |   -> Import: sys
#                            |   -> Import: tkinter
#                            |   -> Import: workers.mqtt_controller_util
#                            |   -> Class: BaseGUIFrame
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _apply_styles(self, theme_name)
#                            |   -> Function: _on_mqtt_message(self, topic, payload)
#                            |   -> Function: _publish_custom_message(self)
#                            |   -> Function: _publish_version_message(self)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#                └── sub_tab_2_3d/
#                    └── gui_3d.py (Lines: 361)
#                            |   -> Import: datasets.logging
#                            |   -> Import: datetime
#                            |   -> Import: display.styling.style
#                            |   -> Import: inspect
#                            |   -> Import: json
#                            |   -> Import: os
#                            |   -> Import: paho.mqtt.client
#                            |   -> Import: pathlib
#                            |   -> Import: sys
#                            |   -> Import: tkinter
#                            |   -> Import: workers.mqtt_controller_util
#                            |   -> Class: BaseGUIFrame
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _apply_styles(self, theme_name)
#                            |   -> Function: _on_mqtt_message(self, topic, payload)
#                            |   -> Function: _publish_custom_message(self)
#                            |   -> Function: _publish_version_message(self)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#            └── tab_7_exepriment/
#                └── sub_tab_1_mosquitto/
#                └── sub_tab_1_mosquitto/
#                    └── gui_7_experiment.py (Lines: 361)
#                            |   -> Import: datasets.logging
#                            |   -> Import: datetime
#                            |   -> Import: display.styling.style
#                            |   -> Import: inspect
#                            |   -> Import: json
#                            |   -> Import: os
#                            |   -> Import: paho.mqtt.client
#                            |   -> Import: pathlib
#                            |   -> Import: sys
#                            |   -> Import: tkinter
#                            |   -> Import: workers.mqtt_controller_util
#                            |   -> Class: BaseGUIFrame
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _apply_styles(self, theme_name)
#                            |   -> Function: _on_mqtt_message(self, topic, payload)
#                            |   -> Function: _publish_custom_message(self)
#                            |   -> Function: _publish_version_message(self)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#    └── prototype/
#        └── gui_translator.py (Lines: 361)
#                |   -> Import: datasets.logging
#                |   -> Import: datetime
#                |   -> Import: display.styling.style
#                |   -> Import: inspect
#                |   -> Import: json
#                |   -> Import: os
#                |   -> Import: paho.mqtt.client
#                |   -> Import: pathlib
#                |   -> Import: sys
#                |   -> Import: tkinter
#                |   -> Import: workers.mqtt_controller_util
#                |   -> Class: BaseGUIFrame
#                |   -> Function: __init__(self, parent, mqtt_util)
#                |   -> Function: _apply_styles(self, theme_name)
#                |   -> Function: _on_mqtt_message(self, topic, payload)
#                |   -> Function: _publish_custom_message(self)
#                |   -> Function: _publish_version_message(self)
#                |   -> Function: debug_button_press(self)
#                |   -> Function: log_button_press(self)
#    └── right_40/
#        ├── bottom_90/
#        └── top_10/
#        └── bottom_90/
#            ├── tab_1_scan/
#            ├── tab_2_monitors/
#            ├── tab_3_debug/
#            ├── tab_4_conductor/
#            └── tab_5_configuration/
#            └── tab_1_scan/
#                ├── display_child_scan_view.py (Lines: 102)
#                        |   -> Import: display.console_logic
#                        |   -> Import: display.debug_logic
#                        |   -> Import: display.utils_scan_view
#                        |   -> Import: inspect
#                        |   -> Import: matplotlib.backends.backend_tkagg
#                        |   -> Import: matplotlib.figure
#                        |   -> Import: numpy
#                        |   -> Import: os
#                        |   -> Import: pandas
#                        |   -> Import: tkinter
#                        |   -> Class: ScanViewTab
#                        |   -> Function: __init__(self, master, app_instance)
#                        |   -> Function: _create_widgets(self)
#                └── gui_tab_1_scan.py (Lines: 361)
#                        |   -> Import: datasets.logging
#                        |   -> Import: datetime
#                        |   -> Import: display.styling.style
#                        |   -> Import: inspect
#                        |   -> Import: json
#                        |   -> Import: os
#                        |   -> Import: paho.mqtt.client
#                        |   -> Import: pathlib
#                        |   -> Import: sys
#                        |   -> Import: tkinter
#                        |   -> Import: workers.mqtt_controller_util
#                        |   -> Class: BaseGUIFrame
#                        |   -> Function: __init__(self, parent, mqtt_util)
#                        |   -> Function: _apply_styles(self, theme_name)
#                        |   -> Function: _on_mqtt_message(self, topic, payload)
#                        |   -> Function: _publish_custom_message(self)
#                        |   -> Function: _publish_version_message(self)
#                        |   -> Function: debug_button_press(self)
#                        |   -> Function: log_button_press(self)
#            └── tab_2_monitors/
#                ├── display_child_scan_monitor.py (Lines: 153)
#                        |   -> Import: display.console_logic
#                        |   -> Import: display.debug_logic
#                        |   -> Import: inspect
#                        |   -> Import: matplotlib.backends.backend_tkagg
#                        |   -> Import: matplotlib.figure
#                        |   -> Import: numpy
#                        |   -> Import: os
#                        |   -> Import: tkinter
#                        |   -> Class: ScanMonitorTab
#                        |   -> Function: __init__(self, master, app_instance)
#                        |   -> Function: _create_widgets(self)
#                └── gui_tab_2_monitors.py (Lines: 361)
#                        |   -> Import: datasets.logging
#                        |   -> Import: datetime
#                        |   -> Import: display.styling.style
#                        |   -> Import: inspect
#                        |   -> Import: json
#                        |   -> Import: os
#                        |   -> Import: paho.mqtt.client
#                        |   -> Import: pathlib
#                        |   -> Import: sys
#                        |   -> Import: tkinter
#                        |   -> Import: workers.mqtt_controller_util
#                        |   -> Class: BaseGUIFrame
#                        |   -> Function: __init__(self, parent, mqtt_util)
#                        |   -> Function: _apply_styles(self, theme_name)
#                        |   -> Function: _on_mqtt_message(self, topic, payload)
#                        |   -> Function: _publish_custom_message(self)
#                        |   -> Function: _publish_version_message(self)
#                        |   -> Function: debug_button_press(self)
#                        |   -> Function: log_button_press(self)
#            └── tab_3_debug/
#                ├── display_child_application_console.py (Lines: 181)
#                        |   -> Import: display.console_logic
#                        |   -> Import: display.debug_logic
#                        |   -> Import: inspect
#                        |   -> Import: os
#                        |   -> Import: src.gui_elements
#                        |   -> Import: tkinter
#                        |   -> Class: ConsoleTab
#                        |   -> Function: __init__(self, master, app_instance)
#                        |   -> Function: _clear_applications_console_action(self)
#                        |   -> Function: _create_widgets(self)
#                        |   -> Function: _on_tab_selected(self, event)
#                ├── display_child_debug.py (Lines: 376)
#                        |   -> Import: display.console_logic
#                        |   -> Import: display.debug_logic
#                        |   -> Import: inspect
#                        |   -> Import: os
#                        |   -> Import: settings_and_config.config_manager_save
#                        |   -> Import: subprocess
#                        |   -> Import: sys
#                        |   -> Import: threading
#                        |   -> Import: time
#                        |   -> Import: tkinter
#                        |   -> Class: DebugTab
#                        |   -> Function: __init__(self, master, app_instance)
#                        |   -> Function: _check_log_files(self)
#                        |   -> Function: _clear_debug_log_file_action(self)
#                        |   -> Function: _create_widgets(self)
#                        |   -> Function: _filter_and_display_log(self, event)
#                        |   -> Function: _on_tab_selected(self, event)
#                        |   -> Function: _open_data_folder_action(self)
#                        |   -> Function: _read_new_log_content(self, file_path, start_pos)
#                        |   -> Function: _toggle_debug_mode(self)
#                        |   -> Function: _toggle_debug_to_file_mode(self)
#                        |   -> Function: _toggle_include_console_messages_to_debug_file_mode(self)
#                        |   -> Function: _toggle_include_visa_messages_to_debug_file_mode(self)
#                        |   -> Function: _toggle_log_truncation_mode(self)
#                        |   -> Function: _toggle_visa_logging_mode(self)
#                └── gui_tab_3_debug.py (Lines: 361)
#                        |   -> Import: datasets.logging
#                        |   -> Import: datetime
#                        |   -> Import: display.styling.style
#                        |   -> Import: inspect
#                        |   -> Import: json
#                        |   -> Import: os
#                        |   -> Import: paho.mqtt.client
#                        |   -> Import: pathlib
#                        |   -> Import: sys
#                        |   -> Import: tkinter
#                        |   -> Import: workers.mqtt_controller_util
#                        |   -> Class: BaseGUIFrame
#                        |   -> Function: __init__(self, parent, mqtt_util)
#                        |   -> Function: _apply_styles(self, theme_name)
#                        |   -> Function: _on_mqtt_message(self, topic, payload)
#                        |   -> Function: _publish_custom_message(self)
#                        |   -> Function: _publish_version_message(self)
#                        |   -> Function: debug_button_press(self)
#                        |   -> Function: log_button_press(self)
#            └── tab_4_conductor/
#                └── gui_mqtt_conductor.py (Lines: 374)
#                        |   -> Import: collections
#                        |   -> Import: datasets.logging
#                        |   -> Import: datetime
#                        |   -> Import: display.styling.style
#                        |   -> Import: inspect
#                        |   -> Import: itertools
#                        |   -> Import: json
#                        |   -> Import: os
#                        |   -> Import: paho.mqtt.client
#                        |   -> Import: subprocess
#                        |   -> Import: threading
#                        |   -> Import: tkinter
#                        |   -> Import: workers.mqtt_controller_util
#                        |   -> Class: MqttConductorFrame
#                        |   -> Function: __init__(self, parent, mqtt_util)
#                        |   -> Function: _apply_styles(self, theme_name)
#                        |   -> Function: _clear_log(self)
#                        |   -> Function: _create_widgets(self)
#                        |   -> Function: _on_message(self, topic, payload)
#                        |   -> Function: _on_sys_message(self, topic, payload)
#                        |   -> Function: _publish_custom_message(self)
#                        |   -> Function: log_to_gui(self, message)
#                        |   -> Function: log_to_table(self, topic, message)
#            └── tab_5_configuration/
#                └── gui_tab_5_configuration.py (Lines: 176)
#                        |   -> Import: datetime
#                        |   -> Import: inspect
#                        |   -> Import: os
#                        |   -> Import: tkinter
#                        |   -> Class: InitialConfigurationTab
#                        |   -> Function: __init__(self, master)
#                        |   -> Function: _create_widgets(self)
#                        |   -> Function: _populate_config_table(self)
#                        |   -> Function: _reload_config_action(self)
#                        |   -> Function: _save_program_configure_action(self)
#                        |   -> Function: console_log(message)
#                        |   -> Function: debug_log(message, file, version, function)
#        └── top_10/
#            └── gui_start_stop.py (Lines: 361)
#                    |   -> Import: datasets.logging
#                    |   -> Import: datetime
#                    |   -> Import: display.styling.style
#                    |   -> Import: inspect
#                    |   -> Import: json
#                    |   -> Import: os
#                    |   -> Import: paho.mqtt.client
#                    |   -> Import: pathlib
#                    |   -> Import: sys
#                    |   -> Import: tkinter
#                    |   -> Import: workers.mqtt_controller_util
#                    |   -> Class: BaseGUIFrame
#                    |   -> Function: __init__(self, parent, mqtt_util)
#                    |   -> Function: _apply_styles(self, theme_name)
#                    |   -> Function: _on_mqtt_message(self, topic, payload)
#                    |   -> Function: _publish_custom_message(self)
#                    |   -> Function: _publish_version_message(self)
#                    |   -> Function: debug_button_press(self)
#                    |   -> Function: log_button_press(self)
#    └── styling/
#        └── style.py (Lines: 112)
#                |   -> Import: os
#└── utils/
#└── workers/
#    ├── Experiments/
#    ├── Instrument/
#    ├── Marker_files/
#    ├── Plotting/
#    ├── Presets/
#    ├── Scanning/
#    ├── controls/
#    ├── orchestrator/
#    ├── zones_groups_devices/
#    ├── connection_status_logic.py (Lines: 78)
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: tkinter
#            |   -> Function: update_connection_status_logic(app_instance, is_connected, is_running, console_print_func)
#    ├── mqtt_controller_util.py (Lines: 336)
#            |   -> Import: datasets.logging
#            |   -> Import: datetime
#            |   -> Import: inspect
#            |   -> Import: json
#            |   -> Import: os
#            |   -> Import: paho.mqtt.client
#            |   -> Import: pathlib
#            |   -> Import: subprocess
#            |   -> Import: sys
#            |   -> Import: threading
#            |   -> Class: MqttControllerUtility
#            |   -> Function: __init__(self, print_to_gui_func, log_treeview_func)
#            |   -> Function: add_subscriber(self, topic_filter, callback_func)
#            |   -> Function: check_status(self)
#            |   -> Function: connect_mqtt(self)
#            |   -> Function: on_connect(self, client, userdata, flags, rc)
#            |   -> Function: on_message(self, client, userdata, msg)
#            |   -> Function: publish_message(self, topic, subtopic, value)
#            |   -> Function: show_topics(self)
#            |   -> Function: start_mosquitto(self)
#            |   -> Function: stop_mosquitto(self)
#    ├── utils_csv_writer.py (Lines: 125)
#            |   -> Import: csv
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Function: write_scan_data_to_csv(file_path, header, data, app_instance_ref, append_mode, console_print_func)
#    ├── utils_display_monitor.py (Lines: 325)
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: matplotlib.offsetbox
#            |   -> Import: numpy
#            |   -> Import: os
#            |   -> Import: traceback
#            |   -> Function: _find_and_plot_peaks(ax, data, start_freq_mhz, end_freq_mhz)
#            |   -> Function: _setup_zoom_events(ax, canvas, original_xlim)
#            |   -> Function: clear_monitor_plots(scan_monitor_tab_instance)
#            |   -> Function: on_double_click(event)
#            |   -> Function: on_press(event)
#            |   -> Function: on_release(event)
#            |   -> Function: reset_zoom(ax, canvas)
#            |   -> Function: update_annot(event)
#            |   -> Function: update_annot(event)
#            |   -> Function: update_annot(event)
#            |   -> Function: update_bottom_plot(scan_monitor_tab_instance, data, start_freq_mhz, end_freq_mhz, plot_title)
#            |   -> Function: update_middle_plot(scan_monitor_tab_instance, data, start_freq_mhz, end_freq_mhz, plot_title)
#            |   -> Function: update_top_plot(scan_monitor_tab_instance, data, start_freq_mhz, end_freq_mhz, plot_title)
#    └── utils_scan_view.py (Lines: 182)
#            |   -> Import: display.console_logic
#            |   -> Import: display.debug_logic
#            |   -> Import: inspect
#            |   -> Import: matplotlib.offsetbox
#            |   -> Import: numpy
#            |   -> Import: os
#            |   -> Import: traceback
#            |   -> Function: _find_and_plot_peaks(ax, data, start_freq_mhz, end_freq_mhz)
#            |   -> Function: _setup_zoom_events(ax, canvas, original_xlim)
#            |   -> Function: on_double_click(event)
#            |   -> Function: on_press(event)
#            |   -> Function: on_release(event)
#            |   -> Function: reset_zoom(ax, canvas)
#            |   -> Function: update_annot(event)
#            |   -> Function: update_single_plot(scan_view_tab_instance, data, start_freq_mhz, end_freq_mhz, plot_title, line_color)
#    └── controls/
#        ├── tab_markers_child_control_poke.py (Lines: 72)
#                |   -> Import: datetime
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: tkinter
#                |   -> Import: utils_showtime_poke
#                |   -> Class: PokeTab
#                |   -> Function: __init__(self, parent_notebook, showtime_tab_instance)
#                |   -> Function: _create_widgets(self)
#        ├── tab_markers_child_control_rbw.py (Lines: 85)
#                |   -> Import: datetime
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: ref.ref_scanner_setting_lists
#                |   -> Import: tkinter
#                |   -> Import: utils_showtime_rbw
#                |   -> Class: RBWTab
#                |   -> Function: __init__(self, parent_notebook, showtime_tab_instance)
#                |   -> Function: _create_widgets(self)
#        ├── tab_markers_child_control_span.py (Lines: 85)
#                |   -> Import: datetime
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: ref.ref_scanner_setting_lists
#                |   -> Import: tkinter
#                |   -> Import: utils_showtime_span
#                |   -> Class: SpanTab
#                |   -> Function: __init__(self, parent_notebook, showtime_tab_instance)
#                |   -> Function: _create_widgets(self)
#        ├── tab_markers_child_control_traces.py (Lines: 143)
#                |   -> Import: datetime
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: tkinter
#                |   -> Import: utils_showtime_trace
#                |   -> Class: TracesTab
#                |   -> Function: __init__(self, parent_notebook, showtime_tab_instance)
#                |   -> Function: _create_widgets(self)
#                |   -> Function: _toggle_and_execute(self, button_type)
#                |   -> Function: _update_button_styles(self)
#        ├── tab_markers_child_control_zone_zoom.py (Lines: 188)
#                |   -> Import: datetime
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: tkinter
#                |   -> Import: utils_showtime_zone_zoom
#                |   -> Class: ZoneZoomTab
#                |   -> Function: __init__(self, parent_notebook, showtime_tab_instance)
#                |   -> Function: _create_widgets(self)
#                |   -> Function: _on_tab_selected(self, event)
#                |   -> Function: _sync_ui_from_state(self)
#        ├── tab_markers_parent_bottom_controls.py (Lines: 214)
#                |   -> Import: datetime
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: src.program_style
#                |   -> Import: tab_markers_child_control_poke
#                |   -> Import: tab_markers_child_control_rbw
#                |   -> Import: tab_markers_child_control_span
#                |   -> Import: tab_markers_child_control_traces
#                |   -> Import: tab_markers_child_control_zone_zoom
#                |   -> Import: tkinter
#                |   -> Class: ControlsFrame
#                |   -> Function: __init__(self, parent_frame, showtime_tab_instance)
#                |   -> Function: _create_widgets(self)
#                |   -> Function: _on_tab_selected(self, event)
#                |   -> Function: _update_control_buttons(self)
#                |   -> Function: switch_to_tab(self, tab_name)
#        ├── utils_showtime_plot.py (Lines: 76)
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: display.utils_display_monitor
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: pandas
#                |   -> Import: ref.ref_frequency_bands
#                |   -> Import: tkinter
#                |   -> Function: plot_all_traces(showtime_tab_instance, trace_data_dict, view_name, start_freq_mhz, stop_freq_mhz)
#        ├── utils_showtime_poke.py (Lines: 86)
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: pandas
#                |   -> Import: ref.ref_frequency_bands
#                |   -> Import: settings_and_config.config_manager_save
#                |   -> Import: utils_showtime_span
#                |   -> Import: yak.Yakety_Yak
#                |   -> Import: yak.utils_yakbeg_handler
#                |   -> Function: on_poke_action(showtime_tab_instance)
#        ├── utils_showtime_rbw.py (Lines: 91)
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: process_math.math_frequency_translation
#                |   -> Import: settings_and_config.config_manager_save
#                |   -> Import: tkinter
#                |   -> Import: yak.Yakety_Yak
#                |   -> Import: yak.utils_yak_setting_handler
#                |   -> Function: on_rbw_button_click(showtime_tab, rbw_hz)
#                |   -> Function: set_rbw_logic(app_instance, rbw_hz, console_print_func)
#        ├── utils_showtime_span.py (Lines: 93)
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: process_math.math_frequency_translation
#                |   -> Import: settings_and_config.config_manager_save
#                |   -> Import: yak.utils_yak_setting_handler
#                |   -> Import: yak.utils_yakbeg_handler
#                |   -> Import: yak.utils_yaknab_handler
#                |   -> Function: on_span_button_click(showtime_tab_instance, span_hz)
#        ├── utils_showtime_trace.py (Lines: 138)
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: numpy
#                |   -> Import: os
#                |   -> Import: pandas
#                |   -> Import: process_math.math_frequency_translation
#                |   -> Import: settings_and_config.config_manager_save
#                |   -> Import: tkinter
#                |   -> Import: utils_showtime_plot
#                |   -> Import: yak.utils_yakbeg_handler
#                |   -> Import: yak.utils_yaknab_handler
#                |   -> Function: _get_and_plot_traces(traces_tab_instance, view_name)
#                |   -> Function: execute_trace_action(traces_tab_instance, action_type)
#                |   -> Function: sync_trace_modes(traces_tab_instance)
#        └── utils_showtime_zone_zoom.py (Lines: 312)
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: process_math.math_frequency_translation
#                |   -> Import: ref.ref_frequency_bands
#                |   -> Import: settings_and_config.config_manager_save
#                |   -> Import: yak.utils_yakbeg_handler
#                |   -> Function: _buffer_start_stop_frequencies(start_freq_mhz, stop_freq_mhz, buffer_mhz)
#                |   -> Function: set_span_to_all_markers(showtime_tab_instance, zone_zoom_tab)
#                |   -> Function: set_span_to_device(showtime_tab_instance, zone_zoom_tab)
#                |   -> Function: set_span_to_group(showtime_tab_instance, zone_zoom_tab)
#                |   -> Function: set_span_to_zone(showtime_tab_instance, zone_zoom_tab)
#    └── Experiments/
#        ├── __init__.py (Lines: 24)
#        ├── tab_experiments_child_JSON_api.py (Lines: 489)
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: requests
#                |   -> Import: subprocess
#                |   -> Import: sys
#                |   -> Import: threading
#                |   -> Import: time
#                |   -> Import: tkinter
#                |   -> Import: webbrowser
#                |   -> Class: JsonApiTab
#                |   -> Function: __init__(self, master, app_instance, console_print_func)
#                |   -> Function: _create_widgets(self)
#                |   -> Function: _on_tab_selected(self, event)
#                |   -> Function: _open_all_api_scans(self)
#                |   -> Function: _open_api_scan_data(self, filename)
#                |   -> Function: _open_latest_api_scan(self)
#                |   -> Function: _open_markers_api(self)
#                |   -> Function: _open_scan_in_progress_api(self)
#                |   -> Function: _run_json_api_thread_target(self)
#                |   -> Function: _start_json_api(self)
#                |   -> Function: _stop_json_api(self)
#                |   -> Function: _update_api_button_states(self)
#                |   -> Function: fetch_and_display()
#        ├── tab_experiments_child_credits.py (Lines: 152)
#                |   -> Import: PIL
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: src.program_style
#                |   -> Import: tkinter
#                |   -> Import: webbrowser
#                |   -> Class: CreditsTab
#                |   -> Function: __init__(self, parent_notebook, app_instance, console_print_func)
#                |   -> Function: _on_tab_selected(self, event)
#                |   -> Function: _open_github_link(self)
#        ├── tab_experiments_child_initial_configuration.py (Lines: 195)
#                |   -> Import: configparser
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: ref.ref_file_paths
#                |   -> Import: ref.ref_program_default_values
#                |   -> Import: settings_and_config.config_manager_save
#                |   -> Import: tkinter
#                |   -> Class: InitialConfigurationTab
#                |   -> Function: __init__(self, master, app_instance, console_print_func, style_obj)
#                |   -> Function: _create_widgets(self)
#                |   -> Function: _populate_config_table(self)
#                |   -> Function: _reload_config_action(self)
#                |   -> Function: _save_program_configure_action(self)
#        ├── tab_experiments_child_intermod.py (Lines: 680)
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: pandas
#                |   -> Import: process_math.calculate_intermod
#                |   -> Import: process_math.ploting_intermod_zones
#                |   -> Import: random
#                |   -> Import: subprocess
#                |   -> Import: sys
#                |   -> Import: tkinter
#                |   -> Import: tkinter.font
#                |   -> Import: typing
#                |   -> Class: InterModTab
#                |   -> Function: __init__(self, master, app_instance, console_print_func)
#                |   -> Function: _browse_markers_file(self)
#                |   -> Function: _create_widgets(self)
#                |   -> Function: _display_imd_results(self, df)
#                |   -> Function: _load_intermod_csv(self)
#                |   -> Function: _on_tab_selected(self, event)
#                |   -> Function: _on_treeview_header_click(self, event)
#                |   -> Function: _open_intermod_csv(self)
#                |   -> Function: _open_intermod_map(self)
#                |   -> Function: _parse_markers_csv(self, csv_path)
#                |   -> Function: _plot_imd_results(self)
#                |   -> Function: _process_imd(self)
#                |   -> Function: _sort_treeview(self, col_name, order)
#        ├── tab_experiments_child_yak_beg.py (Lines: 344)
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: numpy
#                |   -> Import: os
#                |   -> Import: tkinter
#                |   -> Import: yak.utils_yakbeg_handler
#                |   -> Class: YakBegTab
#                |   -> Function: __init__(self, master, app_instance, console_print_func)
#                |   -> Function: _create_widgets(self)
#                |   -> Function: _on_freq_center_span_beg(self)
#                |   -> Function: _on_freq_start_stop_beg(self)
#                |   -> Function: _on_marker_place_all_beg(self)
#                |   -> Function: _on_push_to_monitor(self)
#                |   -> Function: _on_tab_selected(self, event)
#                |   -> Function: _on_trace_data_beg(self)
#                |   -> Function: _on_trace_modes_beg(self)
#        └── tab_experiments_colouring.py (Lines: 306)
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: re
#                |   -> Import: src.program_style
#                |   -> Import: tkinter
#                |   -> Class: ColouringTab
#                |   -> Function: __init__(self, master, app_instance, console_print_func)
#                |   -> Function: _add_color_display_row(self, parent_frame, text, hex_color, row_idx, indent)
#                |   -> Function: _create_widgets(self)
#                |   -> Function: _on_mousewheel(self, event)
#                |   -> Function: _on_tab_selected(self, event)
#                |   -> Function: _populate_content(self)
#    └── Instrument/
#        ├── connection/
#        ├── settings/
#        ├── visa/
#        ├── TAB_INSTRUMENT_PARENT.py (Lines: 49)
#                |   -> Import: connection.tab_instrument_child_connection
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: settings.tab_instrument_child_settings
#                |   -> Import: tkinter
#                |   -> Import: visa.tab_instrument_child_visa_interpreter
#                |   -> Class: TAB_INSTRUMENT_PARENT
#                |   -> Function: __init__(self, parent, app_instance)
#                |   -> Function: _create_widgets(self)
#                |   -> Function: _on_child_tab_selected(self, event)
#                |   -> Function: _on_parent_tab_selected(self, event)
#        └── __init__.py (Lines: 0)
#        └── connection/
#            ├── instrument_logic.py (Lines: 232)
#                    |   -> Import: display.console_logic
#                    |   -> Import: display.debug_logic
#                    |   -> Import: inspect
#                    |   -> Import: os
#                    |   -> Import: pyvisa
#                    |   -> Import: sys
#                    |   -> Import: time
#                    |   -> Import: tkinter
#                    |   -> Import: traceback
#                    |   -> Import: utils_instrument_connection
#                    |   -> Import: yak.Yakety_Yak
#                    |   -> Function: connect_instrument_logic(app_instance, console_print_func)
#                    |   -> Function: disconnect_instrument_logic(app_instance, console_print_func)
#                    |   -> Function: populate_resources_logic(app_instance, combobox_widget, console_print_func)
#                    |   -> Function: query_current_settings_logic(app_instance, console_print_func)
#            ├── tab_instrument_child_connection.py (Lines: 223)
#                    |   -> Import: display.console_logic
#                    |   -> Import: display.debug_logic
#                    |   -> Import: inspect
#                    |   -> Import: instrument_logic
#                    |   -> Import: os
#                    |   -> Import: threading
#                    |   -> Import: time
#                    |   -> Import: tkinter
#                    |   -> Import: yak.utils_yak_setting_handler
#                    |   -> Class: InstrumentTab
#                    |   -> Function: __init__(self, master, app_instance, console_print_func, parent_notebook_ref)
#                    |   -> Function: _connect_instrument(self)
#                    |   -> Function: _create_widgets(self)
#                    |   -> Function: _disconnect_instrument(self)
#                    |   -> Function: _on_tab_selected(self, event)
#                    |   -> Function: _populate_resources(self)
#                    |   -> Function: _power_cycle_instrument(self)
#                    |   -> Function: _reset_instrument(self)
#                    |   -> Function: _toggle_connection(self)
#                    |   -> Function: _update_connection_status(self)
#            └── utils_instrument_connection.py (Lines: 194)
#                    |   -> Import: display.console_logic
#                    |   -> Import: display.debug_logic
#                    |   -> Import: inspect
#                    |   -> Import: os
#                    |   -> Import: pyvisa
#                    |   -> Function: connect_to_instrument(resource_name, console_print_func)
#                    |   -> Function: disconnect_instrument(inst, console_print_func)
#                    |   -> Function: list_visa_resources(console_print_func)
#        └── settings/
#            ├── tab_instrument_child_settings.py (Lines: 120)
#                    |   -> Import: display.console_logic
#                    |   -> Import: display.debug_logic
#                    |   -> Import: inspect
#                    |   -> Import: os
#                    |   -> Import: src.program_style
#                    |   -> Import: tab_instrument_child_settings_amplitude
#                    |   -> Import: tab_instrument_child_settings_bandwidth
#                    |   -> Import: tab_instrument_child_settings_frequency
#                    |   -> Import: tab_instrument_child_settings_markers
#                    |   -> Import: tab_instrument_child_settings_traces
#                    |   -> Import: tkinter
#                    |   -> Class: SettingsParentTab
#                    |   -> Function: __init__(self, master, app_instance, console_print_func)
#                    |   -> Function: _on_tab_selected(self, event)
#                    |   -> Function: refresh_all_child_tabs(self)
#            ├── tab_instrument_child_settings_amplitude.py (Lines: 348)
#                    |   -> Import: display.console_logic
#                    |   -> Import: display.debug_logic
#                    |   -> Import: inspect
#                    |   -> Import: os
#                    |   -> Import: ref.ref_scanner_setting_lists
#                    |   -> Import: settings_and_config.config_manager_instruments
#                    |   -> Import: settings_and_config.config_manager_save
#                    |   -> Import: tkinter
#                    |   -> Import: yak
#                    |   -> Import: yak.Yakety_Yak
#                    |   -> Class: AmplitudeSettingsTab
#                    |   -> Function: __init__(self, master, app_instance, console_print_func)
#                    |   -> Function: _create_widgets(self)
#                    |   -> Function: _find_closest_preset_value(self, value, preset_list)
#                    |   -> Function: _on_power_attenuation_change(self, event)
#                    |   -> Function: _on_ref_level_change(self, event)
#                    |   -> Function: _on_resize(self, event)
#                    |   -> Function: _save_settings_handler(self)
#                    |   -> Function: _set_ui_initial_state(self)
#                    |   -> Function: _update_descriptions(self, value, preset_list, label, var)
#                    |   -> Function: _update_power_attenuation_display(self, value)
#                    |   -> Function: _update_ref_level_display(self, value)
#                    |   -> Function: _update_toggle_button_style(self, button, state)
#            ├── tab_instrument_child_settings_bandwidth.py (Lines: 509)
#                    |   -> Import: display.console_logic
#                    |   -> Import: display.debug_logic
#                    |   -> Import: inspect
#                    |   -> Import: os
#                    |   -> Import: re
#                    |   -> Import: ref.ref_scanner_setting_lists
#                    |   -> Import: settings_and_config.config_manager_instruments
#                    |   -> Import: settings_and_config.config_manager_save
#                    |   -> Import: tkinter
#                    |   -> Import: yak
#                    |   -> Import: yak.utils_yaknab_handler
#                    |   -> Class: BandwidthSettingsTab
#                    |   -> Function: __init__(self, master, app_instance, console_print_func)
#                    |   -> Function: _create_widgets(self)
#                    |   -> Function: _on_averaging_count_selected(self, event, trace_number)
#                    |   -> Function: _on_averaging_toggle(self, trace_number, state)
#                    |   -> Function: _on_continuous_mode_change(self, event)
#                    |   -> Function: _on_rbw_selected(self, event)
#                    |   -> Function: _on_tab_selected(self, event)
#                    |   -> Function: _on_vbw_auto_toggle(self)
#                    |   -> Function: _on_vbw_selected(self, event)
#                    |   -> Function: _save_settings_handler(self)
#                    |   -> Function: _sync_ui_from_app_state(self)
#                    |   -> Function: _update_rbw_combobox_display(self)
#                    |   -> Function: _update_toggle_button_style(self, button, state)
#                    |   -> Function: _update_vbw_combobox_display(self)
#            ├── tab_instrument_child_settings_frequency.py (Lines: 498)
#                    |   -> Import: display.console_logic
#                    |   -> Import: display.debug_logic
#                    |   -> Import: inspect
#                    |   -> Import: numpy
#                    |   -> Import: os
#                    |   -> Import: ref.ref_file_paths
#                    |   -> Import: ref.ref_program_default_values
#                    |   -> Import: ref.ref_scanner_setting_lists
#                    |   -> Import: settings_and_config.config_manager_instruments
#                    |   -> Import: settings_and_config.config_manager_save
#                    |   -> Import: tkinter
#                    |   -> Import: yak.utils_yakbeg_handler
#                    |   -> Class: FrequencySettingsTab
#                    |   -> Function: __init__(self, master, app_instance, console_print_func, style_obj)
#                    |   -> Function: _create_span_preset_buttons(self, parent_frame)
#                    |   -> Function: _create_widgets(self)
#                    |   -> Function: _on_freq_center_span_beg(self)
#                    |   -> Function: _on_freq_start_stop_beg(self)
#                    |   -> Function: _on_span_preset_button_click(self, preset)
#                    |   -> Function: _on_span_variable_change(self)
#                    |   -> Function: _round_variables(self)
#                    |   -> Function: _save_settings_handler(self)
#                    |   -> Function: _set_default_variables(self)
#                    |   -> Function: _update_span_button_styles(self)
#                    |   -> Function: truncate_float(f)
#            ├── tab_instrument_child_settings_markers.py (Lines: 206)
#                    |   -> Import: display.console_logic
#                    |   -> Import: display.debug_logic
#                    |   -> Import: inspect
#                    |   -> Import: os
#                    |   -> Import: settings_and_config.config_manager_marker
#                    |   -> Import: settings_and_config.config_manager_save
#                    |   -> Import: tkinter
#                    |   -> Import: yak.utils_yakbeg_handler
#                    |   -> Class: MarkerSettingsTab
#                    |   -> Function: __init__(self, master, app_instance, console_print_func)
#                    |   -> Function: _create_widgets(self)
#                    |   -> Function: _on_marker_place_all_beg(self)
#                    |   -> Function: _save_settings_handler(self)
#                    |   -> Function: _set_default_variables(self)
#            └── tab_instrument_child_settings_traces.py (Lines: 489)
#                    |   -> Import: display.console_logic
#                    |   -> Import: display.debug_logic
#                    |   -> Import: display.utils_display_monitor
#                    |   -> Import: display.utils_scan_view
#                    |   -> Import: inspect
#                    |   -> Import: os
#                    |   -> Import: pandas
#                    |   -> Import: settings_and_config.config_manager_instruments
#                    |   -> Import: settings_and_config.config_manager_save
#                    |   -> Import: tkinter
#                    |   -> Import: yak.utils_yakbeg_handler
#                    |   -> Import: yak.utils_yaknab_handler
#                    |   -> Class: TraceSettingsTab
#                    |   -> Function: __init__(self, master, app_instance, console_print_func)
#                    |   -> Function: _create_widgets(self)
#                    |   -> Function: _on_all_traces_nab(self)
#                    |   -> Function: _on_push_to_monitor(self)
#                    |   -> Function: _on_tab_selected(self, event)
#                    |   -> Function: _on_trace_data_beg(self)
#                    |   -> Function: _on_trace_modes_beg(self)
#                    |   -> Function: _plot_all_traces_to_monitor(self)
#                    |   -> Function: _save_settings_handler(self)
#        └── visa/
#            ├── ref_visa_commands.py (Lines: 411)
#                    |   -> Function: get_default_visa_commands()
#            ├── tab_instrument_child_visa_interpreter.py (Lines: 417)
#                    |   -> Import: datetime
#                    |   -> Import: display.console_logic
#                    |   -> Import: display.debug_logic
#                    |   -> Import: inspect
#                    |   -> Import: os
#                    |   -> Import: ref.ref_file_paths
#                    |   -> Import: src.program_style
#                    |   -> Import: threading
#                    |   -> Import: time
#                    |   -> Import: tkinter
#                    |   -> Import: utils_visa_interpreter_commands
#                    |   -> Import: utils_visa_interpreter_files
#                    |   -> Class: VisaInterpreterTab
#                    |   -> Function: __init__(self, parent, app_instance, console_print_func)
#                    |   -> Function: _add_new_row(self)
#                    |   -> Function: _delete_selected_row(self)
#                    |   -> Function: _edit_cell(self, item, col_index)
#                    |   -> Function: _handle_connection_status_change_event(self, event)
#                    |   -> Function: _on_double_click(self, event)
#                    |   -> Function: _on_treeview_focus(self, event)
#                    |   -> Function: _on_treeview_select(self, event)
#                    |   -> Function: _refresh_data(self)
#                    |   -> Function: _save_data_to_csv(self)
#                    |   -> Function: _set_ui_initial_state(self)
#                    |   -> Function: _sort_treeview(self, tv, col)
#                    |   -> Function: bind_events(self)
#                    |   -> Function: create_widgets(self)
#                    |   -> Function: load_data_to_treeview(self)
#                    |   -> Function: numeric_sort_key(x)
#                    |   -> Function: on_entry_change(e)
#                    |   -> Function: on_focus_out(e)
#                    |   -> Function: setup_layout(self)
#            ├── utils_visa_interpreter_commands.py (Lines: 122)
#                    |   -> Import: datetime
#                    |   -> Import: display.console_logic
#                    |   -> Import: display.debug_logic
#                    |   -> Import: inspect
#                    |   -> Import: os
#                    |   -> Import: tkinter
#                    |   -> Import: yak.utils_yak_visa
#                    |   -> Class: VisaCommandExecutor
#                    |   -> Function: __init__(self, app_instance, console_print_func)
#                    |   -> Function: _get_instrument_status(self)
#                    |   -> Function: on_do_command(self, command)
#                    |   -> Function: on_execute_command(self, command)
#                    |   -> Function: on_query_command(self, command)
#                    |   -> Function: on_set_command(self, command)
#            └── utils_visa_interpreter_files.py (Lines: 182)
#                    |   -> Import: csv
#                    |   -> Import: datetime
#                    |   -> Import: display.console_logic
#                    |   -> Import: display.debug_logic
#                    |   -> Import: inspect
#                    |   -> Import: os
#                    |   -> Import: ref.ref_file_paths
#                    |   -> Import: ref_visa_commands
#                    |   -> Function: create_default_data_file(data_file)
#                    |   -> Function: initialize_data_file_and_load()
#                    |   -> Function: load_visa_commands_data(data_file)
#                    |   -> Function: save_visa_commands_data(data_file, data)
#    └── Marker_files/
#        ├── tab_markers_child_import_and_edit.py (Lines: 847)
#                |   -> Import: csv
#                |   -> Import: datetime
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: files.utils_marker_report_converter
#                |   -> Import: inspect
#                |   -> Import: json
#                |   -> Import: os
#                |   -> Import: re
#                |   -> Import: src.gui_elements
#                |   -> Import: sys
#                |   -> Import: threading
#                |   -> Import: tkinter
#                |   -> Import: xml.etree.ElementTree
#                |   -> Class: ReportConverterTab
#                |   -> Function: __init__(self, master, app_instance, console_print_func)
#                |   -> Function: _create_widgets(self)
#                |   -> Function: _disable_buttons(self)
#                |   -> Function: _enable_buttons(self)
#                |   -> Function: _increment_string_with_trailing_digits(self, text)
#                |   -> Function: _initiate_conversion(self, file_type)
#                |   -> Function: _load_markers_file(self)
#                |   -> Function: _navigate_cells(self, current_item, current_col_index, direction)
#                |   -> Function: _on_tab_selected(self, event)
#                |   -> Function: _on_tree_double_click(self, event)
#                |   -> Function: _on_tree_header_click(self, event)
#                |   -> Function: _perform_conversion(self, file_path, file_type)
#                |   -> Function: _populate_marker_tree(self)
#                |   -> Function: _save_markers_file_internally(self)
#                |   -> Function: _save_open_air_csv(self)
#                |   -> Function: _sort_treeview(self, column_name, ascending)
#                |   -> Function: _start_editing_cell(self, item, col_index, initial_value)
#                |   -> Function: _update_markers_display_tab_data(self)
#                |   -> Function: get_sort_key(item)
#                |   -> Function: on_edit_complete_and_navigate(event, navigate_direction)
#        ├── utils_file_markers_handling.py (Lines: 141)
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: numpy
#                |   -> Import: os
#                |   -> Import: pandas
#                |   -> Function: _group_by_zone_and_group(data)
#                |   -> Function: load_and_process_markers(app_instance, console_print_func)
#                |   -> Function: load_markers_data(app_instance, console_print_func)
#        └── utils_marker_report_converter.py (Lines: 462)
#                |   -> Import: bs4
#                |   -> Import: csv
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: numpy
#                |   -> Import: os
#                |   -> Import: pdfplumber
#                |   -> Import: re
#                |   -> Import: subprocess
#                |   -> Import: sys
#                |   -> Import: xml.etree.ElementTree
#                |   -> Function: convert_html_report_to_csv(html_content, console_print_func)
#                |   -> Function: convert_pdf_report_to_csv(pdf_file_path, console_print_func)
#                |   -> Function: generate_csv_from_shw(xml_file_path, console_print_func)
#    └── orchestrator/
#        ├── __init__.py (Lines: 60)
#        ├── display_child_orchestrator_tasks.py (Lines: 122)
#                |   -> Import: datetime
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: tkinter
#                |   -> Class: OrchestratorTasksTab
#                |   -> Function: __init__(self, parent, app_instance)
#                |   -> Function: _create_widgets(self)
#                |   -> Function: log_event(self, source, event)
#                |   -> Function: update_status_display(self, is_running, is_paused)
#        ├── orchestrator_gui.py (Lines: 94)
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: tkinter
#                |   -> Class: OrchestratorGUI
#                |   -> Function: __init__(self, parent, app_instance, orchestrator_logic)
#                |   -> Function: _create_widgets(self)
#                |   -> Function: update_button_states(self)
#        └── orchestrator_logic.py (Lines: 98)
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Class: OrchestratorLogic
#                |   -> Function: __init__(self, app_instance, gui)
#                |   -> Function: get_status(self)
#                |   -> Function: log_check_in(self, source_file)
#                |   -> Function: log_task_event(self, source_file, event)
#                |   -> Function: start_orchestrator(self)
#                |   -> Function: stop_orchestrator(self)
#                |   -> Function: toggle_pause(self)
#    └── Plotting/
#        ├── TAB_PLOTTING_PARENT.py (Lines: 45)
#                |   -> Import: inspect
#                |   -> Import: tab_plotting_child_3D
#                |   -> Import: tab_plotting_child_Single
#                |   -> Import: tab_plotting_child_average
#                |   -> Import: tkinter
#                |   -> Class: TAB_PLOTTING_PARENT
#                |   -> Function: __init__(self, parent, app_instance)
#                |   -> Function: _create_widgets(self)
#                |   -> Function: _on_child_tab_selected(self, event)
#                |   -> Function: _on_parent_tab_selected(self, event)
#        ├── __init__.py (Lines: 24)
#        ├── tab_plotting_child_3D.py (Lines: 540)
#                |   -> Import: datetime
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: glob
#                |   -> Import: inspect
#                |   -> Import: numpy
#                |   -> Import: os
#                |   -> Import: pandas
#                |   -> Import: platform
#                |   -> Import: re
#                |   -> Import: tkinter
#                |   -> Import: utils_plotting_scans_over_time
#                |   -> Import: webbrowser
#                |   -> Class: Plotting3DTab
#                |   -> Function: __init__(self, master, app_instance, console_print_func)
#                |   -> Function: _clear_dynamic_3d_buttons(self)
#                |   -> Function: _create_widgets(self)
#                |   -> Function: _find_and_group_csv_files_3d(self, folder_path)
#                |   -> Function: _generate_plot_scans_over_time(self)
#                |   -> Function: _on_tab_selected(self, event)
#                |   -> Function: _open_folder_for_3d_plotting(self)
#                |   -> Function: _select_group_for_3d_plotting(self, prefix)
#        ├── tab_plotting_child_Single.py (Lines: 670)
#                |   -> Import: datetime
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: numpy
#                |   -> Import: os
#                |   -> Import: pandas
#                |   -> Import: tkinter
#                |   -> Import: utils_plotting
#                |   -> Import: webbrowser
#                |   -> Class: PlottingTab
#                |   -> Function: __init__(self, master, app_instance, console_print_func)
#                |   -> Function: _create_widgets(self)
#                |   -> Function: _local_calculate_average(df)
#                |   -> Function: _local_calculate_median(df)
#                |   -> Function: _local_calculate_psd(df, rbw_values_list)
#                |   -> Function: _local_calculate_range(df)
#                |   -> Function: _local_calculate_std_dev(df)
#                |   -> Function: _local_calculate_variance(df)
#                |   -> Function: _on_create_html_checkbox_changed(self)
#                |   -> Function: _on_scan_marker_checkbox_changed(self)
#                |   -> Function: _on_tab_selected(self, event)
#                |   -> Function: _open_last_plot(self)
#                |   -> Function: _plot_current_cycle_average(self)
#                |   -> Function: _plot_single_scan(self)
#        ├── tab_plotting_child_average.py (Lines: 1067)
#                |   -> Import: datetime
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: glob
#                |   -> Import: inspect
#                |   -> Import: numpy
#                |   -> Import: os
#                |   -> Import: pandas
#                |   -> Import: platform
#                |   -> Import: process_math.averaging_utils
#                |   -> Import: re
#                |   -> Import: subprocess
#                |   -> Import: tkinter
#                |   -> Import: utils_plotting
#                |   -> Import: webbrowser
#                |   -> Class: AveragingTab
#                |   -> Function: __init__(self, master, app_instance, console_print_func)
#                |   -> Function: _clear_dynamic_buttons(self)
#                |   -> Function: _create_widgets(self)
#                |   -> Function: _find_and_group_csv_files(self, folder_path)
#                |   -> Function: _generate_csv_selected_series(self)
#                |   -> Function: _generate_multi_average_plot(self, include_scans)
#                |   -> Function: _on_avg_type_checkbox_changed(self)
#                |   -> Function: _on_multi_file_marker_checkbox_changed(self)
#                |   -> Function: _on_tab_selected(self, event)
#                |   -> Function: _open_applied_math_folder(self)
#                |   -> Function: _open_folder_for_averaging(self)
#                |   -> Function: _select_group_for_plotting(self, prefix)
#        ├── utils_plotting.py (Lines: 675)
#                |   -> Import: csv
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: pandas
#                |   -> Import: plotly.express
#                |   -> Import: plotly.graph_objects
#                |   -> Import: re
#                |   -> Import: webbrowser
#                |   -> Function: _add_band_markers(fig, markers_dict, line_color, line_dash, band_name_suffix, MHZ_TO_HZ, console_print_func)
#                |   -> Function: _add_intermodulation_markers(fig, intermod_csv_path, MHZ_TO_HZ, console_print_func)
#                |   -> Function: _add_markers_from_csv(fig, markers_csv_path, MHZ_TO_HZ, console_print_func)
#                |   -> Function: _create_spectrum_plot(data_traces, plot_title, include_tv_markers, include_gov_markers, include_markers, include_intermod_markers, output_html_path, y_range_min_override, y_range_max_override, console_print_func, scan_data_folder, MHZ_TO_HZ, TV_BAND_MARKERS_MHZ, GOVERNMENT_BAND_MARKERS_MHZ, DEFAULT_MARKERS_FILE, DEFAULT_INTERMOD_FILE)
#                |   -> Function: _open_plot_in_browser(html_file_path, console_print_func)
#                |   -> Function: plot_multi_trace_data(df_aggregated, plot_title, include_tv_markers, include_gov_markers, include_markers, include_intermod_markers, historical_dfs_with_names, individual_scan_dfs_with_names, output_html_path, y_range_min_override, y_range_max_override, console_print_func, scan_data_folder, MHZ_TO_HZ, TV_BAND_MARKERS_MHZ, GOVERNMENT_BAND_MARKERS_MHZ, DEFAULT_MARKERS_FILE, DEFAULT_INTERMOD_FILE)
#                |   -> Function: plot_single_scan_data(df_scan, plot_title, include_tv_markers, include_gov_markers, include_markers, include_intermod_markers, output_html_path, console_print_func, scan_data_folder, MHZ_TO_HZ, TV_BAND_MARKERS_MHZ, GOVERNMENT_BAND_MARKERS_MHZ, DEFAULT_MARKERS_FILE, DEFAULT_INTERMOD_FILE)
#        └── utils_plotting_scans_over_time.py (Lines: 303)
#                |   -> Import: datetime
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: pandas
#                |   -> Import: plotly.colors
#                |   -> Import: plotly.graph_objects
#                |   -> Import: re
#                |   -> Import: ref.ref_frequency_bands
#                |   -> Import: webbrowser
#                |   -> Function: plot_Scans_over_time(grouped_csv_files, selected_group_prefix, output_folder, amplitude_threshold_dbm, console_print_func)
#    └── Presets/
#        ├── TAB_PRESETS_PARENT.py (Lines: 47)
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: tab_presets_child_device
#                |   -> Import: tab_presets_child_local
#                |   -> Import: tab_presets_child_preset_editor
#                |   -> Import: tkinter
#                |   -> Class: TAB_PRESETS_PARENT
#                |   -> Function: __init__(self, parent, app_instance)
#                |   -> Function: _create_widgets(self)
#                |   -> Function: _on_child_tab_selected(self, event)
#                |   -> Function: _on_parent_tab_selected(self, event)
#        ├── __init__.py (Lines: 24)
#        ├── tab_presets_child_device.py (Lines: 353)
#                |   -> Import: Instrument.connection.instrument_logic
#                |   -> Import: Presets.utils_preset_csv_process
#                |   -> Import: Presets.utils_preset_query_and_load
#                |   -> Import: Presets.utils_push_preset
#                |   -> Import: csv
#                |   -> Import: datetime
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: src.program_style
#                |   -> Import: tkinter
#                |   -> Class: DevicePresetsTab
#                |   -> Function: __init__(self, parent, app_instance, console_print_func, style_obj)
#                |   -> Function: __load_selected_preset_logic(self, selected_preset_name, is_device_preset, preset_data_dict)
#                |   -> Function: _handle_connection_status_change_event(self, event)
#                |   -> Function: _load_selected_device_preset(self)
#                |   -> Function: _on_connection_status_changed(self, is_connected, instrument_model)
#                |   -> Function: _on_device_preset_select(self, event)
#                |   -> Function: _populate_device_preset_listboxes(self, presets)
#                |   -> Function: _query_and_populate_device_presets(self)
#                |   -> Function: bind_events(self)
#                |   -> Function: create_widgets(self)
#                |   -> Function: save_current_settings_as_user_preset(self)
#                |   -> Function: setup_layout(self)
#        ├── tab_presets_child_local.py (Lines: 569)
#                |   -> Import: Presets.utils_preset_csv_process
#                |   -> Import: Presets.utils_preset_query_and_load
#                |   -> Import: Presets.utils_push_preset
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: ref.ref_file_paths
#                |   -> Import: settings_and_config.config_manager_save
#                |   -> Import: src.program_style
#                |   -> Import: tkinter
#                |   -> Class: LocalPresetsTab
#                |   -> Function: __init__(self, master, app_instance, console_print_func, style_obj)
#                |   -> Function: _create_widgets(self)
#                |   -> Function: _on_mousewheel(self, event)
#                |   -> Function: _on_preset_button_click(self, preset_data, clicked_button)
#                |   -> Function: _on_tab_selected(self, event)
#                |   -> Function: _update_gui_from_preset_data(self, preset_data)
#                |   -> Function: get_and_set_app_var(preset_key, app_attr_name, conversion_func, scale_factor)
#                |   -> Function: get_and_set_bool_app_var(preset_key, app_attr_name)
#                |   -> Function: populate_local_presets_list(self)
#                |   -> Function: set_display_var(tk_var, key, format_str, conversion_func, default_val)
#        ├── tab_presets_child_preset_editor.py (Lines: 356)
#                |   -> Import: Instrument.connection.instrument_logic
#                |   -> Import: datetime
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: numpy
#                |   -> Import: os
#                |   -> Import: pandas
#                |   -> Import: src.program_style
#                |   -> Import: tkinter
#                |   -> Import: utils_presets_editor
#                |   -> Class: PresetEditorTab
#                |   -> Function: __init__(self, master, app_instance, console_print_func, style_obj)
#                |   -> Function: _add_current_settings(self)
#                |   -> Function: _add_new_empty_row(self)
#                |   -> Function: _create_widgets(self)
#                |   -> Function: _delete_selected_preset(self)
#                |   -> Function: _end_edit(self, event)
#                |   -> Function: _export_presets(self)
#                |   -> Function: _import_presets(self)
#                |   -> Function: _move_preset_down(self)
#                |   -> Function: _move_preset_up(self)
#                |   -> Function: _on_double_click(self, event)
#                |   -> Function: _on_edit_escape(self, event)
#                |   -> Function: _on_edit_return(self, event)
#                |   -> Function: _on_tab_selected(self, event)
#                |   -> Function: _on_tree_select(self, event)
#                |   -> Function: _on_window_focus_in(self, event)
#                |   -> Function: _save_presets_to_csv(self)
#                |   -> Function: _start_edit(self, item_id, col_index)
#                |   -> Function: populate_presets_table(self)
#        ├── utils_preset_csv_process.py (Lines: 269)
#                |   -> Import: csv
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: numpy
#                |   -> Import: os
#                |   -> Import: pandas
#                |   -> Function: get_presets_csv_path(config_file_path, console_print_func)
#                |   -> Function: load_user_presets_from_csv(config_file_path, console_print_func)
#                |   -> Function: overwrite_user_presets_csv(config_file_path, presets_data, console_print_func, fieldnames)
#        ├── utils_preset_query_and_load.py (Lines: 271)
#                |   -> Import: Instrument.connection.instrument_logic
#                |   -> Import: Presets.utils_push_preset
#                |   -> Import: csv
#                |   -> Import: datetime
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: pandas
#                |   -> Import: pyvisa
#                |   -> Import: ref.ref_frequency_bands
#                |   -> Import: time
#                |   -> Import: yak.Yakety_Yak
#                |   -> Function: load_selected_preset_logic(app_instance, selected_preset_name, console_print_func, is_device_preset, preset_data_dict)
#                |   -> Function: query_current_instrument_settings_for_preset(inst, console_print_func)
#                |   -> Function: query_device_presets_logic(app_instance, console_print_func)
#        ├── utils_presets_editor.py (Lines: 267)
#                |   -> Import: Instrument.connection.instrument_logic
#                |   -> Import: csv
#                |   -> Import: datetime
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: numpy
#                |   -> Import: os
#                |   -> Import: pandas
#                |   -> Import: ref.ref_file_paths
#                |   -> Import: shutil
#                |   -> Import: utils_preset_csv_process
#                |   -> Class: PresetEditorLogic
#                |   -> Function: __init__(self, app_instance, console_print_func, columns)
#                |   -> Function: add_current_settings(self)
#                |   -> Function: add_new_empty_row(self)
#                |   -> Function: delete_presets(self, selected_filenames)
#                |   -> Function: export_presets(self, file_path)
#                |   -> Function: import_presets(self, file_path)
#                |   -> Function: load_presets(self)
#                |   -> Function: move_preset_down(self, filename)
#                |   -> Function: move_preset_up(self, filename)
#                |   -> Function: save_presets(self)
#                |   -> Function: update_preset_value(self, filename, column_name, new_value)
#        └── utils_push_preset.py (Lines: 210)
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: re
#                |   -> Import: ref.ref_frequency_bands
#                |   -> Import: yak.Yakety_Yak
#                |   -> Function: push_preset_logic(app_instance, console_print_func, preset_data)
#    └── Scanning/
#        ├── TAB_SCANNING_PARENT.py (Lines: 47)
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: tab_scanning_child_bands
#                |   -> Import: tab_scanning_child_scan_configuration
#                |   -> Import: tab_scanning_child_scan_meta_data
#                |   -> Import: tkinter
#                |   -> Class: TAB_SCANNING_PARENT
#                |   -> Function: __init__(self, parent, app_instance)
#                |   -> Function: _create_widgets(self)
#                |   -> Function: _on_child_tab_selected(self, event)
#                |   -> Function: _on_parent_tab_selected(self, event)
#        ├── __init__.py (Lines: 24)
#        ├── tab_scanning_child_bands.py (Lines: 450)
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: matplotlib.backends.backend_tkagg
#                |   -> Import: matplotlib.figure
#                |   -> Import: numpy
#                |   -> Import: os
#                |   -> Import: settings_and_config.config_manager_save
#                |   -> Import: tkinter
#                |   -> Class: BandsTab
#                |   -> Function: __init__(self, master, app_instance, console_print_func)
#                |   -> Function: _create_widgets(self)
#                |   -> Function: _deselect_all_bands(self)
#                |   -> Function: _on_band_button_toggle(self, band_item)
#                |   -> Function: _on_tab_selected(self, event)
#                |   -> Function: _populate_band_buttons(self)
#                |   -> Function: _select_all_bands(self)
#                |   -> Function: _update_all_band_button_styles(self)
#                |   -> Function: _update_band_chart(self)
#                |   -> Function: _update_band_table(self)
#                |   -> Function: _update_button_style(self, button, level)
#        ├── tab_scanning_child_scan_configuration.py (Lines: 319)
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: ref.ref_scanner_setting_lists
#                |   -> Import: ref.ref_scanning_setting
#                |   -> Import: settings_and_config.config_manager_save
#                |   -> Import: subprocess
#                |   -> Import: sys
#                |   -> Import: tkinter
#                |   -> Class: ScanTab
#                |   -> Function: __init__(self, master, app_instance, console_print_func)
#                |   -> Function: _browse_output_folder(self)
#                |   -> Function: _create_setting_row(self, parent, row, key, label_text, app_var, data_list, unit)
#                |   -> Function: _create_widgets(self)
#                |   -> Function: _load_settings_into_ui(self)
#                |   -> Function: _on_boolean_combobox_select(self, event, app_var)
#                |   -> Function: _on_combobox_select(self, event, app_var, data_list, description_var, unit)
#                |   -> Function: _on_tab_selected(self, event)
#                |   -> Function: _open_output_folder(self)
#                |   -> Function: _set_combobox_display_from_value(self, key)
#        ├── tab_scanning_child_scan_meta_data.py (Lines: 556)
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: process_math.google_maps_lookup
#                |   -> Import: ref.ref_antenna_amplifier_type
#                |   -> Import: ref.ref_antenna_type
#                |   -> Import: settings_and_config.config_manager_save
#                |   -> Import: subprocess
#                |   -> Import: tkinter
#                |   -> Class: ScanMetaDataTab
#                |   -> Function: __init__(self, master, app_instance, console_print_func, style_obj)
#                |   -> Function: _create_widgets(self)
#                |   -> Function: _lookup_postal_code(self)
#                |   -> Function: _on_amplifier_type_selected(self, event)
#                |   -> Function: _on_antenna_type_selected(self, event)
#                |   -> Function: _on_notes_change(self, event)
#                |   -> Function: _on_tab_selected(self, event)
#        └── utils_scan_instrument.py (Lines: 481)
#                |   -> Import: datetime
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: numpy
#                |   -> Import: os
#                |   -> Import: pandas
#                |   -> Import: process_math.scan_stitch
#                |   -> Import: pyvisa
#                |   -> Import: re
#                |   -> Import: ref.ref_frequency_bands
#                |   -> Import: src.connection_status_logic
#                |   -> Import: threading
#                |   -> Import: time
#                |   -> Import: utils.utils_csv_writer
#                |   -> Function: _scan_thread_target(app_instance, selected_bands, stop_event, pause_event, console_print_func, update_progress_func)
#                |   -> Function: configure_instrument_for_scan(inst, center_freq_hz, span_hz, rbw_hz, ref_level_dbm, freq_shift_hz, high_sensitivity_on, preamp_on, app_instance_ref, app_console_update_func)
#                |   -> Function: initiate_scan_thread(app_instance, console_print_func, stop_event, pause_event, update_progress_func)
#                |   -> Function: perform_segment_sweep(inst, segment_start_freq_hz, segment_stop_freq_hz, maxhold_enabled, max_hold_time, app_instance_ref, pause_event, stop_event, segment_counter, total_segments_in_band, band_name, app_console_update_func, current_segment_start_freq_hz)
#                |   -> Function: perform_single_sweep(inst, app_instance_ref, app_console_update_func)
#                |   -> Function: query_safe(inst, command, app_instance_ref, app_console_update_func)
#                |   -> Function: scan_bands(app_instance_ref, inst, selected_bands, rbw_hz, ref_level_dbm, freq_shift_hz, maxhold_enabled, high_sensitivity, preamp_on, rbw_step_size_hz, max_hold_time_seconds, scan_name, output_folder, stop_event, pause_event, log_visa_commands_enabled, general_debug_enabled, app_console_update_func, initialize_instrument_func)
#                |   -> Function: write_safe(inst, command, app_instance_ref, app_console_update_func)
#    └── zones_groups_devices/
#        ├── tab_markers_child_zone_groups_devices.py (Lines: 211)
#                |   -> Import: datetime
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: functools
#                |   -> Import: inspect
#                |   -> Import: os
#                |   -> Import: src.program_style
#                |   -> Import: tkinter
#                |   -> Import: utils_button_volume_level
#                |   -> Import: utils_display_showtime_all
#                |   -> Import: utils_display_showtime_devices
#                |   -> Import: utils_display_showtime_groups
#                |   -> Import: utils_display_showtime_zones
#                |   -> Import: utils_files_markers_zone_groups_devices
#                |   -> Class: ZoneGroupsDevicesFrame
#                |   -> Function: __init__(self, parent_frame, showtime_tab_instance)
#                |   -> Function: _create_device_frame(self, parent)
#                |   -> Function: _create_layout(self)
#                |   -> Function: _get_all_devices_in_zone(self, structured_data, zone_name)
#                |   -> Function: _get_devices_to_display(self)
#                |   -> Function: _get_min_max_freq_and_update_title(self, frame_widget, devices, title_prefix)
#                |   -> Function: _make_device_buttons(self)
#                |   -> Function: _make_group_buttons(self)
#                |   -> Function: _make_zone_buttons(self)
#                |   -> Function: load_and_display_data(self)
#        ├── utils_button_volume_level.py (Lines: 73)
#                |   -> Import: datetime
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: math
#                |   -> Import: os
#                |   -> Function: create_signal_level_indicator(value, min_val, max_val, width)
#        ├── utils_display_showtime_all.py (Lines: 146)
#                |   -> Import: Markers.showtime.controls.utils_showtime_zone_zoom
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: numpy
#                |   -> Import: os
#                |   -> Import: pandas
#                |   -> Import: tkinter
#                |   -> Import: utils_display_showtime_shared
#                |   -> Function: no_zone_grou_device_selected(zgd_frame_instance)
#                |   -> Function: on_all_markers_selected(zgd_frame_instance)
#        ├── utils_display_showtime_devices.py (Lines: 154)
#                |   -> Import: Markers.showtime.controls.utils_showtime_zone_zoom
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: math
#                |   -> Import: numpy
#                |   -> Import: os
#                |   -> Import: pandas
#                |   -> Import: utils_display_showtime_groups
#                |   -> Import: utils_display_showtime_shared
#                |   -> Import: yak.utils_yakbeg_handler
#                |   -> Function: on_device_deselected(zgd_frame_instance)
#                |   -> Function: on_device_selected(zgd_frame_instance, device_info)
#        ├── utils_display_showtime_groups.py (Lines: 202)
#                |   -> Import: Markers.showtime.controls.utils_showtime_zone_zoom
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: math
#                |   -> Import: numpy
#                |   -> Import: os
#                |   -> Import: pandas
#                |   -> Import: tkinter
#                |   -> Import: utils_display_showtime_devices
#                |   -> Import: utils_display_showtime_shared
#                |   -> Function: no_zone_grou_device_selected(zgd_frame_instance)
#                |   -> Function: on_group_deselected(zgd_frame_instance)
#                |   -> Function: on_group_selected(zgd_frame_instance, group_name)
#        ├── utils_display_showtime_shared.py (Lines: 278)
#                |   -> Import: Markers.showtime.controls.utils_showtime_zone_zoom
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: math
#                |   -> Import: numpy
#                |   -> Import: os
#                |   -> Import: pandas
#                |   -> Import: settings_and_config.config_manager_save
#                |   -> Import: threading
#                |   -> Import: tkinter
#                |   -> Function: _save_showtime_state_to_config(showtime_tab)
#                |   -> Function: _update_zone_zoom_tab(zgd_frame_instance)
#                |   -> Function: get_current_view_details(zgd_frame_instance)
#        ├── utils_display_showtime_zones.py (Lines: 118)
#                |   -> Import: Markers.showtime.controls.utils_showtime_zone_zoom
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: math
#                |   -> Import: numpy
#                |   -> Import: os
#                |   -> Import: pandas
#                |   -> Import: tkinter
#                |   -> Import: utils_display_showtime_all
#                |   -> Import: utils_display_showtime_shared
#                |   -> Function: on_zone_selected(zgd_frame_instance, zone_name)
#        └── utils_files_markers_zone_groups_devices.py (Lines: 100)
#                |   -> Import: display.console_logic
#                |   -> Import: display.debug_logic
#                |   -> Import: inspect
#                |   -> Import: numpy
#                |   -> Import: os
#                |   -> Import: pandas
#                |   -> Import: ref.ref_file_paths
#                |   -> Function: load_and_structure_markers_data()


--------------------------------------------------

# ====================================================================================
# EVERYTHING.py.LOG
# This file contains the complete content of all Python, CSV, and INI files found during the crawl.
# Each file's content is separated by its path and a dashed line.
#
# Log started at: 2025-08-23 10:46:29
# ====================================================================================

#####################################
### File: OPEN-AIR 2\main.py
#####################################
# main.py
#
# This file serves as the main entry point for the application, orchestrating startup checks and GUI launch.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.222400.1

import os
import inspect
import datetime
import sys
import pathlib

# Add the project's root directory to the system path to allow for imports from
# all sub-folders (e.g., 'configuration' and 'display'). This is a robust way to handle imports.
try:
    project_root = str(pathlib.Path(__file__).resolve().parent)
    if project_root not in sys.path:
        sys.path.append(project_root)
except Exception as e:
    # Fallback in case of an issue with pathlib
    print(f"Error adding project root to sys.path: {e}")

# This block ensures the console can handle UTF-8 characters, preventing encoding errors.
if os.name == 'nt':
    try:
        sys.stdout.reconfigure(encoding='utf-8')
        sys.stderr.reconfigure(encoding='utf-8')
    except AttributeError:
        # Fallback for older Python versions that don't have reconfigure
        pass

# Import core application modules
from datasets.logging import console_log, debug_log
from display.gui_display import Application


# --- Global Scope Variables ---
CURRENT_DATE = datetime.datetime.now().strftime("%Y%m%d")
CURRENT_TIME = datetime.datetime.now().strftime("%H%M%S")
# Note: For hashing, any leading zero in the hour is dropped (e.g., 083015 becomes 83015).
CURRENT_TIME_HASH = int(datetime.datetime.now().strftime("%H%M%S"))
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
current_file = f"{os.path.basename(__file__)}"


def action_check_dependancies():
    # Checks for required system and library dependencies.
    current_function_name = inspect.currentframe().f_code.co_name
    debug_log(
        message=f"🖥️🟢 Ah, good, we're entering '{current_function_name}'! Let's examine the raw materials, shall we?",
        file=current_file,
        version=current_version,
        function=current_function_name,
        console_print_func=console_log
    )

    try:
        # --- Function logic goes here ---
        # Placeholder for dependency checking logic
        console_log("✅ A most glorious success! Dependencies are in order.")
        return True

    except Exception as e:
        console_log(f"❌ Error in {current_function_name}: {e}")
        debug_log(
            message=f"🖥️🔴 Heavens to Betsy! We've hit a snag in the dependencies! The error be: {e}",
            file=current_file,
            version=current_version,
            function=current_function_name,
            console_print_func=console_log
        )
        return False

def action_check_configuration():
    # Validates the application's configuration files.
    current_function_name = inspect.currentframe().f_code.co_name
    debug_log(
        message=f"🖥️🟢 Ahem, commencing the configuration validation experiment in '{current_function_name}'.",
        file=current_file,
        version=current_version,
        function=current_function_name,
        console_print_func=console_log
    )

    try:
        # --- Function logic goes here ---
        # Placeholder for configuration validation
        console_log("✅ Excellent! The configuration is quite, quite brilliant.")
        return True

    except Exception as e:
        console_log(f"❌ Error in {current_function_name}: {e}")
        debug_log(
            message=f"🖥️🔴 By Jove! The configuration is in shambles! The error be: {e}",
            file=current_file,
            version=current_version,
            function=current_function_name,
            console_print_func=console_log
        )
        return False

def action_open_display():
    # Initializes and opens the main graphical user interface.
    current_function_name = inspect.currentframe().f_code.co_name
    debug_log(
        message=f"🖥️🟢 The final step! Activating the main display in '{current_function_name}'!",
        file=current_file,
        version=current_version,
        function=current_function_name,
        console_print_func=console_log
    )

    try:
        # --- Function logic goes here ---
        app = Application()
        app.mainloop()
        console_log("✅ The grand spectacle begins! GUI is now open.")
        return True

    except Exception as e:
        console_log(f"❌ Error in {current_function_name}: {e}")
        debug_log(
            message=f"🖥️🔴 Blast and barnacles! The display has failed to materialize! The error be: {e}",
            file=current_file,
            version=current_version,
            function=current_function_name,
            console_print_func=console_log
        )
        return False

def main():
    """The main execution function for the application."""
    console_log(f"🚀 Launch sequence initiated for version {current_version}.")

    if action_check_dependancies():
        if action_check_configuration():
            action_open_display()
        else:
            console_log("❌ Halting startup due to configuration errors.")
    else:
        console_log("❌ Halting startup due to missing dependencies.")


if __name__ == "__main__":
    main()

#####################################
### File: OPEN-AIR 2\agents\yak\Yakety_Yak.py
#####################################
# tabs/Instrument/Yakety_Yak.py
#
# This file provides a high-level interface for executing VISA commands
# by a user-defined type, model, and manufacturer. It acts as a wrapper
# for the low-level `execute_visa_command` function, ensuring the correct
# command is sent based on the provided parameters. It also manages the
# loading of the `visa_commands.csv` file.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.210502.1
# FIXED: The YakNab function now returns the raw response string without parsing it, as this should be handled by the specific handler function that knows the data structure.
# UPDATED: All debug messages now include the required 🐐 emoji at the start.

import csv
import os
import inspect
import pyvisa
import time
from tkinter import messagebox
from display.debug_logic import debug_log, log_visa_command
from display.console_logic import console_log
from ref.ref_file_paths import VISA_COMMANDS_FILE_PATH

# FIXED: Import the low-level read/write functions from the correct location
from yak.utils_yak_visa import write_safe, query_safe

# --- User-configurable variables ---
VISA_COMMAND_DELAY_SECONDS = 0.05
MAX_RETRY_ATTEMPTS = 3

# Global variable to store loaded commands to avoid re-reading the file
_visa_commands_data = []
_last_file_modification_time = 0

# --- Versioning ---
w = 20250821
x_str = '210502'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"


def _load_commands_from_file(file_path):
    # Function Description:
    # Loads or reloads the VISA commands from the specified CSV file.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 Entering {current_function}. File: {file_path}",
                file=current_file,
                version=current_version,
                function=current_function)

    global _visa_commands_data, _last_file_modification_time

    try:
        if not os.path.exists(file_path):
            debug_log(f"🐐 ❌ File not found: {file_path}. Aborting load. �",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return False

        current_mod_time = os.path.getmtime(file_path)
        if current_mod_time <= _last_file_modification_time:
            debug_log(f"🐐 😴 File '{file_path}' has not been modified since last load. Skipping. 😴",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return True

        with open(file_path, 'r', newline='', encoding='utf-8') as f:
            reader = csv.reader(f)
            header = next(reader)
            _visa_commands_data = [row for row in reader]

        _last_file_modification_time = current_mod_time
        debug_log(f"🐐 ✅ Successfully loaded {len(_visa_commands_data)} commands from file. 🎉",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return True

    except Exception as e:
        debug_log(f"🐐 💥 Error loading commands from file: {e}. This is a goddamn mess! 💥",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        _visa_commands_data = []
        return False

def _find_command(command_type, action_type, model):
    # Function Description:
    # Finds the correct VISA command from the loaded data based on the command type,
    # action type, and instrument model.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🔍 Searching for command. Type: '{command_type}', Action: '{action_type}', Model: '{model}'. Let's find it! 🕵️‍♀️",
                file=current_file,
                version=current_version,
                function=current_function)

    upper_command_type = command_type.upper()
    upper_action_type = action_type.upper()
    upper_model = model.upper()
    
    if not _visa_commands_data:
        debug_log("🐐 ❌ No command data loaded. What a disaster!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return None, None, None

    for row in _visa_commands_data:
        if row[2].upper() == upper_command_type and row[3].upper() == upper_action_type and row[1].upper() == upper_model:
            debug_log(f"🐐 ✅ Found an exact match! Command: '{upper_command_type}', Action: '{upper_action_type}', Model: '{upper_model}'. This is fucking brilliant! ✅",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return row[3], row[4], row[5]

    for row in _visa_commands_data:
        if row[2].upper() == upper_command_type and row[3].upper() == upper_action_type and row[1] == '*':
            debug_log(f"🐐 🔎 Found a wildcard match! Command: '{upper_command_type}', Action: '{upper_action_type}', Model: '*'. Not perfect, but it'll do. 😉",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return row[3], row[4], row[5]

    debug_log(f"🐐 ❌ No matching command found for Type: '{upper_command_type}', Action: '{upper_action_type}', Model: '{upper_model}'. This is a fucking waste of time! 🤯",
                file=current_file,
                version=current_version,
                function=current_function)
    return None, None, None

def YakRig(app_instance, command_type, console_print_func, *variable_values):
    """
    Function Description:
    Executes a 'RIG' VISA command by combining a template command string
    with up to 8 provided variable values. This is designed for single-line
    configuration commands that set multiple parameters at once.

    Inputs:
    - app_instance (object): A reference to the main application instance.
    - command_type (str): The name of the 'RIG' command from the CSV (e.g., "MARKER/PLACE/ALL").
    - console_print_func (function): A function to print messages to the GUI console.
    - variable_values (str...): Up to 8 values to be substituted into the command template.
                                These will replace the placeholders 111, 222, etc.

    Outputs:
    - "PASSED" if the command is executed successfully, "FAILED" otherwise.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🟢 Entering YakRig. command_type: {command_type}, variable_values: {variable_values}",
                file=current_file,
                version=current_version,
                function=current_function)

    _load_commands_from_file(app_instance.VISA_COMMANDS_FILE_PATH)
    
    model = app_instance.connected_instrument_model.get()
    
    action, command_template, _ = _find_command(command_type, "RIG", model)

    if action == "RIG" and command_template:
        full_command = command_template
        placeholders = ["111", "222", "333", "444", "555", "666", "777", "888"]
        
        # Replace placeholders with provided values
        for i, value in enumerate(variable_values):
            if i < len(placeholders):
                full_command = full_command.replace(placeholders[i], str(value))
        
        console_log(f"💬 Rigging command: {full_command}")
        debug_log(f"🐐 📝 Rigged command string: {full_command}",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        if write_safe(app_instance.inst, full_command, console_print_func):
            console_print_func("✅ Rig command executed successfully.")
            debug_log("🐐 ✅ Rig command executed successfully.",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return "PASSED"
        else:
            console_print_func("❌ Rig command execution failed.")
            debug_log("🐐 ❌ Rig command execution failed. What the hell went wrong?!",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return "FAILED"
    else:
        console_log(f"❌ Could not find a matching RIG command for '{command_type}'.")
        debug_log(f"🐐 🚫 No matching RIG command found for '{command_type}'. Fucking useless!",
                   file=current_file,
                    version=current_version,
                    function=current_function)
        return "FAILED"

def YakBeg(app_instance, command_type, console_print_func, *variable_values):
    """
    Function Description:
    Executes a 'BEG' (Beg) VISA command by combining a SET command with a GET query.
    This is an atomic action designed for configuring a setting and immediately
    verifying its value from the instrument.

    Inputs:
    - app_instance (object): A reference to the main application instance.
    - command_type (str): The name of the 'BEG' command from the CSV.
    - console_print_func (function): A function to print messages to the GUI console.
    - variable_values (str...): Up to 8 values to be substituted into the command template.
                                These will replace the placeholders 111, 222, etc.

    Outputs:
    - The response string from the GET command if successful, or "FAILED" otherwise.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🟢 Entering YakBeg. command_type: {command_type}, variable_values: {variable_values}",
                file=current_file,
                version=current_version,
                function=current_function)
    
    _load_commands_from_file(app_instance.VISA_COMMANDS_FILE_PATH)
    
    model = app_instance.connected_instrument_model.get()
    
    action, command_template, _ = _find_command(command_type, "BEG", model)

    if action == "BEG" and command_template:
        full_command = command_template
        placeholders = ["111", "222", "333", "444", "555", "666", "777", "888"]
        
        # Replace placeholders with provided values
        for i, value in enumerate(variable_values):
            if i < len(placeholders):
                full_command = full_command.replace(placeholders[i], str(value))

        console_log(f"💬 Begging for a response with command: {full_command}")
        debug_log(f"🐐 📝 Beg command string: {full_command}",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        # The BEG command is a single string with both set and get queries.
        # We use query_safe to send the entire string and get the response.
        response = query_safe(app_instance.inst, full_command, console_print_func)
    
        if response is not None:
            console_print_func(f"✅ Beg Response: {response}")
            debug_log(f"🐐 ✅ Beg query response: {response}. Fucking finally!",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return response
        else:
            console_print_func("❌ No response received or query failed.")
            debug_log("🐐 ❌ Beg query failed or no response. What the hell happened?!",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return "FAILED"
    else:
        console_log(f"❌ Could not find a matching BEG command for '{command_type}'.")
        debug_log(f"🐐 🚫 No matching BEG command found for '{command_type}'. Fucking useless!",
                   file=current_file,
                    version=current_version,
                    function=current_function)
        return "FAILED"

def YakGet(app_instance, command_type, console_print_func):
    # Function Description:
    # Executes a 'GET' or a new 'NAB' VISA command for a given command type.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🟢 Entering YakGet. command_type: {command_type}",
                file=current_file,
                version=current_version,
                function=current_function)
    
    _load_commands_from_file(VISA_COMMANDS_FILE_PATH)
    
    manufacturer = app_instance.connected_instrument_manufacturer.get()
    model = app_instance.connected_instrument_model.get()
    
    action, command, variable = _find_command(command_type, "GET", model)
    if not action:
        action, command, variable = _find_command(command_type, "NAB", model)
    
    if action and command:
        return execute_visa_command(app_instance, action, command, variable, console_print_func)
    else:
        console_print_func(f"❌ Could not find a matching GET or NAB command for '{command_type}'.")
        debug_log(f"🐐 🚫 No matching GET or NAB command found for '{command_type}'. Fucking useless!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return "FAILED"
  
def YakNab(app_instance, command_type, console_print_func):
    """
    Function Description:
    Executes a 'NAB' (multi-query) VISA command for a given command type.
    
    Inputs:
    - app_instance (object): A reference to the main application instance.
    - command_type (str): The name of the 'NAB' command from the CSV.
    - console_print_func (function): A function to print messages to the GUI console.
    
    Outputs:
    - The response string from the GET command if successful, or a list of parsed strings otherwise.
      "FAILED" on failure.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🟢 Entering YakNab. command_type: {command_type}",
                file=current_file,
                version=current_version,
                function=current_function)

    _load_commands_from_file(app_instance.VISA_COMMANDS_FILE_PATH)
    
    manufacturer = app_instance.connected_instrument_manufacturer.get()
    model = app_instance.connected_instrument_model.get()

    action, command, num_reads_str = _find_command(command_type, "NAB", model)

    if action == "NAB" and command:
        try:
            response_string = query_safe(app_instance.inst, command, console_print_func)
        except (ValueError, IndexError):
            console_print_func("❌ NAB command variable for num_reads is not a valid integer.")
            debug_log("🐐 🤷‍♀️ NAB command variable for num_reads is not a valid integer. Defaulting to 1. 🤷‍♀️",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            response_string = query_safe(app_instance.inst, command, console_print_func)
        
        if response_string is not None:
            values = [val.strip() for val in response_string.split(';') if val.strip()]
            console_print_func(f"✅ NAB Response: {values}")
            debug_log(f"🐐 ✅ NAB Query response: {response_string}. Fucking finally!",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return values
        else:
            return "FAILED"
    else:
        console_print_func(f"❌ Could not find a matching NAB command for '{command_type}'.")
        debug_log(f"🐐 🚫 No matching NAB command found for '{command_type}'. Fucking useless!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return "FAILED"


def YakSet(app_instance, command_type, variable_value, console_print_func):
    # Function Description:
    # Executes a 'SET' VISA command with a specific value.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🟢 Entering YakSet. command_type: {command_type}, variable_value: {variable_value}",
                file=current_file,
                version=current_version,
                function=current_function)

    _load_commands_from_file(app_instance.VISA_COMMANDS_FILE_PATH)
    
    manufacturer = app_instance.connected_instrument_manufacturer.get()
    model = app_instance.connected_instrument_model.get()
    
    action, command, _ = _find_command(command_type, "SET", model)
    
    if action == "SET" and command:
        return execute_visa_command(app_instance, action, command, variable_value, console_print_func)
    else:
        console_print_func(f"❌ Could not find a matching SET command for '{command_type}'.")
        debug_log(f"🐐 🚫 No matching SET command found for '{command_type}'. Fucking useless!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return "FAILED"

def YakDo(app_instance, command_type, console_print_func):
    # Function Description:
    # Executes a 'DO' VISA command.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🟢 Entering YakDo. command_type: {command_type}",
                file=current_file,
                version=current_version,
                function=current_function)

    _load_commands_from_file(VISA_COMMANDS_FILE_PATH)
    
    manufacturer = app_instance.connected_instrument_manufacturer.get()
    model = app_instance.connected_instrument_model.get()
    
    action, command, variable = _find_command(command_type, "DO", model)
    
    if action == "DO" and command:
        return execute_visa_command(app_instance, action, command, variable, console_print_func)
    else:
        console_print_func(f"❌ Could not find a matching DO command for '{command_type}'.")
        debug_log(f"🐐 🚫 No matching DO command found for '{command_type}'. Fucking useless!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return "FAILED"

def execute_visa_command(app_instance, action_type, visa_command, variable_value, console_print_func, num_reads=1):
    # Function Description:
    # Executes a given VISA command based on its action type and variable value.
    current_function = inspect.currentframe().f_code.co_name
    inst = app_instance.inst

    if not inst:
        console_print_func("❌ No instrument connected. Cannot execute VISA command.")
        debug_log("🐐 ❌ No instrument connected for execute_visa_command. Fucking useless!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return "FAILED"

    try:
        if action_type == "GET":
            full_command = f"{visa_command}{variable_value}" if variable_value and variable_value.strip() == "?" else visa_command
            debug_log(f"🐐 📝 Prepared command string for GET: {full_command}",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            response = query_safe(inst, full_command, console_print_func)
            if response is not None:
                console_print_func(f"✅ Response: {response}")
                debug_log(f"🐐 ✅ Query response: {response}. Finally!",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return response
            else:
                console_print_func("❌ No response received or query failed.")
                debug_log("🐐 ❌ Query failed or no response. What the hell happened?!",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return "FAILED"
        elif action_type == "NAB":
            full_command = visa_command
            
            response_string = query_safe(inst, full_command, console_print_func)
            
            if response_string is not None:
                values = [val.strip() for val in response_string.split(';') if val.strip()]
                console_print_func(f"✅ NAB Response: {values}")
                debug_log(f"🐐 ✅ NAB Query response: {response_string}. Fucking finally!",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return values
            else:
                return "FAILED"

        elif action_type == "DO":
            if variable_value and variable_value.strip():
                full_command = f"{visa_command} {variable_value}"
            else:
                full_command = visa_command
            
            debug_log(f"🐐 📝 Prepared command string for DO: {full_command}",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            if write_safe(inst, full_command, console_print_func):
                console_print_func("✅ Command executed successfully.")
                debug_log("🐐 ✅ Command executed successfully.",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return "PASSED"
            else:
                console_print_func("❌ Command execution failed.")
                debug_log("🐐 ❌ DO command execution failed. What the hell went wrong?!",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return "FAILED"
        elif action_type == "SET":
            try:
                float_value = float(variable_value)
                int_value = int(float_value)
                if float_value == int_value:
                    full_command = f"{visa_command} {int_value}"
                else:
                    full_command = f"{visa_command} {float_value}"
            except (ValueError, TypeError):
                full_command = f"{visa_command} {variable_value}"
            
            debug_log(f"🐐 📝 Prepared command string for SET: {full_command}",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            if write_safe(inst, full_command, console_print_func):
                console_print_func("✅ Command executed successfully.")
                debug_log("🐐 ✅ Command executed successfully.",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return "PASSED"
            else:
                console_print_func("❌ Command execution failed.")
                debug_log("🐐 ❌ SET command execution failed. What the hell went wrong?!",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return "FAILED"
        elif action_type == "RIG":
            full_command = visa_command
            
            debug_log(f"🐐 📝 Prepared command string for RIG: {full_command}",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            if write_safe(inst, full_command, console_print_func):
                console_print_func("✅ Rig command executed successfully.")
                debug_log("🐐 ✅ Rig command executed successfully.",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return "PASSED"
            else:
                console_print_func("❌ Rig command execution failed.")
                debug_log("🐐 ❌ Rig command execution failed. What the hell went wrong?!",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return "FAILED"
        elif action_type == "BEG":
            full_command = visa_command
            debug_log(f"🐐 📝 Prepared command string for BEG: {full_command}",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            response_string = query_safe(inst, visa_command, console_print_func)
            if response_string is not None:
                return response_string
            else:
                return "FAILED"
        else:
            console_print_func(f"⚠️ Unknown action type '{action_type}'. Cannot execute command.")
            debug_log(f"🐐 ❌ Unknown action type '{action_type}' for command: {visa_command}. This is a goddamn mess!",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return "FAILED"
    except Exception as e:
        console_print_func(f"❌ Error during VISA command execution: {e}")
        debug_log(f"🐐 🧨 Error executing VISA command '{visa_command}': {e}. This thing is a pain in the ass!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return "FAILED"


#####################################
### File: OPEN-AIR 2\agents\yak\utils_yak_setting_handler.py
#####################################
# yak/utils_yak_setting_handler.py
#
# This file provides a high-level interface for executing and managing all VISA commands.
# It acts as a central handler, exposing public API functions for the GUI to use,
# and internally calling the low-level Yak functions to communicate with the instrument.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.210502.1
# FIXED: Removed incorrect MHz-to-Hz conversion from set_resolution_bandwidth and set_video_bandwidth functions.
# UPDATED: Corrected debug log messages to accurately reflect the units being processed.
# NEW: Added a new handler function to toggle trace averaging on a per-trace basis.
# UPDATED: All debug messages now include the required 🐐 emoji at the start.

import os
import inspect
import numpy as np
import threading
import time

from display.debug_logic import debug_log
from display.console_logic import console_log

# NEW: Import the Yak functions from Yakety_Yak.py
from yak.Yakety_Yak import YakGet, YakSet, YakDo, YakNab

# --- Versioning ---
w = 20250821
x_str = '210502'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"


# Conversion constant from Megahertz to Hertz
MHZ_TO_HZ_CONVERSION = 1_000_000

# =========================================================================
# PUBLIC API FOR CONTROLLING SETTINGS - GUI should call these functions
# =========================================================================
def refresh_all_from_instrument(app_instance, console_print_func):
    # This is a new public API for the GUI to call
    # Queries all settings from the instrument and returns a dictionary of values.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🟢 API call to refresh all settings from the instrument.",
              file=current_file,
              version=current_version,
              function=current_function)

    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot refresh settings.")
        return None

    settings = {}
    try:
        settings['center_freq_hz'] = YakGet(app_instance, "FREQUENCY/CENTER", console_print_func)
        settings['span_hz'] = YakGet(app_instance, "FREQUENCY/SPAN", console_print_func)
        settings['start_freq_hz'] = YakGet(app_instance, "FREQUENCY/START", console_print_func)
        settings['stop_freq_hz'] = YakGet(app_instance, "FREQUENCY/STOP", console_print_func)

        settings['rbw_hz'] = YakGet(app_instance, "BANDWIDTH/RESOLUTION", console_print_func)
        settings['vbw_hz'] = YakGet(app_instance, "BANDWIDTH/VIDEO", console_print_func)
        settings['vbw_auto_on'] = YakGet(app_instance, "BANDWIDTH/VIDEO/AUTO", console_print_func) in ["ON", "1"]

        settings['initiate_continuous_on'] = YakGet(app_instance, "INITIATE/CONTINUOUS", console_print_func) in ["ON", "1"]

        settings['ref_level_dbm'] = YakGet(app_instance, "AMPLITUDE/REFERENCE LEVEL", console_print_func)
        settings['power_attenuation_db'] = YakGet(app_instance, "AMPLITUDE/POWER/ATTENUATION", console_print_func)
        settings['preamp_on'] = YakGet(app_instance, "AMPLITUDE/POWER/GAIN", console_print_func) in ["ON", "1"]
        settings['high_sensitivity_on'] = YakGet(app_instance, "AMPLITUDE/POWER/HIGH SENSITIVE", console_print_func) in ["ON", "1"]

        settings['trace1_mode'] = YakGet(app_instance, "TRACE/1/MODE", console_print_func)
        settings['trace2_mode'] = YakGet(app_instance, "TRACE/2/MODE", console_print_func)
        settings['trace3_mode'] = YakGet(app_instance, "TRACE/3/MODE", console_print_func)
        settings['trace4_mode'] = YakGet(app_instance, "TRACE/4/MODE", console_print_func)

        for i in range(6):
            settings[f'marker{i+1}_on'] = YakGet(app_instance, f"MARKER/{i+1}/CALCULATE/STATE", console_print_func) in ["ON", "1"]

        # NEW: Get averaging state and count for all traces
        for i in range(1, 5):
            avg_status, avg_count = get_trace_averaging_settings(app_instance, i, console_print_func)
            settings[f'trace{i}_average_on'] = avg_status
            settings[f'trace{i}_average_count'] = avg_count

        debug_log(f"🐐 ✅ Retrieved all settings: {settings}", file=current_file, version=current_version, function=current_function)
        return settings
    except Exception as e:
        console_print_func(f"❌ Failed to retrieve settings from instrument: {e}.")
        debug_log(f"🐐 ❌ Error retrieving settings from instrument: {e}. What a mess!",
                  file=current_file,
                  version=current_version,
                  function=current_function)
        return None

def _trigger_gui_refresh(app_instance):
    # Function Description:
    # Safely calls the refresh method on the correct GUI object from the main thread.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🔄 Attempting to refresh GUI from within handler. 🔄",
              file=current_file,
              version=current_version,
              function=current_function)
    
    try:
        # CORRECTED PATH: Navigate through the `tabs_parent` dictionary to find the right object
        instrument_parent_tab = app_instance.tabs_parent.tab_content_frames['Instruments']
        settings_tab = instrument_parent_tab.settings_tab
        # FIXED: Corrected the function call to the existing method
        settings_tab.refresh_all_child_tabs()
    except AttributeError as e:
        debug_log(f"🐐 💥 CRITICAL ERROR: Failed to find the GUI refresh method. Path traversal failed. Error: {e} 💥",
                  file=current_file,
                  version=current_version,
                  function=current_function)
    except Exception as e:
        debug_log(f"🐐 🤯 An unexpected error occurred during GUI refresh: {e}. 🤯",
                  file=current_file,
                  version=current_version,
                  function=current_function)

def set_center_frequency(app_instance, value, console_print_func):
    """
    Sets the center frequency on the instrument and triggers a GUI refresh.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to set center frequency: {value} MHz.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot set frequency.")
        return False
    
    try:
        hz_value = int(float(value) * MHZ_TO_HZ_CONVERSION)
        if YakSet(app_instance, "FREQUENCY/CENTER", str(hz_value), console_print_func) == "PASSED":
            app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
            return True
    except ValueError:
        console_print_func(f"❌ Invalid frequency value: '{value}'. Please enter a number.")
    return False

def set_span_frequency(app_instance, value, console_print_func):
    """
    Sets the span frequency on the instrument and triggers a GUI refresh.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to set span: {value} MHz.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot set span.")
        return False
        
    try:
        hz_value = int(float(value) * MHZ_TO_HZ_CONVERSION)
        if YakSet(app_instance, "FREQUENCY/SPAN", str(hz_value), console_print_func) == "PASSED":
            app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
            return True
    except ValueError:
        console_print_func(f"❌ Invalid span value: '{value}'. Please enter a number.")
    return False

def set_start_frequency(app_instance, value, console_print_func):
    """
    Sets the start frequency on the instrument and triggers a GUI refresh.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to set start frequency: {value} MHz.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot set start frequency.")
        return False
        
    try:
        hz_value = int(float(value) * MHZ_TO_HZ_CONVERSION)
        if YakSet(app_instance, "FREQUENCY/START", str(hz_value), console_print_func) == "PASSED":
            app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
            return True
    except ValueError:
        console_print_func(f"❌ Invalid start frequency value: '{value}'. Please enter a number.")
    return False

def set_stop_frequency(app_instance, value, console_print_func):
    """
    Sets the stop frequency on the instrument and triggers a GUI refresh.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to set stop frequency: {value} MHz.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot set stop frequency.")
        return False
        
    try:
        hz_value = int(float(value) * MHZ_TO_HZ_CONVERSION)
        if YakSet(app_instance, "FREQUENCY/STOP", str(hz_value), console_print_func) == "PASSED":
            app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
            return True
    except ValueError:
        console_print_func(f"❌ Invalid stop frequency value: '{value}'. Please enter a number.")
    return False

def set_resolution_bandwidth(app_instance, value, console_print_func):
    """
    Sets the resolution bandwidth on the instrument and triggers a GUI refresh.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to set resolution bandwidth: {value} Hz.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot set RBW.")
        return False
    
    try:
        hz_value = int(float(value))
        if YakSet(app_instance, "BANDWIDTH/RESOLUTION", str(hz_value), console_print_func) == "PASSED":
            app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
            return True
    except ValueError:
        console_print_func(f"❌ Invalid RBW value: '{value}'. Please enter a number.")
    return False
    
def set_video_bandwidth(app_instance, value, console_print_func):
    """
    Sets the video bandwidth on the instrument and triggers a GUI refresh.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to set video bandwidth: {value} Hz.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot set VBW.")
        return False
        
    try:
        hz_value = int(float(value))
        if YakSet(app_instance, "BANDWIDTH/VIDEO", str(hz_value), console_print_func) == "PASSED":
            app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
            return True
    except ValueError:
        console_print_func(f"❌ Invalid VBW value: '{value}'. Please enter a number.")
    return False
    
def toggle_vbw_auto(app_instance, console_print_func):
    """
    Toggles the automatic VBW setting on the instrument and triggers a GUI refresh.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to toggle VBW auto.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot toggle VBW Auto.")
        return False
    
    current_state = app_instance.vbw_auto_on_var.get()
    new_state = "OFF" if current_state else "ON"
    
    if YakDo(app_instance, f"BANDWIDTH/VIDEO/AUTO/{new_state}", console_print_func=console_print_func) == "PASSED":
        app_instance.vbw_auto_on_var.set(not current_state)
        app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
        return True
    return False
    
def set_continuous_initiate_mode(app_instance, mode, console_print_func):
    """
    Sets the continuous initiate mode on the instrument and triggers a GUI refresh.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to set continuous initiate mode: {mode}.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot set continuous initiate mode.")
        return False
    
    mode_str = "ON" if mode else "OFF"
    if YakDo(app_instance, f"INITIATE/CONTINUOUS/{mode_str}", console_print_func=console_print_func) == "PASSED":
        app_instance.initiate_continuous_on_var.set(mode)
        app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
        return True
    return False
    
def do_immediate_initiate(app_instance, console_print_func):
    """
    Initiates an immediate sweep on the instrument and triggers a GUI refresh.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to initiate immediate scan.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot initiate immediate scan.")
        return False
    
    if YakDo(app_instance, "INITIATE/IMMEDIATE", console_print_func=console_print_func) == "PASSED":
        console_print_func("✅ Immediate scan initiated successfully.")
        app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
        return True
    return False
    
def set_reference_level(tab_instance, app_instance, value, console_print_func):
    """
    Sets the reference level on the instrument and triggers a GUI refresh.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to set reference level: {value} dBm.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot set reference level.")
        return False
    
    try:
        int_value = int(float(value))
        if YakDo(app_instance, f"AMPLITUDE/REFERENCE LEVEL/{int_value}", console_print_func=console_print_func) == "PASSED":
            app_instance.ref_level_dbm_var.set(value)
            app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
            return True
        else:
            return False
    except (ValueError, TypeError) as e:
        console_print_func(f"❌ Invalid reference level value: '{value}'. Please enter a number. Error: {e}")
        debug_log(f"🐐 ❌ ValueError: could not convert reference level to int. Failed to parse data. Error: {e}",
                  file=current_file,
                  version=current_version,
                  function=current_function, special=True)
        return False
    except Exception as e:
        console_print_func(f"❌ An unexpected error occurred while setting the reference level: {e}")
        debug_log(f"🐐 🧨 An unexpected error occurred: {e}",
                  file=current_file,
                  version=current_version,
                  function=current_function, special=True)
        return False


def toggle_preamp(tab_instance, app_instance, console_print_func):
    """
    Toggles the preamp on or off and updates the UI state.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to toggle the preamp switch! ⚡",
              file=current_file,
              version=current_version,
              function=current_function)
    
    try:
        is_on = app_instance.preamp_on_var.get()
        if is_on:
            YakDo(app_instance, "AMPLITUDE/POWER/GAIN/OFF", console_print_func=console_print_func)
            app_instance.preamp_on_var.set(False)
            console_print_func("✅ Preamp turned OFF.")
            if app_instance.high_sensitivity_on_var.get():
                debug_log(f"🐐 Preamp turned off, automatically turning off high sensitivity. 🕵️‍♀️",
                        file=current_file,
                        version=current_version,
                        function=current_function)
                toggle_high_sensitivity(tab_instance=tab_instance, app_instance=app_instance, console_print_func=console_print_func)
        else:
            YakDo(app_instance, "AMPLITUDE/POWER/GAIN/ON", console_print_func=console_print_func)
            app_instance.preamp_on_var.set(True)
            console_print_func("✅ Preamp turned ON.")

        tab_instance._update_toggle_button_style(button=tab_instance.preamp_toggle_button, state=app_instance.preamp_on_var.get())
        app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))

    except Exception as e:
        console_print_func(f"❌ Error toggling preamp: {e}")
        debug_log(f"🐐 🧨 Arrr, the code be capsized! Error toggling preamp: {e} 🏴‍☠️",
                  file=current_file,
                  version=current_version,
                  function=current_function)


def toggle_high_sensitivity(tab_instance, app_instance, console_print_func):
    """
    Toggles the high sensitivity mode on or off and updates the UI state.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to toggle the high sensitivity switch! 🔬",
              file=current_file,
              version=current_version,
              function=current_function)

    try:
        is_on = app_instance.high_sensitivity_on_var.get()
        if is_on:
            YakDo(app_instance, "AMPLITUDE/POWER/HIGH SENSITIVE/OFF", console_print_func=console_print_func)
            app_instance.high_sensitivity_on_var.set(False)
            console_print_func("✅ High Sensitivity turned OFF.")
        else:
            YakDo(app_instance, "AMPLITUDE/POWER/HIGH SENSITIVE/ON", console_print_func=console_print_func)
            app_instance.high_sensitivity_on_var.set(True)
            console_print_func("✅ High Sensitivity turned ON.")

        tab_instance._update_toggle_button_style(button=tab_instance.hs_toggle_button, state=app_instance.high_sensitivity_on_var.get())
        
        results = YakNab(app_instance, "AMPLITUDE/POWER/HIGH SENSITIVE", console_print_func=console_print_func)
        if results is not None and len(results) >= 3:
            ref_level_dbm, attenuation_db, preamp_on = results
            app_instance.ref_level_dbm_var.set(float(ref_level_dbm))
            app_instance.power_attenuation_db_var.set(float(attenuation_db))
            app_instance.preamp_on_var.set(int(preamp_on) == 1)
            tab_instance._set_ui_initial_state()
            console_print_func("✅ Updated UI with new values from instrument.")
        
    except Exception as e:
        console_print_func(f"❌ Error toggling high sensitivity: {e}")
        debug_log(f"🐐 🧨 Arrr, the code be capsized! The error be: {e} 🏴‍☠️",
                  file=current_file,
                  version=current_version,
                  function=current_function)


def set_power_attenuation(tab_instance, app_instance, value, console_print_func):
    """
    Sets the power attenuation on the instrument and triggers a GUI refresh.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to set power attenuation: {value} dB.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot set power attenuation.")
        return False
    
    if YakDo(app_instance, f"AMPLITUDE/POWER/ATTENUATION/{value}DB", console_print_func=console_print_func) == "PASSED":
        app_instance.power_attenuation_db_var.set(value)
        app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
        return True
    return False
    
    
def set_trace_mode(app_instance, trace_number, mode, console_print_func):
    """
    Sets the trace mode for a specific trace on the instrument and triggers a GUI refresh.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to set trace {trace_number} mode: {mode}.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot set trace mode.")
        return False
    
    if YakDo(app_instance, f"TRACE/{trace_number}/MODE/{mode}", console_print_func=console_print_func) == "PASSED":
        trace_var = getattr(app_instance, f"trace{trace_number}_mode_var")
        trace_var.set(mode)
        app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
        return True
    return False
    
def do_turn_all_markers_on(app_instance, console_print_func):
    """
    Turns on all markers on the instrument and triggers a GUI refresh.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to turn on all markers.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot turn on markers.")
        return False
    
    if YakDo(app_instance, "MARKER/All/CALCULATE/STATE/ON", console_print_func=console_print_func) == "PASSED":
        app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
        return True
    return False
    
def toggle_marker_state(app_instance, marker_number, state, console_print_func):
    """
    Toggles the state of a specific marker on the instrument and triggers a GUI refresh.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to toggle marker {marker_number} state to {state}.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot set marker state.")
        return False
        
    new_state = "ON" if state else "OFF"
    if YakDo(app_instance, f"MARKER/{marker_number}/CALCULATE/STATE/{new_state}", console_print_func=console_print_func) == "PASSED":
        app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
        return True
    return False
    
def do_peak_search(app_instance, console_print_func):
    """
    Performs a peak search on the instrument and triggers a GUI refresh.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to perform peak search.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot perform peak search.")
        return False
    
    if YakDo(app_instance, "MARKER/PEAK/SEARCH", console_print_func=console_print_func) == "PASSED":
        console_print_func("✅ Peak search command sent successfully.")
        app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
        return True
    return False

def toggle_trace_averaging(app_instance, trace_number, is_on, console_print_func):
    """
    Function Description:
    Toggles the averaging state for a specific trace and triggers a GUI refresh.
    
    Inputs:
    - app_instance (object): A reference to the main application instance.
    - trace_number (int): The number of the trace to toggle (1-4).
    - is_on (bool): The desired state for averaging (True for ON, False for OFF).
    - console_print_func (function): A function to print messages to the GUI console.
    
    Outputs:
    - bool: True if the command is executed successfully, False otherwise.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to toggle trace averaging for trace {trace_number} to {is_on}.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot toggle trace averaging.")
        return False

    state_str = "ON" if is_on else "OFF"
    command_type = f"AVERAGE/{state_str}"
    
    if YakDo(app_instance, command_type, console_print_func) == "PASSED":
        console_print_func(f"✅ Trace {trace_number} averaging turned {state_str}.")
        app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
        return True
    
    return False

def set_trace_averaging_count(app_instance, trace_number, count, console_print_func):
    """
    Function Description:
    Sets the averaging count for a specific trace and triggers a GUI refresh.
    
    Inputs:
    - app_instance (object): A reference to the main application instance.
    - trace_number (int): The number of the trace to set (1-4).
    - count (int): The desired averaging count.
    - console_print_func (function): A function to print messages to the GUI console.
    
    Outputs:
    - bool: True if the command is executed successfully, False otherwise.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to set trace averaging count for trace {trace_number} to {count}.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot set trace averaging count.")
        return False
        
    command_type = f"AVERAGE"
    variable_value = count
    
    if YakSet(app_instance, command_type, variable_value, console_print_func) == "PASSED":
        console_print_func(f"✅ Trace {trace_number} averaging count set to {count}.")
        app_instance.after(0, lambda: _trigger_gui_refresh(app_instance))
        return True
    
    return False

def get_trace_averaging_settings(app_instance, trace_number, console_print_func) -> (bool, int):
    """
    Function Description:
    Retrieves the averaging state and count for a specific trace using a single NAB command.
    
    Inputs:
    - app_instance (object): A reference to the main application instance.
    - trace_number (int): The number of the trace to query (1-4).
    - console_print_func (function): A function to print messages to the GUI console.
    
    Outputs:
    - (bool, int): A tuple containing the averaging state (True/False) and the count, or (None, None) on failure.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to retrieve averaging settings for trace {trace_number}.",
              file=current_file,
              version=current_version,
              function=current_function)
              
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot retrieve averaging settings.")
        return None, None

    command_type = "AVERAGE"
    
    response = YakNab(app_instance, command_type, console_print_func)
    
    if response and isinstance(response, list) and len(response) >= 2:
        try:
            state_str = response[0]
            count_str = response[1]
            
            is_on = state_str in ["ON", "1"]
            count = int(float(count_str))
            
            return is_on, count
        except (ValueError, IndexError, TypeError) as e:
            console_print_func(f"❌ Failed to parse averaging settings. Error: {e}")
            debug_log(f"🐐 ❌ Arrr, the response be gibberish! Error: {e}",
                      file=current_file,
                      version=current_version,
                      function=current_function)
    
    return None, None

def _process_trace_data(raw_data_string, start_freq_hz, end_freq_hz, console_print_func):
    """
    Function Description:
    Processes a raw comma-separated string of trace amplitude data into
    a list of (frequency, amplitude) pairs.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 Processing raw trace data into frequency/amplitude pairs. This is a crucial step.",
              file=current_file,
              version=current_version,
              function=current_function)

    if not raw_data_string or "FAILED" in raw_data_string:
        console_print_func("❌ Received invalid data from the instrument. Cannot process trace.")
        return None

    try:
        amplitudes_dbm = [float(val) for val in raw_data_string.split(',')]
        
        num_points = len(amplitudes_dbm)
        if num_points <= 1:
            console_print_func("⚠️ Received insufficient data points from the instrument. Cannot create a meaningful trace.")
            return None
            
        freq_points = np.linspace(start_freq_hz, end_freq_hz, num_points)
        
        processed_data = list(zip(freq_points / MHZ_TO_HZ_CONVERSION, amplitudes_dbm))

        debug_log(f"🐐 ✅ Successfully processed trace data. First 5 points: {processed_data[:5]}...",
                  file=current_file,
                  version=current_version,
                  function=current_function)
        
        return processed_data

    except ValueError as e:
        console_print_func(f"❌ Failed to parse trace data string. Error: {e}")
        debug_log(f"🐐 ❌ ValueError: could not convert string to float. Failed to parse data string. Error: {e}",
                  file=current_file,
                  version=current_version,
                  function=current_function, special=True)
        return None
    except Exception as e:
        console_print_func(f"❌ An unexpected error occurred while processing trace data: {e}")
        debug_log(f"🐐 🧨 An unexpected error occurred: {e}",
                  file=current_file,
                  version=current_version,
                  function=current_function, special=True)
        return None


def get_trace_data_logic(app_instance, console_print_func):
    """
    Function Description:
    Retrieves trace data for all active traces from the instrument.
    This function has been refactored to be more robust, checking for valid data and
    handling different trace modes with a simple update cycle counter.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 Getting trace data from the instrument.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot get trace data.")
        return False
    
    all_trace_data = []

    center_freq_hz = float(YakGet(app_instance, "FREQUENCY/CENTER", console_print_func))
    span_hz = float(YakGet(app_instance, "FREQUENCY/SPAN", console_print_func))
    start_freq_hz = center_freq_hz - (span_hz / 2)
    end_freq_hz = center_freq_hz + (span_hz / 2)

    for i in range(1, 5):
        command_type = f"TRACE/{i}/DATA"
        raw_data_string = YakGet(app_instance, command_type.upper(), console_print_func)
        
        if raw_data_string is not None and raw_data_string != "FAILED":
            processed_data = _process_trace_data(raw_data_string, start_freq_hz, end_freq_hz, console_print_func)
            if processed_data:
                all_trace_data.append(processed_data)
                console_print_func(f"✅ Trace {i} data received and processed.")
            else:
                all_trace_data.append(None)
                console_print_func(f"❌ Failed to process Trace {i} data.")
        else:
            all_trace_data.append(None)
            console_print_func(f"❌ Failed to retrieve Trace {i} data.")
    
    return all_trace_data
    
def do_power_cycle(app_instance, console_print_func):
    """
    Sends a power cycle command to the instrument and handles the disconnection state.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to power cycle the device.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot power cycle device.")
        return False

    console_print_func("⚠️ Initiating device power cycle. Connection will be lost for ~20 seconds. Please wait to reconnect.")
    
    if YakDo(app_instance, "POWER/RESET", console_print_func=console_print_func) == "PASSED":
        app_instance.is_connected.set(False)
        return True
        
    return False

def get_all_marker_values_logic(app_instance, console_print_func):
    """
    Retrieves and returns the X and Y values for all active markers.
    Returns a list of tuples: [(x1, y1), (x2, y2), ...]
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 Getting all marker values from the instrument.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot read markers.")
        return None
    
    marker_values = []
    for i in range(1, 7):
        marker_state = YakGet(app_instance, f"MARKER/{i}/CALCULATE/STATE", console_print_func)
        if marker_state in ["ON", "1"]:
            x_value = YakGet(app_instance, f"MARKER/{i}/CALCULATE/X", console_print_func)
            y_value = YakGet(app_instance, f"MARKER/{i}/CALCULATE/Y", console_print_func)

            try:
                x_value_mhz = float(x_value) / MHZ_TO_HZ_CONVERSION
                y_value_dbm = float(y_value)
                marker_values.append((x_value_mhz, y_value_dbm))
            except (ValueError, TypeError):
                console_print_func(f"⚠️ Could not parse marker {i} values.")
                debug_log(f"🐐 ❌ Failed to parse marker {i} values. What a mess!",
                          file=current_file,
                          version=current_version,
                          function=current_function)
                marker_values.append((None, None))
    
    return marker_values


def reset_device(app_instance, console_print_func):
    """
    Sends a soft reset command to the instrument.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 API call to reset the device.",
              file=current_file,
              version=current_version,
              function=current_function)
    
    if not app_instance.is_connected.get():
        console_print_func("❌ Not connected to an instrument. Cannot reset device.")
        return False
    
    if YakDo(app_instance, "SYSTEM/RESET", console_print_func=console_print_func) == "PASSED":
        return True
    return False


#####################################
### File: OPEN-AIR 2\agents\yak\utils_yak_visa.py
#####################################
# tabs/Instrument/utils_yak_visa.py
#
# This file provides utility functions for safe and standardized execution of
# VISA commands (GET, SET, DO) on connected instruments. It wraps PyVISA operations
# with error handling and integrates with the application's debug logging.
# NOTE: The high-level command execution logic (e.g., `execute_visa_command`) has been
# moved to the new `Yakety_Yak.py` file to separate concerns and improve modularity.
# This file now focuses exclusively on low-level, safe read/write operations.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.210502.1
# UPDATED: All debug messages now include the required 🐐 emoji at the start.

import inspect
import pyvisa
import time
import os

# Updated imports for new logging functions
from display.debug_logic import debug_log, log_visa_command
from display.console_logic import console_log

# --- Versioning ---
w = 20250821
x_str = '210502'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"


def _reset_device(inst, console_print_func):
    """
    Function Description:
    Sends a soft reset command to the instrument to restore a known state after an error.
    This is a last resort to recover from a bad state. It's a fucking miracle worker!

    Inputs to this function:
    - inst: The PyVISA instrument instance.
    - console_print_func: The function to print messages to the GUI console.

    Process of this function:
    1. Sends the '*RST' command using write_safe.
    2. Logs the attempt and the result to the debug and console.
    
    Outputs of this function:
    - bool: True if the reset command was sent, False otherwise.
    """
    current_function = inspect.currentframe().f_code.co_name
    console_print_func("⚠️ Command failed. Attempting to reset the instrument with '*RST'...")
    debug_log(f"🐐 🟡 Command failed. Attempting to send reset command '*RST' to the instrument.",
                file=current_file,
                version=current_version,
                function=current_function)
    # Use the write_safe function to send the reset command
    reset_success = write_safe(inst, "*RST", console_print_func)
    if reset_success:
        console_print_func("✅ Device reset command sent successfully.")
        debug_log("🐐 ✅ Reset command sent. Goddamn, that felt good!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
    else:
        console_print_func("❌ Failed to send reset command.")
        debug_log("🐐 ❌ Failed to send reset command. This is a goddamn mess!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
    return reset_success


def write_safe(inst, command, console_print_func):
    # Function Description:
    # Safely writes a SCPI command to the instrument.
    # Logs the command and handles potential errors.
    #
    # Inputs to this function:
    # - inst (pyvisa.resources.Resource): The PyVISA instrument object.
    # - command (str): The SCPI command string to write.
    # - console_print_func (function): Function to print messages to the GUI console.
    #
    # Process of this function:
    # 1. Checks if the instrument is connected.
    # 2. Attempts to write the command.
    # 3. Logs success or failure to the console and debug log.
    #
    # Outputs of this function:
    # - bool: True if the command was written successfully, False otherwise.
    #
    # (2025-08-01) Change: Refactored to use new logging.
    # (2025-08-11) Change: No changes.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 📝 Attempting to write command: {command}",
                file=current_file,
                version=current_version,
                function=current_function)
    if not inst:
        console_print_func("⚠️ Warning: Instrument not connected. Cannot write command.")
        debug_log("🐐 ❌ Instrument not connected. Fucking useless!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return False
    try:
        inst.write(command)
        log_visa_command(command, "SENT") # Log the VISA command
        return True
    except Exception as e:
        console_print_func(f"❌ Error writing command '{command}': {e}")
        debug_log(f"🐐 🧨 Error writing command '{command}': {e}. This thing is a pain in the ass!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        _reset_device(inst, console_print_func)
        return False

def query_safe(inst, command, console_print_func):
    # Function Description:
    # Safely queries the instrument with a SCPI command and returns the response.
    # Logs the command and response, and handles potential errors.
    #
    # Inputs to this function:
    # - inst (pyvisa.resources.Resource): The PyVISA instrument object.
    # - command (str): The full SCPI command string to query.
    # - console_print_func (function): Function to print messages to the GUI console.
    #
    # Process of this function:
    # 1. Checks if the instrument is connected.
    # 2. Attempts to query the instrument.
    # 3. Logs the command, response, and handles errors.
    #
    # Outputs of this function:
    # - str or None: The instrument's response if successful, None otherwise.
    #
    # (2025-08-01) Change: Refactored to use new logging.
    # (2025-08-11) Change: No changes.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 📝 Attempting to query command: {command}",
                file=current_file,
                version=current_version,
                function=current_function)
    if not inst:
        console_print_func("⚠️ Warning: Instrument not connected. Cannot query command.")
        debug_log("🐐 ❌ Instrument not connected. Fucking useless!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return None
    try:
        response = inst.query(command).strip()
        log_visa_command(command, "SENT") # Log the VISA command
        log_visa_command(response, "RECEIVED") # Log the VISA response
        return response
    except Exception as e:
        console_print_func(f"❌ Error querying command '{command}': {e}")
        debug_log(f"🐐 🧨 Error querying command '{command}': {e}. This goddamn thing is broken!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        _reset_device(inst, console_print_func)
        return None

def set_safe(inst, command, value, console_print_func):
    """
    Function Description:
    Safely writes a SET command to the instrument with a specified value.

    Inputs to this function:
    - inst: The PyVISA instrument instance.
    - command (str): The base VISA command string (e.g., ":SENSe:FREQuency:CENTer").
    - value: The value to set (will be converted to string).
    - console_print_func (function): Function to print messages to the GUI console.

    Process of this function:
    1. Constructs the full command string.
    2. Calls write_safe to send the command.

    Outputs of this function:
    - bool: True if the command was written successfully, False otherwise.
    """
    current_function = inspect.currentframe().f_code.co_name
    full_command = f"{command} {value}"
    debug_log(f"🐐 📝 Attempting to SET: {full_command}",
                file=current_file,
                version=current_version,
                function=current_function)
    return write_safe(inst, full_command, console_print_func)

def _wait_for_opc(inst, console_print_func, timeout=5):

    """
    Function Description:
    Waits for the instrument's Operation Complete (OPC) flag by querying *OPC?.
    This is a blocking function that handles timeouts.

    Inputs to this function:
    - inst: The PyVISA instrument instance.
    - console_print_func: The function to print messages to the GUI console.
    - timeout (int): The maximum time to wait for a response in seconds.

    Outputs of this function:
    - str: "PASSED" if the operation completes, "TIME FAILED" on timeout,
      or "FAILED" for other errors.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🟠 Waiting for Operation Complete (*OPC?) with a timeout of {timeout} seconds. Let's see if this thing is done!",
                file=current_file,
                version=current_version,
                function=current_function)

    original_timeout = inst.timeout
    inst.timeout = timeout * 1000 # PyVISA timeout is in milliseconds

    try:
        response = inst.query("*OPC?").strip()
        inst.timeout = original_timeout # Restore original timeout
        log_visa_command("*OPC?", "SENT")
        log_visa_command(response, "RECEIVED")

        if response == "1":
            console_print_func("✅ Operation Complete. Fucking brilliant!")
            debug_log("🐐 ✅ OPC query successful. Fucking brilliant!",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return "PASSED"
        else:
            console_print_func("❌ Operation failed to complete or returned an unexpected value.")
            debug_log(f"🐐 ❌ OPC query returned '{response}', not '1'. What the hell?!",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            _reset_device(inst, console_print_func)
            return "FAILED"

    except pyvisa.errors.VisaIOError as e:
        inst.timeout = original_timeout # Restore original timeout
        console_print_func(f"❌ Operation Complete query timed out after {timeout} seconds.")
        debug_log(f"🐐 ❌ OPC query failed with a timeout: {e}. This thing is a stubborn bastard!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        _reset_device(inst, console_print_func)
        return "TIME FAILED"
    except Exception as e:
        inst.timeout = original_timeout # Restore original timeout
        console_print_func(f"❌ Error during Operation Complete query: {e}")
        debug_log(f"🐐 🧨 Error during OPC query: {e}. This bugger is being problematic!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        _reset_device(inst, console_print_func)
        return "FAILED"


#####################################
### File: OPEN-AIR 2\agents\yak\utils_yakbeg_handler.py
#####################################
# yak/utils_yaknab_handler.py
#
# This file provides handler functions for new "NAB" commands. These commands
# are designed for efficient, single-query retrieval of multiple instrument settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.210502.1
# UPDATED: Added new handler for Amplitude settings.
# FIXED: Corrected the parsing logic to handle both float and string responses for boolean-like settings.
# UPDATED: The function now handles a 5th return value for Sweep Time.
# NEW: Implemented a new handler for the TRACE/ALL/ONETWOTHREE NAB command, designed to handle multiple reads for large data sets.
# UPDATED: All debug messages now include the required 🐐 emoji at the start.

import inspect
import os
import numpy as np
from typing import Optional, List, Dict

from yak.Yakety_Yak import YakBeg, YakNab
from display.debug_logic import debug_log
from display.console_logic import console_log

# --- Versioning ---
w = 20250821
x_str = '210502'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"


# Helper conversion function
MHZ_TO_HZ = 1000000

def handle_freq_start_stop_beg(app_instance, start_freq, stop_freq, console_print_func):
    # Function Description:
    # Handles the extended YakBeg command for FREQUENCY/START-STOP.
    # It now returns start, stop, center, and span frequencies.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🟢 Entering {current_function}. Arrr, a treasure map for frequencies! 🗺️",
                file=current_file,
                version=current_version,
                function=current_function)
    
    # We send start and stop, and get back start, stop, span, and center
    response = YakBeg(app_instance, "FREQUENCY/START-STOP", console_print_func, start_freq, stop_freq)
    
    if response and response != "FAILED":
        try:
            # Response is a semicolon-separated string of four values
            parts = response.split(';')
            if len(parts) == 4:
                start = float(parts[0])
                stop = float(parts[1])
                span = float(parts[2])
                center = float(parts[3])
                debug_log(f"🐐 ✅ Processed response: start={start}, stop={stop}, span={span}, center={center}",
                        file=current_file,
                        version=current_version,
                        function=current_function)
                return start, stop, span, center
        except (ValueError, IndexError) as e:
            console_print_func(f"❌ Failed to parse response from instrument for multiple traces. Error: {e}")
            debug_log(f"🐐 ❌ Arrr, the response be gibberish! Error: {e}",
                        file=current_file,
                        version=current_version,
                        function=current_function)
    return None, None, None, None

def handle_freq_center_span_beg(app_instance, center_freq, span_freq, console_print_func):
    # Function Description:
    # Handles the extended YakBeg command for FREQUENCY/CENTER-SPAN.
    # It now returns center, span, start, and stop frequencies.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🟢 Entering {current_function}. Plotting a course to the center! 🧭",
                file=current_file,
                version=current_version,
                function=current_function)
    
    # We send center and span, and get back span, center, start, and stop
    response = YakBeg(app_instance, "FREQUENCY/CENTER-SPAN", console_print_func, center_freq, span_freq)
    
    if response and response != "FAILED":
        try:
            # Response is a semicolon-separated string of four values
            parts = response.split(';')
            if len(parts) == 4:
                # FIXED: Correct parsing order to match the VISA response
                span = float(parts[0])
                center = float(parts[1])
                start = float(parts[2])
                stop = float(parts[3])
                debug_log(f"🐐 ✅ Processed response: center={center}, span={span}, start={start}, stop={stop}",
                        file=current_file,
                        version=current_version,
                        function=current_function)
                return center, span, start, stop
        except (ValueError, IndexError) as e:
            console_print_func(f"❌ Failed to parse response from instrument for multiple traces. Error: {e}")
            debug_log(f"🐐 ❌ Arrr, the response be gibberish! Error: {e}",
                        file=current_file,
                        version=current_version,
                        function=current_function)
    return None, None, None, None

def handle_marker_place_all_beg(app_instance, marker_freqs_mhz, console_print_func):
    # Function Description:
    # Handles the YakBeg command for MARKER/PLACE/ALL.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🟢 Entering {current_function}. Parameters: marker_freqs_mhz={marker_freqs_mhz}",
                file=current_file,
                version=current_version,
                function=current_function)
    
    if not app_instance.inst:
        console_print_func("❌ No instrument connected. Cannot set markers.")
        debug_log("🐐 ❌ No instrument connected. Aborting marker operation.",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return "FAILED"

    marker_freqs_hz = []
    for freq in marker_freqs_mhz:
        try:
            marker_freqs_hz.append(int(float(freq) * MHZ_TO_HZ))
        except ValueError:
            console_print_func(f"❌ Invalid marker frequency entered: '{freq}'. Must be a number.")
            debug_log(f"🐐 🚫 Invalid marker frequency entered: '{freq}'. Aborting YakBeg.",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return "FAILED"

    response = YakBeg(app_instance, "MARKER/PLACE/ALL", console_print_func, *marker_freqs_hz)
    
    debug_log(f"🐐 ✅ Marker operation complete. Response: {response}. ✅",
                file=current_file,
                version=current_version,
                function=current_function)
    return response

def handle_trace_modes_beg(app_instance, trace_modes, console_print_func):
    # Function Description:
    # Handles the YakBeg command for TRACE/MODES.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🟢 Entering {current_function}",
                file=current_file,
                version=current_version,
                function=current_function)
    response = YakBeg(app_instance, "TRACE/MODES", console_print_func, *trace_modes)
    debug_log(f"🐐 ✅ Trace mode operation complete. Response: {response}. ✅",
                file=current_file,
                version=current_version,
                function=current_function)
    return response

def handle_trace_data_beg(app_instance, trace_number, start_freq_mhz, stop_freq_mhz, console_print_func):
    # Function Description:
    # Handles the YakBeg command for TRACE/DATA, including parsing and returning data.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🟢 Entering {current_function}",
                file=current_file,
                version=current_version,
                function=current_function)
    
    command_type = f"TRACE/{trace_number}/DATA"
    start_freq_hz = int(start_freq_mhz * MHZ_TO_HZ)
    stop_freq_hz = int(stop_freq_mhz * MHZ_TO_HZ)

    response_string = YakBeg(app_instance, command_type, console_print_func, start_freq_hz, stop_freq_hz)

    if response_string and response_string != "FAILED":
        try:
            values = [float(val.strip()) for val in response_string.split(',') if val.strip()]
            num_points = len(values)
            if num_points > 0:
                frequencies = np.linspace(start_freq_hz, stop_freq_hz, num_points)
                debug_log(f"🐐 ✅ Successfully parsed {num_points} data points from trace response.",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return list(zip(frequencies / MHZ_TO_HZ, values))
        except (ValueError, IndexError, TypeError) as e:
            console_print_func(f"❌ Failed to parse trace data: {e}. What a disaster!")
            debug_log(f"🐐 ❌ Failed to parse trace data string. Error: {e}",
                        file=current_file,
                        version=current_version,
                        function=current_function)
    return None


#####################################
### File: OPEN-AIR 2\agents\yak\utils_yaknab_handler.py
#####################################
# yak/utils_yaknab_handler.py
#
# This file provides handler functions for new "NAB" commands. These commands
# are designed for efficient, single-query retrieval of multiple instrument settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.210502.1
# UPDATED: Added new handler for Amplitude settings.
# FIXED: Corrected the parsing logic to handle both float and string responses for boolean-like settings.
# UPDATED: The function now handles a 5th return value for Sweep Time.
# NEW: Implemented a new handler for the TRACE/ALL/ONETWOTHREE NAB command, designed to handle multiple reads for large data sets.
# UPDATED: All debug messages now include the required 🐐 emoji at the start.

import inspect
import os
import numpy as np
from typing import Optional, List, Dict

from yak.Yakety_Yak import YakBeg, YakNab
from display.debug_logic import debug_log
from display.console_logic import console_log


# --- Versioning ---
w = 20250821
x_str = '210502'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"


# Helper conversion function
MHZ_TO_HZ = 1000000

def handle_bandwidth_settings_nab(app_instance, console_print_func) -> Optional[Dict]:
    """
    Function Description:
    Executes the "BANDWIDTH/SETTINGS" NAB command to retrieve multiple bandwidth
    settings in a single query. It returns a dictionary of the retrieved values.
    
    The corresponding NAB command can be found in `visa_commands.csv`.

    Inputs:
    - app_instance (object): A reference to the main application instance.
    - console_print_func (function): A function to print messages to the GUI console.

    Outputs:
    - dict: A dictionary containing the fetched settings, or None on failure.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🟢 Entering {current_function}. Retrieving all bandwidth settings with a single NAB command. Let's make this snappy! ⚡",
              file=current_file,
              version=current_version,
              function=current_function)
    
    response = YakNab(app_instance, "BANDWIDTH/SETTINGS", console_print_func)

    if response and isinstance(response, list) and len(response) == 5:
        try:
            vbw_auto_on_value = response[2]
            continuous_mode_on_value = response[3]
            
            settings = {
                "RBW_Hz": float(response[0]),
                "VBW_Hz": float(response[1]),
                "VBW_Auto_On": vbw_auto_on_value == 'ON' or vbw_auto_on_value == '1' or float(vbw_auto_on_value) == 1.0,
                "Continuous_Mode_On": continuous_mode_on_value == 'ON' or continuous_mode_on_value == '1' or float(continuous_mode_on_value) == 1.0,
                "Sweep_Time_s": float(response[4])
            }
            console_print_func("✅ Successfully retrieved all bandwidth settings.")
            debug_log(f"🐐 ✅ Successfully retrieved bandwidth settings: {settings}. A truly magnificent feat! ✨",
                      file=current_file,
                      version=current_version,
                      function=current_function)
            return settings
        except (ValueError, IndexError) as e:
            console_print_func(f"❌ Failed to parse response from instrument for bandwidth settings. Error: {e}")
            debug_log(f"🐐 ❌ Arrr, the response be gibberish! Error: {e}",
                      file=current_file,
                      version=current_version,
                      function=current_function)
            return None
    
    console_log("❌ Failed to retrieve all bandwidth settings from instrument.")
    return None


def handle_amplitude_settings_nab(app_instance, console_print_func) -> Optional[Dict]:
    """
    Function Description:
    Executes a NAB command to retrieve multiple amplitude settings in a single query.
    It retrieves the Reference Level, Power Attenuation, and Preamp state.
    
    The corresponding NAB command can be found in `visa_commands.csv`.

    Inputs:
    - app_instance (object): A reference to the main application instance.
    - console_print_func (function): A function to print messages to the GUI console.

    Outputs:
    - dict: A dictionary containing the fetched settings, or None on failure.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🟢 Entering {current_function}. Retrieving all amplitude settings with a single NAB command. A treasure hunt for data! 🗺️",
              file=current_file,
              version=current_version,
              function=current_function)
    
    response = YakNab(app_instance, "AMPLITUDE/SETTINGS", console_print_func)

    if response and isinstance(response, list) and len(response) == 3:
        try:
            settings = {
                "Ref_Level_dBm": float(response[0]),
                "Attenuation_dB": float(response[1]),
                "Preamp_On": response[2].upper() == 'ON' or response[2] == '1'
            }
            console_print_func("✅ Successfully retrieved all amplitude settings.")
            debug_log(f"🐐 ✅ Successfully retrieved amplitude settings: {settings}. A truly magnificent feat! ✨",
                      file=current_file,
                      version=current_version,
                      function=current_function)
            return settings
        except (ValueError, IndexError) as e:
            console_print_func(f"❌ Failed to parse response from instrument for amplitude settings. Error: {e}")
            debug_log(f"🐐 ❌ Arrr, the response be gibberish! Error: {e}",
                      file=current_file,
                      version=current_version,
                      function=current_function)
            return None
    
    console_log("❌ Failed to retrieve all amplitude settings from instrument.")
    return None


def handle_all_traces_nab(app_instance, console_print_func) -> Optional[Dict]:
    """
    Function Description:
    This handler executes the "TRACE/ALL/ONETWOTHREE" NAB command.
    It retrieves the start/stop frequencies, trace modes, and data for traces 1, 2, and 3
    in a single, efficient query. It then processes the complex response string into
    a structured dictionary of data and modes suitable for plotting or display.

    Inputs:
    - app_instance: The main application instance.
    - console_print_func: A function to print messages to the GUI console.

    Outputs:
    - Optional[Dict]: A dictionary with keys for "TraceData", "StartFreq", "StopFreq",
                      and "TraceModes" if successful.
                      Returns None on failure.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"🐐 🟢 Entering {current_function}. Retrieving multiple traces with a single NAB command.",
              file=current_file,
              version=current_version,
              function=current_function)

    response_list = YakNab(app_instance, "TRACE/ALL/ONETWOTHREE", console_print_func)

    if response_list and isinstance(response_list, list) and len(response_list) == 8:
        try:
            start_freq_hz = float(response_list[0])
            stop_freq_hz = float(response_list[1])

            trace_modes = {
                "Trace1": response_list[2],
                "Trace2": response_list[3],
                "Trace3": response_list[4],
            }

            trace_data = {}
            for i in range(1, 4):
                trace_string = response_list[i + 4]
                values = [float(val.strip()) for val in trace_string.split(',') if val.strip()]
                num_points = len(values)

                if num_points > 0:
                    frequencies = np.linspace(start_freq_hz, stop_freq_hz, num_points)
                    trace_data[f"Trace{i}"] = list(zip(frequencies / MHZ_TO_HZ, values))
                else:
                    trace_data[f"Trace{i}"] = []

            console_log("✅ Successfully retrieved and parsed data for three traces.")
            debug_log(f"🐐 ✅ Successfully retrieved traces. What a haul! 🎣",
                      file=current_file,
                      version=current_version,
                      function=current_function)

            return {
                "TraceData": trace_data,
                "StartFreq": start_freq_hz,
                "StopFreq": stop_freq_hz,
                "TraceModes": trace_modes
            }

        except (ValueError, IndexError, TypeError) as e:
            console_log(f"❌ Failed to parse response from instrument for multiple traces. Error: {e}")
            debug_log(f"🐐 ❌ Arrr, the response be gibberish! Error: {e}",
                      file=current_file,
                      version=current_version,
                      function=current_function)
    return None


#####################################
### File: OPEN-AIR 2\datasets\dataset_publisher.py
#####################################
import sys
import os

# Get the path of the parent directory (OPEN-AIR 2)
# and add it to the Python search path.
parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.append(parent_dir)

# Now, your imports will work correctly.
from workers.mqtt_controller_util import MqttControllerUtility

# The rest of your script follows...

# The rest of your script follows...
def main():
    """
    Initializes the MQTT utility, starts the broker, and publishes all JSON files
    in the current directory to the broker.
    """

    # Dummy functions for the MqttControllerUtility class
    def print_to_gui_func(message):
        print(f"GUI: {message}")

    def log_treeview_func(message):
        print(f"LOG: {message}")

    # Initialize the utility class
    mqtt_util = MqttControllerUtility(print_to_gui_func, log_treeview_func)
    
    # Start the Mosquitto broker
    mqtt_util.start_mosquitto()
    
    # Connect the MQTT client to the broker
    mqtt_util.connect_mqtt()

    # Get the current directory
    current_directory = os.path.dirname(os.path.abspath(__file__))
    
    # Find all JSON files in the current directory
    json_files = [f for f in os.listdir(current_directory) if f.endswith('.json')]

    if not json_files:
        print_to_gui_func("No JSON files found in the current directory.")
        return

    print_to_gui_func(f"Found {len(json_files)} JSON file(s) to publish.")

    for file_name in json_files:
        file_path = os.path.join(current_directory, file_name)
        topic = f"file_data/{os.path.splitext(file_name)[0]}"

        try:
            with open(file_path, 'r') as f:
                data = json.load(f)
            
            # Publish the entire JSON object as the value
            # Note: The `publish_message` function is designed for a single value.
            # We'll adapt it to publish the JSON data directly.
            
            # For simplicity, we can pass the data as a string
            mqtt_util.publish_message(topic=topic, subtopic="", value=json.dumps(data))
            
            print_to_gui_func(f"Successfully published '{file_name}' to topic '{topic}'.")

        except json.JSONDecodeError:
            print_to_gui_func(f"Error: Could not decode JSON from file '{file_name}'. Skipping.")
        except Exception as e:
            print_to_gui_func(f"An unexpected error occurred while processing '{file_name}': {e}")
            
    # You may want to keep the script running to allow other messages to be processed,
    # or you can stop the broker and client after publishing. For this example,
    # we'll assume the client runs on its own thread and the script will exit.

if __name__ == '__main__':
    main()

#####################################
### File: OPEN-AIR 2\datasets\logging.py
#####################################
# configuration/logging.py
#
# A simple utility file to provide standardized debugging functions for the application.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.215200.1

import os
import inspect
import datetime

# --- Global Scope Variables ---
# ⏰ As requested, the version is now hardcoded to the time this file was generated.
# The version strings and numbers below are static and will not change at runtime.
current_version = "20250822.215200.1"
# The hash calculation drops the leading zero from the hour, but 21 has no leading zero.
current_version_hash = (20250822 * 215200 * 1)
current_file = f"{os.path.basename(__file__)}"

# --- Logging Toggles ---
LOG_TO_TERMINAL = True
LOG_TO_FILE = True
FILE_LOG_PATH = "debug.log"


def console_log(message: str):
    """
    Prints a message to the console if the toggle is enabled.
    """
    current_function_name = inspect.currentframe().f_code.co_name

    try:
        if LOG_TO_TERMINAL:
            print(message)

    except Exception as e:
        if LOG_TO_TERMINAL:
            print(f"❌ Error in {current_function_name}: {e}")

def debug_log(message: str, file: str, version: str, function: str, console_print_func):
    """
    Prints a detailed debug message with a 'mad scientist' personality,
    directing output based on the global toggles.
    """
    current_function_name = inspect.currentframe().f_code.co_name
    
    try:
        # Re-formatting the message to better match the 'mad scientist' persona
        log_message = f"💡📝{message} | {file} | {version} Function: {function}"

        # --- Function logic goes here ---
        if LOG_TO_TERMINAL:
            console_print_func(log_message)

        if LOG_TO_FILE:
            # We explicitly open the log file with UTF-8 encoding to support emojis
            with open(FILE_LOG_PATH, "a", encoding="utf-8") as log_file:
                log_file.write(log_message + "\n")

    except Exception as e:
        if LOG_TO_TERMINAL:
            console_print_func(f"❌ Error in {current_function_name}: {e}")


#####################################
### File: OPEN-AIR 2\datasets\north star - ref_program_default_values.py
#####################################


# --- DEFINITIVE FIX: This dictionary now perfectly mirrors the provided config.ini and vars files ---
DEFAULT_CONFIG = {
    'Application': {
        'geometry': '1920x1127+1912+32',
        'window_state': 'zoomed',
        'last_config_save_time': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        'paned_window_sash_position_percentage': '40',
    },
    'Debug': {
        'general_debug_enabled': 'True',
        'debug_to_gui_console': 'True',
        'debug_to_terminal': 'False',
        'debug_to_file': 'True',
        'include_console_messages_to_debug_file': 'True',
        'log_visa_commands_enabled': 'False',
        'log_truncation_enabled': 'True',
        'include_visa_messages_to_debug_file': 'True',
    },
    'Instrument': {
        'brand': 'Keysight',
        'series': 'E440xB',
        'visa_resource': 'TCPIP0::192.168.1.100::inst0::INSTR',
    },
    'InstrumentSettings': {
        'center_freq_mhz': '1500',
        'span_freq_mhz': '3000',
        'start_freq_mhz': '0',
        'stop_freq_mhz': '3000',
        'rbw_mhz': '1',
        'vbw_mhz': '1',
        'vbw_auto_on': 'True',
        'initiate_continuous_on': 'True',
        'ref_level_dbm': '-30',
        'preamp_on': 'False',
        'power_attenuation_db': '10',
        'high_sensitivity_on': 'False',
        'high_pass_filter_on': 'False', # Added from vars file
    },
    'MarkerTab': {
        'showtime_mode': 'buffered',
        'span_hz': '1000000',
        'rbw_hz': '100000',
        'trace_live': 'True',
        'trace_max_hold': 'False',
        'trace_min_hold': 'False',
        'buffer_mhz': '3.0',
        'poke_freq_mhz': '444.444444',
        'buffered_start_var': '0.0',
        'buffered_stop_var': '0.0',
    },
    'Scan': {
        'output_folder': 'c:\\documents',
        'output_filename': 'DefaultScan',
        'start_freq_mhz': '0.0',
        'stop_freq_mhz': '3000.0',
        'step_freq_khz': '100.0',
        'dwell_time_ms': '100.0',
        'scan_band_selection': 'All',
        'open_html_after_complete': 'True',
        'include_markers': 'True',
        'include_gov_markers': 'True',
        'include_tv_markers': 'True',
        'include_scan_intermod_markers': 'True',
        'math_average': 'True',
        'math_median': 'True',
        'math_variance': 'True',
        'math_standard_deviation': 'True',
        'math_range': 'True',
        'math_percentile': 'True',
    },
    'Antenna': {
        'selected_antenna_type': 'Generic',
        'antenna_description': 'Broadband Omni',
        'antenna_use': 'General Purpose',
        'antenna_mount': 'Tripod',
        'antenna_amplifier': 'None',
    },
    'Amplifier': {
        'selected_amplifier_type': 'Generic',
        'amplifier_description': 'Inline LNA',
        'amplifier_use': 'Compensate for cable loss',
    },
    'Report': {
        'operator_name': 'RF Technician',
        'operator_contact': 'tech@example.com',
        'venue_name': 'Default Venue',
        'venue_address': '123 Main St',
        'venue_city': 'Anytown',
        'venue_province': 'ON',
        'venue_postal_code': 'A1B 2C3',
        'notes': 'This is a default report generated by the OPEN-AIR software.',
        'scanner_type': 'Generic RF Scanner',
    },
    'Plotting': {
        'current_style_theme': 'dark',
        'plot_grid_on': 'True',
        'plot_legend_on': 'True',
        'plot_title_on': 'True',
        'plot_title_text': 'RF Scan',
    },
}

#####################################
### File: OPEN-AIR 2\display\base_gui_component_rebuilt.py
#####################################
# display/base_gui_component_rebuilt.py
#
# A reusable base class for GUI frames, now fully integrated with the centralized
# logging and MQTT orchestrator utilities and the new styling module.
#
# Author: Anthony Peter Kuzub
#
# Version 20250824.160000.1

import os
import inspect
import pathlib
import tkinter as tk
from tkinter import ttk
import json

# --- Module Imports ---
from datasets.logging import debug_log, console_log
from workers.mqtt_controller_util import MqttControllerUtility
from styling.style import THEMES, DEFAULT_THEME

# --- Global Scope Variables ---
# Dynamically get the file path relative to the project root for topic naming and logging
current_file_path = pathlib.Path(__file__).resolve()
# Assuming project root is two levels up from this file's location
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")

# Versioning
CURRENT_DATE = 20250824
CURRENT_TIME = 160000
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME * REVISION_NUMBER)


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common functionality for MQTT,
    logging, and styling.
    """
    def __init__(self, parent, mqtt_util, console_print_func, **kwargs):
        super().__init__(parent, **kwargs)

        self.current_file = current_file
        self.current_version = current_version
        self.mqtt_util = mqtt_util
        self.console_print_func = console_print_func
        self.current_topic_prefix = self._get_topic_prefix()

        # Apply styles immediately to affect all child widgets
        self._apply_styles(DEFAULT_THEME)

    def _get_topic_prefix(self):
        """
        A utility function to determine the MQTT topic root from the file path.
        e.g., 'tabs/Scanning/tab_scanning_child_bands.py' -> 'tabs/Scanning/tab_scanning_child_bands'
        """
        relative_path = pathlib.Path(self.current_file)
        topic = str(relative_path).replace(os.sep, '/')
        return os.path.splitext(topic)[0]

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        # Configure styles using the imported color palette
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TButton', background=colors["secondary"], foreground=colors["fg"])
        style.configure('TEntry', fieldbackground=colors["entry_bg"], foreground=colors["entry_fg"])
        style.configure('TCombobox', fieldbackground=colors["entry_bg"], foreground=colors["entry_fg"])
        style.configure('TCheckbutton', background=colors["bg"], foreground=colors["fg"])
        style.configure('TNotebook', background=colors["bg"])
        style.configure('TNotebook.Tab', background=colors["secondary"], foreground=colors["fg"])
        style.map('TNotebook.Tab', background=[('selected', colors["primary"])])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe.Label', background=colors["bg"], foreground=colors["fg"])
        style.configure('Treeview', background=colors["table_bg"], foreground=colors["table_fg"], fieldbackground=colors["table_bg"])
        style.configure('Treeview.Heading', background=colors["table_heading_bg"], foreground=colors["fg"])
        style.configure('ScrolledText', background=colors["entry_bg"], foreground=colors["entry_fg"], borderwidth=1)
        style.configure('Horizontal.TScale', background=colors["bg"], troughcolor=colors["secondary"])

    def _publish_value(self, element_name, value):
        """
        Publishes a value to a topic based on the file path and element name.
        """
        self.mqtt_util.publish_message(
            topic=self.current_topic_prefix,
            subtopic=element_name,
            value=value
        )

#####################################
### File: OPEN-AIR 2\display\gui_display.py
#####################################
# display/gui_display.py
#
# A script that dynamically builds the application's Tkinter GUI based on the
# predefined directory structure. It acts as the "orchestrator," recursively
# traversing a folder hierarchy to construct the user interface, now with
# support for "tear-off" tabs that can become their own windows.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.230500.2

# 📚 Python's standard library modules are our trusty sidekicks!
# os: Provides a way to interact with the operating system, like getting file names.
import os
# inspect: Allows us to "look inside" live objects, which is crucial for dynamic introspection.
import inspect
# datetime: Handles dates and times, used here for our versioning system.
import datetime
# tkinter: The foundational GUI toolkit for Python.
import tkinter as tk
# ttk: The "themed Tkinter" module, providing a more modern, stylable set of widgets.
from tkinter import ttk
# importlib.util: A powerful module for dynamic, programmatic importing of Python files.
import importlib.util
# sys: Provides access to system-specific parameters and functions, including the module search path.
import sys
# pathlib: A modern, object-oriented way to handle filesystem paths, making our code cleaner and more robust.
import pathlib

# --- Module Imports ---
# We no longer need to add the parent directory to the path as this is handled in main.py
from display.styling.style import THEMES, DEFAULT_THEME
from datasets.logging import debug_log, console_log
from workers.mqtt_controller_util import MqttControllerUtility


# --- Global Scope Variables ---
# ⏰ As requested, the version is now hardcoded to the time this file was generated.
# The version strings and numbers below are static and will not change at runtime.
# This represents the date (YYYYMMDD) of file creation.
CURRENT_DATE = 20250822
# This represents the time (HHMMSS) of file creation.
CURRENT_TIME = 230500
# This is a numeric hash of the time, useful for unique IDs.
CURRENT_TIME_HASH = 230500
# Our project's current revision number, which is manually incremented.
REVISION_NUMBER = 2
# Assembling the full version string as per the protocol (W.X.Y).
current_version = "20250822.230500.2"
# Creating a unique integer hash for the current version for internal tracking.
current_version_hash = (CURRENT_DATE * CURRENT_TIME_HASH * REVISION_NUMBER)
# Getting the name of the current file to use in our logs, ensuring it's always accurate.
current_file = f"{os.path.basename(__file__)}"


class Application(tk.Tk):
    """
    The main application class that orchestrates the GUI build process.
    
    This class inherits from `tk.Tk`, making it the root of our application's GUI.
    It's responsible for setting up the main window and kicking off the dynamic
    GUI construction based on the folder structure. It now manages the state
    of detached tabs.
    """
    def __init__(self):
        """
        The constructor for our main application.
        
        It sets up the main window, applies styling, and starts the recursive
        process of building the GUI. It's the first function called upon app launch.
        """
        # We grab the name of the current function for our debug logs.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # 🚀 A celebratory log message to mark the start of our journey!
        debug_log(
            message="🖥️ 🟢 The grand orchestrator is waking up! Let's get this GUI built!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        # --- NEW: State management dictionaries for tear-off tabs ---
        # We need a way to track which frames belong to which notebooks.
        self._notebooks = {}
        self._frames_by_path = {}
        self._detached_windows = {}
        # We'll store the name of the last selected tab for logging purposes.
        self.last_selected_tab_name = None

        try:
            # We must first call the parent class's constructor to initialize the Tkinter window.
            super().__init__()
            # Setting the title of our application window, which appears in the title bar.
            self.title("OPEN-AIR 2")
            # Defining the initial size of the window in pixels.
            self.geometry("1000x700")

            # --- NEW: Apply the selected theme ---
            # We call a helper method to apply our chosen theme and store the color palette.
            self.theme_colors = self._apply_styles(theme_name=DEFAULT_THEME)

            # --- NEW: Initialize a single MQTT utility instance here (Orchestration Layer) ---
            self.mqtt_util = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
            self.mqtt_util.connect_mqtt()

            # 🏗️ Let the dynamic building begin! We call our recursive builder function,
            # starting from the directory where this script resides.
            self._build_from_directory(path=pathlib.Path(__file__).parent, parent_widget=self)
            
            # 🎉 A final cheer for a job well done!
            console_log("✅ Celebration of success! The application's core has been built.")

        except Exception as e:
            # 🆘 Oh no, an error! We catch it here to prevent the app from crashing.
            console_log(f"❌ Error in {current_function_name}: {e}")
            # We log the detailed error message for easier debugging.
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the entire application using ttk.Style.
        
        This method configures the look and feel of various `ttk` widgets based on
        the color and style information loaded from our `style` module.
        
        Args:
            theme_name (str): The name of the theme to apply.
            
        Returns:
            dict: The dictionary of colors from the applied theme.
        """
        # We grab the colors from our theme dictionary, defaulting to 'dark' if the theme isn't found.
        colors = THEMES.get(theme_name, THEMES["dark"])
        
        style = ttk.Style(self)
        style.theme_use("clam")

        # --- Configure widget styles ---
        # We configure the default style for all widgets ('.').
        # UPDATED: We use values from our theme for padding and borderwidth, making our styles consistent.
        style.configure('.',
                        background=colors["bg"],
                        foreground=colors["fg"],
                        font=('Helvetica', 10),
                        padding=colors["padding"],
                        borderwidth=colors["border_width"])

        # Specific configurations for `TFrame` widgets.
        style.configure('TFrame',
                        background=colors["bg"])

        # Specific configurations for `TNotebook` widgets (the container for our tabs).
        style.configure('TNotebook',
                        background=colors["primary"],
                        borderwidth=0)
        
        # This is a 'map' configuration, which defines how a widget's style changes
        # based on its state (e.g., 'selected' or not).
        style.map('TNotebook.Tab',
                  background=[('selected', colors["accent"]), ('!selected', colors["secondary"])],
                  foreground=[('selected', colors["text"]), ('!selected', colors["fg"])])

        # UPDATED: Applying padding from the theme to notebook tabs.
        # We calculate the tab padding based on our base padding value from the theme.
        tab_padding = [colors["padding"] * 10, colors["padding"] * 5]
        style.configure('TNotebook.Tab',
                        padding=tab_padding,
                        font=('Helvetica', 11, 'bold'),
                        borderwidth=0)

        # UPDATED: Applying padding and border_width from the theme to buttons.
        # We make the buttons' padding and border more prominent.
        style.configure('TButton',
                        background=colors["accent"],
                        foreground=colors["text"],
                        padding=colors["padding"] * 5,
                        relief=colors["relief"],
                        borderwidth=colors["border_width"] * 2)
        
        style.map('TButton',
                  background=[('active', colors["secondary"])])

        # --- Configure the main window background ---
        # We apply the main background color to the root window itself.
        self.configure(background=colors["bg"])
        
        # We return the color dictionary so other methods can access the theme's colors.
        return colors


    def _build_from_directory(self, path: pathlib.Path, parent_widget):
        """
        Recursively builds the GUI based on folder structure, supporting percentage-based layouts.
        
        This is the heart of the dynamic builder. It inspects a directory and decides
        what kind of Tkinter widget to create based on the folder naming convention.
        
        Args:
            path (pathlib.Path): The path to the current directory being processed.
            parent_widget: The Tkinter widget that will be the parent for new widgets.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        try:
            # We first get all the subdirectories and sort them for a consistent build order.
            sub_dirs = sorted([d for d in path.iterdir() if d.is_dir()])
            
            # We identify directories that define a layout (e.g., 'left_50', 'top_30').
            layout_dirs = [d for d in sub_dirs if d.name.split('_')[0] in ['left', 'right', 'top', 'bottom']]
            
            # If we find layout directories, we process them first. This is a top-down approach.
            if layout_dirs:
                # We check if the layout is horizontal or vertical.
                is_horizontal = any(d.name.startswith('left_') or d.name.startswith('right_') for d in layout_dirs)
                is_vertical = any(d.name.startswith('top_') or d.name.startswith('bottom_') for d in layout_dirs)

                # We log an error if a developer tries to mix horizontal and vertical layouts.
                if is_horizontal and is_vertical:
                    console_log(f"❌ Layout Error: Cannot mix horizontal and vertical layouts in '{path}'.")
                    return

                # We define a strict sort order to ensure 'left' is before 'right', 'top' before 'bottom', etc.
                sort_order = ['left', 'top', 'right', 'bottom']
                # We sort the layout directories according to our defined order.
                sorted_layout_dirs = sorted(layout_dirs, key=lambda d: sort_order.index(d.name.split('_')[0]))
                
                # --- Horizontal Layout Processing ---
                if is_horizontal:
                    # We keep track of the current horizontal position (relx).
                    current_relx = 0.0
                    for sub_dir in sorted_layout_dirs:
                        # We only process 'left' and 'right' directories in this block.
                        if sub_dir.name.split('_')[0] not in ['left', 'right']: continue
                        try:
                            # We parse the percentage from the folder name (e.g., 'left_50' gives us 50).
                            percentage = int(sub_dir.name.split('_')[1])
                            # We convert the percentage to a relative width.
                            rel_width = percentage / 100.0
                            # We create a new `ttk.Frame`, which is stylable.
                            # UPDATED: We use the theme's border and relief settings.
                            new_frame = ttk.Frame(parent_widget, borderwidth=self.theme_colors["border_width"], relief=self.theme_colors["relief"])
                            # We use `.place()` to position the frame with relative coordinates and size.
                            new_frame.place(relx=current_relx, rely=0, relwidth=rel_width, relheight=1.0)
                            # 🔄 We recursively call this function to build the contents of the new frame.
                            self._build_from_directory(path=sub_dir, parent_widget=new_frame)
                            # We update the horizontal position for the next frame.
                            current_relx += rel_width
                        except (IndexError, ValueError):
                            # A helpful warning if the folder name is not formatted correctly.
                            console_log(f"⚠️ Warning: Could not parse percentage from folder name '{sub_dir.name}'.")
                
                # --- Vertical Layout Processing ---
                elif is_vertical:
                    # We keep track of the current vertical position (rely).
                    current_rely = 0.0
                    for sub_dir in sorted_layout_dirs:
                        # We only process 'top' and 'bottom' directories in this block.
                        if sub_dir.name.split('_')[0] not in ['top', 'bottom']: continue
                        try:
                            # We parse the percentage from the folder name.
                            percentage = int(sub_dir.name.split('_')[1])
                            # We convert the percentage to a relative height.
                            rel_height = percentage / 100.0
                            # We create a new `ttk.Frame`.
                            # UPDATED: We use the theme's border and relief settings.
                            new_frame = ttk.Frame(parent_widget, borderwidth=self.theme_colors["border_width"], relief=self.theme_colors["relief"])
                            # We use `.place()` to position the frame with relative coordinates and size.
                            new_frame.place(relx=0, rely=current_rely, relwidth=1.0, relheight=rel_height)
                            # 🔄 We recursively call this function to build the contents of the new frame.
                            self._build_from_directory(path=sub_dir, parent_widget=new_frame)
                            # We update the vertical position for the next frame.
                            current_rely += rel_height
                        except (IndexError, ValueError):
                            # A helpful warning if the folder name is not formatted correctly.
                            console_log(f"⚠️ Warning: Could not parse percentage from folder name '{sub_dir.name}'.")
                # If we've processed a layout, we stop here.
                return

            # We check for directories that are meant to be a tab container.
            is_tab_container = any(d.name.startswith("tab_") or d.name.startswith("sub_tab_") for d in sub_dirs)
            if is_tab_container:
                # If it's a tab container, we create a `ttk.Notebook` widget.
                notebook = ttk.Notebook(parent_widget)
                # We use `.pack()` to make the notebook fill the entire parent widget.
                notebook.pack(fill=tk.BOTH, expand=True)
                
                # --- NEW: We register this notebook for tear-off functionality.
                notebook.bind('<Control-Button-1>', self._tear_off_tab)
                # 🛠️ We bind a new event to handle tab change logging.
                notebook.bind('<<NotebookTabChanged>>', self._on_tab_change)
                
                tab_dirs = [d for d in sub_dirs if d.name.startswith("tab_") or d.name.startswith("sub_tab_")]
                for tab_dir in tab_dirs:
                    # We create a new frame for each tab's content.
                    tab_frame = ttk.Frame(notebook)
                    
                    # --- NEW: We store a reference to this frame.
                    self._frames_by_path[tab_dir] = tab_frame
                    
                    # We parse the folder name to create a user-friendly display name for the tab.
                    # e.g., 'tab_1_main_page' becomes 'Main Page'.
                    parts = tab_dir.name.split('_')
                    start_index = next((i for i, part in enumerate(parts) if part.isdigit()), -1)
                    display_name = " ".join(parts[start_index + 1:]).title() if start_index != -1 else tab_dir.name
                    # We add the new frame as a tab to the notebook.
                    notebook.add(tab_frame, text=display_name)
                    # 🔄 We recursively build the contents of this new tab.
                    self._build_from_directory(path=tab_dir, parent_widget=tab_frame)
                # If we've processed tabs, we stop here.
                return

            # If no layout or tab directories were found, we look for child components.
            for sub_dir in sub_dirs:
                # We identify directories that contain a child component (e.g., 'child_1_button_panel').
                if sub_dir.name.startswith("child_"):
                    self._build_child_container(path=sub_dir, parent_widget=parent_widget)

            # We also look for direct Python files that define GUI components (e.g., 'gui_1_button_panel.py').
            py_files = [f for f in path.iterdir() if f.is_file() and f.name.startswith("gui_") and f.suffix == '.py']
            for py_file in py_files:
                self._build_child_container(path=py_file, parent_widget=parent_widget)

        except Exception as e:
            # Another safety net for errors during the recursive build process.
            console_log(f"❌ Error in {current_function_name} for path {path}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _build_child_container(self, path: pathlib.Path, parent_widget):
        """
        Dynamically imports and instantiates a GUI component from a Python file.
        
        This method is responsible for finding a Python file that defines a GUI component,
        importing it into memory, and then creating an instance of the component to
        add to the application's GUI hierarchy.
        
        Args:
            path (pathlib.Path): The path to the directory or file containing the component.
            parent_widget: The Tkinter widget that will be the parent for the new component.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        try:
            # We determine if the path is a directory or a direct file.
            if path.is_dir():
                # If it's a directory, we search for the 'gui_*.py' file inside it.
                gui_file = next(f for f in path.iterdir() if f.is_file() and f.name.startswith("gui_") and f.suffix == '.py')
            else:
                # If it's a file, we use the path directly.
                gui_file = path

            # 🪄 This is the magical part where we dynamically import the module.
            # We get the name of the module from the file's stem (e.g., 'gui_1_button_panel').
            module_name = gui_file.stem
            # We create a 'spec' which tells Python how to load our module.
            spec = importlib.util.spec_from_file_location(module_name, gui_file)
            # We create the module object from the spec.
            module = importlib.util.module_from_spec(spec)
            # We add our new module to the system's modules dictionary to make it accessible.
            sys.modules[module_name] = module
            # We execute the module, which runs its code and defines its functions and classes.
            spec.loader.exec_module(module)

            # --- 🎯 REFACTORED: The "hardcoded part" you wanted to change! ---
            # We now iterate through all members (classes, functions, etc.) of the imported module.
            for name, obj in inspect.getmembers(module):
                # First, we check if the member is a class.
                if inspect.isclass(obj):
                    # We check if this class is a subclass of `ttk.Frame`.
                    # This is much more flexible than hardcoding a specific class name like "GUIFrame"!
                    if issubclass(obj, ttk.Frame):
                        # If we find a matching class, we instantiate it with the `parent_widget`.
                        # We pass the shared mqtt_util instance here!
                        frame_instance = obj(parent_widget, mqtt_util=self.mqtt_util)
                        # We pack the new frame to make it visible and fill its parent.
                        frame_instance.pack(fill=tk.BOTH, expand=True)
                        # We've found our class and built the frame, so we can break the loop and return.
                        return

                # We also check for functions that build the GUI.
                # This provides backward compatibility with the old naming convention.
                elif inspect.isfunction(obj):
                    # We check if the function's name matches our known component-building function.
                    if name == "create_yo_button_frame":
                        obj(parent_widget)
                        return # We've found and run the function, so we're done here.
            # 🚨 If we get here, it means we couldn't find a valid class or function in the imported module.
            raise AttributeError(f"Module '{module_name}' needs a class that inherits from 'ttk.Frame' or a 'create_yo_button_frame' function.")

        except Exception as e:
            # A final safety net for any errors during the import or execution of a child component.
            console_log(f"❌ Error importing or executing module at {path}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _tear_off_tab(self, event):
        """
        Tears a tab off of its Notebook and places it into a new Toplevel window.
        
        This method is triggered by a <Control-Button-1> event on a tab.
        It moves the selected tab's frame from the Notebook to its own new window.
        
        Args:
            event: The Tkinter event object.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        try:
            # We determine which notebook widget was clicked.
            notebook = event.widget
            # We use the event coordinates to find the tab that was clicked.
            tab_id = notebook.identify(event.x, event.y)
            if not tab_id:
                return # No tab was clicked, so we do nothing.
            # 🎯 FIX: We need to use the `id` of the widget, not its text label.
            # This is the unique internal identifier for the tab's content frame.
            frame_id = notebook.tab(tab_id, "id")
            
            # We get the title of the tab to use for the new window.
            tab_title = notebook.tab(tab_id, "text")
            
            # If the frame is already detached, we do nothing.
            if frame_id in self._detached_windows:
                console_log(f"⚠️ Tab '{tab_title}' is already in a detached window.")
                return

            # We create a new top-level window.
            new_window = tk.Toplevel(self)
            new_window.title(tab_title)
            
            # We move the frame from the notebook to the new window.
            notebook.hide(tab_id)
            frame_id.pack(in_=new_window, fill=tk.BOTH, expand=True)
            
            # We store a reference to the detached window.
            self._detached_windows[frame_id] = {
                "window": new_window,
                "notebook": notebook,
                "tab_title": tab_title
            }
            
            # We bind the new window's close button to our re-attachment function.
            new_window.protocol("WM_DELETE_WINDOW", lambda: self._re_attach_tab(frame_id))

            console_log(f"✅ Celebration of success! Tab '{tab_title}' has been detached and is now a new window.")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _re_attach_tab(self, frame):
        """
        Re-attaches a detached frame back to its original Notebook.
        
        This method is called when the user closes the detached Toplevel window.
        It moves the frame back to its original notebook and destroys the window.
        
        Args:
            frame: The Tkinter frame object that was detached.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        try:
            if frame not in self._detached_windows:
                return # Frame is not detached, so we do nothing.
            # We retrieve the notebook and title from our state dictionary.
            state = self._detached_windows[frame]
            notebook = state["notebook"]
            tab_title = state["tab_title"]
            window = state["window"]
            
            # We re-parent the frame back to its original notebook.
            frame.pack_forget()
            frame.pack(in_=notebook, fill=tk.BOTH, expand=True)
            
            # We add the tab back to the notebook at the same position.
            notebook.add(frame, text=tab_title)
            
            # We clean up our state dictionary and destroy the Toplevel window.
            del self._detached_windows[frame]
            window.destroy()
            
            console_log(f"✅ Celebration of success! Tab '{tab_title}' has been re-attached.")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            
    def _on_tab_change(self, event):
        """
        Logs a debug message when a tab is selected or deselected.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🔍🔵 Entering '{current_function_name}' to log a tab change.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            notebook = event.widget
            newly_selected_tab_id = notebook.select()
            newly_selected_tab_name = notebook.tab(newly_selected_tab_id, "text")

            if self.last_selected_tab_name:
                debug_log(
                    message=f"📘🔴 Tab '{self.last_selected_tab_name}' deselected!",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

            debug_log(
                message=f"📘🟢 Tab '{newly_selected_tab_name}' selected!",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            
            self.last_selected_tab_name = newly_selected_tab_name
            
            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


# 🏃 This is the standard entry point for a Python script.
# The code inside this block only runs when the script is executed directly.
if __name__ == "__main__":
    # A friendly message to signal the start of the application.
    console_log("--- Initializing the Dynamic GUI Builder ---")
    
    # We create an instance of our main Application class.
    app = Application()
    # This call starts the Tkinter event loop, which handles all user interactions and keeps the window open.
    app.mainloop()
    # Once the mainloop exits (e.g., the user closes the window), this message is printed.
    console_log("--- Application closed. ---")

#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_1_instrument\sub_tab_1_connection\gui_connection.py
#####################################
# tabs/Instrument/tab_instrument_child_connection.py
#
# This file defines the InstrumentTab, a Tkinter Frame for handling instrument
# connection and disconnection. This refactored version is a mock for testing,
# using a shared MQTT utility for communication instead of direct device control.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250823.132200.1

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk, messagebox
import json
import paho.mqtt.client as mqtt
import threading
from collections import defaultdict

# --- Module Imports ---
# We are intentionally removing the following imports for this test version:
# from .instrument_logic import connect_instrument_logic, disconnect_instrument_logic, populate_resources_logic
# from yak.utils_yak_setting_handler import reset_device, do_power_cycle
from datasets.logging import debug_log, console_log
from display.styling.style import THEMES, DEFAULT_THEME
from workers.mqtt_controller_util import MqttControllerUtility

# --- Global Scope Variables ---
CURRENT_DATE = datetime.datetime.now().strftime("%Y%m%d")
CURRENT_TIME = datetime.datetime.now().strftime("%H%M%S")
CURRENT_TIME_HASH = int(datetime.datetime.now().strftime("%H%M%S"))
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
current_file = f"tabs/Instrument/tab_instrument_child_connection.py"

# Mocked resources for the UI
MOCK_VISA_RESOURCES = ["ASRL1::INSTR", "GPIB0::2::INSTR", "TCPIP::192.168.1.1::INSTR"]


class InstrumentTab(ttk.Frame):
    """
    A Tkinter Frame for handling instrument connection and disconnection.
    This refactored version is a mock for testing, using a shared MQTT utility for communication instead of direct device control.
    """
    def __init__(self, master=None, mqtt_util=None, *args, **kwargs):
        super().__init__(master, **kwargs)
        self.pack(fill="both", expand=True)

        self.mqtt_util = mqtt_util
        self._message_counter = 0

        # Tkinter StringVars for displaying instrument details
        self.manufacturer_var = tk.StringVar(self, value="N/A")
        self.model_var = tk.StringVar(self, value="N/A")
        self.serial_number_var = tk.StringVar(self, value="N/A")
        self.version_var = tk.StringVar(self, value="N/A")
        self.resource_var = tk.StringVar(self, value="")
        self.is_connected = tk.BooleanVar(self, value=False)
        self.mqtt_status_var = tk.StringVar(self, value="Last MQTT Payload: N/A")

        self._apply_styles(theme_name=DEFAULT_THEME)
        self._create_widgets()
        
        if self.mqtt_util:
            self.mqtt_util.add_subscriber(topic_filter="conductor/test/#", callback_func=self._on_message)

    def _apply_styles(self, theme_name: str):
        """Applies a theme based on the central style definition."""
        colors = THEMES.get(theme_name)
        style = ttk.Style(self)
        style.theme_use("clam")
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TButton', background=colors["accent"], foreground=colors["text"])
        style.map('Orange.TButton',
                  background=[('!active', 'orange'), ('active', 'orange')])
        style.map('Blue.TButton',
                  background=[('!active', colors['accent']), ('active', colors['secondary'])])
        style.map('TButton',
                  background=[('active', colors['secondary'])])
        style.map('Red.TButton',
                  background=[('!active', 'red'), ('active', 'darkred')])
        style.map('Green.TButton',
                  background=[('!active', 'green'), ('active', 'darkgreen')])
        style.configure('Dark.TLabelframe', background=colors["bg"], foreground=colors["fg"])
        style.configure('Dark.TLabel.Value', background=colors["bg"], foreground=colors["fg"])

    def _create_widgets(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering _create_widgets. Creating simplified widgets for the Connection Tab. 🛠️",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function,
                    console_print_func=console_log)
        
        self.grid_columnconfigure(0, weight=1)

        # Main frame
        main_frame = ttk.Frame(self, style='Dark.TFrame')
        main_frame.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
        main_frame.columnconfigure(0, weight=1)

        # Button to populate VISA resources
        self.populate_button = ttk.Button(main_frame, text="Populate list of available VISA Devices", command=lambda: self._publish_test_message(button_id="populate"), style='Blue.TButton')
        self.populate_button.grid(row=0, column=0, padx=5, pady=5, sticky="ew")

        # Dropdown for VISA resources
        self.resource_combobox = ttk.Combobox(main_frame, textvariable=self.resource_var, values=MOCK_VISA_RESOURCES, state='readonly', style='TCombobox')
        self.resource_combobox.grid(row=1, column=0, padx=5, pady=5, sticky="ew")

        # Connect/Disconnect button
        self.connect_button = ttk.Button(main_frame, text="Connect", command=self._toggle_connection, style='Green.TButton')
        self.connect_button.grid(row=2, column=0, padx=5, pady=5, sticky="ew")
        
        # NEW: Instrument Details Frame
        self.details_frame = ttk.LabelFrame(main_frame, text="Device Details", style='Dark.TLabelframe', padding=10)
        self.details_frame.grid(row=3, column=0, padx=5, pady=5, sticky="ew")
        self.details_frame.grid_columnconfigure(1, weight=1)
        self.details_frame.grid_remove() # Hide initially

        ttk.Label(self.details_frame, text="Manufacturer:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        ttk.Label(self.details_frame, textvariable=self.manufacturer_var, style='Dark.TLabel.Value').grid(row=0, column=1, sticky="ew", padx=5, pady=2)

        ttk.Label(self.details_frame, text="Model:").grid(row=1, column=0, sticky="w", padx=5, pady=2)
        ttk.Label(self.details_frame, textvariable=self.model_var, style='Dark.TLabel.Value').grid(row=1, column=1, sticky="ew", padx=5, pady=2)
        
        ttk.Label(self.details_frame, text="Serial Number:").grid(row=2, column=0, sticky="w", padx=5, pady=2)
        ttk.Label(self.details_frame, textvariable=self.serial_number_var, style='Dark.TLabel.Value').grid(row=2, column=1, sticky="ew", padx=5, pady=2)
        
        ttk.Label(self.details_frame, text="Firmware Version:").grid(row=3, column=0, sticky="w", padx=5, pady=2)
        ttk.Label(self.details_frame, textvariable=self.version_var, style='Dark.TLabel.Value').grid(row=3, column=1, sticky="ew", padx=5, pady=2)

        # NEW: Reset and Power Cycle Buttons Frame
        control_buttons_frame = ttk.Frame(main_frame, style='Dark.TFrame')
        control_buttons_frame.grid(row=4, column=0, padx=5, pady=5, sticky="ew")
        control_buttons_frame.grid_columnconfigure(0, weight=1)
        control_buttons_frame.grid_columnconfigure(1, weight=1)

        self.reset_button = ttk.Button(control_buttons_frame, text="Reset Instrument (*RST)", command=lambda: self._publish_test_message(button_id="reset"), style='Orange.TButton')
        self.reset_button.grid(row=0, column=0, padx=5, pady=5, sticky="ew")
        self.reset_button.config(state=tk.DISABLED) # Start disabled
        
        self.power_cycle_button = ttk.Button(control_buttons_frame, text="Power Cycle", command=lambda: self._publish_test_message(button_id="power_cycle"), style='Red.TButton')
        self.power_cycle_button.grid(row=0, column=1, padx=5, pady=5, sticky="ew")
        self.power_cycle_button.config(state=tk.DISABLED) # Start disabled

        # NEW: MQTT Status Label
        mqtt_status_frame = ttk.Frame(self)
        mqtt_status_frame.grid(row=1, column=0, padx=10, pady=5, sticky="ew")
        mqtt_status_frame.grid_columnconfigure(0, weight=1)
        ttk.Label(mqtt_status_frame, textvariable=self.mqtt_status_var, anchor="center").grid(row=0, column=0, sticky="ew")

        # Store a reference to the buttons for styling updates
        self._button_status = defaultdict(lambda: None)
        self._button_status["populate"] = self.populate_button
        self._button_status["connect"] = self.connect_button
        self._button_status["disconnect"] = self.connect_button
        self._button_status["reset"] = self.reset_button
        self._button_status["power_cycle"] = self.power_cycle_button
        
        debug_log(f"Simplified widgets for Connection Tab created. Ready to go! ",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function,
                    console_print_func=console_log)


    def _update_connection_status(self, is_connected):
        """Updates the UI based on the mock connection status."""
        if is_connected:
            self.connect_button.config(text="Disconnect", style='Red.TButton')
            self.populate_button.config(state=tk.DISABLED)
            self.resource_combobox.config(state='disabled')
            self.reset_button.config(state=tk.NORMAL)
            self.power_cycle_button.config(state=tk.NORMAL)
            self.details_frame.grid()
            
            # Mock device details
            self.manufacturer_var.set("MockCo")
            self.model_var.set("MockModel-9000")
            self.serial_number_var.set("SN12345678")
            self.version_var.set("v1.0.0")

            console_log("✅ Connection successful. UI updated.")
        else:
            self.connect_button.config(text="Connect", style='Green.TButton')
            self.populate_button.config(state=tk.NORMAL)
            self.resource_combobox.config(state='readonly')
            self.reset_button.config(state=tk.DISABLED)
            self.power_cycle_button.config(state=tk.DISABLED)
            self.details_frame.grid_remove()
            self.manufacturer_var.set("N/A")
            self.model_var.set("N/A")
            self.serial_number_var.set("N/A")
            self.version_var.set("N/A")
            console_log("❌ Disconnected from instrument. UI updated.")
    
    def _toggle_connection(self):
        """Toggles the mock connection state and publishes a test message."""
        if self.is_connected.get():
            self._publish_test_message("disconnect")
        else:
            self._publish_test_message("connect")

    def _update_button_style(self, button_id, value):
        """A simple function to update button styles based on the received payload."""
        button = self._button_status.get(button_id)
        if button:
            if value % 2 == 1:
                if button_id == "connect":
                    button.configure(style='Green.TButton', text='Connected')
                elif button_id == "populate":
                    button.configure(style='Orange.TButton')
            else:
                if button_id == "connect":
                    button.configure(style='Red.TButton', text='Disconnect')
                elif button_id == "populate":
                    button.configure(style='Blue.TButton')

    def _on_message(self, topic, payload):
        """The callback for when a PUBLISH message is received from the server."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering {current_function} with arguments: topic: {topic}, payload: {payload}",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function,
                  console_print_func=console_log)
        try:
            payload_data = json.loads(payload)
            value = payload_data.get("value")
            subtopic = topic.split('/')[-1]
            self.mqtt_status_var.set(f"Last MQTT Payload: {value}")
            
            button_id = subtopic.split('_')[-1]
            if button_id == "connect":
                is_connected = True if value % 2 == 1 else False
                self.is_connected.set(is_connected)
            
            self._update_button_style(button_id, value)
            console_log("✅ Received message and updated result label.")
        except json.JSONDecodeError:
            console_log("❌ Failed to decode message payload as JSON.")

    def _publish_test_message(self, button_id):
        """Publishes an incrementing test message to the MQTT broker."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering {current_function} with argument: button_id: {button_id}",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function,
                  console_print_func=console_log)
        
        self._message_counter += 1
        topic = "conductor/test"
        payload = json.dumps({"value": self._message_counter})
        
        try:
            self.mqtt_util.publish_message(topic=topic, subtopic=f"test_connection_{button_id}", value=payload)
            console_log(f"✅ Published message to '{topic}/test_connection_{button_id}': {payload}")
        except Exception as e:
            console_log(f"❌ Failed to publish message: {e}")

# Standalone block for testing purposes.
if __name__ == "__main__":
    root = tk.Tk()
    root.title("Instrument Connection Tab Test")
    
    class MockMqttUtil:
        def __init__(self):
            self.subscribers = defaultdict(list)
            self._message_id = 0

        def add_subscriber(self, topic_filter, callback_func):
            self.subscribers[topic_filter].append(callback_func)
            print(f"Mocking add_subscriber: {topic_filter}")

        def publish_message(self, topic, subtopic, value):
            full_topic = f"{topic}/{subtopic}" if subtopic else topic
            print(f"Mocking publish_message: {full_topic} -> {value}")
            self._message_id += 1
            for topic_filter, callbacks in self.subscribers.items():
                if paho.mqtt.client.topic_matches_sub(topic_filter, full_topic):
                    for callback in callbacks:
                        callback(full_topic, value)
    
    mqtt_utility = MockMqttUtil()
    app_frame = InstrumentTab(master=root, mqtt_util=mqtt_utility)
    root.mainloop()



#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_1_instrument\sub_tab_2_settings\sub_tab_1_frequency\gui_frequency.py
#####################################
# tabs/Instrument/tab_instrument_child_settings_frequency.py
#
# This file defines the FrequencySettingsTab as a standalone ttk.Frame.
# All GUI elements are directly connected to MQTT publishing, with all
# complex logic for data handling and rendering removed.
#
# Author: Anthony Peter Kuzub
#
# Version 20250824.180000.2

import tkinter as tk
from tkinter import ttk
import os
import pathlib
import json
from collections import defaultdict
import inspect
import datetime
import threading

# Import core utilities and style module
from datasets.logging import debug_log, console_log
from workers.mqtt_controller_util import MqttControllerUtility
from styling.style import THEMES, DEFAULT_THEME


class FrequencySettingsTab(ttk.Frame):
    """
    A standalone Tkinter Frame that provides a user interface for frequency settings.
    All interactions are connected to MQTT.
    """
    def __init__(self, parent_frame, mqtt_util, **kwargs):
        super().__init__(parent_frame, **kwargs)
        self.pack(fill=tk.BOTH, expand=True)

        self.mqtt_util = mqtt_util
        self.current_topic_prefix = self._get_topic_prefix()

        # Tkinter variables for frequency settings, now in MHz
        self.freq_start_var = tk.DoubleVar(value=100.0)
        self.freq_stop_var = tk.DoubleVar(value=200.0)
        self.freq_center_var = tk.DoubleVar(value=150.0)
        self.freq_span_var = tk.DoubleVar(value=100.0)
        
        self.freq_common_result_var = tk.StringVar(value="Result: N/A")
        
        self.span_buttons = {}

        self._apply_styles(theme_name=DEFAULT_THEME)
        self._create_widgets()

    def _get_topic_prefix(self):
        """Constructs the MQTT topic prefix based on the file path."""
        # This is a key part of the new standalone design
        current_file_path = pathlib.Path(__file__).resolve()
        project_root = current_file_path.parent.parent.parent.parent
        relative_path = current_file_path.relative_to(project_root)
        topic = str(relative_path).replace(os.sep, '/')
        return os.path.splitext(topic)[0]

    def _apply_styles(self, theme_name: str):
        """Applies a theme based on the central style definition."""
        colors = THEMES.get(theme_name)
        style = ttk.Style(self)
        style.theme_use("clam")
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TButton', background=colors["accent"], foreground=colors["text"])
        style.map('Orange.TButton', background=[('!active', 'orange'), ('active', 'orange')])
        style.map('Blue.TButton', background=[('!active', colors['accent']), ('active', colors['secondary'])])
        style.map('TButton', background=[('active', colors['secondary'])])
        style.map('Red.TButton', background=[('!active', 'red'), ('active', 'darkred')])
        style.map('Green.TButton', background=[('!active', 'green'), ('active', 'darkgreen')])
        style.configure('Dark.TLabelframe', background=colors["bg"], foreground=colors["fg"])
        style.configure('Dark.TLabel.Value', background=colors["bg"], foreground=colors["fg"])

    def _create_widgets(self):
        """Creates the UI widgets for the tab."""
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(0, weight=0)
        self.grid_rowconfigure(1, weight=0)
        self.grid_rowconfigure(2, weight=0)

        # --- FREQUENCY/START-STOP Frame ---
        freq_ss_frame = ttk.Frame(self, padding=10)
        freq_ss_frame.grid(row=0, column=0, padx=10, pady=5, sticky="ew")
        freq_ss_frame.grid_columnconfigure(0, weight=1)

        main_start_stop_frame = ttk.Frame(freq_ss_frame)
        main_start_stop_frame.grid(row=0, column=0, sticky="ew")
        main_start_stop_frame.grid_columnconfigure(0, weight=1)
        main_start_stop_frame.grid_columnconfigure(1, weight=1)

        start_frame = ttk.Frame(main_start_stop_frame, padding=5)
        start_frame.grid(row=0, column=0, padx=5, pady=5, sticky="ew")
        start_frame.grid_columnconfigure(0, weight=1)
        ttk.Label(start_frame, text="Start:").grid(row=0, column=0, sticky="ew", padx=5, pady=2)
        start_entry = ttk.Entry(start_frame, textvariable=self.freq_start_var)
        start_entry.grid(row=1, column=0, sticky="ew")
        start_entry.bind("<Return>", lambda e: self._publish_value("start_frequency_entry", self.freq_start_var.get()))
        start_entry.bind("<FocusOut>", lambda e: self._publish_value("start_frequency_focusout", self.freq_start_var.get()))
        start_scale = ttk.Scale(start_frame, from_=100, to=1000, orient=tk.HORIZONTAL, variable=self.freq_start_var)
        start_scale.grid(row=2, column=0, sticky="ew")
        start_scale.bind("<ButtonRelease-1>", lambda e: self._publish_value("start_frequency_slider", self.freq_start_var.get()))

        stop_frame = ttk.Frame(main_start_stop_frame, padding=5)
        stop_frame.grid(row=0, column=1, padx=5, pady=5, sticky="ew")
        stop_frame.grid_columnconfigure(0, weight=1)
        ttk.Label(stop_frame, text="Stop:").grid(row=0, column=0, sticky="ew", padx=5, pady=2)
        stop_entry = ttk.Entry(stop_frame, textvariable=self.freq_stop_var)
        stop_entry.grid(row=1, column=0, sticky="ew")
        stop_entry.bind("<Return>", lambda e: self._publish_value("stop_frequency_entry", self.freq_stop_var.get()))
        stop_entry.bind("<FocusOut>", lambda e: self._publish_value("stop_frequency_focusout", self.freq_stop_var.get()))
        stop_scale = ttk.Scale(stop_frame, from_=100, to=1000, orient=tk.HORIZONTAL, variable=self.freq_stop_var)
        stop_scale.grid(row=2, column=0, sticky="ew")
        stop_scale.bind("<ButtonRelease-1>", lambda e: self._publish_value("stop_frequency_slider", self.freq_stop_var.get()))

        # --- FREQUENCY/CENTER-SPAN Frame ---
        freq_cs_frame = ttk.Frame(self, padding=10)
        freq_cs_frame.grid(row=1, column=0, padx=10, pady=5, sticky="ew")
        freq_cs_frame.grid_columnconfigure(0, weight=1)
        freq_cs_frame.grid_columnconfigure(1, weight=1)

        ttk.Label(freq_cs_frame, text="Center Frequency:", justify=tk.RIGHT).grid(row=0, column=0, padx=5, pady=2, sticky="e")
        center_scale = ttk.Scale(freq_cs_frame, from_=100, to=1000, orient=tk.HORIZONTAL, variable=self.freq_center_var)
        center_scale.grid(row=1, column=0, columnspan=2, padx=5, pady=2, sticky="ew")
        center_scale.bind("<ButtonRelease-1>", lambda e: self._publish_value("center_frequency_slider", self.freq_center_var.get()))
        center_entry = ttk.Entry(freq_cs_frame, textvariable=self.freq_center_var)
        center_entry.grid(row=0, column=1, padx=5, pady=2, sticky="ew")
        center_entry.bind("<Return>", lambda e: self._publish_value("center_frequency_entry", self.freq_center_var.get()))
        center_entry.bind("<FocusOut>", lambda e: self._publish_value("center_frequency_focusout", self.freq_center_var.get()))

        ttk.Label(freq_cs_frame, text="Span:", justify=tk.RIGHT).grid(row=2, column=0, padx=5, pady=2, sticky="e")
        span_scale = ttk.Scale(freq_cs_frame, from_=0, to=500, orient=tk.HORIZONTAL, variable=self.freq_span_var)
        span_scale.grid(row=3, column=0, columnspan=2, padx=5, pady=2, sticky="ew")
        span_scale.bind("<ButtonRelease-1>", lambda e: self._publish_value("span_frequency_slider", self.freq_span_var.get()))
        span_entry = ttk.Entry(freq_cs_frame, textvariable=self.freq_span_var)
        span_entry.grid(row=2, column=1, padx=5, pady=2, sticky="ew")
        span_entry.bind("<Return>", lambda e: self._publish_value("span_frequency_entry", self.freq_span_var.get()))
        span_entry.bind("<FocusOut>", lambda e: self._publish_value("span_frequency_focusout", self.freq_span_var.get()))

        span_buttons_frame = ttk.Frame(freq_cs_frame, padding=5)
        span_buttons_frame.grid(row=4, column=0, columnspan=2, padx=5, pady=5, sticky="ew")
        self._create_span_preset_buttons(parent_frame=span_buttons_frame)

        # --- COMMON RESULT FRAME ---
        common_result_frame = ttk.Frame(self, padding=10)
        common_result_frame.grid(row=2, column=0, padx=10, pady=5, sticky="ew")
        common_result_frame.grid_columnconfigure(0, weight=1)
        ttk.Label(common_result_frame, textvariable=self.freq_common_result_var).grid(row=0, column=0, padx=5, pady=2, sticky="ew")

    def _create_span_preset_buttons(self, parent_frame):
        """Creates mock buttons for predefined frequency spans and links them to MQTT."""
        # Mocked presets to avoid external file dependency
        mock_presets = {
            "300 kHz": {"span_mhz": 0.3, "center_mhz": 400.0},
            "1 MHz": {"span_mhz": 1.0, "center_mhz": 400.0},
            "5 MHz": {"span_mhz": 5.0, "center_mhz": 400.0},
            "20 MHz": {"span_mhz": 20.0, "center_mhz": 400.0},
        }

        for i, (label, preset) in enumerate(mock_presets.items()):
            button_text = f"{label}\n{preset['span_mhz']:.2f} MHz"
            button = ttk.Button(parent_frame,
                                text=button_text,
                                command=lambda p=preset: self._publish_value("span_preset_button", f"span:{p['span_mhz']},center:{p['center_mhz']}"))
            button.grid(row=0, column=i, sticky="ew", padx=2, pady=5)

        parent_frame.grid_rowconfigure(0, weight=1)
        for i in range(len(mock_presets)):
            parent_frame.grid_columnconfigure(i, weight=1)

    def _publish_value(self, element_name, value):
        """Publishes a value to a topic based on the file path and element name."""
        if self.mqtt_util:
            self.mqtt_util.publish_message(
                topic=self.current_topic_prefix,
                subtopic=element_name,
                value=value
            )

if __name__ == "__main__":
    # Example for standalone testing
    root = tk.Tk()
    root.title("Standalone Instrument Frequency Tab Demo")
    root.geometry("1000x600")

    class MockMqttUtil:
        def add_subscriber(self, topic_filter, callback_func):
            pass
        def publish_message(self, topic, subtopic, value):
            full_topic = f"{topic}/{subtopic}" if subtopic else topic
            print(f"MOCK MQTT PUBLISH: Topic='{full_topic}', Value='{value}'")
    
    mqtt_utility = MockMqttUtil()
    app_frame = FrequencySettingsTab(parent_frame=root, mqtt_util=mqtt_utility)
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_1_instrument\sub_tab_2_settings\sub_tab_2_bandwidth\gui_bandwidth.py
#####################################
# tabs/Instrument/tab_instrument_child_settings_bandwidth.py
#
# This file defines the BandwidthSettingsTab, a Tkinter Frame for controlling a spectrum
# analyzer's bandwidth and initiate settings. This refactored version removes dependencies
# on external utility and configuration files and implements a self-contained mock MQTT publisher
# for testing purposes.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250823.130530.1

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import re
import json
import paho.mqtt.client as mqtt
import threading
from collections import defaultdict

# --- Module Imports ---
# We are intentionally removing the following imports for this test version:
# from display.debug_logic import debug_log
# from display.console_logic import console_log
# from yak import utils_yak_setting_handler
# from ref.ref_scanner_setting_lists import (
#     PRESET_BANDWIDTH_RBW,
#     PRESET_BANDWIDTH_VIDEO,
#     PRESET_CONTINUOUS_MODE,
#     PRESET_AVERAGING
# )
# from yak.utils_yaknab_handler import handle_bandwidth_settings_nab
# from settings_and_config.config_manager_instruments import _save_instrument_settings
# from settings_and_config.config_manager_save import save_program_config
from display.styling.style import THEMES, DEFAULT_THEME


# --- Global Scope Variables ---
CURRENT_DATE = datetime.datetime.now().strftime("%Y%m%d")
CURRENT_TIME = datetime.datetime.now().strftime("%H%M%S")
CURRENT_TIME_HASH = int(datetime.datetime.now().strftime("%H%M%S"))
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
current_file = f"tabs/Instrument/tab_instrument_child_settings_bandwidth.py"

# --- Mocking core dependencies for this standalone test file ---
def debug_log(message, file, version, function, console_print_func):
    """A mock debug log function for testing purposes."""
    print(f"DEBUG: {message}")

def console_log(message):
    """A mock console log function for testing purposes."""
    print(f"CONSOLE: {message}")

# Mocked preset lists for the UI, as the original imports have been removed.
PRESET_BANDWIDTH_RBW = [
    {"label": "1M", "value": 1000000},
    {"label": "100k", "value": 100000},
    {"label": "10k", "value": 10000},
]
PRESET_BANDWIDTH_VIDEO = [
    {"label": "30k", "value": 30000},
    {"label": "10k", "value": 10000},
    {"label": "3k", "value": 3000},
]
PRESET_CONTINUOUS_MODE = [
    {"label": "ON", "value": "ON"},
    {"label": "OFF", "value": "OFF"}
]
PRESET_AVERAGING = [
    {"label": "AVG OFF", "value": 0},
    {"label": "10", "value": 10},
    {"label": "20", "value": 20}
]

class BandwidthSettingsTab(ttk.Frame):
    """
    A Tkinter Frame that provides a user interface for bandwidth and initiate settings.
    This is a refactored version for testing, implementing its own mock MQTT client.
    """
    def __init__(self, master=None, mqtt_util=None, *args, **kwargs):
        """
        Initializes the BandwidthSettingsTab.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Initializing BandwidthSettingsTab. Setting up the GUI and its logic. 💻",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function,
                  console_print_func=console_log)
        
        super().__init__(master, **kwargs)
        self.pack(fill="both", expand=True)

        self.mqtt_util = mqtt_util
        self._message_counter = 0
        self._button_status = defaultdict(lambda: None)

        self.rbw_labels = [f"{p['label']} ({p['value']} Hz)" for p in PRESET_BANDWIDTH_RBW]
        self.vbw_labels = [f"{p['label']} ({p['value']} Hz)" for p in PRESET_BANDWIDTH_VIDEO]
        self.initiate_modes = [p['value'] for p in PRESET_CONTINUOUS_MODE]
        self.avg_labels = [f"{p['value']}" for p in PRESET_AVERAGING]

        self.rbw_hz_var = tk.DoubleVar(self, value=PRESET_BANDWIDTH_RBW[0]['value'])
        self.vbw_hz_var = tk.DoubleVar(self, value=PRESET_BANDWIDTH_VIDEO[0]['value'])
        self.vbw_auto_state_var = tk.BooleanVar(self, value=False)
        self.continuous_mode_var = tk.StringVar(self, value=PRESET_CONTINUOUS_MODE[0]['value'])
        self.average_on_var = tk.BooleanVar(self, value=False)
        self.average_count_var = tk.IntVar(self, value=PRESET_AVERAGING[0]['value'])
        
        self.mqtt_status_var = tk.StringVar(value="Last MQTT Payload: N/A")

        self._apply_styles(theme_name=DEFAULT_THEME)
        self._create_widgets()

        if self.mqtt_util:
            self.mqtt_util.add_subscriber(topic_filter="conductor/test/#", callback_func=self._on_message)

    def _apply_styles(self, theme_name: str):
        """Applies a theme based on the central style definition."""
        colors = THEMES.get(theme_name)
        style = ttk.Style(self)
        style.theme_use("clam")
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TButton', background=colors["accent"], foreground=colors["text"])
        style.map('Orange.TButton',
                  background=[('!active', 'orange'), ('active', 'orange')])
        style.map('Blue.TButton',
                  background=[('!active', colors['accent']), ('active', colors['secondary'])])
        style.map('TButton',
                  background=[('active', colors['secondary'])])
        style.map('Red.TButton',
                  background=[('!active', 'red'), ('active', 'darkred')])
        style.map('Green.TButton',
                  background=[('!active', 'green'), ('active', 'darkgreen')])
        style.configure('Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

    def _create_widgets(self):
        """
        Creates and arranges the widgets for the Bandwidth Settings tab.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering _create_widgets. Creating widgets for the Bandwidth Settings Tab. ⚙️",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function,
                  console_print_func=console_log)

        self.grid_columnconfigure(0, weight=1)
        self.grid_columnconfigure(1, weight=1)

        # --- Bandwidth Settings Frame ---
        bandwidth_frame = ttk.LabelFrame(self, text="Bandwidth Settings", style='Dark.TLabelframe')
        bandwidth_frame.grid(row=0, column=0, padx=10, pady=10, sticky="ew", columnspan=2)
        bandwidth_frame.grid_columnconfigure(1, weight=1)

        ttk.Label(bandwidth_frame, text="Resolution BW (Hz):").grid(row=0, column=0, padx=5, pady=2, sticky="w")
        
        self.rbw_combobox = ttk.Combobox(bandwidth_frame,
                                         textvariable=self.rbw_hz_var,
                                         values=self.rbw_labels,
                                         state='readonly')
        self.rbw_combobox.grid(row=0, column=1, padx=5, pady=2, sticky="ew")
        self.rbw_combobox.bind("<<ComboboxSelected>>", lambda event, id="rbw": self._publish_test_message(event, id))
        
        ttk.Label(bandwidth_frame, text="Video BW (Hz):").grid(row=1, column=0, padx=5, pady=2, sticky="w")
        
        self.vbw_combobox = ttk.Combobox(bandwidth_frame,
                                         textvariable=self.vbw_hz_var,
                                         values=self.vbw_labels,
                                         state='readonly')
        self.vbw_combobox.grid(row=1, column=1, padx=5, pady=2, sticky="ew")
        self.vbw_combobox.bind("<<ComboboxSelected>>", lambda event, id="vbw": self._publish_test_message(event, id))

        ttk.Label(bandwidth_frame, text="VBW Auto:").grid(row=2, column=0, padx=5, pady=2, sticky="w")
        self.vbw_auto_toggle_button = ttk.Button(bandwidth_frame,
                                                 text="OFF",
                                                 command=lambda: self._publish_test_message(None, "vbw_auto"),
                                                 style='Red.TButton')
        self.vbw_auto_toggle_button.grid(row=2, column=1, padx=5, pady=2, sticky="ew")
        
        # --- Initiate Settings Frame ---
        initiate_frame = ttk.LabelFrame(self, text="Initiate Settings", style='Dark.TLabelframe')
        initiate_frame.grid(row=1, column=0, padx=10, pady=10, sticky="ew", columnspan=2)
        initiate_frame.grid_columnconfigure(1, weight=1)
        
        ttk.Label(initiate_frame, text="Continuous Mode:").grid(row=0, column=0, padx=5, pady=2, sticky="w")
        self.initiate_continuous_dropdown = ttk.Combobox(initiate_frame,
                                                         textvariable=self.continuous_mode_var,
                                                         values=self.initiate_modes,
                                                         state='readonly')
        self.initiate_continuous_dropdown.grid(row=0, column=1, padx=5, pady=2, sticky="ew")
        self.initiate_continuous_dropdown.bind("<<ComboboxSelected>>", lambda event, id="continuous": self._publish_test_message(event, id))
        
        self.initiate_immediate_button = ttk.Button(initiate_frame,
                                                     text="Initiate Immediate",
                                                     command=lambda: self._publish_test_message(None, "immediate"),
                                                     style='Blue.TButton')
        self.initiate_immediate_button.grid(row=1, column=0, columnspan=2, padx=5, pady=5, sticky="ew")
        
        # --- Averaging Frame (Updated layout for Trace 1 only) ---
        averaging_frame = ttk.LabelFrame(self, text="Averaging", style='Dark.TLabelframe')
        averaging_frame.grid(row=2, column=0, padx=10, pady=10, sticky="ew", columnspan=2)
        averaging_frame.grid_columnconfigure((1, 3), weight=1)

        ttk.Label(averaging_frame, text="Trace 1 Averaging:").grid(row=0, column=0, padx=5, pady=2, sticky="w")
        self.average_on_button = ttk.Button(averaging_frame, text="OFF", command=lambda: self._publish_test_message(None, "avg_toggle"), style='Red.TButton')
        self.average_on_button.grid(row=0, column=1, padx=5, pady=2, sticky="ew")
        
        ttk.Label(averaging_frame, text="Count:").grid(row=0, column=2, padx=5, pady=2, sticky="w")
        self.average_count_dropdown = ttk.Combobox(averaging_frame, textvariable=self.average_count_var, values=self.avg_labels, state='readonly')
        self.average_count_dropdown.grid(row=0, column=3, padx=5, pady=2, sticky="ew")
        self.average_count_dropdown.bind("<<ComboboxSelected>>", lambda event, id="avg_count": self._publish_test_message(event, id))

        # --- NEW: MQTT Status Label ---
        mqtt_status_frame = ttk.Frame(self)
        mqtt_status_frame.grid(row=3, column=0, padx=10, pady=5, sticky="ew", columnspan=2)
        mqtt_status_frame.grid_columnconfigure(0, weight=1)
        ttk.Label(mqtt_status_frame, textvariable=self.mqtt_status_var, anchor="center").grid(row=0, column=0, sticky="ew")

        # Store a reference to the comboboxes and buttons for styling updates
        self._button_status["rbw"] = self.rbw_combobox
        self._button_status["vbw"] = self.vbw_combobox
        self._button_status["vbw_auto"] = self.vbw_auto_toggle_button
        self._button_status["continuous"] = self.initiate_continuous_dropdown
        self._button_status["immediate"] = self.initiate_immediate_button
        self._button_status["avg_toggle"] = self.average_on_button
        self._button_status["avg_count"] = self.average_count_dropdown
        
        debug_log(message=f"Widgets for Bandwidth Settings Tab created. Bandwidth controls are ready! 🛠️",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function,
                  console_print_func=console_log)


    def _update_button_style(self, button_id, value):
        """A simple function to update button styles based on the received payload."""
        button = self._button_status.get(button_id)
        if button:
            if value % 2 == 1:
                if isinstance(button, ttk.Button):
                    button.configure(style='Orange.TButton')
                else: # Combobox
                    button.configure(foreground='orange')
            else:
                if isinstance(button, ttk.Button):
                    button.configure(style='Blue.TButton')
                else: # Combobox
                    button.configure(foreground='white')

    def _on_message(self, topic, payload):
        """The callback for when a PUBLISH message is received from the server."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering {current_function} with arguments: topic: {topic}, payload: {payload}",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function,
                  console_print_func=console_log)
        try:
            payload_data = json.loads(payload)
            value = payload_data.get("value")
            subtopic = topic.split('/')[-1]
            self.mqtt_status_var.set(f"Last MQTT Payload: {value}")
            button_id = subtopic.split('_')[-1]
            self._update_button_style(button_id, value)
            console_log("✅ Received message and updated result label.")
        except json.JSONDecodeError:
            console_log("❌ Failed to decode message payload as JSON.")

    def _publish_test_message(self, event=None, button_id=""):
        """Publishes an incrementing test message to the MQTT broker."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering {current_function} with argument: button_id: {button_id}",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function,
                  console_print_func=console_log)
        
        self._message_counter += 1
        topic = "conductor/test"
        payload = json.dumps({"value": self._message_counter})
        
        try:
            self.mqtt_util.publish_message(topic=topic, subtopic=f"test_bandwidth_{button_id}", value=payload)
            console_log(f"✅ Published message to '{topic}/test_bandwidth_{button_id}': {payload}")
        except Exception as e:
            console_log(f"❌ Failed to publish message: {e}")

# Standalone block for testing purposes.
if __name__ == "__main__":
    root = tk.Tk()
    root.title("Bandwidth Settings Tab Test")
    
    class MockMqttUtil:
        def __init__(self):
            self.subscribers = defaultdict(list)
            self._message_id = 0
            self.lock = threading.Lock()

        def add_subscriber(self, topic_filter, callback_func):
            with self.lock:
                self.subscribers[topic_filter].append(callback_func)
                print(f"Mocking add_subscriber: {topic_filter}")

        def publish_message(self, topic, subtopic, value):
            with self.lock:
                full_topic = f"{topic}/{subtopic}" if subtopic else topic
                print(f"Mocking publish_message: {full_topic} -> {value}")
                self._message_id += 1
                for topic_filter, callbacks in self.subscribers.items():
                    if paho.mqtt.client.topic_matches_sub(topic_filter, full_topic):
                        for callback in callbacks:
                            callback(full_topic, value)
    
    mqtt_utility = MockMqttUtil()
    app_frame = BandwidthSettingsTab(master=root, mqtt_util=mqtt_utility)
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_1_instrument\sub_tab_2_settings\sub_tab_3_amplitude\gui_amplitude.py
#####################################
# tabs/Instrument/tab_instrument_child_settings_amplitude.py
#
# This file defines the AmplitudeSettingsTab, a Tkinter Frame for controlling a spectrum
# analyzer's amplitude-related settings. This version is now fully integrated into the
# main application, using a shared MQTT utility for communication.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250823.131230.1

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import json
import paho.mqtt.client as mqtt
import threading
import numpy as np
from collections import defaultdict

# --- Module Imports ---
# These are the dependencies needed for a stand-in test environment, simulating the original behavior.
from datasets.logging import debug_log, console_log
from display.styling.style import THEMES, DEFAULT_THEME
from workers.mqtt_controller_util import MqttControllerUtility

# --- Global Scope Variables ---
CURRENT_DATE = datetime.datetime.now().strftime("%Y%m%d")
CURRENT_TIME = datetime.datetime.now().strftime("%H%M%S")
CURRENT_TIME_HASH = int(datetime.datetime.now().strftime("%H%M%S"))
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
current_file = f"tabs/Instrument/tab_instrument_child_settings_amplitude.py"

# Mocked preset lists for the UI, as the original imports have been removed.
PRESET_AMPLITUDE_REFERENCE_LEVEL = [
    {"label": "-10", "value": -10.0, "description": "High signal level, good for strong signals."},
    {"label": "0", "value": 0.0, "description": "General purpose level, standard for most signals."},
    {"label": "10", "value": 10.0, "description": "Higher signal level, for stronger signals."},
]
PRESET_AMPLITUDE_POWER_ATTENUATION = [
    {"label": "0", "value": 0.0, "description": "No attenuation, for very weak signals."},
    {"label": "10", "value": 10.0, "description": "Standard 10 dB attenuation."},
    {"label": "20", "value": 20.0, "description": "Higher 20 dB attenuation, for strong signals."},
]
PRESET_AMPLITUDE_PREAMP_STATE = [
    {"label": "PREAMP ON", "value": "ON"},
    {"label": "PREAMP OFF", "value": "OFF"}
]
PRESET_AMPLITUDE_HIGH_SENSITIVITY_STATE = [
    {"label": "HIGH SENSITIVITY ON", "value": "ON"},
    {"label": "HIGH SENSITIVITY OFF", "value": "OFF"}
]


class AmplitudeSettingsTab(ttk.Frame):
    """
    A Tkinter Frame that provides a user interface for amplitude settings.
    This version correctly uses a parent-provided MQTT utility class.
    """
    def __init__(self, master=None, mqtt_util=None, *args, **kwargs):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Initializing AmplitudeSettingsTab. Setting up the GUI and its logic. 💻",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function,
                  console_print_func=console_log)

        super().__init__(master, *args, **kwargs)
        self.pack(fill="both", expand=True)

        self.mqtt_util = mqtt_util
        self._message_counter = 0
        self._button_status = defaultdict(lambda: None)
        
        self.is_ref_level_tracing = False
        self.is_attenuation_tracing = False
        
        # Mock Tkinter variables for the UI
        self.preamp_state_var = tk.BooleanVar(self, value=False)
        self.high_sensitivity_state_var = tk.BooleanVar(self, value=False)
        self.ref_level_dbm_var = tk.DoubleVar(self, value=PRESET_AMPLITUDE_REFERENCE_LEVEL[1]['value'])
        self.power_attenuation_db_var = tk.DoubleVar(self, value=PRESET_AMPLITUDE_POWER_ATTENUATION[1]['value'])
        self.mqtt_status_var = tk.StringVar(self, value="Last MQTT Payload: N/A")

        self._apply_styles(theme_name=DEFAULT_THEME)
        self._create_widgets()
        
        if self.mqtt_util:
            self.mqtt_util.add_subscriber(topic_filter="conductor/test/#", callback_func=self._on_message)

    def _apply_styles(self, theme_name: str):
        """Applies a theme based on the central style definition."""
        colors = THEMES.get(theme_name)
        style = ttk.Style(self)
        style.theme_use("clam")
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TButton', background=colors["accent"], foreground=colors["text"])
        style.map('Orange.TButton',
                  background=[('!active', 'orange'), ('active', 'orange')])
        style.map('Blue.TButton',
                  background=[('!active', colors['accent']), ('active', colors['secondary'])])
        style.map('TButton',
                  background=[('active', colors['secondary'])])
        style.map('Red.TButton',
                  background=[('!active', 'red'), ('active', 'darkred')])
        style.map('Green.TButton',
                  background=[('!active', 'green'), ('active', 'darkgreen')])
        style.configure('Description.TLabel', background=colors["bg"], foreground=colors["fg"], font=("Helvetica", 8, "italic"))
        style.configure('InteractionBars.TScale', troughcolor=colors["secondary"], background=colors["accent"])

    def _create_widgets(self):
        """
        Creates and arranges the widgets for the Amplitude Settings tab.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering {current_function}. The mad scientist is preparing the amplitude controls! 🔊🧪",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function,
                  console_print_func=console_log)

        self.grid_columnconfigure(0, weight=1)
        
        # --- Top Buttons for Preamp and High Sensitivity ---
        top_buttons_frame = ttk.Frame(self)
        top_buttons_frame.grid(row=0, column=0, padx=10, pady=10, sticky="ew")
        top_buttons_frame.grid_columnconfigure(0, weight=1)
        top_buttons_frame.grid_columnconfigure(1, weight=1)
        
        self.preamp_toggle_button = ttk.Button(top_buttons_frame,
                                               text="PREAMP OFF",
                                               command=lambda: self._on_toggle_button_press(button_id="preamp"),
                                               style='Red.TButton')
        self.preamp_toggle_button.grid(row=0, column=0, padx=5, pady=2, sticky="ew")
        self._button_status["preamp"] = self.preamp_toggle_button

        self.hs_toggle_button = ttk.Button(top_buttons_frame,
                                           text="HIGH SENSITIVITY OFF",
                                           command=lambda: self._on_toggle_button_press(button_id="high_sensitivity"),
                                           style='Red.TButton')
        self.hs_toggle_button.grid(row=0, column=1, padx=5, pady=2, sticky="ew")
        self._button_status["high_sensitivity"] = self.hs_toggle_button
        
        # --- Reference Level Controls (New layout) ---
        ref_level_frame = ttk.Frame(self)
        ref_level_frame.grid(row=1, column=0, padx=10, pady=5, sticky="ew")
        ref_level_frame.grid_columnconfigure(0, weight=1)

        ref_level_title_frame = ttk.Frame(ref_level_frame)
        ref_level_title_frame.grid(row=0, column=0, sticky="ew")
        ref_level_title_frame.grid_columnconfigure(1, weight=1)
        
        ttk.Label(ref_level_title_frame, text="Reference Level (dBm):").grid(row=0, column=0, padx=5, sticky="w")
        self.ref_level_value_label = ttk.Label(ref_level_title_frame, textvariable=self.ref_level_dbm_var)
        self.ref_level_value_label.grid(row=0, column=1, padx=5, sticky="e")

        ref_values = [p["value"] for p in PRESET_AMPLITUDE_REFERENCE_LEVEL]
        ref_min = min(ref_values)
        ref_max = max(ref_values)
        self.ref_level_slider = ttk.Scale(ref_level_frame,
                                          orient="horizontal",
                                          variable=self.ref_level_dbm_var,
                                          from_=ref_min,
                                          to=ref_max,
                                          command=lambda v: self._update_descriptions(value=float(v), preset_list=PRESET_AMPLITUDE_REFERENCE_LEVEL, label=self.ref_level_description_label, var=self.ref_level_dbm_var))
        self.ref_level_slider.grid(row=1, column=0, padx=5, pady=5, sticky="ew")
        self.ref_level_slider.bind("<ButtonRelease-1>", lambda e: self._publish_test_message(button_id="ref_level_slider"))
        self._button_status["ref_level_slider"] = self.ref_level_slider
        
        self.ref_level_description_label = ttk.Label(ref_level_frame, text="", style='Description.TLabel', anchor="center")
        self.ref_level_description_label.grid(row=2, column=0, padx=5, pady=2, sticky="ew")
        
        # --- Spacer ---
        ttk.Frame(self, height=10).grid(row=2, column=0)

        # --- Power Attenuation Controls (New layout) ---
        power_att_frame = ttk.Frame(self)
        power_att_frame.grid(row=3, column=0, padx=10, pady=5, sticky="ew")
        power_att_frame.grid_columnconfigure(0, weight=1)

        power_att_title_frame = ttk.Frame(power_att_frame)
        power_att_title_frame.grid(row=0, column=0, sticky="ew")
        power_att_title_frame.grid_columnconfigure(1, weight=1)
        
        ttk.Label(power_att_title_frame, text="Power Attenuation (dB):").grid(row=0, column=0, padx=5, sticky="w")
        self.power_attenuation_value_label = ttk.Label(power_att_title_frame, textvariable=self.power_attenuation_db_var)
        self.power_attenuation_value_label.grid(row=0, column=1, padx=5, sticky="e")

        att_values = [p["value"] for p in PRESET_AMPLITUDE_POWER_ATTENUATION]
        att_min = min(att_values)
        att_max = max(att_values)
        self.power_attenuation_slider = ttk.Scale(power_att_frame,
                                                  orient="horizontal",
                                                  variable=self.power_attenuation_db_var,
                                                  from_=att_min,
                                                  to=att_max,
                                                  command=lambda v: self._update_descriptions(value=float(v), preset_list=PRESET_AMPLITUDE_POWER_ATTENUATION, label=self.power_attenuation_description_label, var=self.power_attenuation_db_var))
        self.power_attenuation_slider.grid(row=1, column=0, padx=5, pady=5, sticky="ew")
        self.power_attenuation_slider.bind("<ButtonRelease-1>", lambda e: self._publish_test_message(button_id="power_attenuation_slider"))
        self._button_status["power_attenuation_slider"] = self.power_attenuation_slider

        self.power_attenuation_description_label = ttk.Label(power_att_frame, text="", style='Description.TLabel', anchor="center")
        self.power_attenuation_description_label.grid(row=2, column=0, padx=5, pady=2, sticky="ew")
        
        # --- NEW: MQTT Status Label ---
        mqtt_status_frame = ttk.Frame(self)
        mqtt_status_frame.grid(row=4, column=0, padx=10, pady=5, sticky="ew")
        mqtt_status_frame.grid_columnconfigure(0, weight=1)
        ttk.Label(mqtt_status_frame, textvariable=self.mqtt_status_var, anchor="center").grid(row=0, column=0, sticky="ew")

        self._update_descriptions(value=self.ref_level_dbm_var.get(), preset_list=PRESET_AMPLITUDE_REFERENCE_LEVEL, label=self.ref_level_description_label, var=self.ref_level_dbm_var)
        self._update_descriptions(value=self.power_attenuation_db_var.get(), preset_list=PRESET_AMPLITUDE_POWER_ATTENUATION, label=self.power_attenuation_description_label, var=self.power_attenuation_db_var)

        debug_log(message=f"Widgets for Amplitude Settings Tab created. The amplitude controls are ready! 📉�",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function,
                  console_print_func=console_log)


    def _on_toggle_button_press(self, button_id):
        """Toggles the state of a button and publishes a test message."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering {current_function}. Button ID: {button_id}",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function,
                  console_print_func=console_log)
        
        if button_id == "preamp":
            current_state = self.preamp_state_var.get()
            self.preamp_state_var.set(not current_state)
            self._update_toggle_button_style(button=self._button_status["preamp"], state=not current_state)
        elif button_id == "high_sensitivity":
            current_state = self.high_sensitivity_state_var.get()
            self.high_sensitivity_state_var.set(not current_state)
            self._update_toggle_button_style(button=self._button_status["high_sensitivity"], state=not current_state)

        self._publish_test_message(button_id)
        
    def _find_closest_preset_value(self, value, preset_list):
        """Finds the closest discrete preset value for a given float value."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering {current_function}. Finding closest preset for value: {value}",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function,
                  console_print_func=console_log)

        values = [p["value"] for p in preset_list]
        return min(values, key=lambda x: abs(x - value))

    def _update_descriptions(self, value, preset_list, label, var):
        """
        Updates a description label and the variable value based on the slider value
        by finding the closest preset and snapping to it.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering {current_function}. Seeking the closest preset for a value of {value}...",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function,
                  console_print_func=console_log)
        
        closest_value = self._find_closest_preset_value(value, preset_list)
        
        closest_preset = next((preset for preset in preset_list if np.isclose(preset["value"], closest_value)), None)

        if closest_preset:
            var.set(closest_preset["value"])
            label.config(text=closest_preset["description"])
            debug_log(message=f"Found a description! ' {closest_preset['description']} '",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function,
                      console_print_func=console_log)
        else:
            label.config(text="No matching description found.")
            debug_log(message=f"Arrr, no description to be found! Shiver me timbers! 🏴‍☠️",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function,
                      console_print_func=console_log)

    def _update_button_style(self, button_id, value):
        """A simple function to update button styles based on the received payload."""
        button = self._button_status.get(button_id)
        if button:
            if value % 2 == 1:
                if isinstance(button, ttk.Button):
                    button.configure(style='Orange.TButton')
                else:
                    # Not a button, so we update the variable
                    pass
            else:
                if isinstance(button, ttk.Button):
                    button.configure(style='Blue.TButton')
                else:
                    # Not a button, so we update the variable
                    pass

    def _on_message(self, topic, payload):
        """The callback for when a PUBLISH message is received from the server."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering {current_function} with arguments: topic: {topic}, payload: {payload}",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function,
                  console_print_func=console_log)
        try:
            payload_data = json.loads(payload)
            value = payload_data.get("value")
            subtopic = topic.split('/')[-1]
            self.mqtt_status_var.set(f"Last MQTT Payload: {value}")
            
            button_id = subtopic.split('_')[-1]
            
            if button_id == "preamp":
                 if value % 2 == 1: # ON state
                     self._update_toggle_button_style(self._button_status["preamp"], state=True)
                 else: # OFF state
                     self._update_toggle_button_style(self._button_status["preamp"], state=False)
            elif button_id == "high_sensitivity":
                 if value % 2 == 1: # ON state
                     self._update_toggle_button_style(self._button_status["high_sensitivity"], state=True)
                 else: # OFF state
                     self._update_toggle_button_style(self._button_status["high_sensitivity"], state=False)
            else:
                self._update_button_style(button_id, value)
            
            console_log("✅ Received message and updated result label.")
        except json.JSONDecodeError:
            console_log("❌ Failed to decode message payload as JSON.")

    def _publish_test_message(self, button_id):
        """Publishes an incrementing test message to the MQTT broker."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering {current_function} with argument: button_id: {button_id}",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function,
                  console_print_func=console_log)
        
        self._message_counter += 1
        topic = "conductor/test"
        payload = json.dumps({"value": self._message_counter})
        
        try:
            self.mqtt_util.publish_message(topic=topic, subtopic=f"test_amplitude_{button_id}", value=payload)
            console_log(f"✅ Published message to '{topic}/test_amplitude_{button_id}': {payload}")
        except Exception as e:
            console_log(f"❌ Failed to publish message: {e}")

    def _update_toggle_button_style(self, button, state):
        """Updates the style and text of a toggle button based on its state."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering {current_function}. Updating button style for state: {state} 🤔",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function,
                  console_print_func=console_log)
        
        # Determine the correct preset list to use based on the button instance
        preset_list = None
        if button == self._button_status.get("preamp"):
            preset_list = PRESET_AMPLITUDE_PREAMP_STATE
            if state:
                button.config(style='Green.TButton', text=next((p['label'] for p in preset_list if p['value'] == 'ON'), "ON"))
            else:
                button.config(style='Red.TButton', text=next((p['label'] for p in preset_list if p['value'] == 'OFF'), "OFF"))
        elif button == self._button_status.get("high_sensitivity"):
            preset_list = PRESET_AMPLITUDE_HIGH_SENSITIVITY_STATE
            if state:
                button.config(style='Green.TButton', text=next((p['label'] for p in preset_list if p['value'] == 'ON'), "ON"))
            else:
                button.config(style='Red.TButton', text=next((p['label'] for p in preset_list if p['value'] == 'OFF'), "OFF"))



#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_1_instrument\sub_tab_2_settings\sub_tab_4_markers\gui_markers.py
#####################################
# tabs/Instrument/tab_instrument_child_settings_markers.py
#
# This file defines the MarkerSettingsTab, a Tkinter Frame for controlling a spectrum
# analyzer's marker settings. This refactored version is now fully integrated into the
# main application, using a shared MQTT utility for communication.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250823.131500.1

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import json
import paho.mqtt.client as mqtt
import threading
import numpy as np
from collections import defaultdict

# --- Module Imports ---
# These are the dependencies needed for a stand-in test environment, simulating the original behavior.
from datasets.logging import debug_log, console_log
from display.styling.style import THEMES, DEFAULT_THEME
from workers.mqtt_controller_util import MqttControllerUtility

# --- Global Scope Variables ---
CURRENT_DATE = datetime.datetime.now().strftime("%Y%m%d")
CURRENT_TIME = datetime.datetime.now().strftime("%H%M%S")
CURRENT_TIME_HASH = int(datetime.datetime.now().strftime("%H%M%S"))
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
current_file = f"tabs/Instrument/tab_instrument_child_settings_markers.py"


class MarkerSettingsTab(ttk.Frame):
    """
    A Tkinter Frame that provides a user interface for marker settings.
    This version correctly uses a parent-provided MQTT utility class.
    """
    def __init__(self, master=None, mqtt_util=None, *args, **kwargs):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Initializing MarkerSettingsTab. This should be a walk in the park! 🚶‍♀️",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function,
                  console_print_func=console_log)

        super().__init__(master, *args, **kwargs)
        self.pack(fill="both", expand=True)

        self.mqtt_util = mqtt_util
        self._message_counter = 0
        self.marker_freq_vars = [tk.DoubleVar(self, value=f) for f in [111.0, 222.0, 333.0, 444.0, 555.0, 666.0]]
        self.marker_result_table = None
        self.marker_place_all_button = None
        self.mqtt_status_var = tk.StringVar(value="Last MQTT Payload: N/A")

        self._apply_styles(theme_name=DEFAULT_THEME)
        self._create_widgets()
        
        if self.mqtt_util:
            self.mqtt_util.add_subscriber(topic_filter="conductor/test/#", callback_func=self._on_message)

    def _apply_styles(self, theme_name: str):
        """Applies a theme based on the central style definition."""
        colors = THEMES.get(theme_name)
        style = ttk.Style(self)
        style.theme_use("clam")
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TButton', background=colors["accent"], foreground=colors["text"])
        style.map('Orange.TButton',
                  background=[('!active', 'orange'), ('active', 'orange')])
        style.map('Blue.TButton',
                  background=[('!active', colors['accent']), ('active', colors['secondary'])])
        style.map('TButton',
                  background=[('active', colors['secondary'])])
        style.configure('Description.TLabel', background=colors["bg"], foreground=colors["fg"], font=("Helvetica", 8, "italic"))
        style.configure('InteractionBars.TScale', troughcolor=colors["secondary"], background=colors["accent"])

    def _create_widgets(self):
        """Creates the GUI widgets for the tab."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Creating widgets for MarkerSettingsTab. The puzzle pieces are coming together! 🧩",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function,
                  console_print_func=console_log)
        
        main_container = ttk.Frame(self, padding="10")
        main_container.pack(fill="both", expand=True)
        main_container.grid_columnconfigure(0, weight=1)
        
        marker_input_frame = ttk.Frame(main_container)
        marker_input_frame.grid(row=0, column=0, pady=(0, 5), sticky="ew")
        for i in range(6):
            marker_input_frame.grid_columnconfigure(i, weight=1)
            ttk.Label(marker_input_frame, text=f"M{i+1} Freq (MHz):").grid(row=0, column=i, padx=2, pady=2)
            ttk.Entry(marker_input_frame, textvariable=self.marker_freq_vars[i], width=8).grid(row=1, column=i, padx=2, pady=2)

        self.marker_place_all_button = ttk.Button(main_container, 
                                                 text="YakBeg - MARKER/PLACE/ALL",
                                                 command=lambda: self._publish_test_message(button_id="place_all"),
                                                 style='Blue.TButton')
        self.marker_place_all_button.grid(row=1, column=0, pady=5, sticky="ew")

        results_frame = ttk.Frame(main_container)
        results_frame.grid(row=2, column=0, pady=(5, 0), sticky="nsew")
        results_frame.grid_columnconfigure(0, weight=1)
        results_frame.grid_rowconfigure(0, weight=1)
        
        self.marker_result_table = ttk.Treeview(results_frame, columns=('Marker', 'Frequency', 'Amplitude'), show='headings', height=6)
        self.marker_result_table.heading('Marker', text='Marker')
        self.marker_result_table.heading('Frequency', text='Frequency (MHz)')
        self.marker_result_table.heading('Amplitude', text='Amplitude (dBm)')
        
        self.marker_result_table.column('Marker', width=80, stretch=tk.YES, anchor='center')
        self.marker_result_table.column('Frequency', width=120, stretch=tk.YES, anchor='center')
        self.marker_result_table.column('Amplitude', width=120, stretch=tk.YES, anchor='center')
        
        self.marker_result_table.grid(row=0, column=0, sticky="nsew")

        vsb = ttk.Scrollbar(results_frame, orient="vertical", command=self.marker_result_table.yview)
        vsb.grid(row=0, column=1, sticky="ns")
        self.marker_result_table.configure(yscrollcommand=vsb.set)
        
        # NEW: MQTT Status Label
        mqtt_status_frame = ttk.Frame(main_container)
        mqtt_status_frame.grid(row=3, column=0, padx=10, pady=5, sticky="ew")
        mqtt_status_frame.grid_columnconfigure(0, weight=1)
        ttk.Label(mqtt_status_frame, textvariable=self.mqtt_status_var, anchor="center").grid(row=0, column=0, sticky="ew")

    def _update_button_style(self, button_id, value):
        """A simple function to update button styles based on the received payload."""
        if button_id == "place_all":
            if value % 2 == 1:
                self.marker_place_all_button.config(style='Orange.TButton')
            else:
                self.marker_place_all_button.config(style='Blue.TButton')

    def _on_message(self, topic, payload):
        """The callback for when a PUBLISH message is received from the server."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering {current_function} with arguments: topic: {topic}, payload: {payload}",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function,
                  console_print_func=console_log)
        try:
            payload_data = json.loads(payload)
            value = payload_data.get("value")
            subtopic = topic.split('/')[-1]
            self.mqtt_status_var.set(f"Last MQTT Payload: {value}")
            self._update_button_style(subtopic.split('_')[-1], value)
            console_log("✅ Received message and updated result label.")
        except json.JSONDecodeError:
            console_log("❌ Failed to decode message payload as JSON.")
            
    def _publish_test_message(self, button_id):
        """Publishes an incrementing test message to the MQTT broker."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering {current_function} with argument: button_id: {button_id}",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function,
                  console_print_func=console_log)
        
        self._message_counter += 1
        topic = "conductor/test"
        payload = json.dumps({"value": self._message_counter})
        
        try:
            self.mqtt_util.publish_message(topic=topic, subtopic=f"test_markers_{button_id}", value=payload)
            console_log(f"✅ Published message to '{topic}/test_markers_{button_id}': {payload}")
        except Exception as e:
            console_log(f"❌ Failed to publish message: {e}")


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_1_instrument\sub_tab_2_settings\sub_tab_5_traces\gui_traces.py
#####################################
# tabs/Instrument/tab_instrument_child_settings_traces.py
#
# This file defines the TraceSettingsTab, a Tkinter Frame for controlling a spectrum
# analyzer's trace settings. This refactored version removes dependencies on external
# utility and configuration files and implements a self-contained mock MQTT publisher for testing purposes.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250823.130000.1

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import json
import paho.mqtt.client as mqtt
import threading
import pandas as pd
from collections import defaultdict

# --- Module Imports ---
# We are intentionally removing the following imports for this test version:
# from display.debug_logic import debug_log
# from display.console_logic import console_log
# from yak.utils_yakbeg_handler import handle_trace_modes_beg, handle_trace_data_beg
# from yak.utils_yaknab_handler import handle_all_traces_nab
# from display.utils_display_monitor import update_top_plot, update_middle_plot, update_bottom_plot, clear_monitor_plots
# from display.utils_scan_view import update_single_plot
# from settings_and_config.config_manager_instruments import _save_instrument_settings
# from settings_and_config.config_manager_save import save_program_config
from display.styling.style import THEMES, DEFAULT_THEME


# --- Global Scope Variables ---
CURRENT_DATE = datetime.datetime.now().strftime("%Y%m%d")
CURRENT_TIME = datetime.datetime.now().strftime("%H%M%S")
CURRENT_TIME_HASH = int(datetime.datetime.now().strftime("%H%M%S"))
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
current_file = f"tabs/Instrument/tab_instrument_child_settings_traces.py"

# --- Mocking core dependencies for this standalone test file ---
def debug_log(message, file, version, function, console_print_func):
    """A mock debug log function for testing purposes."""
    print(f"DEBUG: {message}")

def console_log(message):
    """A mock console log function for testing purposes."""
    print(f"CONSOLE: {message}")

# Mocked preset lists for the UI
MOCK_TRACE_MODES = ["VIEW", "WRITE", "BLANK", "MAXHOLD", "MINHOLD"]

class TraceSettingsTab(ttk.Frame):
    """
    A Tkinter Frame that provides a user interface for trace settings.
    This is a refactored version for testing, implementing its own mock MQTT client.
    """
    def __init__(self, master=None, mqtt_util=None, *args, **kwargs):
        """
        Initializes the TraceSettingsTab.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Initializing TraceSettingsTab. Setting up the GUI and its logic. �",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function,
                  console_print_func=console_log)
        
        super().__init__(master, **kwargs)
        self.pack(fill="both", expand=True)

        self.mqtt_util = mqtt_util
        self._message_counter = 0
        self._button_status = defaultdict(lambda: None)

        self.trace_modes = MOCK_TRACE_MODES
        self.trace_modes_result_var = tk.StringVar(value="Result: N/A")
        self.trace_data_count_var = tk.StringVar(value="0")
        self.mqtt_status_var = tk.StringVar(value="Last MQTT Payload: N/A")

        self.trace_mode_vars = {
            "trace1": tk.StringVar(value="WRITE"),
            "trace2": tk.StringVar(value="MAXHOLD"),
            "trace3": tk.StringVar(value="MINHOLD"),
            "trace4": tk.StringVar(value="BLANK")
        }

        self._apply_styles(theme_name=DEFAULT_THEME)
        self._create_widgets()

        if self.mqtt_util:
            self.mqtt_util.add_subscriber(topic_filter="conductor/test/#", callback_func=self._on_message)

    def _apply_styles(self, theme_name: str):
        """Applies a theme based on the central style definition."""
        colors = THEMES.get(theme_name)
        style = ttk.Style(self)
        style.theme_use("clam")
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TButton', background=colors["accent"], foreground=colors["text"])
        style.map('Orange.TButton',
                  background=[('!active', 'orange'), ('active', 'orange')])
        style.map('Blue.TButton',
                  background=[('!active', colors['accent']), ('active', colors['secondary'])])
        style.map('TButton',
                  background=[('active', colors['secondary'])])
        style.configure('Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

    def _create_widgets(self):
        """
        Creates and arranges the widgets for the Trace Settings tab.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering _create_widgets. Creating widgets for the Trace Settings Tab. 📈",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function,
                  console_print_func=console_log)
        
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(2, weight=1)

        # --- TRACE/MODES Frame ---
        trace_modes_frame = ttk.LabelFrame(self, text="Trace Modes", padding=10)
        trace_modes_frame.grid(row=0, column=0, padx=10, pady=5, sticky="ew")
        trace_modes_frame.grid_columnconfigure(0, weight=1)
        trace_modes_frame.grid_columnconfigure(1, weight=1)
        trace_modes_frame.grid_columnconfigure(2, weight=1)
        trace_modes_frame.grid_columnconfigure(3, weight=1)

        ttk.Label(trace_modes_frame, text="Trace 1 Mode:").grid(row=0, column=0, padx=5, pady=2, sticky="w")
        trace1_combo = ttk.Combobox(trace_modes_frame, textvariable=self.trace_mode_vars["trace1"], values=self.trace_modes, state="readonly")
        trace1_combo.grid(row=1, column=0, padx=5, pady=2, sticky="ew")
        self.trace_mode_vars["trace1"].trace_add('write', lambda *args: self._publish_test_message(button_id="trace1"))

        ttk.Label(trace_modes_frame, text="Trace 2 Mode:").grid(row=0, column=1, padx=5, pady=2, sticky="w")
        trace2_combo = ttk.Combobox(trace_modes_frame, textvariable=self.trace_mode_vars["trace2"], values=self.trace_modes, state="readonly")
        trace2_combo.grid(row=1, column=1, padx=5, pady=2, sticky="ew")
        self.trace_mode_vars["trace2"].trace_add('write', lambda *args: self._publish_test_message(button_id="trace2"))

        ttk.Label(trace_modes_frame, text="Trace 3 Mode:").grid(row=0, column=2, padx=5, pady=2, sticky="w")
        trace3_combo = ttk.Combobox(trace_modes_frame, textvariable=self.trace_mode_vars["trace3"], values=self.trace_modes, state="readonly")
        trace3_combo.grid(row=1, column=2, padx=5, pady=2, sticky="ew")
        self.trace_mode_vars["trace3"].trace_add('write', lambda *args: self._publish_test_message(button_id="trace3"))

        ttk.Label(trace_modes_frame, text="Trace 4 Mode:").grid(row=0, column=3, padx=5, pady=2, sticky="w")
        trace4_combo = ttk.Combobox(trace_modes_frame, textvariable=self.trace_mode_vars["trace4"], values=self.trace_modes, state="readonly")
        trace4_combo.grid(row=1, column=3, padx=5, pady=2, sticky="ew")
        self.trace_mode_vars["trace4"].trace_add('write', lambda *args: self._publish_test_message(button_id="trace4"))

        self.trace_modes_result_var = tk.StringVar(value="Result: N/A")
        ttk.Label(trace_modes_frame, textvariable=self.trace_modes_result_var).grid(row=2, column=0, columnspan=4, padx=5, pady=2, sticky="ew")

        # --- TRACE/DATA Frame ---
        trace_data_frame = ttk.LabelFrame(self, text="Trace Data", padding=10)
        trace_data_frame.grid(row=1, column=0, padx=10, pady=5, sticky="nsew")
        trace_data_frame.grid_columnconfigure(0, weight=1)
        
        self.trace_data_tree = ttk.Treeview(trace_data_frame, columns=("Frequency", "Value"), show="headings", height=6)
        self.trace_data_tree.heading("Frequency", text="Frequency (MHz)")
        self.trace_data_tree.heading("Value", text="Value (dBm)")
        self.trace_data_tree.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)
        
        vsb = ttk.Scrollbar(trace_data_frame, orient="vertical", command=self.trace_data_tree.yview)
        vsb.grid(row=0, column=1, sticky="ns")
        self.trace_data_tree.configure(yscrollcommand=vsb.set)
        
        # --- NEW: MQTT Status Label ---
        mqtt_status_frame = ttk.Frame(self)
        mqtt_status_frame.grid(row=2, column=0, padx=10, pady=5, sticky="ew")
        mqtt_status_frame.grid_columnconfigure(0, weight=1)
        ttk.Label(mqtt_status_frame, textvariable=self.mqtt_status_var, anchor="center").grid(row=0, column=0, sticky="ew")

        # Store a reference to the comboboxes for styling updates
        self._button_status["trace1"] = trace1_combo
        self._button_status["trace2"] = trace2_combo
        self._button_status["trace3"] = trace3_combo
        self._button_status["trace4"] = trace4_combo
        
        debug_log(message=f"Widgets for Trace Settings Tab created. The controls are ready to go! 🗺️",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function,
                  console_print_func=console_log)


    def _update_button_style(self, button_id, value):
        """A simple function to update button styles based on the received payload."""
        button = self._button_status.get(button_id)
        if button:
            if value % 2 == 1:
                # For a combobox, this is a bit different. Let's just change the foreground color to simulate a status change.
                button.configure(foreground='orange')
            else:
                button.configure(foreground='white')

    def _on_message(self, topic, payload):
        """The callback for when a PUBLISH message is received from the server."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering {current_function} with arguments: topic: {topic}, payload: {payload}",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function,
                  console_print_func=console_log)
        try:
            payload_data = json.loads(payload)
            value = payload_data.get("value")
            subtopic = topic.split('/')[-1]
            self.mqtt_status_var.set(f"Last MQTT Payload: {value}")
            # The button_id is now in the subtopic, e.g., "test_traces_trace1"
            button_id = subtopic.split('_')[-1]
            self._update_button_style(button_id, value)
            console_log("✅ Received message and updated result label.")
        except json.JSONDecodeError:
            console_log("❌ Failed to decode message payload as JSON.")

    def _publish_test_message(self, button_id):
        """Publishes an incrementing test message to the MQTT broker."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering {current_function} with argument: button_id: {button_id}",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function,
                  console_print_func=console_log)
        
        self._message_counter += 1
        topic = "conductor/test"
        payload = json.dumps({"value": self._message_counter})
        
        try:
            self.mqtt_util.publish_message(topic=topic, subtopic=f"test_traces_{button_id}", value=payload)
            console_log(f"✅ Published message to '{topic}/test_traces_{button_id}': {payload}")
        except Exception as e:
            console_log(f"❌ Failed to publish message: {e}")

# Standalone block for testing purposes.
if __name__ == "__main__":
    root = tk.Tk()
    root.title("Trace Settings Tab Test")
    
    class MockMqttUtil:
        def __init__(self):
            self.subscribers = defaultdict(list)
            self._message_id = 0

        def add_subscriber(self, topic_filter, callback_func):
            self.subscribers[topic_filter].append(callback_func)
            print(f"Mocking add_subscriber: {topic_filter}")

        def publish_message(self, topic, subtopic, value):
            full_topic = f"{topic}/{subtopic}" if subtopic else topic
            print(f"Mocking publish_message: {full_topic} -> {value}")
            self._message_id += 1
            for topic_filter, callbacks in self.subscribers.items():
                if mqtt.topic_matches_sub(topic_filter, full_topic):
                    for callback in callbacks:
                        callback(full_topic, value)
    
    mqtt_utility = MockMqttUtil()
    app_frame = TraceSettingsTab(master=root, mqtt_util=mqtt_utility)
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_1_instrument\sub_tab_3_translator\gui_translator.py
#####################################
# tabs/Instrument/tab_instrument_child_visa_interpreter.py
#
# This file defines the VisaInterpreterTab as a standalone ttk.Frame.
# All GUI elements are directly connected to MQTT publishing, with all
# complex logic for data handling and rendering removed.
#
# Author: Anthony Peter Kuzub
#
# Version 20250824.180000.1

import tkinter as tk
from tkinter import ttk
import os
import pathlib
import json
from collections import defaultdict
import inspect
import datetime
import threading

# Import core utilities and style module
from datasets.logging import debug_log, console_log
from workers.mqtt_controller_util import MqttControllerUtility
from styling.style import THEMES, DEFAULT_THEME


class VisaInterpreterTab(ttk.Frame):
    """
    A standalone Tkinter Frame that provides a user interface for executing and
    managing VISA commands. All interactions are connected to MQTT.
    """
    def __init__(self, parent_frame, mqtt_util, **kwargs):
        super().__init__(parent_frame, **kwargs)
        self.pack(fill=tk.BOTH, expand=True)

        self.mqtt_util = mqtt_util
        self.current_topic_prefix = self._get_topic_prefix()

        # Mock data for the Treeview
        self.mock_data = [
            ("Keysight", "N9912A", "QUERY", "*IDN?", "", "IDN", "True"),
            ("Keysight", "N9912A", "SET", ":SYST:PRES", "1", "Preset", "True"),
            ("Keysight", "N9912A", "DO", ":MMEM:STOR:STAT", "", "Store State", "False")
        ]
        
        self.sort_direction = {}
        self.last_selected_item = None
        
        self.manufacturer_var = tk.StringVar(self, value="N/A")
        self.model_var = tk.StringVar(self, value="N/A")
        self.serial_number_var = tk.StringVar(self, value="N/A")
        self.version_var = tk.StringVar(self, value="N/A")

        self._apply_styles(theme_name=DEFAULT_THEME)
        self._create_widgets()
        self._load_data_to_treeview()

    def _get_topic_prefix(self):
        """Constructs the MQTT topic prefix based on the file path."""
        relative_path = pathlib.Path(__file__).resolve().relative_to(pathlib.Path(__file__).resolve().parent.parent.parent.parent)
        topic = str(relative_path).replace(os.sep, '/')
        return os.path.splitext(topic)[0]
    
    def _apply_styles(self, theme_name: str):
        """Applies a theme based on the central style definition."""
        colors = THEMES.get(theme_name)
        style = ttk.Style(self)
        style.theme_use("clam")
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TButton', background=colors["accent"], foreground=colors["text"])
        style.map('Orange.TButton', background=[('!active', 'orange'), ('active', 'orange')])
        style.map('Blue.TButton', background=[('!active', colors['accent']), ('active', colors['secondary'])])
        style.map('TButton', background=[('active', colors['secondary'])])
        style.map('Red.TButton', background=[('!active', 'red'), ('active', 'darkred')])
        style.map('Green.TButton', background=[('!active', 'green'), ('active', 'darkgreen')])
        style.configure('Dark.TLabelframe', background=colors["bg"], foreground=colors["fg"])
        style.configure('Dark.TLabel.Value', background=colors["bg"], foreground=colors["fg"])
        style.configure('Treeview', fieldbackground=colors["table_bg"], foreground=colors["table_fg"])
        style.configure('Treeview.Heading', background=colors["table_heading_bg"], foreground=colors["fg"])


    def _create_widgets(self):
        """Creates the UI widgets for the VisaInterpreterTab."""
        self.columnconfigure(0, weight=1)
        self.rowconfigure(0, weight=1)
        self.rowconfigure(1, weight=0)

        main_frame = ttk.Frame(self)
        main_frame.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
        main_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(0, weight=1)

        tree_frame = ttk.Frame(main_frame)
        tree_frame.grid(row=0, column=0, sticky="nsew")
        tree_frame.rowconfigure(0, weight=1)
        tree_frame.columnconfigure(0, weight=1)

        columns = ("Manufacturer", "Model", "Command Type", "Action", "VISA Command", "Variable", "Validated")
        self.treeview = ttk.Treeview(tree_frame, columns=columns, show="headings")
        self.treeview.pack(side="left", fill="both", expand=True)

        for col in columns:
            self.treeview.heading(col, text=col, command=lambda c=col: self._publish_value("sort_column", c))
            self.treeview.column(col, anchor="w", width=100)
            self.sort_direction[col] = 'asc'

        scrollbar = ttk.Scrollbar(tree_frame, orient="vertical", command=self.treeview.yview)
        self.treeview.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side="right", fill="y")
        
        control_frame = ttk.LabelFrame(self, text="Controls")
        control_frame.grid(row=1, column=0, sticky="ew", padx=10, pady=5)
        control_frame.columnconfigure(1, weight=1)

        self.status_label = ttk.Label(control_frame, text="Status: Disconnected", foreground="red")
        self.status_label.grid(row=0, column=0, columnspan=2, sticky="ew", padx=5, pady=2)

        ttk.Label(control_frame, text="Command:", style='TLabel').grid(row=1, column=0, sticky="w", padx=5, pady=2)
        self.command_entry = ttk.Entry(control_frame)
        self.command_entry.grid(row=1, column=1, sticky="ew", padx=5, pady=2)
        self.command_entry.bind('<Return>', lambda e: self._publish_value("command_entry_return", self.command_entry.get().strip()))

        button_frame = ttk.Frame(control_frame)
        button_frame.grid(row=2, column=0, columnspan=2, sticky="ew", padx=5, pady=5)
        button_frame.columnconfigure(0, weight=1)
        button_frame.columnconfigure(1, weight=1)
        button_frame.columnconfigure(2, weight=1)
        button_frame.columnconfigure(3, weight=1)

        self.execute_command_button = ttk.Button(button_frame, text="Execute", command=lambda: self._publish_value("execute_command", self.command_entry.get().strip()))
        self.execute_command_button.grid(row=0, column=0, sticky="ew", padx=2, pady=2)

        self.query_button = ttk.Button(button_frame, text="Query", command=lambda: self._publish_value("query_command", self.command_entry.get().strip()))
        self.query_button.grid(row=0, column=1, sticky="ew", padx=2, pady=2)
        
        self.set_button = ttk.Button(button_frame, text="Set", command=lambda: self._publish_value("set_command", self.command_entry.get().strip()))
        self.set_button.grid(row=0, column=2, sticky="ew", padx=2, pady=2)
        
        self.do_button = ttk.Button(button_frame, text="Do", command=lambda: self._publish_value("do_command", self.command_entry.get().strip()))
        self.do_button.grid(row=0, column=3, sticky="ew", padx=2, pady=2)

        action_frame = ttk.Frame(control_frame)
        action_frame.grid(row=3, column=0, columnspan=2, sticky="ew", padx=5, pady=5)
        action_frame.columnconfigure(0, weight=1)
        action_frame.columnconfigure(1, weight=1)
        action_frame.columnconfigure(2, weight=1)
        action_frame.columnconfigure(3, weight=1)

        ttk.Button(action_frame, text="Load Data", command=lambda: self._publish_value("load_data", "clicked")).grid(row=0, column=0, sticky="ew", padx=2, pady=2)
        ttk.Button(action_frame, text="Add New Row", command=lambda: self._publish_value("add_new_row", "clicked")).grid(row=0, column=1, sticky="ew", padx=2, pady=2)
        ttk.Button(action_frame, text="Save Data", command=lambda: self._publish_value("save_data", "clicked")).grid(row=0, column=2, sticky="ew", padx=2, pady=2)
        ttk.Button(action_frame, text="Delete Row", command=lambda: self._publish_value("delete_row", "clicked")).grid(row=0, column=3, sticky="ew", padx=2, pady=2)
        
    def _load_data_to_treeview(self):
        """Loads data from the internal list into the Treeview widget."""
        for item in self.treeview.get_children():
            self.treeview.delete(item)
        for row in self.mock_data:
            self.treeview.insert('', 'end', values=row)

    def _publish_value(self, element_name, value):
        """Publishes a value to a topic based on the file path and element name."""
        if self.mqtt_util:
            self.mqtt_util.publish_message(
                topic=self.current_topic_prefix,
                subtopic=element_name,
                value=value
            )

if __name__ == "__main__":
    # Example for standalone testing
    root = tk.Tk()
    root.title("Standalone VISA Interpreter Tab Demo")
    root.geometry("1000x600")

    class MockMqttUtil:
        def add_subscriber(self, topic_filter, callback_func):
            pass
        def publish_message(self, topic, subtopic, value):
            full_topic = f"{topic}/{subtopic}" if subtopic else topic
            print(f"MOCK MQTT PUBLISH: Topic='{full_topic}', Value='{value}'")
    
    mqtt_utility = MockMqttUtil()
    app_frame = VisaInterpreterTab(parent_frame=root, mqtt_util=mqtt_utility)
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_2_markers\sub_tab_1_showtime\gui_child_1_showtime.py
#####################################
# tabs/Markers/showtime/zones_groups_devices/tab_markers_child_zone_groups_devices.py
#
# This file defines the ZoneGroupsDevicesFrame as a standalone ttk.Frame.
# All GUI elements are directly connected to MQTT publishing, with all
# complex logic for data handling and rendering removed.
#
# Author: Anthony Peter Kuzub
#
# Version 20250824.180000.1

import tkinter as tk
from tkinter import ttk
import os
import pathlib
import json
import inspect
import threading
from datetime import datetime
from collections import defaultdict

# Import core utilities and style module
from datasets.logging import debug_log, console_log
from workers.mqtt_controller_util import MqttControllerUtility
from styling.style import THEMES, DEFAULT_THEME


class ZoneGroupsDevicesFrame(ttk.Frame):
    """
    A standalone Tkinter Frame that provides a user interface for selecting
    zones, groups, and devices, with all interactions connected to MQTT.
    """
    def __init__(self, parent_frame, mqtt_util, **kwargs):
        super().__init__(parent_frame, **kwargs)
        self.pack(fill=tk.BOTH, expand=True)

        self.mqtt_util = mqtt_util
        self.current_topic_prefix = self._get_topic_prefix()

        self.structured_data = {
            'Zone A': {
                'Group 1': [{'NAME': 'Device 1', 'DEVICE': 'Type A', 'CENTER': '100.0', 'PEAK': -50.0}, {'NAME': 'Device 2', 'DEVICE': 'Type A', 'CENTER': '101.0', 'PEAK': -60.0}],
                'Group 2': [{'NAME': 'Device 3', 'DEVICE': 'Type B', 'CENTER': '150.0', 'PEAK': -45.0}]
            },
            'Zone B': {
                'Group 3': [{'NAME': 'Device 4', 'DEVICE': 'Type C', 'CENTER': '200.0', 'PEAK': -70.0}]
            }
        }
        self.active_zone_button = None
        self.active_group_button = None

        self._apply_styles(theme_name=DEFAULT_THEME)
        self._create_widgets()

    def _get_topic_prefix(self):
        """Constructs the MQTT topic prefix based on the file path."""
        relative_path = pathlib.Path(__file__).resolve().relative_to(pathlib.Path(__file__).resolve().parent.parent.parent.parent)
        topic = str(relative_path).replace(os.sep, '/')
        return os.path.splitext(topic)[0]

    def _apply_styles(self, theme_name: str):
        """Applies a theme based on the central style definition."""
        colors = THEMES.get(theme_name)
        style = ttk.Style(self)
        style.theme_use("clam")
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TButton', background=colors["accent"], foreground=colors["text"])
        style.map('Orange.TButton', background=[('!active', 'orange'), ('active', 'orange')])
        style.map('Blue.TButton', background=[('!active', colors['accent']), ('active', colors['secondary'])])
        style.map('TButton', background=[('active', colors['secondary'])])
        style.map('Red.TButton', background=[('!active', 'red'), ('active', 'darkred')])
        style.map('Green.TButton', background=[('!active', 'green'), ('active', 'darkgreen')])
        style.configure('Dark.TLabelframe', background=colors["bg"], foreground=colors["fg"])
        style.configure('Dark.TLabel.Value', background=colors["bg"], foreground=colors["fg"])

    def _create_widgets(self):
        """Creates the main layout with zones, groups, and the scrollable device frame."""
        self.columnconfigure(0, weight=1)
        self.rowconfigure(2, weight=1)
        
        self.zones_frame = ttk.LabelFrame(self, text="Zones")
        self.zones_frame.grid(row=0, column=0, sticky="ew", padx=10, pady=5)
        self._make_zone_buttons()
        
        self.groups_frame = ttk.LabelFrame(self, text="Groups")
        self.groups_frame.grid(row=1, column=0, sticky="ew", padx=10, pady=5)
        self._make_group_buttons('Zone A')
        
        self.devices_outer_frame = ttk.LabelFrame(self, text="Devices")
        self.devices_outer_frame.grid(row=2, column=0, sticky="nsew", padx=10, pady=5)
        self.devices_outer_frame.grid_rowconfigure(0, weight=1)
        self.devices_outer_frame.grid_columnconfigure(0, weight=1)
        
        self.canvas = tk.Canvas(self.devices_outer_frame, borderwidth=0, highlightthickness=0)
        scrollbar = ttk.Scrollbar(self.devices_outer_frame, orient="vertical", command=self.canvas.yview)
        self.devices_scrollable_frame = ttk.Frame(self.canvas)
        self.devices_scrollable_frame.bind("<Configure>", lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all")))
        
        self.canvas.create_window((0, 0), window=self.devices_scrollable_frame, anchor="nw")
        self.canvas.configure(yscrollcommand=scrollbar.set)
        
        self.canvas.grid(row=0, column=0, sticky="nsew")
        scrollbar.grid(row=0, column=1, sticky="ns")

        self._make_device_buttons('Zone A', 'Group 1')

    def _make_zone_buttons(self):
        """Creates the zone selection buttons in a grid."""
        for widget in self.zones_frame.winfo_children():
            widget.destroy()

        max_columns = 6
        for i, zone_name in enumerate(self.structured_data.keys()):
            row, col = divmod(i, max_columns)
            btn = ttk.Button(self.zones_frame, text=zone_name,
                             command=lambda z=zone_name: self._publish_value("zone_selected", z))
            btn.grid(row=row, column=col, padx=2, pady=2, sticky="ew")
            self.zones_frame.columnconfigure(col, weight=1)

    def _make_group_buttons(self, zone_name):
        """Creates group buttons, dynamically showing/hiding the frame."""
        for widget in self.groups_frame.winfo_children():
            widget.destroy()

        groups = self.structured_data.get(zone_name, {})
        max_columns = 6
        for i, group_name in enumerate(groups.keys()):
            row, col = divmod(i, max_columns)
            btn = ttk.Button(self.groups_frame, text=group_name,
                             command=lambda g=group_name: self._publish_value("group_selected", g))
            btn.grid(row=row, column=col, padx=2, pady=2, sticky="ew")
            self.groups_frame.columnconfigure(col, weight=1)

    def _make_device_buttons(self, zone_name, group_name):
        """Creates the detailed, multi-line device buttons in the scrollable frame."""
        for widget in self.devices_scrollable_frame.winfo_children():
            widget.destroy()
        
        devices_to_display = self.structured_data.get(zone_name, {}).get(group_name, [])
        self.devices_outer_frame.config(text=f"Devices ({len(devices_to_display)})")

        max_cols = 4
        for col in range(max_cols):
            self.devices_scrollable_frame.grid_columnconfigure(col, weight=1)
            
        for i, device in enumerate(devices_to_display):
            name = device.get('NAME', 'N/A')
            device_type = device.get('DEVICE', 'N/A')
            center = device.get('CENTER', 'N/A')
            peak = device.get('PEAK', -120.0)
            
            btn_text = f"{name}\n{device_type}\n{center} MHz\n{peak} dBm"
            
            btn = ttk.Button(self.devices_scrollable_frame, text=btn_text,
                             command=lambda d=device: self._publish_value("device_selected", d.get('NAME', 'N/A')))
            
            row, col = divmod(i, max_cols)
            btn.grid(row=row, column=col, padx=5, pady=2, sticky="ew")

    def _publish_value(self, element_name, value):
        """Publishes a value to a topic based on the file path and element name."""
        if self.mqtt_util:
            self.mqtt_util.publish_message(
                topic=self.current_topic_prefix,
                subtopic=element_name,
                value=value
            )

if __name__ == "__main__":
    # Example for standalone testing
    root = tk.Tk()
    root.title("Standalone GUI Demo")
    root.geometry("800x600")

    class MockMqttUtil:
        def __init__(self):
            self.subscribers = defaultdict(list)
            self._message_id = 0
            self.lock = threading.Lock()

        def add_subscriber(self, topic_filter, callback_func):
            pass

        def publish_message(self, topic, subtopic, value):
            full_topic = f"{topic}/{subtopic}" if subtopic else topic
            print(f"MOCK MQTT PUBLISH: Topic='{full_topic}', Value='{value}'")
    
    mqtt_utility = MockMqttUtil()
    app_frame = ZoneGroupsDevicesFrame(parent_frame=root, mqtt_util=mqtt_utility)
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_2_markers\sub_tab_2_editor\gui_child_2_editor.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version corrects the styling of tables and entry widgets for a more cohesive look.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250823.001500.20

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from datasets.logging import debug_log, console_log
from workers.mqtt_controller_util import MqttControllerUtility
from display.styling.style import THEMES, DEFAULT_THEME

# --- Global Scope Variables ---
CURRENT_DATE = 20250823
CURRENT_TIME = 1500
CURRENT_TIME_HASH = 1500
REVISION_NUMBER = 20
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class is now designed as a self-contained "island" that manages its own MQTT state.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # We apply the style at the top of the __init__ to affect all child widgets.
            self._apply_styles(theme_name=DEFAULT_THEME)

            # Create a label for the frame
            frame_label = ttk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = ttk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame, style="Custom.TEntry")
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = ttk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)

            # We now register our callback with the central utility instead of overwriting the client's callback.
            parent_folder = str(pathlib.Path(self.current_file).parent)
            subscription_topic = f"{parent_folder.replace('\\', '/')}/#"
            self.mqtt_util.add_subscriber(topic_filter=subscription_topic, callback_func=self._on_mqtt_message)


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings", style="Custom.Treeview")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            # New frame for log buttons, placed at the bottom below the table.
            log_button_frame = ttk.Frame(self)
            log_button_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=5)

            # Button 1: Log
            self.log_button = ttk.Button(
                log_button_frame, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = ttk.Button(
                log_button_frame, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        # General widget styling
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])

        # Table (Treeview) styling
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

        # Entry (textbox) styling
        style.configure('Custom.TEntry',
                        fieldbackground=colors["entry_bg"],
                        foreground=colors["entry_fg"],
                        bordercolor=colors["table_border"])
        
    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            message_content = json.loads(payload)["value"]
            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_3_presets\sub_tab_1_pusher\gui_child_1_pusher.py
#####################################
# tabs/Presets/tab_presets_child_local.py
#
# Stripped-down GUI for displaying and loading local presets, with all
# interactions connected to MQTT publishing.
#
# Author: Anthony Peter Kuzub
#
# Version 20250824.160000.1

import tkinter as tk
from tkinter import ttk
import pathlib
import os

from display.base_gui_component_rebuilt import BaseGUIFrame
from workers.mqtt_controller_util import MqttControllerUtility
from datasets.logging import console_log

class LocalPresetsTab(BaseGUIFrame):
    """
    A Tkinter Frame for displaying and loading user-defined local presets.
    All controls publish to MQTT via the BaseGUIFrame's utility.
    """
    def __init__(self, master, mqtt_util, **kwargs):
        super().__init__(master, mqtt_util, console_log, **kwargs)
        self.pack(fill=tk.BOTH, expand=True)
        self._create_widgets()

    def _create_widgets(self):
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(0, weight=1)
        self.grid_rowconfigure(1, weight=0)

        canvas = tk.Canvas(self, highlightthickness=0)
        scrollbar = ttk.Scrollbar(self, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)

        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        canvas.grid(row=0, column=0, sticky="nsew")
        scrollbar.grid(row=0, column=1, sticky="ns")

        max_cols = 5
        for i in range(max_cols):
            scrollable_frame.grid_columnconfigure(i, weight=1)

        mock_presets = [
            {'NickName': 'Preset A', 'Start': '100.0', 'Stop': '200.0'},
            {'NickName': 'Preset B', 'Start': '300.0', 'Stop': '400.0'},
            {'NickName': 'Preset C', 'Start': '500.0', 'Stop': '600.0'}
        ]
        
        row_idx = 0
        col_idx = 0
        
        for preset in mock_presets:
            button_text = f"{preset['NickName']}\nStart: {preset['Start']} MHz\nStop: {preset['Stop']} MHz"
            preset_button = ttk.Button(scrollable_frame,
                                       text=button_text,
                                       command=lambda name=preset['NickName']: self._publish_value("load_preset", name))
            
            preset_button.grid(row=row_idx, column=col_idx, padx=5, pady=5, sticky="nsew")

            col_idx += 1
            if col_idx >= max_cols:
                col_idx = 0
                row_idx += 1
        
        selected_preset_box = ttk.LabelFrame(self, text="Selected Preset Details")
        selected_preset_box.grid(row=1, column=0, padx=10, pady=10, sticky="ew")
        ttk.Label(selected_preset_box, text="Details will be displayed here.").pack(padx=5, pady=5)

#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_3_presets\sub_tab_2_editor\gui_child_2_editor.py
#####################################
# tabs/Presets/tab_presets_child_preset_editor.py
#
# Stripped-down GUI for managing presets, with all interactions
# connected to MQTT publishing.
#
# Author: Anthony Peter Kuzub
#
# Version 20250824.160000.1

import tkinter as tk
from tkinter import ttk
import pathlib
import os

from display.base_gui_component_rebuilt import BaseGUIFrame
from workers.mqtt_controller_util import MqttControllerUtility
from datasets.logging import console_log

class PresetEditorTab(BaseGUIFrame):
    """
    A Tkinter Frame that provides comprehensive functionality for managing
    user-defined presets. All controls publish to MQTT via the BaseGUIFrame's utility.
    """
    def __init__(self, master, mqtt_util, **kwargs):
        super().__init__(master, mqtt_util, console_log, **kwargs)
        self.pack(fill=tk.BOTH, expand=True)
        self.columns = ['Filename', 'NickName'] # Simplified columns for this example
        self._create_widgets()

    def _create_widgets(self):
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(0, weight=0)
        self.grid_rowconfigure(1, weight=0)
        self.grid_rowconfigure(2, weight=1)
        self.grid_rowconfigure(3, weight=0)
        self.grid_rowconfigure(4, weight=0)

        top_button_frame = ttk.Frame(self)
        top_button_frame.grid(row=0, column=0, columnspan=2, sticky="ew", padx=10, pady=5)
        top_button_frame.grid_columnconfigure(0, weight=1)
        top_button_frame.grid_columnconfigure(1, weight=1)
        top_button_frame.grid_columnconfigure(2, weight=1)

        add_current_button = ttk.Button(top_button_frame, text="Add Current Settings", command=lambda: self._publish_value("add_current_settings", "clicked"))
        add_current_button.grid(row=0, column=0, padx=5, pady=5, sticky="ew")

        add_empty_row_button = ttk.Button(top_button_frame, text="Add New Empty Row", command=lambda: self._publish_value("add_empty_row", "clicked"))
        add_empty_row_button.grid(row=0, column=1, padx=5, pady=5, sticky="ew")

        delete_button = ttk.Button(top_button_frame, text="Delete Selected", command=lambda: self._publish_value("delete_selected", "clicked"))
        delete_button.grid(row=0, column=2, padx=5, pady=5, sticky="ew")

        move_button_frame = ttk.Frame(self)
        move_button_frame.grid(row=1, column=0, columnspan=2, sticky="ew", padx=10, pady=5)
        move_button_frame.grid_columnconfigure(0, weight=1)
        move_button_frame.grid_columnconfigure(1, weight=1)

        move_up_button = ttk.Button(move_button_frame, text="Move Preset UP", command=lambda: self._publish_value("move_up", "clicked"))
        move_up_button.grid(row=0, column=0, padx=5, pady=5, sticky="ew")

        move_down_button = ttk.Button(move_button_frame, text="Move Preset DOWN", command=lambda: self._publish_value("move_down", "clicked"))
        move_down_button.grid(row=0, column=1, padx=5, pady=5, sticky="ew")

        presets_tree = ttk.Treeview(self, columns=self.columns, show='headings')
        presets_tree.heading("Filename", text="Filename")
        presets_tree.heading("NickName", text="NickName")
        presets_tree.grid(row=2, column=0, sticky="nsew", padx=10, pady=10)

        vsb = ttk.Scrollbar(self, orient="vertical", command=presets_tree.yview)
        vsb.grid(row=2, column=1, sticky='ns')
        presets_tree.configure(yscrollcommand=vsb.set)
        
        # Mock double-click event to publish the selected item's filename
        def on_double_click(event):
            item_id = presets_tree.identify_row(event.y)
            if item_id:
                filename = presets_tree.item(item_id, 'values')[0]
                self._publish_value("double_click", filename)
        presets_tree.bind("<Double-1>", on_double_click)

        file_ops_button_frame = ttk.Frame(self)
        file_ops_button_frame.grid(row=4, column=0, columnspan=2, pady=10, padx=10, sticky="ew")
        file_ops_button_frame.grid_columnconfigure(0, weight=1)
        file_ops_button_frame.grid_columnconfigure(1, weight=1)

        import_button = ttk.Button(file_ops_button_frame, text="Import Presets", command=lambda: self._publish_value("import_presets", "clicked"))
        import_button.grid(row=0, column=0, padx=5, pady=5, sticky="ew")

        export_button = ttk.Button(file_ops_button_frame, text="Export Presets", command=lambda: self._publish_value("export_presets", "clicked"))
        export_button.grid(row=0, column=1, padx=5, pady=5, sticky="ew")

#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_3_presets\sub_tab_3_collector\gui_child_3_collector.py
#####################################
# tabs/Presets/tab_presets_child_device.py
#
# This file defines the DevicePresetsTab, a Tkinter Frame that provides
# functionality for managing instrument-defined presets. This refactored version
# is a mock for testing, using a shared MQTT utility for communication.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250823.133400.1

import tkinter as tk
from tkinter import ttk, filedialog, simpledialog
import inspect
import os
import json
import paho.mqtt.client as mqtt
import threading
from collections import defaultdict
from datetime import datetime

# --- Module Imports ---
# We are intentionally removing the following imports for this test version:
# from display.debug_logic import debug_log
# from display.console_logic import console_log
# from src.program_style import COLOR_PALETTE
# from Presets.utils_preset_csv_process import load_user_presets_from_csv, overwrite_user_presets_csv
# from Presets.utils_preset_query_and_load import query_device_presets_logic, load_selected_preset_logic
# from Instrument.connection.instrument_logic import query_current_settings_logic

# --- Mocking core dependencies for this standalone test file ---
from display.styling.style import THEMES, DEFAULT_THEME
from workers.mqtt_controller_util import MqttControllerUtility

from datasets.logging import console_log, debug_log
current_version = "GEMINI SUCKS"

# Mocked resources for the UI
MOCK_DEVICE_PRESETS = ["PRESET1.STA", "PRESET2.STA", "PRESET3.STA"]


class DevicePresetsTab(ttk.Frame):
    def __init__(self, parent, mqtt_util=None, *args, **kwargs):
        super().__init__(parent, *args, **kwargs)
        self.pack(fill="both", expand=True)
        self.mqtt_util = mqtt_util
        self._message_counter = 0

        self.last_clicked_button = None
        self.cached_user_presets = {}
        self.device_preset_listbox = None
        self.device_preset_listbox_label = None
        self.query_device_presets_button = None
        self.load_device_preset_button = None
        self.save_current_button = None
        self.filename_entry = None
        self.nickname_entry = None

        self.mqtt_status_var = tk.StringVar(self, value="Last MQTT Payload: N/A")
        
        self.create_widgets()
        self.setup_layout()

        if self.mqtt_util:
            self.mqtt_util.add_subscriber(topic_filter="conductor/test/#", callback_func=self._on_message)

    def create_widgets(self):
        self._apply_styles(theme_name=DEFAULT_THEME)

        self.device_presets_frame = ttk.LabelFrame(self, text="Device Presets", style='Dark.TLabelframe')
        self.device_presets_frame.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")

        self.query_device_presets_button = ttk.Button(self.device_presets_frame,
                                                    text="Query Device Presets",
                                                    command=lambda: self._publish_test_message(button_id="query"),
                                                    style='Blue.TButton')
        self.query_device_presets_button.grid(row=0, column=0, padx=5, pady=5, sticky="ew")

        self.device_preset_listbox_label = ttk.Label(self.device_presets_frame, text="Available Device Presets:")
        self.device_preset_listbox_label.grid(row=1, column=0, padx=5, pady=2, sticky="w")

        self.device_preset_listbox_frame = ttk.Frame(self.device_presets_frame, style='TFrame')
        self.device_preset_listbox_frame.grid(row=2, column=0, padx=5, pady=5, sticky="nsew")

        self.device_preset_listbox = tk.Listbox(self.device_preset_listbox_frame, height=10, width=50,
                                                selectmode=tk.SINGLE, exportselection=False)
        self.device_preset_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        self.device_preset_listbox.insert(tk.END, *MOCK_DEVICE_PRESETS)
        self.device_preset_listbox.bind("<<ListboxSelect>>", lambda e: self._publish_test_message(e, button_id="listbox_select"))


        self.device_preset_scrollbar = ttk.Scrollbar(self.device_preset_listbox_frame, orient="vertical", command=self.device_preset_listbox.yview)
        self.device_preset_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.device_preset_listbox.config(yscrollcommand=self.device_preset_scrollbar.set)

        self.load_device_preset_button = ttk.Button(self.device_presets_frame,
                                                    text="Load Selected Device Preset",
                                                    command=lambda: self._publish_test_message(button_id="load"),
                                                    style='Blue.TButton')
        self.load_device_preset_button.grid(row=3, column=0, padx=5, pady=5, sticky="ew")

        self.save_current_frame = ttk.LabelFrame(self, text="Save Current Instrument Settings as User Preset", style='Dark.TLabelframe')
        self.save_current_frame.grid(row=4, column=0, padx=10, pady=10, sticky="ew")

        self.filename_label = ttk.Label(self.save_current_frame, text="Filename (e.g., MY_PRESET.STA):")
        self.filename_label.grid(row=0, column=0, padx=5, pady=2, sticky="w")
        self.filename_entry = ttk.Entry(self.save_current_frame, style='TEntry')
        self.filename_entry.grid(row=0, column=1, padx=5, pady=2, sticky="ew")

        self.nickname_label = ttk.Label(self.save_current_frame, text="Nickname (optional):")
        self.nickname_label.grid(row=1, column=0, padx=5, pady=2, sticky="w")
        self.nickname_entry = ttk.Entry(self.save_current_frame, style='TEntry')
        self.nickname_entry.grid(row=1, column=1, padx=5, pady=2, sticky="ew")

        self.save_current_button = ttk.Button(self.save_current_frame,
                                            text="Save Current Settings to PRESETS.CSV",
                                            command=lambda: self._publish_test_message(button_id="save"),
                                            style='Blue.TButton')
        self.save_current_button.grid(row=2, column=0, columnspan=2, padx=5, pady=5, sticky="ew")
        
        # NEW: MQTT Status Label
        mqtt_status_frame = ttk.Frame(self)
        mqtt_status_frame.grid(row=5, column=0, padx=10, pady=5, sticky="ew")
        mqtt_status_frame.grid_columnconfigure(0, weight=1)
        ttk.Label(mqtt_status_frame, textvariable=self.mqtt_status_var, anchor="center").grid(row=0, column=0, sticky="ew")

        self._button_status = defaultdict(lambda: None)
        self._button_status["query"] = self.query_device_presets_button
        self._button_status["load"] = self.load_device_preset_button
        self._button_status["save"] = self.save_current_button
        self._button_status["listbox_select"] = self.device_preset_listbox

    def setup_layout(self):
        self.grid_rowconfigure(0, weight=1)
        self.grid_columnconfigure(0, weight=1)
        self.device_presets_frame.grid_columnconfigure(0, weight=1)
        self.device_preset_listbox_frame.grid_columnconfigure(0, weight=1)
        self.save_current_frame.grid_columnconfigure(1, weight=1)

    def _apply_styles(self, theme_name: str):
        """Applies a theme based on the central style definition."""
        colors = THEMES.get(theme_name)
        style = ttk.Style(self)
        style.theme_use("clam")
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TButton', background=colors["accent"], foreground=colors["text"])
        style.map('Orange.TButton',
                  background=[('!active', 'orange'), ('active', 'orange')])
        style.map('Blue.TButton',
                  background=[('!active', colors['accent']), ('active', colors['secondary'])])
        style.map('TButton',
                  background=[('active', colors['secondary'])])
        style.map('Red.TButton',
                  background=[('!active', 'red'), ('active', 'darkred')])
        style.map('Green.TButton',
                  background=[('!active', 'green'), ('active', 'darkgreen')])
        style.configure('Dark.TLabelframe', background=colors["bg"], foreground=colors["fg"])
        style.configure('Dark.TLabel.Value', background=colors["bg"], foreground=colors["fg"])

    def _on_message(self, topic, payload):
        """The callback for when a PUBLISH message is received from the server."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering {current_function} with arguments: topic: {topic}, payload: {payload}",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function,
                  console_print_func=console_log)
        try:
            payload_data = json.loads(payload)
            value = payload_data.get("value")
            subtopic = topic.split('/')[-1]
            self.mqtt_status_var.set(f"Last MQTT Payload: {value}")
            button_id = subtopic.split('_')[-1]
            
            console_log("✅ Received message and updated result label.")
        except json.JSONDecodeError:
            console_log("❌ Failed to decode message payload as JSON.")

    def _publish_test_message(self, event=None, button_id=""):
        """Publishes an incrementing test message to the MQTT broker."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering {current_function} with argument: button_id: {button_id}",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function,
                  console_print_func=console_log)
        
        self._message_counter += 1
        topic = "conductor/test"
        payload = json.dumps({"value": self._message_counter})
        
        try:
            self.mqtt_util.publish_message(topic=topic, subtopic=f"test_presets_device_{button_id}", value=payload)
            console_log(f"✅ Published message to '{topic}/test_presets_device_{button_id}': {payload}")
        except Exception as e:
            console_log(f"❌ Failed to publish message: {e}")

# Standalone block for testing purposes.
if __name__ == "__main__":
    root = tk.Tk()
    root.title("Device Presets Tab Test")
    
    class MockMqttUtil:
        def __init__(self):
            self.subscribers = defaultdict(list)
            self._message_id = 0

        def add_subscriber(self, topic_filter, callback_func):
            self.subscribers[topic_filter].append(callback_func)
            print(f"Mocking add_subscriber: {topic_filter}")

        def publish_message(self, topic, subtopic, value):
            full_topic = f"{topic}/{subtopic}" if subtopic else topic
            print(f"Mocking publish_message: {full_topic} -> {value}")
            self._message_id += 1
            for topic_filter, callbacks in self.subscribers.items():
                if paho.mqtt.client.topic_matches_sub(topic_filter, full_topic):
                    for callback in callbacks:
                        callback(full_topic, value)
    
    mqtt_utility = MockMqttUtil()
    app_frame = DevicePresetsTab(parent=root, mqtt_util=mqtt_utility)
    root.mainloop()



#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_4_intermod\sub_tab_1_calculator\gui_child_1_calculator.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version corrects the styling of tables and entry widgets for a more cohesive look.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250823.001500.20

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from datasets.logging import debug_log, console_log
from workers.mqtt_controller_util import MqttControllerUtility
from display.styling.style import THEMES, DEFAULT_THEME

# --- Global Scope Variables ---
CURRENT_DATE = 20250823
CURRENT_TIME = 1500
CURRENT_TIME_HASH = 1500
REVISION_NUMBER = 20
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class is now designed as a self-contained "island" that manages its own MQTT state.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # We apply the style at the top of the __init__ to affect all child widgets.
            self._apply_styles(theme_name=DEFAULT_THEME)

            # Create a label for the frame
            frame_label = ttk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = ttk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame, style="Custom.TEntry")
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = ttk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)

            # We now register our callback with the central utility instead of overwriting the client's callback.
            parent_folder = str(pathlib.Path(self.current_file).parent)
            subscription_topic = f"{parent_folder.replace('\\', '/')}/#"
            self.mqtt_util.add_subscriber(topic_filter=subscription_topic, callback_func=self._on_mqtt_message)


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings", style="Custom.Treeview")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            # New frame for log buttons, placed at the bottom below the table.
            log_button_frame = ttk.Frame(self)
            log_button_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=5)

            # Button 1: Log
            self.log_button = ttk.Button(
                log_button_frame, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = ttk.Button(
                log_button_frame, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        # General widget styling
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])

        # Table (Treeview) styling
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

        # Entry (textbox) styling
        style.configure('Custom.TEntry',
                        fieldbackground=colors["entry_bg"],
                        foreground=colors["entry_fg"],
                        bordercolor=colors["table_border"])
        
    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            message_content = json.loads(payload)["value"]
            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_4_intermod\sub_tab_2_future\gui_1_top.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version corrects the styling of tables and entry widgets for a more cohesive look.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250823.001500.20

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from datasets.logging import debug_log, console_log
from workers.mqtt_controller_util import MqttControllerUtility
from display.styling.style import THEMES, DEFAULT_THEME

# --- Global Scope Variables ---
CURRENT_DATE = 20250823
CURRENT_TIME = 1500
CURRENT_TIME_HASH = 1500
REVISION_NUMBER = 20
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class is now designed as a self-contained "island" that manages its own MQTT state.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # We apply the style at the top of the __init__ to affect all child widgets.
            self._apply_styles(theme_name=DEFAULT_THEME)

            # Create a label for the frame
            frame_label = ttk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = ttk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame, style="Custom.TEntry")
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = ttk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)

            # We now register our callback with the central utility instead of overwriting the client's callback.
            parent_folder = str(pathlib.Path(self.current_file).parent)
            subscription_topic = f"{parent_folder.replace('\\', '/')}/#"
            self.mqtt_util.add_subscriber(topic_filter=subscription_topic, callback_func=self._on_mqtt_message)


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings", style="Custom.Treeview")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            # New frame for log buttons, placed at the bottom below the table.
            log_button_frame = ttk.Frame(self)
            log_button_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=5)

            # Button 1: Log
            self.log_button = ttk.Button(
                log_button_frame, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = ttk.Button(
                log_button_frame, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        # General widget styling
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])

        # Table (Treeview) styling
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

        # Entry (textbox) styling
        style.configure('Custom.TEntry',
                        fieldbackground=colors["entry_bg"],
                        foreground=colors["entry_fg"],
                        bordercolor=colors["table_border"])
        
    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            message_content = json.loads(payload)["value"]
            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_4_intermod\sub_tab_2_future\gui_2_bottom copy.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version corrects the styling of tables and entry widgets for a more cohesive look.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250823.001500.20

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from datasets.logging import debug_log, console_log
from workers.mqtt_controller_util import MqttControllerUtility
from display.styling.style import THEMES, DEFAULT_THEME

# --- Global Scope Variables ---
CURRENT_DATE = 20250823
CURRENT_TIME = 1500
CURRENT_TIME_HASH = 1500
REVISION_NUMBER = 20
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class is now designed as a self-contained "island" that manages its own MQTT state.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # We apply the style at the top of the __init__ to affect all child widgets.
            self._apply_styles(theme_name=DEFAULT_THEME)

            # Create a label for the frame
            frame_label = ttk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = ttk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame, style="Custom.TEntry")
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = ttk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)

            # We now register our callback with the central utility instead of overwriting the client's callback.
            parent_folder = str(pathlib.Path(self.current_file).parent)
            subscription_topic = f"{parent_folder.replace('\\', '/')}/#"
            self.mqtt_util.add_subscriber(topic_filter=subscription_topic, callback_func=self._on_mqtt_message)


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings", style="Custom.Treeview")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            # New frame for log buttons, placed at the bottom below the table.
            log_button_frame = ttk.Frame(self)
            log_button_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=5)

            # Button 1: Log
            self.log_button = ttk.Button(
                log_button_frame, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = ttk.Button(
                log_button_frame, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        # General widget styling
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])

        # Table (Treeview) styling
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

        # Entry (textbox) styling
        style.configure('Custom.TEntry',
                        fieldbackground=colors["entry_bg"],
                        foreground=colors["entry_fg"],
                        bordercolor=colors["table_border"])
        
    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            message_content = json.loads(payload)["value"]
            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_4_intermod\sub_tab_2_future\gui_44_last.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version corrects the styling of tables and entry widgets for a more cohesive look.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250823.001500.20

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from datasets.logging import debug_log, console_log
from workers.mqtt_controller_util import MqttControllerUtility
from display.styling.style import THEMES, DEFAULT_THEME

# --- Global Scope Variables ---
CURRENT_DATE = 20250823
CURRENT_TIME = 1500
CURRENT_TIME_HASH = 1500
REVISION_NUMBER = 20
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class is now designed as a self-contained "island" that manages its own MQTT state.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # We apply the style at the top of the __init__ to affect all child widgets.
            self._apply_styles(theme_name=DEFAULT_THEME)

            # Create a label for the frame
            frame_label = ttk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = ttk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame, style="Custom.TEntry")
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = ttk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)

            # We now register our callback with the central utility instead of overwriting the client's callback.
            parent_folder = str(pathlib.Path(self.current_file).parent)
            subscription_topic = f"{parent_folder.replace('\\', '/')}/#"
            self.mqtt_util.add_subscriber(topic_filter=subscription_topic, callback_func=self._on_mqtt_message)


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings", style="Custom.Treeview")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            # New frame for log buttons, placed at the bottom below the table.
            log_button_frame = ttk.Frame(self)
            log_button_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=5)

            # Button 1: Log
            self.log_button = ttk.Button(
                log_button_frame, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = ttk.Button(
                log_button_frame, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        # General widget styling
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])

        # Table (Treeview) styling
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

        # Entry (textbox) styling
        style.configure('Custom.TEntry',
                        fieldbackground=colors["entry_bg"],
                        foreground=colors["entry_fg"],
                        bordercolor=colors["table_border"])
        
    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            message_content = json.loads(payload)["value"]
            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_5_sweeping\gui_child_1_single.py
#####################################
# tabs/Plotting/tab_plotting_child_3D.py
#
# Stripped-down GUI for generating 3D plots, with all interactions
# connected to MQTT publishing.
#
# Author: Anthony Peter Kuzub
#
# Version 20250824.180000.1

import tkinter as tk
from tkinter import ttk
import pathlib
import os

from datasets.logging import console_log
from display.styling.style import THEMES, DEFAULT_THEME
from workers.mqtt_controller_util import MqttControllerUtility

class Plotting3DTab(ttk.Frame):
    def __init__(self, master, mqtt_util, **kwargs):
        super().__init__(master, **kwargs)
        self.pack(fill=tk.BOTH, expand=True)

        self.mqtt_util = mqtt_util
        self.current_topic_prefix = self._get_topic_prefix()

        self._apply_styles(theme_name=DEFAULT_THEME)
        self._create_widgets()

    def _get_topic_prefix(self):
        relative_path = pathlib.Path(__file__).resolve().relative_to(pathlib.Path(__file__).resolve().parent.parent.parent)
        topic = str(relative_path).replace(os.sep, '/')
        return os.path.splitext(topic)[0]

    def _apply_styles(self, theme_name: str):
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TButton', background=colors["secondary"], foreground=colors["fg"])
        style.configure('TCombobox', fieldbackground=colors["entry_bg"], foreground=colors["entry_fg"])
        style.configure('TCheckbutton', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelFrame.Label', background=colors["bg"], foreground=colors["fg"])

    def _create_widgets(self):
        self.grid_columnconfigure(0, weight=1)

        self.plot_3d_frame = ttk.LabelFrame(self, text="3D Scans Over Time Plotting", padding="10")
        self.plot_3d_frame.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")

        self.open_folder_3d_button = ttk.Button(self.plot_3d_frame, text="Open Folder for 3D Plotting", command=lambda: self._publish_value("open_folder_for_3d_plotting", "clicked"))
        self.open_folder_3d_button.grid(row=0, column=0, columnspan=2, padx=5, pady=5, sticky="ew")

        self.discovered_series_3d_frame = ttk.LabelFrame(self.plot_3d_frame, text="Discovered Series of Scans (for 3D)", padding="10")
        self.discovered_series_3d_frame.grid(row=1, column=0, columnspan=2, padx=5, pady=5, sticky="nsew")
        self.dynamic_3d_buttons_frame = ttk.Frame(self.discovered_series_3d_frame)
        self.dynamic_3d_buttons_frame.pack(fill="both", expand=True)

        ttk.Button(self.dynamic_3d_buttons_frame, text="Group 'Mock_Group_A' (5 files)", command=lambda: self._publish_value("group_select", "Mock_Group_A")).grid(row=0, column=0, padx=5, pady=2, sticky="ew")
        ttk.Button(self.dynamic_3d_buttons_frame, text="Group 'Mock_Group_B' (3 files)", command=lambda: self._publish_value("group_select", "Mock_Group_B")).grid(row=1, column=0, padx=5, pady=2, sticky="ew")

        amplitude_threshold_frame = ttk.Frame(self.plot_3d_frame)
        amplitude_threshold_frame.grid(row=2, column=0, columnspan=2, padx=5, pady=5, sticky="ew")
        amplitude_threshold_frame.grid_columnconfigure(1, weight=1)

        ttk.Label(amplitude_threshold_frame, text="Amplitude Threshold (dBm):").grid(row=0, column=0, padx=5, pady=2, sticky="w")
        amplitude_threshold_var = tk.DoubleVar(self, value=-80.0)
        amplitude_threshold_entry = ttk.Entry(amplitude_threshold_frame, textvariable=amplitude_threshold_var)
        amplitude_threshold_entry.grid(row=0, column=1, padx=5, pady=2, sticky="ew")
        amplitude_threshold_entry.bind("<KeyRelease>", lambda e: self._publish_value("amplitude_threshold", amplitude_threshold_var.get()))

        self.generate_plot_scans_over_time_button = ttk.Button(self.plot_3d_frame, text="Generate 3D Plot of Scans Over Time", command=lambda: self._publish_value("generate_3d_plot", "clicked"))
        self.generate_plot_scans_over_time_button.grid(row=3, column=0, columnspan=2, padx=5, pady=5, sticky="ew")
        self.generate_plot_scans_over_time_button.config(state=tk.DISABLED)

    def _publish_value(self, element_name, value):
        if self.mqtt_util:
            self.mqtt_util.publish_message(
                topic=self.current_topic_prefix,
                subtopic=element_name,
                value=value
            )

#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_5_sweeping\sub_tab_0_bands\gui_bands.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version corrects the styling of tables and entry widgets for a more cohesive look.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250823.001500.20

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from datasets.logging import debug_log, console_log
from workers.mqtt_controller_util import MqttControllerUtility
from display.styling.style import THEMES, DEFAULT_THEME

# --- Global Scope Variables ---
CURRENT_DATE = 20250823
CURRENT_TIME = 1500
CURRENT_TIME_HASH = 1500
REVISION_NUMBER = 20
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class is now designed as a self-contained "island" that manages its own MQTT state.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # We apply the style at the top of the __init__ to affect all child widgets.
            self._apply_styles(theme_name=DEFAULT_THEME)

            # Create a label for the frame
            frame_label = ttk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = ttk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame, style="Custom.TEntry")
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = ttk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)

            # We now register our callback with the central utility instead of overwriting the client's callback.
            parent_folder = str(pathlib.Path(self.current_file).parent)
            subscription_topic = f"{parent_folder.replace('\\', '/')}/#"
            self.mqtt_util.add_subscriber(topic_filter=subscription_topic, callback_func=self._on_mqtt_message)


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings", style="Custom.Treeview")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            # New frame for log buttons, placed at the bottom below the table.
            log_button_frame = ttk.Frame(self)
            log_button_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=5)

            # Button 1: Log
            self.log_button = ttk.Button(
                log_button_frame, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = ttk.Button(
                log_button_frame, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        # General widget styling
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])

        # Table (Treeview) styling
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

        # Entry (textbox) styling
        style.configure('Custom.TEntry',
                        fieldbackground=colors["entry_bg"],
                        foreground=colors["entry_fg"],
                        bordercolor=colors["table_border"])
        
    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            message_content = json.loads(payload)["value"]
            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_5_sweeping\sub_tab_0_configuration\gui_configureation.py
#####################################
# tabs/Scanning/tab_scanning_child_scan_configuration.py
#
# Stripped-down GUI for scan configuration, with all interactions
# connected to MQTT publishing.
#
# Author: Anthony Peter Kuzub
#
# Version 20250824.160000.1

import tkinter as tk
from tkinter import ttk
import pathlib
import os

from display.base_gui_component_rebuilt import BaseGUIFrame
from workers.mqtt_controller_util import MqttControllerUtility
from datasets.logging import console_log

class ScanTab(BaseGUIFrame):
    """
    A Tkinter Frame with GUI elements for configuring a scan.
    All controls publish to MQTT via the BaseGUIFrame's utility.
    """
    def __init__(self, master, mqtt_util, **kwargs):
        super().__init__(master, mqtt_util, console_log, **kwargs)
        self.pack(fill=tk.BOTH, expand=True)
        self._create_widgets()

    def _create_widgets(self):
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(2, weight=1)
        
        # --- Output Settings ---
        output_frame = ttk.LabelFrame(self, text="Output Settings")
        output_frame.grid(row=0, column=0, padx=10, pady=10, sticky="ew")
        output_frame.grid_columnconfigure(1, weight=1)

        ttk.Label(output_frame, text="Scan Name:").grid(row=0, column=0, padx=5, pady=2, sticky="w")
        scan_name_var = tk.StringVar(self)
        scan_name_entry = ttk.Entry(output_frame, textvariable=scan_name_var)
        scan_name_entry.grid(row=0, column=1, padx=5, pady=2, sticky="ew")
        scan_name_entry.bind("<KeyRelease>", lambda e: self._publish_value("scan_name", scan_name_var.get()))

        ttk.Label(output_frame, text="Output Folder:").grid(row=1, column=0, padx=5, pady=2, sticky="w")
        output_folder_var = tk.StringVar(self)
        ttk.Entry(output_frame, textvariable=output_folder_var, state="readonly").grid(row=1, column=1, padx=5, pady=2, sticky="ew")
        ttk.Button(output_frame, text="Browse", command=lambda: self._publish_value("browse_folder_button", "clicked")).grid(row=1, column=2, padx=5, pady=2)
        ttk.Button(output_frame, text="Open Output Folder", command=lambda: self._publish_value("open_folder_button", "clicked")).grid(row=2, column=0, columnspan=3, padx=5, pady=5, sticky="ew")

        # --- Scan Settings ---
        settings_frame = ttk.LabelFrame(self, text="Scan Settings")
        settings_frame.grid(row=1, column=0, padx=10, pady=10, sticky="ew")
        settings_frame.grid_columnconfigure(2, weight=1)

        row_idx = 0
        self._create_setting_row(settings_frame, row_idx, "graph_quality", "Graph Quality:", ["High", "Medium", "Low"], "graph_quality_combobox"); row_idx += 1
        self._create_setting_row(settings_frame, row_idx, "dwell_time", "DWELL (s):", ["0.1", "0.5", "1.0", "Custom"], "dwell_time_combobox"); row_idx += 1
        self._create_setting_row(settings_frame, row_idx, "max_hold_time", "Max Hold Time (s):", ["1", "5", "10", "Infinite"], "max_hold_time_combobox"); row_idx += 1
        self._create_setting_row(settings_frame, row_idx, "scan_rbw", "Scan RBW (Hz):", ["100", "300", "1k", "10k"], "scan_rbw_combobox"); row_idx += 1
        self._create_setting_row(settings_frame, row_idx, "reference_level", "Reference Level (dBm):", ["-10", "0", "10", "20"], "reference_level_combobox"); row_idx += 1
        self._create_setting_row(settings_frame, row_idx, "frequency_shift", "Frequency Shift (Hz):", ["0", "10k", "100k"], "frequency_shift_combobox"); row_idx += 1
        self._create_setting_row(settings_frame, row_idx, "num_scan_cycles", "Number of Scan Cycles:", ["1", "5", "10", "Infinite"], "num_scan_cycles_combobox"); row_idx += 1
        
        # Boolean settings
        ttk.Label(settings_frame, text="High Sensitivity:").grid(row=row_idx, column=0, padx=5, pady=2, sticky="w");
        hs_combo_var = tk.StringVar(self)
        hs_combo = ttk.Combobox(settings_frame, values=["Yes", "No"], state="readonly", textvariable=hs_combo_var)
        hs_combo.grid(row=row_idx, column=1, padx=5, pady=2, sticky="w")
        hs_combo.bind("<<ComboboxSelected>>", lambda e: self._publish_value("high_sensitivity", hs_combo_var.get() == "Yes")); row_idx += 1
        
        ttk.Label(settings_frame, text="Preamplifier ON:").grid(row=row_idx, column=0, padx=5, pady=2, sticky="w");
        pa_combo_var = tk.StringVar(self)
        pa_combo = ttk.Combobox(settings_frame, values=["Yes", "No"], state="readonly", textvariable=pa_combo_var)
        pa_combo.grid(row=row_idx, column=1, padx=5, pady=2, sticky="w")
        pa_combo.bind("<<ComboboxSelected>>", lambda e: self._publish_value("preamplifier_on", pa_combo_var.get() == "Yes")); row_idx += 1
        
        ttk.Label(settings_frame, text="Scan RBW Segmentation (Hz):").grid(row=row_idx, column=0, padx=5, pady=2, sticky="w")
        scan_rbw_segmentation_var = tk.StringVar(self)
        scan_rbw_segmentation_entry = ttk.Entry(settings_frame, textvariable=scan_rbw_segmentation_var)
        scan_rbw_segmentation_entry.grid(row=row_idx, column=1, sticky="ew", columnspan=2, padx=5, pady=2)
        scan_rbw_segmentation_entry.bind("<KeyRelease>", lambda e: self._publish_value("scan_rbw_segmentation", scan_rbw_segmentation_var.get()))
        row_idx += 1
        
        ttk.Label(settings_frame, text="Default Focus Width (Hz):").grid(row=row_idx, column=0, padx=5, pady=2, sticky="w")
        default_focus_width_var = tk.StringVar(self)
        default_focus_width_entry = ttk.Entry(settings_frame, textvariable=default_focus_width_var)
        default_focus_width_entry.grid(row=row_idx, column=1, sticky="ew", columnspan=2, padx=5, pady=2)
        default_focus_width_entry.bind("<KeyRelease>", lambda e: self._publish_value("default_focus_width", default_focus_width_var.get()))
        row_idx += 1

    def _create_setting_row(self, parent, row, key, label_text, data_list, mqtt_topic_suffix):
        ttk.Label(parent, text=label_text).grid(row=row, column=0, padx=5, pady=2, sticky="w")
        combo_var = tk.StringVar(self)
        combo = ttk.Combobox(parent, values=data_list, state="readonly", textvariable=combo_var)
        combo.grid(row=row, column=1, padx=5, pady=2, sticky="w")
        ttk.Label(parent, text="").grid(row=row, column=2, padx=5, pady=2, sticky="w")
        combo.bind("<<ComboboxSelected>>", lambda e: self._publish_value(mqtt_topic_suffix, combo_var.get()))

#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_5_sweeping\sub_tab_1_single\gui_child_1_single.py
#####################################
# tabs/Plotting/tab_plotting_child_Single.py
#
# Stripped-down GUI for plotting single scans, with all interactions
# connected to MQTT publishing.
#
# Author: Anthony Peter Kuzub
#
# Version 20250824.180000.1

import tkinter as tk
from tkinter import ttk
import pathlib
import os

from datasets.logging import console_log
from display.styling.style import THEMES, DEFAULT_THEME
from workers.mqtt_controller_util import MqttControllerUtility

class PlottingTab(ttk.Frame):
    def __init__(self, master, mqtt_util, **kwargs):
        super().__init__(master, **kwargs)
        self.pack(fill=tk.BOTH, expand=True)

        self.mqtt_util = mqtt_util
        self.current_topic_prefix = self._get_topic_prefix()

        self.open_html_after_complete_var = tk.BooleanVar(self, value=False)
        self.create_html_report_var = tk.BooleanVar(self, value=True)
        self.include_tv_markers_var = tk.BooleanVar(self, value=False)
        self.include_gov_markers_var = tk.BooleanVar(self, value=False)
        self.include_markers_var = tk.BooleanVar(self, value=False)
        self.include_scan_intermod_markers_var = tk.BooleanVar(self, value=False)

        self._apply_styles(theme_name=DEFAULT_THEME)
        self._create_widgets()

    def _get_topic_prefix(self):
        relative_path = pathlib.Path(__file__).resolve().relative_to(pathlib.Path(__file__).resolve().parent.parent.parent)
        topic = str(relative_path).replace(os.sep, '/')
        return os.path.splitext(topic)[0]

    def _apply_styles(self, theme_name: str):
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TButton', background=colors["secondary"], foreground=colors["fg"])
        style.configure('TCombobox', fieldbackground=colors["entry_bg"], foreground=colors["entry_fg"])
        style.configure('TCheckbutton', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelFrame.Label', background=colors["bg"], foreground=colors["fg"])

    def _create_widgets(self):
        self.grid_columnconfigure(0, weight=1)

        plotting_options_frame = ttk.LabelFrame(self, text="SCAN Plotting Options", padding="10")
        plotting_options_frame.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")

        scan_options_inner_frame = ttk.Frame(plotting_options_frame)
        scan_options_inner_frame.grid(row=0, column=0, padx=5, pady=5, sticky="nsew", columnspan=2)
        scan_options_inner_frame.grid_columnconfigure(0, weight=1)
        scan_options_inner_frame.grid_columnconfigure(1, weight=1)

        html_output_options_frame = ttk.LabelFrame(scan_options_inner_frame, text="HTML Output Options", padding="10")
        html_output_options_frame.grid(row=0, column=0, padx=5, pady=5, sticky="nsew")
        html_output_options_frame.grid_columnconfigure(0, weight=1)

        ttk.Checkbutton(html_output_options_frame, text="Plot the HTML after every scan", variable=self.open_html_after_complete_var, command=lambda: self._publish_value("open_html_after_complete", self.open_html_after_complete_var.get())).grid(row=0, column=0, padx=5, pady=2, sticky="w")
        ttk.Checkbutton(html_output_options_frame, text="Create HTML", variable=self.create_html_report_var, command=lambda: self._publish_value("create_html_report", self.create_html_report_var.get())).grid(row=1, column=0, padx=5, pady=2, sticky="w")

        scan_markers_to_plot_frame = ttk.LabelFrame(scan_options_inner_frame, text="Scan Markers to Plot", padding="10")
        scan_markers_to_plot_frame.grid(row=0, column=1, padx=5, pady=5, sticky="nsew")
        scan_markers_to_plot_frame.grid_columnconfigure(0, weight=1)
        
        ttk.Checkbutton(scan_markers_to_plot_frame, text="Include TV Band Markers", variable=self.include_tv_markers_var, command=lambda: self._publish_value("include_tv_markers", self.include_tv_markers_var.get())).grid(row=0, column=0, padx=5, pady=2, sticky="w")
        ttk.Checkbutton(scan_markers_to_plot_frame, text="Include Government Band Markers", variable=self.include_gov_markers_var, command=lambda: self._publish_value("include_gov_markers", self.include_gov_markers_var.get())).grid(row=1, column=0, padx=5, pady=2, sticky="w")
        ttk.Checkbutton(scan_markers_to_plot_frame, text="Include Markers", variable=self.include_markers_var, command=lambda: self._publish_value("include_markers", self.include_markers_var.get())).grid(row=2, column=0, padx=5, pady=2, sticky="w")
        ttk.Checkbutton(scan_markers_to_plot_frame, text="Include Intermodulations", variable=self.include_scan_intermod_markers_var, command=lambda: self._publish_value("include_scan_intermod_markers", self.include_scan_intermod_markers_var.get())).grid(row=3, column=0, padx=5, pady=2, sticky="w")

        self.plot_button = ttk.Button(plotting_options_frame, text="Plot Single Scan", command=lambda: self._publish_value("plot_single_scan", "clicked"))
        self.plot_button.grid(row=1, column=0, padx=5, pady=5, sticky="ew")

        self.plot_average_button = ttk.Button(plotting_options_frame, text="Plot Current Cycle Average (All Traces)", command=lambda: self._publish_value("plot_current_cycle_average", "clicked"))
        self.plot_average_button.grid(row=2, column=0, padx=5, pady=5, sticky="ew")
        self.plot_average_button.config(state=tk.DISABLED)

        self.open_last_plot_button = ttk.Button(plotting_options_frame, text="Open Last Plot", command=lambda: self._publish_value("open_last_plot", "clicked"))
        self.open_last_plot_button.grid(row=3, column=0, padx=5, pady=5, sticky="ew")
        
    def _publish_value(self, element_name, value):
        if self.mqtt_util:
            self.mqtt_util.publish_message(
                topic=self.current_topic_prefix,
                subtopic=element_name,
                value=value
            )

#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_5_sweeping\sub_tab_2_meta_data\gui_metadata.py
#####################################
# tabs/Scanning/tab_scanning_child_bands.py
#
# Stripped-down GUI for selecting frequency bands, with all interactions
# connected to MQTT publishing.
#
# Author: Anthony Peter Kuzub
#
# Version 20250824.160000.1

import tkinter as tk
from tkinter import ttk
import pathlib
import os

from display.base_gui_component_rebuilt import BaseGUIFrame
from workers.mqtt_controller_util import MqttControllerUtility
from datasets.logging import console_log

class BandsTab(BaseGUIFrame):
    """
    A Tkinter Frame with GUI elements for selecting frequency bands.
    All controls publish to MQTT via the BaseGUIFrame's utility.
    """
    def __init__(self, master, mqtt_util, **kwargs):
        super().__init__(master, mqtt_util, console_log, **kwargs)
        self.pack(fill=tk.BOTH, expand=True)
        self._create_widgets()

    def _create_widgets(self):
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(2, weight=1)
        
        band_button_frame = ttk.Frame(self)
        band_button_frame.grid(row=0, column=0, pady=5, padx=10, sticky="ew")
        band_button_frame.grid_columnconfigure(0, weight=1)
        band_button_frame.grid_columnconfigure(1, weight=1)
        
        ttk.Button(band_button_frame, text="Select All", command=lambda: self._publish_value("select_all_bands", "clicked")).grid(row=0, column=0, padx=5, sticky="ew")
        ttk.Button(band_button_frame, text="Deselect All", command=lambda: self._publish_value("deselect_all_bands", "clicked")).grid(row=0, column=1, padx=5, sticky="ew")

        bands_inner_frame = ttk.Frame(self)
        bands_inner_frame.grid(row=1, column=0, padx=10, pady=5, sticky="nsew")
        bands_inner_frame.grid_columnconfigure(0, weight=1)
        bands_inner_frame.grid_columnconfigure(1, weight=1)

        mock_bands = [
            {"name": "VHF Band", "start": 137.0, "stop": 144.0, "level": 1},
            {"name": "UHF Band", "start": 400.0, "stop": 420.0, "level": 2},
            {"name": "ISM Band", "start": 902.0, "stop": 928.0, "level": 3},
            {"name": "LTE Band", "start": 700.0, "stop": 800.0, "level": 0}
        ]
        
        for i, band in enumerate(mock_bands):
            button_text = f"{band['name']}\nStart: {band['start']:.3f} MHz\nStop: {band['stop']:.3f} MHz"
            
            # This is where the MQTT connection happens
            btn = ttk.Button(bands_inner_frame, text=button_text,
                             command=lambda b=band: self._publish_value("band_toggle", b["name"]))
            
            row, col = divmod(i, 2)
            btn.grid(row=row, column=col, sticky="ew", padx=2, pady=2)
            
        table_frame = ttk.Frame(self)
        table_frame.grid(row=2, column=0, sticky="nsew", padx=10, pady=5)
        table_frame.grid_columnconfigure(0, weight=1)
        table_frame.grid_rowconfigure(0, weight=1)
        ttk.Label(table_frame, text="This is where the table would go.").grid(row=0, column=0, sticky="nsew")
        
        chart_frame = ttk.Frame(self)
        chart_frame.grid(row=3, column=0, sticky="nsew", padx=10, pady=5)
        chart_frame.grid_columnconfigure(0, weight=1)
        chart_frame.grid_rowconfigure(0, weight=1)
        ttk.Label(chart_frame, text="This is where the chart would go.").grid(row=0, column=0, sticky="nsew")

#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_5_sweeping\sub_tab_2_statistical\gui_child_2_statistical.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version corrects the styling of tables and entry widgets for a more cohesive look.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250823.001500.20

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from datasets.logging import debug_log, console_log
from workers.mqtt_controller_util import MqttControllerUtility
from display.styling.style import THEMES, DEFAULT_THEME

# --- Global Scope Variables ---
CURRENT_DATE = 20250823
CURRENT_TIME = 1500
CURRENT_TIME_HASH = 1500
REVISION_NUMBER = 20
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class is now designed as a self-contained "island" that manages its own MQTT state.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # We apply the style at the top of the __init__ to affect all child widgets.
            self._apply_styles(theme_name=DEFAULT_THEME)

            # Create a label for the frame
            frame_label = ttk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = ttk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame, style="Custom.TEntry")
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = ttk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)

            # We now register our callback with the central utility instead of overwriting the client's callback.
            parent_folder = str(pathlib.Path(self.current_file).parent)
            subscription_topic = f"{parent_folder.replace('\\', '/')}/#"
            self.mqtt_util.add_subscriber(topic_filter=subscription_topic, callback_func=self._on_mqtt_message)


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings", style="Custom.Treeview")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            # New frame for log buttons, placed at the bottom below the table.
            log_button_frame = ttk.Frame(self)
            log_button_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=5)

            # Button 1: Log
            self.log_button = ttk.Button(
                log_button_frame, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = ttk.Button(
                log_button_frame, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        # General widget styling
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])

        # Table (Treeview) styling
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

        # Entry (textbox) styling
        style.configure('Custom.TEntry',
                        fieldbackground=colors["entry_bg"],
                        foreground=colors["entry_fg"],
                        bordercolor=colors["table_border"])
        
    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            message_content = json.loads(payload)["value"]
            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_5_sweeping\sub_tab_3_averaging\gui_averaging.py
#####################################
# tabs/Plotting/tab_plotting_child_average.py
#
# Stripped-down GUI for plotting averaged scan data, with all interactions
# connected to MQTT publishing.
#
# Author: Anthony Peter Kuzub
#
# Version 20250824.180000.1

import tkinter as tk
from tkinter import ttk
import pathlib
import os

from datasets.logging import console_log
from display.styling.style import THEMES, DEFAULT_THEME
from workers.mqtt_controller_util import MqttControllerUtility

class AveragingTab(ttk.Frame):
    def __init__(self, master, mqtt_util, **kwargs):
        super().__init__(master, **kwargs)
        self.pack(fill=tk.BOTH, expand=True)

        self.mqtt_util = mqtt_util
        self.current_topic_prefix = self._get_topic_prefix()

        self.last_opened_folder = None
        self.grouped_csv_files = {}
        self.selected_group_prefix = None

        self.math_average_var = tk.BooleanVar(self, value=False)
        self.math_median_var = tk.BooleanVar(self, value=False)
        self.math_range_var = tk.BooleanVar(self, value=False)
        self.math_standard_deviation_var = tk.BooleanVar(self, value=False)
        self.math_variance_var = tk.BooleanVar(self, value=False)
        self.math_psd_var = tk.BooleanVar(self, value=False)

        self.include_tv_markers_var = tk.BooleanVar(self, value=False)
        self.include_gov_markers_var = tk.BooleanVar(self, value=False)
        self.include_markers_var = tk.BooleanVar(self, value=False)
        self.include_scan_intermod_markers_var = tk.BooleanVar(self, value=False)

        self._apply_styles(theme_name=DEFAULT_THEME)
        self._create_widgets()
        
    def _get_topic_prefix(self):
        relative_path = pathlib.Path(__file__).resolve().relative_to(pathlib.Path(__file__).resolve().parent.parent.parent)
        topic = str(relative_path).replace(os.sep, '/')
        return os.path.splitext(topic)[0]

    def _apply_styles(self, theme_name: str):
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TButton', background=colors["secondary"], foreground=colors["fg"])
        style.configure('TCombobox', fieldbackground=colors["entry_bg"], foreground=colors["entry_fg"])
        style.configure('TCheckbutton', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelFrame.Label', background=colors["bg"], foreground=colors["fg"])
        
    def _create_widgets(self):
        self.grid_columnconfigure(0, weight=1)

        self.averaging_folder_frame = ttk.LabelFrame(self, text="Plotting Averages from Folder", padding="10")
        self.averaging_folder_frame.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")

        self.open_folder_button = ttk.Button(self.averaging_folder_frame, text="Open Folder to Average", command=lambda: self._publish_value("open_folder_to_average", "clicked"))
        self.open_folder_button.grid(row=0, column=0, columnspan=2, padx=5, pady=5, sticky="ew")

        self.discovered_series_frame = ttk.LabelFrame(self.averaging_folder_frame, text="Discovered Series of Scans", padding="10")
        self.discovered_series_frame.grid(row=1, column=0, columnspan=2, padx=5, pady=5, sticky="nsew")
        self.dynamic_avg_buttons_frame = ttk.Frame(self.discovered_series_frame)
        self.dynamic_avg_buttons_frame.pack(fill="both", expand=True)

        math_and_markers_frame = ttk.Frame(self.averaging_folder_frame)
        math_and_markers_frame.grid(row=2, column=0, columnspan=2, padx=5, pady=5, sticky="nsew")
        math_and_markers_frame.grid_columnconfigure(0, weight=1)
        math_and_markers_frame.grid_columnconfigure(1, weight=1)

        apply_math_frame = ttk.LabelFrame(math_and_markers_frame, text="Apply Math", padding="10")
        apply_math_frame.grid(row=0, column=0, padx=5, pady=5, sticky="nsew")
        apply_math_frame.grid_columnconfigure(0, weight=1)

        math_types = ["Average", "Median", "Range", "Standard Deviation", "Variance", "Power Spectral Density (PSD)"]
        vars = [self.math_average_var, self.math_median_var, self.math_range_var, self.math_standard_deviation_var, self.math_variance_var, self.math_psd_var]
        for i, text in enumerate(math_types):
            chk = ttk.Checkbutton(apply_math_frame, text=text, variable=vars[i], command=lambda t=text, v=vars[i]: self._publish_value(f"math_{t.lower().replace(' ', '_')}", v.get()))
            chk.grid(row=i, column=0, padx=5, pady=2, sticky="w")

        markers_to_plot_frame = ttk.LabelFrame(math_and_markers_frame, text="Markers to Plot", padding="10")
        markers_to_plot_frame.grid(row=0, column=1, padx=5, pady=5, sticky="nsew")
        markers_to_plot_frame.grid_columnconfigure(0, weight=1)
        
        marker_types = ["Include TV Band Markers", "Include Government Band Markers", "Include Markers", "Include Intermodulations"]
        vars = [self.include_tv_markers_var, self.include_gov_markers_var, self.include_markers_var, self.include_scan_intermod_markers_var]
        for i, text in enumerate(marker_types):
            chk = ttk.Checkbutton(markers_to_plot_frame, text=text, variable=vars[i], command=lambda t=text, v=vars[i]: self._publish_value(f"marker_{t.lower().replace(' ', '_')}", v.get()))
            chk.grid(row=i, column=0, padx=5, pady=2, sticky="w")

        make_averages_frame = ttk.LabelFrame(self.averaging_folder_frame, text="Make Averages", padding="10")
        make_averages_frame.grid(row=3, column=0, columnspan=2, padx=5, pady=5, sticky="nsew")
        make_averages_frame.grid_columnconfigure(0, weight=1)

        self.generate_csv_button = ttk.Button(make_averages_frame, text="Generate CSV of Selected Series of Scan", command=lambda: self._publish_value("generate_csv_button", "clicked"))
        self.generate_csv_button.grid(row=0, column=0, padx=5, pady=5, sticky="ew")
        self.generate_csv_button.config(state=tk.DISABLED)

        self.open_applied_math_folder_button = ttk.Button(make_averages_frame, text="Open Folder of Applied Math", command=lambda: self._publish_value("open_applied_math_folder", "clicked"))
        self.open_applied_math_folder_button.grid(row=1, column=0, padx=5, pady=5, sticky="ew")
        self.open_applied_math_folder_button.config(state=tk.DISABLED)

        self.generate_plot_averages_button = ttk.Button(make_averages_frame, text="Generate Plot of Averages", command=lambda: self._publish_value("generate_plot_averages", "clicked"))
        self.generate_plot_averages_button.grid(row=2, column=0, padx=5, pady=5, sticky="ew")
        self.generate_plot_averages_button.config(state=tk.DISABLED)

        self.generate_plot_averages_with_scan_button = ttk.Button(make_averages_frame, text="Generate Plot of Averages with Scan", command=lambda: self._publish_value("generate_plot_averages_with_scan", "clicked"))
        self.generate_plot_averages_with_scan_button.grid(row=3, column=0, padx=5, pady=5, sticky="ew")
        self.generate_plot_averages_with_scan_button.config(state=tk.DISABLED)
        
    def _publish_value(self, element_name, value):
        if self.mqtt_util:
            self.mqtt_util.publish_message(
                topic=self.current_topic_prefix,
                subtopic=element_name,
                value=value
            )

#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_6_graphing\sub_tab_1_from_file\gui_child1_from_file.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version corrects the styling of tables and entry widgets for a more cohesive look.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250823.001500.20

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from datasets.logging import debug_log, console_log
from workers.mqtt_controller_util import MqttControllerUtility
from display.styling.style import THEMES, DEFAULT_THEME

# --- Global Scope Variables ---
CURRENT_DATE = 20250823
CURRENT_TIME = 1500
CURRENT_TIME_HASH = 1500
REVISION_NUMBER = 20
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class is now designed as a self-contained "island" that manages its own MQTT state.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # We apply the style at the top of the __init__ to affect all child widgets.
            self._apply_styles(theme_name=DEFAULT_THEME)

            # Create a label for the frame
            frame_label = ttk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = ttk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame, style="Custom.TEntry")
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = ttk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)

            # We now register our callback with the central utility instead of overwriting the client's callback.
            parent_folder = str(pathlib.Path(self.current_file).parent)
            subscription_topic = f"{parent_folder.replace('\\', '/')}/#"
            self.mqtt_util.add_subscriber(topic_filter=subscription_topic, callback_func=self._on_mqtt_message)


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings", style="Custom.Treeview")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            # New frame for log buttons, placed at the bottom below the table.
            log_button_frame = ttk.Frame(self)
            log_button_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=5)

            # Button 1: Log
            self.log_button = ttk.Button(
                log_button_frame, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = ttk.Button(
                log_button_frame, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        # General widget styling
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])

        # Table (Treeview) styling
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

        # Entry (textbox) styling
        style.configure('Custom.TEntry',
                        fieldbackground=colors["entry_bg"],
                        foreground=colors["entry_fg"],
                        bordercolor=colors["table_border"])
        
    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            message_content = json.loads(payload)["value"]
            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_6_graphing\sub_tab_2_3d\gui_3d.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version corrects the styling of tables and entry widgets for a more cohesive look.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250823.001500.20

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from datasets.logging import debug_log, console_log
from workers.mqtt_controller_util import MqttControllerUtility
from display.styling.style import THEMES, DEFAULT_THEME

# --- Global Scope Variables ---
CURRENT_DATE = 20250823
CURRENT_TIME = 1500
CURRENT_TIME_HASH = 1500
REVISION_NUMBER = 20
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class is now designed as a self-contained "island" that manages its own MQTT state.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # We apply the style at the top of the __init__ to affect all child widgets.
            self._apply_styles(theme_name=DEFAULT_THEME)

            # Create a label for the frame
            frame_label = ttk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = ttk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame, style="Custom.TEntry")
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = ttk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)

            # We now register our callback with the central utility instead of overwriting the client's callback.
            parent_folder = str(pathlib.Path(self.current_file).parent)
            subscription_topic = f"{parent_folder.replace('\\', '/')}/#"
            self.mqtt_util.add_subscriber(topic_filter=subscription_topic, callback_func=self._on_mqtt_message)


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings", style="Custom.Treeview")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            # New frame for log buttons, placed at the bottom below the table.
            log_button_frame = ttk.Frame(self)
            log_button_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=5)

            # Button 1: Log
            self.log_button = ttk.Button(
                log_button_frame, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = ttk.Button(
                log_button_frame, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        # General widget styling
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])

        # Table (Treeview) styling
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

        # Entry (textbox) styling
        style.configure('Custom.TEntry',
                        fieldbackground=colors["entry_bg"],
                        foreground=colors["entry_fg"],
                        bordercolor=colors["table_border"])
        
    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            message_content = json.loads(payload)["value"]
            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_7_exepriment\sub_tab_1_mosquitto\gui_7_experiment.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version corrects the styling of tables and entry widgets for a more cohesive look.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250823.001500.20

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from datasets.logging import debug_log, console_log
from workers.mqtt_controller_util import MqttControllerUtility
from display.styling.style import THEMES, DEFAULT_THEME

# --- Global Scope Variables ---
CURRENT_DATE = 20250823
CURRENT_TIME = 1500
CURRENT_TIME_HASH = 1500
REVISION_NUMBER = 20
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class is now designed as a self-contained "island" that manages its own MQTT state.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # We apply the style at the top of the __init__ to affect all child widgets.
            self._apply_styles(theme_name=DEFAULT_THEME)

            # Create a label for the frame
            frame_label = ttk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = ttk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame, style="Custom.TEntry")
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = ttk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)

            # We now register our callback with the central utility instead of overwriting the client's callback.
            parent_folder = str(pathlib.Path(self.current_file).parent)
            subscription_topic = f"{parent_folder.replace('\\', '/')}/#"
            self.mqtt_util.add_subscriber(topic_filter=subscription_topic, callback_func=self._on_mqtt_message)


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings", style="Custom.Treeview")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            # New frame for log buttons, placed at the bottom below the table.
            log_button_frame = ttk.Frame(self)
            log_button_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=5)

            # Button 1: Log
            self.log_button = ttk.Button(
                log_button_frame, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = ttk.Button(
                log_button_frame, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        # General widget styling
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])

        # Table (Treeview) styling
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

        # Entry (textbox) styling
        style.configure('Custom.TEntry',
                        fieldbackground=colors["entry_bg"],
                        foreground=colors["entry_fg"],
                        bordercolor=colors["table_border"])
        
    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            message_content = json.loads(payload)["value"]
            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\prototype\gui_translator.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version corrects the styling of tables and entry widgets for a more cohesive look.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250823.001500.20

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from datasets.logging import debug_log, console_log
from workers.mqtt_controller_util import MqttControllerUtility
from display.styling.style import THEMES, DEFAULT_THEME

# --- Global Scope Variables ---
CURRENT_DATE = 20250823
CURRENT_TIME = 1500
CURRENT_TIME_HASH = 1500
REVISION_NUMBER = 20
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class is now designed as a self-contained "island" that manages its own MQTT state.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # We apply the style at the top of the __init__ to affect all child widgets.
            self._apply_styles(theme_name=DEFAULT_THEME)

            # Create a label for the frame
            frame_label = ttk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = ttk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame, style="Custom.TEntry")
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = ttk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)

            # We now register our callback with the central utility instead of overwriting the client's callback.
            parent_folder = str(pathlib.Path(self.current_file).parent)
            subscription_topic = f"{parent_folder.replace('\\', '/')}/#"
            self.mqtt_util.add_subscriber(topic_filter=subscription_topic, callback_func=self._on_mqtt_message)


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings", style="Custom.Treeview")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            # New frame for log buttons, placed at the bottom below the table.
            log_button_frame = ttk.Frame(self)
            log_button_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=5)

            # Button 1: Log
            self.log_button = ttk.Button(
                log_button_frame, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = ttk.Button(
                log_button_frame, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        # General widget styling
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])

        # Table (Treeview) styling
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

        # Entry (textbox) styling
        style.configure('Custom.TEntry',
                        fieldbackground=colors["entry_bg"],
                        foreground=colors["entry_fg"],
                        bordercolor=colors["table_border"])
        
    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            message_content = json.loads(payload)["value"]
            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\right_40\bottom_90\tab_1_scan\display_child_scan_view.py
#####################################
# display/display_child_scan_view.py
#
# This file defines the ScanViewTab, a Tkinter Frame for displaying a live, single-pane plot of scan data.
# It is designed to be added as a separate tab to the main display pane, focusing on a single trace.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250816.222300.1

current_version = "20250816.222300.1"
current_version_hash = 20250816 * 222300 * 1

import tkinter as tk
from tkinter import ttk
import inspect
import os
import numpy as np
import pandas as pd
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

# Import logging functions for debugging
from display.debug_logic import debug_log
from display.console_logic import console_log

# Import the new utility file
from display.utils_scan_view import update_single_plot

class ScanViewTab(ttk.Frame):
    """
    A Tkinter Frame that provides a single, large plot for viewing scan data.
    """
    def __init__(self, master=None, app_instance=None, **kwargs):
        """
        Initializes the ScanViewTab.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Initializing ScanViewTab. Preparing the single plot!",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)

        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.plot = {} # To store references to the plot canvas

        self._create_widgets()

        debug_log(f"ScanViewTab initialized. Plot is ready to go!",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)


    def _create_widgets(self):
        """
        Creates and arranges the widgets for the Scan View tab.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Creating ScanViewTab widgets.",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)

        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(0, weight=1)

        # --- Single Plot Frame ---
        plot_frame = ttk.Frame(self)
        plot_frame.grid(row=0, column=0, padx=5, pady=5, sticky="nsew")
        plot_frame.grid_columnconfigure(0, weight=1)
        plot_frame.grid_rowconfigure(0, weight=1)
        figure = Figure(figsize=(8, 6), dpi=100, facecolor='#1e1e1e')
        ax = figure.add_subplot(111, facecolor='#1e1e1e')
        ax.tick_params(axis='x', colors='white')
        ax.tick_params(axis='y', colors='white')
        ax.spines['bottom'].set_color('white')
        ax.spines['top'].set_color('white')
        ax.spines['left'].set_color('white')
        ax.spines['right'].set_color('white')
        ax.set_title("Live Trace", color='white')
        canvas = FigureCanvasTkAgg(figure, master=plot_frame)
        canvas_widget = canvas.get_tk_widget()
        canvas_widget.grid(row=0, column=0, sticky="nsew")
        self.plot = {'figure': figure, 'ax': ax, 'canvas': canvas, 'widget': canvas_widget}

        debug_log(f"ScanViewTab widgets created. The placeholder is ready!",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        # Call the new utility function to set up the plot with initial empty data
        update_single_plot(self, pd.DataFrame(columns=['Frequency_Hz', 'Power_dBm']), 0, 100, "Initial Plot View")

#####################################
### File: OPEN-AIR 2\display\right_40\bottom_90\tab_1_scan\gui_tab_1_scan.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version corrects the styling of tables and entry widgets for a more cohesive look.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250823.001500.20

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from datasets.logging import debug_log, console_log
from workers.mqtt_controller_util import MqttControllerUtility
from display.styling.style import THEMES, DEFAULT_THEME

# --- Global Scope Variables ---
CURRENT_DATE = 20250823
CURRENT_TIME = 1500
CURRENT_TIME_HASH = 1500
REVISION_NUMBER = 20
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class is now designed as a self-contained "island" that manages its own MQTT state.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # We apply the style at the top of the __init__ to affect all child widgets.
            self._apply_styles(theme_name=DEFAULT_THEME)

            # Create a label for the frame
            frame_label = ttk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = ttk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame, style="Custom.TEntry")
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = ttk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)

            # We now register our callback with the central utility instead of overwriting the client's callback.
            parent_folder = str(pathlib.Path(self.current_file).parent)
            subscription_topic = f"{parent_folder.replace('\\', '/')}/#"
            self.mqtt_util.add_subscriber(topic_filter=subscription_topic, callback_func=self._on_mqtt_message)


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings", style="Custom.Treeview")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            # New frame for log buttons, placed at the bottom below the table.
            log_button_frame = ttk.Frame(self)
            log_button_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=5)

            # Button 1: Log
            self.log_button = ttk.Button(
                log_button_frame, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = ttk.Button(
                log_button_frame, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        # General widget styling
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])

        # Table (Treeview) styling
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

        # Entry (textbox) styling
        style.configure('Custom.TEntry',
                        fieldbackground=colors["entry_bg"],
                        foreground=colors["entry_fg"],
                        bordercolor=colors["table_border"])
        
    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            message_content = json.loads(payload)["value"]
            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\right_40\bottom_90\tab_2_monitors\display_child_scan_monitor.py
#####################################
# display/display_child_scan_monitor.py
#
# This file defines the ScanMonitorTab, a Tkinter Frame that provides
# a real-time view of scan data using Matplotlib plots.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250811.130322.1 (REFACTORED: The plot layout was redesigned to use a ttk.PanedWindow and individually declared plots to allow for resizable sashes between them.)

current_version = "20250811.130322.1"
current_version_hash = 20250811 * 130322 * 1 + hash(open(__file__, "r").read())

import tkinter as tk
from tkinter import ttk
import inspect
import os
import numpy as np
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

# Import logging functions for debugging
from display.debug_logic import debug_log
from display.console_logic import console_log

class ScanMonitorTab(ttk.Frame):
    """
    A Tkinter Frame that provides real-time monitoring of scan data with plots.
    """
    def __init__(self, master=None, app_instance=None, **kwargs):
        # This function description tells me what this function does
        # Initializes the ScanMonitorTab, creating a frame to hold real-time
        # plots of scan data. It sets up Matplotlib figures and canvases for
        # three graphs.
        #
        # Inputs to this function
        #   master (tk.Widget): The parent widget, typically a ttk.Notebook.
        #   app_instance (object): A reference to the main application instance
        #                          to access shared variables and methods.
        #   **kwargs: Arbitrary keyword arguments for Tkinter Frame.
        #
        # Outputs of this function
        #   None. Initializes the Tkinter frame and its internal state.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Initializing ScanMonitorTab. Preparing the plots!",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)

        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.plots = {} # To store references to the plot canvases by name

        self._create_widgets()

        debug_log(f"ScanMonitorTab initialized. Plots are ready to go!",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)


    def _create_widgets(self):
        # This function description tells me what this function does
        # Creates and arranges the widgets for the Scan Monitor tab.
        # It sets up a frame for three Matplotlib graphs.
        #
        # Inputs to this function
        #   None.
        #
        # Outputs of this function
        #   None. Populates the tab with GUI elements.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Creating ScanMonitorTab widgets.",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)

        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(0, weight=1)

        # NEW: Use a PanedWindow to hold the plots with sashes
        plot_paned_window = ttk.PanedWindow(self, orient=tk.VERTICAL)
        plot_paned_window.grid(row=0, column=0, padx=5, pady=5, sticky="nsew")

        # --- Top Plot ---
        top_plot_frame = ttk.Frame(plot_paned_window)
        plot_paned_window.add(top_plot_frame, weight=1)
        top_plot_frame.grid_columnconfigure(0, weight=1)
        top_plot_frame.grid_rowconfigure(0, weight=1)
        figure_top = Figure(figsize=(5, 2.5), dpi=100, facecolor='#1e1e1e')
        ax_top = figure_top.add_subplot(111, facecolor='#1e1e1e')
        ax_top.tick_params(axis='x', colors='white')
        ax_top.tick_params(axis='y', colors='white')
        ax_top.spines['bottom'].set_color('white')
        ax_top.spines['top'].set_color('white')
        ax_top.spines['left'].set_color('white')
        ax_top.spines['right'].set_color('white')
        ax_top.set_title("Live", color='white') # UPDATED: Shorter title
        canvas_top = FigureCanvasTkAgg(figure_top, master=top_plot_frame)
        canvas_widget_top = canvas_top.get_tk_widget()
        canvas_widget_top.grid(row=0, column=0, sticky="nsew")
        self.plots["top"] = {'figure': figure_top, 'ax': ax_top, 'canvas': canvas_top, 'widget': canvas_widget_top}

        # --- Middle Plot ---
        middle_plot_frame = ttk.Frame(plot_paned_window)
        plot_paned_window.add(middle_plot_frame, weight=1)
        middle_plot_frame.grid_columnconfigure(0, weight=1)
        middle_plot_frame.grid_rowconfigure(0, weight=1)
        figure_middle = Figure(figsize=(5, 2.5), dpi=100, facecolor='#1e1e1e')
        ax_middle = figure_middle.add_subplot(111, facecolor='#1e1e1e')
        ax_middle.tick_params(axis='x', colors='white')
        ax_middle.tick_params(axis='y', colors='white')
        ax_middle.spines['bottom'].set_color('white')
        ax_middle.spines['top'].set_color('white')
        ax_middle.spines['left'].set_color('white')
        ax_middle.spines['right'].set_color('white')
        ax_middle.set_title("Max Hold", color='white') # UPDATED: Shorter title
        canvas_middle = FigureCanvasTkAgg(figure_middle, master=middle_plot_frame)
        canvas_widget_middle = canvas_middle.get_tk_widget()
        canvas_widget_middle.grid(row=0, column=0, sticky="nsew")
        self.plots["middle"] = {'figure': figure_middle, 'ax': ax_middle, 'canvas': canvas_middle, 'widget': canvas_widget_middle}

        # --- Bottom Plot ---
        bottom_plot_frame = ttk.Frame(plot_paned_window)
        plot_paned_window.add(bottom_plot_frame, weight=1)
        bottom_plot_frame.grid_columnconfigure(0, weight=1)
        bottom_plot_frame.grid_rowconfigure(0, weight=1)
        figure_bottom = Figure(figsize=(5, 2.5), dpi=100, facecolor='#1e1e1e')
        ax_bottom = figure_bottom.add_subplot(111, facecolor='#1e1e1e')
        ax_bottom.tick_params(axis='x', colors='white')
        ax_bottom.tick_params(axis='y', colors='white')
        ax_bottom.spines['bottom'].set_color('white')
        ax_bottom.spines['top'].set_color('white')
        ax_bottom.spines['left'].set_color('white')
        ax_bottom.spines['right'].set_color('white')
        ax_bottom.set_title("Min Hold", color='white') # UPDATED: Shorter title
        canvas_bottom = FigureCanvasTkAgg(figure_bottom, master=bottom_plot_frame)
        canvas_widget_bottom = canvas_bottom.get_tk_widget()
        canvas_widget_bottom.grid(row=0, column=0, sticky="nsew")
        self.plots["bottom"] = {'figure': figure_bottom, 'ax': ax_bottom, 'canvas': canvas_bottom, 'widget': canvas_widget_bottom}

        debug_log(f"ScanMonitorTab widgets created. The placeholders are ready!",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)

#####################################
### File: OPEN-AIR 2\display\right_40\bottom_90\tab_2_monitors\gui_tab_2_monitors.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version corrects the styling of tables and entry widgets for a more cohesive look.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250823.001500.20

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from datasets.logging import debug_log, console_log
from workers.mqtt_controller_util import MqttControllerUtility
from display.styling.style import THEMES, DEFAULT_THEME

# --- Global Scope Variables ---
CURRENT_DATE = 20250823
CURRENT_TIME = 1500
CURRENT_TIME_HASH = 1500
REVISION_NUMBER = 20
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class is now designed as a self-contained "island" that manages its own MQTT state.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # We apply the style at the top of the __init__ to affect all child widgets.
            self._apply_styles(theme_name=DEFAULT_THEME)

            # Create a label for the frame
            frame_label = ttk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = ttk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame, style="Custom.TEntry")
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = ttk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)

            # We now register our callback with the central utility instead of overwriting the client's callback.
            parent_folder = str(pathlib.Path(self.current_file).parent)
            subscription_topic = f"{parent_folder.replace('\\', '/')}/#"
            self.mqtt_util.add_subscriber(topic_filter=subscription_topic, callback_func=self._on_mqtt_message)


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings", style="Custom.Treeview")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            # New frame for log buttons, placed at the bottom below the table.
            log_button_frame = ttk.Frame(self)
            log_button_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=5)

            # Button 1: Log
            self.log_button = ttk.Button(
                log_button_frame, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = ttk.Button(
                log_button_frame, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        # General widget styling
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])

        # Table (Treeview) styling
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

        # Entry (textbox) styling
        style.configure('Custom.TEntry',
                        fieldbackground=colors["entry_bg"],
                        foreground=colors["entry_fg"],
                        bordercolor=colors["table_border"])
        
    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            message_content = json.loads(payload)["value"]
            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\right_40\bottom_90\tab_3_debug\display_child_application_console.py
#####################################
# display/display_child_console.py
#
# This file defines the ConsoleTab, a Tkinter Frame that provides the application's
# console output area. It includes a scrolled text widget for displaying messages
# and a button to clear the console output. This tab is designed to be a child
# of the new TAB_DISPLAY_PARENT.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250810.220500.3 (FIXED: Corrected a race condition by initializing the console_text widget before other setup logic in the __init__ method, resolving the AttributeError.)

current_version = "20250810.220500.3" # this variable should always be defined below the header to make the debugging better
current_version_hash = 20250810 * 220500 * 3 # Example hash, adjust as needed

import tkinter as tk
from tkinter import ttk, scrolledtext
import inspect
import os

# Import the console and GUI redirector functions
from display.console_logic import console_log, set_gui_console_redirector, set_clear_console_func
from display.debug_logic import debug_log # CORRECTED: Import debug_log from src, not display
from src.gui_elements import TextRedirector # Import TextRedirector class

class ConsoleTab(ttk.Frame):
    """
    A Tkinter Frame that provides the application's console output area and controls.
    """
    def __init__(self, master=None, app_instance=None, **kwargs):
        # This function description tells me what this function does
        # Initializes the ConsoleTab, creating a dedicated frame for console output.
        # It sets up a ScrolledText widget and redirects stdout/stderr to it.
        # It also registers a function to clear the console output.
        #
        # Inputs to this function
        #   master (tk.Widget): The parent widget, typically a ttk.Notebook.
        #   app_instance (object): A reference to the main application instance
        #                          to access shared variables and methods.
        #   **kwargs: Arbitrary keyword arguments for Tkinter Frame.
        #
        # Process of this function
        #   1. Calls the superclass constructor (ttk.Frame).
        #   2. Stores a reference to the main app instance.
        #   3. Initializes the console text widget and assigns it to app_instance.
        #   4. Calls `_create_widgets` to build the rest of the UI.
        #   5. Sets up the console redirection.
        #   6. Registers the clear console action.
        #
        # Outputs of this function
        #   None. Initializes the Tkinter frame and its internal state.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Initializing ConsoleTab...",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)

        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        
        # CRITICAL FIX: The console text widget MUST be created here before it's used by other functions.
        # This fixes the AttributeError that was happening.
        self.console_text = scrolledtext.ScrolledText(self, wrap="word", bg="#2b2b2b", fg="#cccccc", insertbackground="white")
        self.app_instance.console_text = self.console_text
        self.console_text.config(state=tk.DISABLED)

        # NEW: Initialize the redirector instance here, and store it on the object.
        self.redirector = TextRedirector(self.console_text, "stdout")

        self._create_widgets()

        # FUCKING IMPORTANT: Set the console redirector here, after console_text is created.
        # This ensures all future print() and console_log calls go to this widget.
        if self.app_instance.console_text: # Ensure the app_instance's console_text is set to this widget
            # Pass our new redirector instance
            set_gui_console_redirector(self.redirector, self.redirector)
            console_log(f"Console output redirected to GUI. Version: {current_version}", function=current_function)
            debug_log(f"GUI console redirector set to ConsoleTab's scrolled text widget.",
                        file=f"{os.path.basename(__file__)} - {current_version}",
                        version=current_version,
                        function=current_function)
        else:
            debug_log(f"ERROR: app_instance.console_text not set to ConsoleTab's widget. Console redirection failed!",
                        file=f"{os.path.basename(__file__)} - {current_version}",
                        version=current_version,
                        function=current_function)
        
        # NEW: Register the clear console action with console_logic
        set_clear_console_func(self._clear_applications_console_action)
        
        debug_log(f"ConsoleTab initialized. The new console is ready for action!",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)


    def _create_widgets(self):
        # This function description tells me what this function does
        # Creates and arranges the widgets for the Console tab.
        # This includes the scrolled text area for output and the button to clear it.
        #
        # Inputs to this function
        #   None.
        #
        # Outputs of this function
        #   None. Populates the tab with GUI elements.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Creating ConsoleTab widgets.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)

        self.grid_rowconfigure(0, weight=1) # Console text area
        self.grid_rowconfigure(1, weight=0) # Clear Console button
        self.grid_columnconfigure(0, weight=1)

        # Console ScrolledText
        # The widget is created in __init__ now. We just need to place it.
        self.console_text.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)
        # The state will be managed by console_log itself when writing.

        # Clear Applications Console Button
        self.clear_applications_console_button = ttk.Button(self, text="Clear Applications Console",
                                                            command=self._clear_applications_console_action,
                                                            style='Red.TButton')
        self.clear_applications_console_button.grid(row=1, column=0, padx=5, pady=5, sticky="ew")

        debug_log(f"ConsoleTab widgets created.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)


    def _clear_applications_console_action(self):
        # This function description tells me what this function does
        # Clears the entire content of the ScrolledText widget for the application console.
        #
        # Inputs to this function
        #   None.
        #
        # Process of this function
        #   1. Checks if `app_instance.console_text` exists.
        #   2. If it exists, it deletes all text from the widget.
        #   3. Calls `console_log` to confirm the action.
        #   4. If the widget is not found, it logs an error.
        #
        # Outputs of this function
        #   None. Clears the contents of the console display.
        current_function = inspect.currentframe().f_code.co_name
        if self.app_instance.console_text:
            self.app_instance.console_text.delete("1.0", tk.END)
            console_log(f"Applications console cleared.", function=current_function)
        else:
            debug_log(f"ERROR: Cannot clear applications console, console_text widget not found. Fucking useless!",
                        file=f"{os.path.basename(__file__)} - {current_version}",
                        version=current_version,
                        function=current_function)


    def _on_tab_selected(self, event):
        # This function description tells me what this function does
        # Placeholder for actions to be taken when the Console tab is selected.
        #
        # Inputs to this function
        #   event (tkinter.Event): The event object.
        #
        # Outputs of this function
        #   None.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"ConsoleTab selected. No specific refresh action needed.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)


#####################################
### File: OPEN-AIR 2\display\right_40\bottom_90\tab_3_debug\display_child_debug.py
#####################################
# display/display_child_debug.py
#
# This file defines the DebugTab, a Tkinter Frame that provides the application's
# debug control settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.220500.1

import tkinter as tk
from tkinter import ttk, scrolledtext, filedialog
import inspect
import os
import subprocess
import sys
import threading
import time

from display.debug_logic import (
    debug_log,
    set_debug_mode, set_log_visa_commands_mode,
    set_debug_to_file_mode, set_include_console_messages_to_debug_file_mode,
    clear_debug_log_file, set_log_truncation_mode, set_include_visa_messages_to_debug_file_mode,
    DEBUG_FILE_PATH, VISA_FILE_PATH
)
from display.console_logic import console_log
from settings_and_config.config_manager_save import save_program_config 

# --- Version Information ---
current_version = "20250821.220500.1"
current_version_hash = 20250821 * 220500 * 1

class DebugTab(ttk.Frame):
    """
    A Tkinter Frame that provides the debug control settings for the application.
    """
    def __init__(self, master=None, app_instance=None, **kwargs):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Initializing DebugTab...",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)

        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.polling_id = None
        self.last_software_log_size = 0
        self.last_visa_log_size = 0
        self.read_log_thread = None
        self.stop_thread = threading.Event()
        
        self.software_log_lines = []
        
        self.log_filter_var = tk.StringVar(value="All")
        self.log_filter_map = {
            "All": None,
            "🐐 YAK": "🐐",
            "💾 Saves": "💾",
            "🖥️ displays": "🖥️",
            "🛠️ utilities": "🛠️"
        }

        self._create_widgets()
        
        self.app_instance.gui_debug = self.software_log_text
        
        debug_log(f"DebugTab initialized. The debug controls and log viewers are ready for action! 🛡️",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)

    def _create_widgets(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Creating DebugTab widgets.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)

        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(2, weight=1)
        
        master_control_frame = ttk.LabelFrame(self, text="Master Debug Control", style='Dark.TLabelframe')
        master_control_frame.grid(row=0, column=0, padx=10, pady=5, sticky="ew")
        master_control_frame.grid_columnconfigure(0, weight=1)
        
        self.toggle_debug_button = ttk.Button(master_control_frame, text="Enable Debug", command=self._toggle_debug_mode, style='Blue.TButton')
        self.toggle_debug_button.grid(row=0, column=0, padx=5, pady=5, sticky="ew")
        
        if self.app_instance.general_debug_enabled_var.get():
            self.toggle_debug_button.config(text="Disable Debug", style='Red.TButton')
        else:
            self.toggle_debug_button.config(text="Enable Debug", style='Blue.TButton')

        log_paned_window = ttk.PanedWindow(self, orient=tk.VERTICAL)
        log_paned_window.grid(row=2, column=0, sticky="nsew", padx=10, pady=5)
        
        software_log_frame = ttk.LabelFrame(log_paned_window, text="Software Debug Log")
        log_paned_window.add(software_log_frame, weight=1)
        software_log_frame.grid_columnconfigure(0, weight=1)
        software_log_frame.grid_rowconfigure(3, weight=1)

        file_log_controls_frame = ttk.Frame(software_log_frame, style='Dark.TFrame')
        file_log_controls_frame.grid(row=0, column=0, sticky="ew", padx=5, pady=5)
        file_log_controls_frame.grid_columnconfigure(0, weight=1)
        
        self.debug_to_file_checkbox = ttk.Checkbutton(file_log_controls_frame, text="Log to File",
                                                      variable=self.app_instance.debug_to_file_var,
                                                      command=self._toggle_debug_to_file_mode,
                                                      style='TCheckbutton')
        self.debug_to_file_checkbox.grid(row=0, column=0, padx=5, pady=2, sticky="w")
        
        self.include_console_messages_checkbox = ttk.Checkbutton(file_log_controls_frame, text="Include Console Messages",
                                                                 variable=self.app_instance.include_console_messages_to_debug_file_var,
                                                                 command=self._toggle_include_console_messages_to_debug_file_mode,
                                                                 style='TCheckbutton')
        self.include_console_messages_checkbox.grid(row=1, column=0, padx=5, pady=2, sticky="w")
        
        # --- DEFINITIVE FIX: Corrected variable name to use '_enabled_var' suffix ---
        self.include_visa_messages_to_debug_file_checkbox = ttk.Checkbutton(file_log_controls_frame, text="Include VISA Messages into Debug File",
                                                                              variable=self.app_instance.include_visa_messages_to_debug_file_enabled_var,
                                                                              command=self._toggle_include_visa_messages_to_debug_file_mode,
                                                                              style='TCheckbutton')
        self.include_visa_messages_to_debug_file_checkbox.grid(row=2, column=0, padx=5, pady=2, sticky="w")

        self.log_truncation_checkbox = ttk.Checkbutton(file_log_controls_frame, text="Truncate Long Numeric Messages",
                                                       variable=self.app_instance.log_truncation_enabled_var,
                                                       command=self._toggle_log_truncation_mode,
                                                       style='TCheckbutton')
        self.log_truncation_checkbox.grid(row=3, column=0, padx=5, pady=2, sticky="w")
        
        self.clear_debug_log_button = ttk.Button(software_log_frame, text="Clear Debug Log File",
                                                   command=self._clear_debug_log_file_action,
                                                   style='Red.TButton')
        self.clear_debug_log_button.grid(row=1, column=0, padx=5, pady=5, sticky="ew")

        filter_frame = ttk.Frame(software_log_frame)
        filter_frame.grid(row=2, column=0, padx=5, pady=5, sticky="ew")
        filter_frame.grid_columnconfigure(1, weight=1)
        
        ttk.Label(filter_frame, text="Filter Log:").grid(row=0, column=0, padx=(0, 5), sticky="w")
        self.log_filter_dropdown = ttk.Combobox(filter_frame, textvariable=self.log_filter_var, state="readonly")
        self.log_filter_dropdown['values'] = list(self.log_filter_map.keys())
        self.log_filter_dropdown.current(0)
        self.log_filter_dropdown.bind("<<ComboboxSelected>>", self._filter_and_display_log)
        self.log_filter_dropdown.grid(row=0, column=1, sticky="ew")
        
        self.software_log_text = scrolledtext.ScrolledText(software_log_frame, wrap="word", height=10, bg="#2b2b2b", fg="#cccccc", insertbackground="white")
        self.software_log_text.grid(row=3, column=0, sticky="nsew")
        self.software_log_text.config(state=tk.DISABLED)

        visa_log_frame = ttk.LabelFrame(log_paned_window, text="VISA Commands Log")
        log_paned_window.add(visa_log_frame, weight=1)
        visa_log_frame.grid_columnconfigure(0, weight=1)
        visa_log_frame.grid_rowconfigure(1, weight=1)

        visa_log_controls_frame = ttk.Frame(visa_log_frame, style='Dark.TFrame')
        visa_log_controls_frame.grid(row=0, column=0, sticky="ew", padx=5, pady=5)
        visa_log_controls_frame.grid_columnconfigure(0, weight=1)

        self.log_visa_commands_checkbox = ttk.Checkbutton(visa_log_frame, text="Log VISA Commands",
                                                          variable=self.app_instance.log_visa_commands_enabled_var,
                                                          command=self._toggle_visa_logging_mode,
                                                          style='TCheckbutton')
        self.log_visa_commands_checkbox.grid(row=0, column=0, padx=5, pady=5, sticky="w")
        
        self.visa_log_text = scrolledtext.ScrolledText(visa_log_frame, wrap="word", height=10, bg="#2b2b2b", fg="#cccccc", insertbackground="white")
        self.visa_log_text.grid(row=1, column=0, columnspan=2, sticky="nsew")
        self.visa_log_text.config(state=tk.DISABLED)

        bottom_button_frame = ttk.Frame(self, style='Dark.TFrame')
        bottom_button_frame.grid(row=3, column=0, padx=10, pady=5, sticky="ew")
        bottom_button_frame.grid_columnconfigure(0, weight=1)
        
        self.open_data_folder_button = ttk.Button(bottom_button_frame, text="Open Data Folder", command=self._open_data_folder_action, style='Blue.TButton')
        self.open_data_folder_button.grid(row=0, column=0, padx=5, pady=5, sticky="ew")
        
        self.last_save_time_label = ttk.Label(bottom_button_frame,
                                              textvariable=self.app_instance.last_config_save_time_var,
                                              style='Dark.TLabel.Value')
        self.last_save_time_label.grid(row=1, column=0, padx=5, pady=2, sticky="e")

        debug_log(f"DebugTab widgets created. Log viewers are a go! 🛡️",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
    
    def _filter_and_display_log(self, event=None):
        """Filters the log content based on the dropdown selection and updates the display."""
        selected_filter = self.log_filter_var.get()
        filter_emoji = self.log_filter_map.get(selected_filter)
        
        filtered_lines = []
        for line in self.software_log_lines:
            if filter_emoji is None or line.strip().startswith(filter_emoji):
                filtered_lines.append(line)
        
        self.software_log_text.config(state=tk.NORMAL)
        self.software_log_text.delete("1.0", tk.END)
        self.software_log_text.insert(tk.END, "".join(filtered_lines))
        self.software_log_text.config(state=tk.DISABLED)
        self.software_log_text.see(tk.END)

    def _toggle_debug_mode(self):
        """Toggles the global debug mode and updates the button's appearance."""
        current_state = self.app_instance.general_debug_enabled_var.get()
        new_state = not current_state
        self.app_instance.general_debug_enabled_var.set(new_state)
        set_debug_mode(new_state)
        save_program_config (config=self.app_instance.program_config)

        if new_state:
            self.toggle_debug_button.config(text="Disable Debug", style='Red.TButton')
            console_log("Debug mode is now ENABLED. The microscope is on! 🔬")
        else:
            self.toggle_debug_button.config(text="Enable Debug", style='Green.TButton')
            console_log("Debug mode is now DISABLED. Back to normal. 🤫")
        
    def _toggle_visa_logging_mode(self):
        """Toggles the global VISA command logging based on checkbox state."""
        new_state = self.app_instance.log_visa_commands_enabled_var.get()
        set_log_visa_commands_mode(new_state)
        save_program_config (config=self.app_instance.program_config)
        debug_log(f"Toggling VISA logging. Current state: {new_state}", file=f"{os.path.basename(__file__)}", version=current_version)

    def _toggle_debug_to_file_mode(self):
        """Toggles whether debug messages are written to a file."""
        new_state = self.app_instance.debug_to_file_var.get()
        set_debug_to_file_mode(new_state)
        save_program_config (config=self.app_instance.program_config)
        debug_log(f"Toggling debug output to file. Current state: {new_state}", file=f"{os.path.basename(__file__)}", version=current_version)

    def _toggle_include_console_messages_to_debug_file_mode(self):
        """Toggles whether console messages are included in the debug file."""
        new_state = self.app_instance.include_console_messages_to_debug_file_var.get()
        set_include_console_messages_to_debug_file_mode(new_state)
        save_program_config (config=self.app_instance.program_config)
        debug_log(f"Toggling inclusion of console messages to debug file. Current state: {new_state}", file=f"{os.path.basename(__file__)}", version=current_version)

    def _toggle_log_truncation_mode(self):
        """Toggles whether log messages are truncated."""
        new_state = self.app_instance.log_truncation_enabled_var.get()
        set_log_truncation_mode(new_state)
        save_program_config (config=self.app_instance.program_config)
        debug_log(f"Toggling log truncation. Current state: {new_state}", file=f"{os.path.basename(__file__)}", version=current_version)

    def _toggle_include_visa_messages_to_debug_file_mode(self):
        """Toggles whether VISA messages are included in the debug file."""
        new_state = self.app_instance.include_visa_messages_to_debug_file_enabled_var.get()
        set_include_visa_messages_to_debug_file_mode(new_state)
        save_program_config (config=self.app_instance.program_config)
        debug_log(f"Toggling inclusion of VISA messages to debug file. Current state: {new_state}", file=f"{os.path.basename(__file__)}", version=current_version)

    def _clear_debug_log_file_action(self):
        """Action to clear the debug log file."""
        debug_log(f"Attempting to clear debug log files.", file=f"{os.path.basename(__file__)}", version=current_version)
        clear_debug_log_file(DEBUG_FILE_PATH)
        clear_debug_log_file(VISA_FILE_PATH)
        console_log(f"Debug log files cleared. Fucking finally!")
        self.software_log_lines = []
        self.software_log_text.config(state=tk.NORMAL)
        self.software_log_text.delete("1.0", tk.END)
        self.software_log_text.config(state=tk.DISABLED)
        self.visa_log_text.config(state=tk.NORMAL)
        self.visa_log_text.delete("1.0", tk.END)
        self.visa_log_text.config(state=tk.DISABLED)
        self.last_software_log_size = 0
        self.last_visa_log_size = 0

    def _open_data_folder_action(self):
        """Opens the main DATA folder in the file explorer."""
        debug_log(f"Opening DATA folder...", file=f"{os.path.basename(__file__)}", version=current_version)
        data_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), '..', 'DATA')
        if os.path.exists(data_path):
            try:
                if sys.platform == "win32":
                    os.startfile(data_path)
                elif sys.platform == "darwin":
                    subprocess.Popen(["open", data_path])
                else:
                    subprocess.Popen(["xdg-open", data_path])
                console_log(f"✅ Opened data folder: {data_path}")
            except Exception as e:
                console_log(f"❌ Failed to open data folder: {e}")
        else:
            console_log(f"❌ Data folder not found at: {data_path}")

    def _read_new_log_content(self, file_path, start_pos):
        """Reads new lines from a file starting from a given position and returns them."""
        if not os.path.exists(file_path):
            return ""
        new_content = ""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                f.seek(start_pos)
                new_content = f.read()
        except Exception as e:
            debug_log(f"ERROR: Failed to read from log file {file_path}: {e}", file=f"{os.path.basename(__file__)}", version=current_version)
            return ""
        return new_content

    def _check_log_files(self):
        """Checks for new content in the log files and updates the displays."""
        if self.stop_thread.is_set():
            return
        try:
            current_size = os.path.getsize(DEBUG_FILE_PATH)
            if current_size > self.last_software_log_size:
                new_content = self._read_new_log_content(DEBUG_FILE_PATH, self.last_software_log_size)
                if new_content:
                    self.software_log_lines.extend(new_content.splitlines(keepends=True))
                    self._filter_and_display_log()
                self.last_software_log_size = current_size
            elif current_size < self.last_software_log_size:
                self.software_log_lines = []
                self.last_software_log_size = current_size
                self._filter_and_display_log()
        except FileNotFoundError:
            pass
        except Exception as e:
            debug_log(f"ERROR: An error occurred while checking software log file: {e}", file=f"{os.path.basename(__file__)}", version=current_version)
        try:
            current_size = os.path.getsize(VISA_FILE_PATH)
            if current_size > self.last_visa_log_size:
                new_content = self._read_new_log_content(VISA_FILE_PATH, self.last_visa_log_size)
                if new_content:
                    self.visa_log_text.config(state=tk.NORMAL)
                    self.visa_log_text.insert(tk.END, new_content)
                    self.visa_log_text.config(state=tk.DISABLED)
                    self.visa_log_text.see(tk.END)
                self.last_visa_log_size = current_size
            elif current_size < self.last_visa_log_size:
                self.visa_log_text.config(state=tk.NORMAL)
                self.visa_log_text.delete("1.0", tk.END)
                self.visa_log_text.config(state=tk.DISABLED)
                self.last_visa_log_size = current_size
        except FileNotFoundError:
            pass
        except Exception as e:
            debug_log(f"ERROR: An error occurred while checking VISA log file: {e}", file=f"{os.path.basename(__file__)}", version=current_version)
        self.after(500, self._check_log_files)

    def _on_tab_selected(self, event):
        """Starts log monitoring when the tab becomes active."""
        debug_log(f"ConsoleTab selected. Initializing log monitoring.", file=f"{os.path.basename(__file__)}", version=current_version)
        try:
            with open(DEBUG_FILE_PATH, 'r', encoding='utf-8', errors='ignore') as f:
                self.software_log_lines = f.readlines()
            self.last_software_log_size = os.path.getsize(DEBUG_FILE_PATH)
        except FileNotFoundError:
            self.software_log_lines = ["❌ Log file not found. It's an empty void of nothingness!"]
            self.last_software_log_size = 0
        try:
            with open(VISA_FILE_PATH, 'r', encoding='utf-8', errors='ignore') as f:
                visa_content = f.read()
                self.visa_log_text.config(state=tk.NORMAL)
                self.visa_log_text.delete("1.0", tk.END)
                self.visa_log_text.insert(tk.END, visa_content)
            self.visa_log_text.config(state=tk.DISABLED)
            self.last_visa_log_size = os.path.getsize(VISA_FILE_PATH)
        except FileNotFoundError:
            self.visa_log_text.config(state=tk.NORMAL)
            self.visa_log_text.delete("1.0", tk.END)
            self.visa_log_text.insert(tk.END, "❌ VISA log file not found. It's an empty void of nothingness!")
            self.visa_log_text.config(state=tk.DISABLED)
            self.last_visa_log_size = 0
        self._filter_and_display_log()
        self.after(500, self._check_log_files)

#####################################
### File: OPEN-AIR 2\display\right_40\bottom_90\tab_3_debug\gui_tab_3_debug.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version corrects the styling of tables and entry widgets for a more cohesive look.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250823.001500.20

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from datasets.logging import debug_log, console_log
from workers.mqtt_controller_util import MqttControllerUtility
from display.styling.style import THEMES, DEFAULT_THEME

# --- Global Scope Variables ---
CURRENT_DATE = 20250823
CURRENT_TIME = 1500
CURRENT_TIME_HASH = 1500
REVISION_NUMBER = 20
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class is now designed as a self-contained "island" that manages its own MQTT state.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # We apply the style at the top of the __init__ to affect all child widgets.
            self._apply_styles(theme_name=DEFAULT_THEME)

            # Create a label for the frame
            frame_label = ttk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = ttk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame, style="Custom.TEntry")
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = ttk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)

            # We now register our callback with the central utility instead of overwriting the client's callback.
            parent_folder = str(pathlib.Path(self.current_file).parent)
            subscription_topic = f"{parent_folder.replace('\\', '/')}/#"
            self.mqtt_util.add_subscriber(topic_filter=subscription_topic, callback_func=self._on_mqtt_message)


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings", style="Custom.Treeview")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            # New frame for log buttons, placed at the bottom below the table.
            log_button_frame = ttk.Frame(self)
            log_button_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=5)

            # Button 1: Log
            self.log_button = ttk.Button(
                log_button_frame, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = ttk.Button(
                log_button_frame, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        # General widget styling
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])

        # Table (Treeview) styling
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

        # Entry (textbox) styling
        style.configure('Custom.TEntry',
                        fieldbackground=colors["entry_bg"],
                        foreground=colors["entry_fg"],
                        bordercolor=colors["table_border"])
        
    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            message_content = json.loads(payload)["value"]
            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\right_40\bottom_90\tab_4_conductor\gui_mqtt_conductor.py
#####################################
# display/right_40/bottom_90/tab_4_conductor/gui_mqtt_conductor.py
#
# A comprehensive GUI component for managing and testing an MQTT broker and client.
# This file now integrates with the MqttControllerUtility to handle all broker and client logic.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250823.124255.1

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk, scrolledtext
import subprocess
import threading
import json
import paho.mqtt.client as mqtt
from collections import defaultdict
from itertools import filterfalse

# --- Module Imports ---
from datasets.logging import debug_log, console_log
from workers.mqtt_controller_util import MqttControllerUtility
from display.styling.style import THEMES, DEFAULT_THEME

# --- Global Scope Variables ---
CURRENT_DATE = datetime.datetime.now().strftime("%Y%m%d")
CURRENT_TIME = datetime.datetime.now().strftime("%H%M%S")
CURRENT_TIME_HASH = int(datetime.datetime.now().strftime("%H%M%S"))
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
current_file = f"display/right_40/bottom_90/tab_4_conductor/{os.path.basename(__file__)}"

# --- Constant Variables (No Magic Numbers) ---
SERVER_STATUS_FRAME_TEXT = "Server Status"
PUBLISH_FRAME_TEXT = "Publish Message"
SUBSCRIPTIONS_FRAME_TEXT = "Live Subscriptions"
CLIENTS_FRAME_TEXT = "Connected Clients"
TOPIC_LABEL_TEXT = "Topic:"
SUBTOPIC_LABEL_TEXT = "Subtopic:"
VALUE_LABEL_TEXT = "Value:"
PUBLISH_BUTTON_TEXT = "Publish"
CLEAR_BUTTON_TEXT = "Clear Log"
COLUMNS = ("Topic", "Message")
SERVER_STATUS_TEXT = "Status:"
SERVER_ADDRESS_TEXT = "Broker Address:"
SERVER_VERSION_TEXT = "Version:"
SERVER_UPTIME_TEXT = "Uptime:"
SERVER_MESSAGE_COUNT_TEXT = "Messages:"
CLIENT_COUNT_TEXT = "Clients:"
FILTER_LABEL_TEXT = "Filter Topics:"
STATUS_RUNNING_TEXT = "Running"
STATUS_STOPPED_TEXT = "Stopped"


class MqttConductorFrame(ttk.Frame):
    """
    A comprehensive GUI frame for controlling and monitoring a local MQTT broker.
    It provides a centralized view of broker status, topic activity, and connected clients.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        """
        Initializes the GUI, setting up layout and widgets.
        This version integrates with the main application's MqttControllerUtility.

        Args:
            parent: The parent widget for this frame.
            mqtt_util: A shared instance of MqttControllerUtility.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message=f"🐐🟢 Initializing the '{self.__class__.__name__}' GUI frame. This one's a masterpiece of form over function!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            super().__init__(parent, *args, **kwargs)
            self.mqtt_util = mqtt_util
            
            self._apply_styles(theme_name=DEFAULT_THEME)
            
            self.topics_in_table = defaultdict(lambda: None)
            self.clients_in_table = set()

            # FIX: Create widgets first before subscribing to prevent AttributeError.
            self._create_widgets()
            
            # Now subscribe to messages after the widgets exist.
            self.mqtt_util.log_to_table = self.log_to_table
            self.mqtt_util.print_to_gui_func = self.log_to_gui
            self.mqtt_util.add_subscriber(topic_filter="#", callback_func=self._on_message)
            self.mqtt_util.add_subscriber(topic_filter="$SYS/#", callback_func=self._on_sys_message)
            
            self.pack(pady=10, padx=10, fill=tk.BOTH, expand=True)

            console_log("✅ Celebration of success! The visual layout is complete.")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """Applies the specified theme to the GUI elements."""
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])
        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])
        style.configure('Custom.TEntry',
                        fieldbackground=colors["entry_bg"],
                        foreground=colors["entry_fg"],
                        bordercolor=colors["table_border"])
        style.configure('TButton', background=colors["accent"], foreground=colors["text"], padding=5)

    def _create_widgets(self):
        """Creates all the UI widgets for the comprehensive conductor tab."""
        top_frame = ttk.Frame(master=self)
        top_frame.pack(side=tk.TOP, pady=10, padx=10, fill=tk.X, expand=False)
        center_frame = ttk.Frame(master=self)
        center_frame.pack(pady=10, padx=10, fill=tk.BOTH, expand=True)
        bottom_frame = ttk.Frame(master=self)
        bottom_frame.pack(side=tk.BOTTOM, pady=10, padx=10, fill=tk.X, expand=False)

        server_status_frame = ttk.LabelFrame(master=top_frame, text=SERVER_STATUS_FRAME_TEXT)
        server_status_frame.pack(side=tk.LEFT, fill=tk.BOTH, padx=5, expand=True)
        self.server_status_label = ttk.Label(master=server_status_frame, text=f"{SERVER_STATUS_TEXT} {STATUS_STOPPED_TEXT}")
        self.server_address_label = ttk.Label(master=server_status_frame, text=f"{SERVER_ADDRESS_TEXT} localhost")
        self.server_version_label = ttk.Label(master=server_status_frame, text=f"{SERVER_VERSION_TEXT} N/A")
        self.server_uptime_label = ttk.Label(master=server_status_frame, text=f"{SERVER_UPTIME_TEXT} N/A")
        self.server_message_count_label = ttk.Label(master=server_status_frame, text=f"{SERVER_MESSAGE_COUNT_TEXT} N/A")
        self.server_client_count_label = ttk.Label(master=server_status_frame, text=f"{CLIENT_COUNT_TEXT} N/A")
        self.server_status_label.pack(anchor=tk.W, padx=5, pady=2)
        self.server_address_label.pack(anchor=tk.W, padx=5, pady=2)
        self.server_version_label.pack(anchor=tk.W, padx=5, pady=2)
        self.server_uptime_label.pack(anchor=tk.W, padx=5, pady=2)
        self.server_message_count_label.pack(anchor=tk.W, padx=5, pady=2)
        self.server_client_count_label.pack(anchor=tk.W, padx=5, pady=2)
        
        server_controls_frame = ttk.Frame(master=top_frame)
        server_controls_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=5, pady=5)
        # --- Bind buttons to the actual utility functions ---
        self.start_btn = ttk.Button(master=server_controls_frame, text="Start Broker", command=self.mqtt_util.start_mosquitto)
        self.stop_btn = ttk.Button(master=server_controls_frame, text="Stop Broker", command=self.mqtt_util.stop_mosquitto)
        self.check_status_btn = ttk.Button(master=server_controls_frame, text="Check Status", command=self.mqtt_util.check_status)
        self.start_btn.pack(pady=2, padx=5, fill=tk.X)
        self.stop_btn.pack(pady=2, padx=5, fill=tk.X)
        self.check_status_btn.pack(pady=2, padx=5, fill=tk.X)

        publish_frame = ttk.LabelFrame(master=top_frame, text=PUBLISH_FRAME_TEXT)
        publish_frame.pack(side=tk.LEFT, fill=tk.BOTH, padx=5, expand=True)
        tk.Label(master=publish_frame, text=TOPIC_LABEL_TEXT).grid(row=0, column=0, padx=5, pady=5, sticky="e")
        self.topic_entry = ttk.Entry(master=publish_frame, style="Custom.TEntry")
        self.topic_entry.grid(row=0, column=1, columnspan=2, padx=5, pady=5, sticky="ew")
        self.topic_entry.insert(0, f"conductor/test_message")

        tk.Label(master=publish_frame, text=VALUE_LABEL_TEXT).grid(row=1, column=0, padx=5, pady=5, sticky="e")
        self.value_entry = ttk.Entry(master=publish_frame, style="Custom.TEntry")
        self.value_entry.grid(row=1, column=1, columnspan=2, padx=5, pady=5, sticky="ew")
        self.value_entry.insert(0, "Test Payload")

        # --- Bind the publish button to the new _publish_custom_message method ---
        publish_btn = ttk.Button(master=publish_frame, text=PUBLISH_BUTTON_TEXT, command=self._publish_custom_message)
        publish_btn.grid(row=0, column=3, rowspan=2, padx=5, sticky="ew")

        subscriptions_frame = ttk.LabelFrame(master=center_frame, text=SUBSCRIPTIONS_FRAME_TEXT)
        subscriptions_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        self.subscriptions_table = ttk.Treeview(master=subscriptions_frame, columns=COLUMNS, show="headings", style="Custom.Treeview")
        self.subscriptions_table.heading("Topic", text="Topic")
        self.subscriptions_table.heading("Message", text="Message Content")
        self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        table_scrollbar = ttk.Scrollbar(master=subscriptions_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
        self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
        table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        bottom_btn_frame = ttk.Frame(master=bottom_frame)
        bottom_btn_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=5, pady=5)
        self.log_btn = ttk.Button(master=bottom_btn_frame, text="Log", command=lambda: console_log("A sample log message from the Conductor."))
        self.debug_btn = ttk.Button(master=bottom_btn_frame, text="Debug", command=lambda: debug_log(message="A sample debug message.", file=current_file, version=current_version, function="_create_widgets", console_print_func=console_log))
        self.clear_btn = ttk.Button(master=bottom_btn_frame, text=CLEAR_BUTTON_TEXT, command=self._clear_log)
        self.log_btn.pack(side=tk.LEFT, padx=5, pady=5)
        self.debug_btn.pack(side=tk.LEFT, padx=5, pady=5)
        self.clear_btn.pack(side=tk.RIGHT, padx=5, pady=5)
    
    def log_to_gui(self, message):
        """Allows the utility to log messages to the console."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🐐🔵 Entering '{current_function_name}' to print a message to the GUI console.",
            file=current_file,
            version=current_version,
            function=current_function_name,
            console_print_func=console_log
        )
        try:
            # The console_log function already exists globally.
            console_log(message)
            console_log("✅ Celebration of success!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=current_function_name,
                console_print_func=console_log
            )
            
    def log_to_table(self, topic: str, message: str):
        """Allows the utility to log messages to the table."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🐐🔵 Entering '{current_function_name}' to add a message to the table.",
            file=current_file,
            version=current_version,
            function=current_function_name,
            console_print_func=console_log
        )
        try:
            self.subscriptions_table.insert('', 'end', values=(topic, message))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            console_log("✅ Celebration of success!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=current_function_name,
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        """Publishes the message from the GUI's text boxes."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🐐🟢 Entering '{current_function_name}' to publish a custom message.",
            file=current_file,
            version=current_version,
            function=current_function_name,
            console_print_func=console_log
        )
        try:
            topic = self.topic_entry.get()
            value = self.value_entry.get()
            if not topic or not value:
                console_log("❌ Please enter a topic and a value.")
                return

            self.mqtt_util.publish_message(topic=topic, subtopic="", value=value)
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=current_function_name,
                console_print_func=console_log
            )

    def _clear_log(self):
        """Clears the contents of the subscriptions table."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🐐🟢 Entering '{current_function_name}' to clear the log.",
            file=current_file,
            version=current_version,
            function=current_function_name,
            console_print_func=console_log
        )
        try:
            self.subscriptions_table.delete(*self.subscriptions_table.get_children())
            console_log("✅ Log cleared successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=current_function_name,
                console_print_func=console_log
            )

    def _on_message(self, topic, payload):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🐐🔵 Entering '{current_function_name}' to process a general MQTT message.",
            file=current_file,
            version=current_version,
            function=current_function_name,
            console_print_func=console_log
        )
        try:
            self.log_to_table(topic=topic, message=payload)
            console_log("✅ General message logged to table!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=current_function_name,
                console_print_func=console_log
            )

    def _on_sys_message(self, topic, payload):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"�🔵 Entering '{current_function_name}' to process a system status message.",
            file=current_file,
            version=current_version,
            function=current_function_name,
            console_print_func=console_log
        )
        try:
            if "$SYS/broker/version" in topic:
                self.server_version_label.config(text=f"{SERVER_VERSION_TEXT} {payload}")
            elif "$SYS/broker/uptime" in topic:
                self.server_uptime_label.config(text=f"{SERVER_UPTIME_TEXT} {payload}")
            elif "$SYS/broker/messages/sent" in topic:
                self.server_message_count_label.config(text=f"{SERVER_MESSAGE_COUNT_TEXT} {payload}")
            elif "$SYS/broker/clients/connected" in topic:
                self.server_client_count_label.config(text=f"{CLIENT_COUNT_TEXT} {payload}")
            
            self.server_status_label.config(text=f"{SERVER_STATUS_TEXT} {STATUS_RUNNING_TEXT}")
            console_log("✅ System status message processed and GUI updated.")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=current_function_name,
                console_print_func=console_log
            )

#####################################
### File: OPEN-AIR 2\display\right_40\bottom_90\tab_5_configuration\gui_tab_5_configuration.py
#####################################
# tabs/Experiments/tab_experiments_child_initial_configuration.py
#
# This file defines the InitialConfigurationTab, a child tab for the Experiments
# section. This refactored version is a standalone test harness with mock functionality.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250823.133000.1

import tkinter as tk
from tkinter import ttk, scrolledtext, filedialog
import inspect
import os
import datetime

# --- Mocking core dependencies for this standalone test file ---
# We are intentionally removing the following imports for this test version:
# from display.debug_logic import debug_log
# from display.console_logic import console_log
# from settings_and_config.config_manager_save import load_program_config, save_program_config
# from ref.ref_program_default_values import DEFAULT_CONFIG
# from ref.ref_file_paths import DATA_FOLDER_PATH, CONFIG_FILE_PATH

def debug_log(message, file, version, function):
    """A mock debug log function for testing purposes."""
    print(f"DEBUG: {message} | {file} | {version} | {function}")

def console_log(message):
    """A mock console log function for testing purposes."""
    print(f"CONSOLE: {message}")

# --- Version Information ---
CURRENT_DATE = datetime.datetime.now().strftime("%Y%m%d")
CURRENT_TIME = datetime.datetime.now().strftime("%H%M%S")
CURRENT_TIME_HASH = int(datetime.datetime.now().strftime("%H%M%S"))
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
current_file = f"tabs/Experiments/tab_experiments_child_initial_configuration.py"


class InitialConfigurationTab(ttk.Frame):
    def __init__(self, master=None, *args, **kwargs):
        """
        Initializes the InitialConfigurationTab, a Tkinter Frame for viewing and
        editing the application's configuration.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"📕🟢 Initializing InitialConfigurationTab...",
                  file=current_file, version=current_version, function=current_function)

        super().__init__(master, **kwargs)
        
        self._create_widgets()
        self._populate_config_table()
        
        debug_log(message=f"📕✅ InitialConfigurationTab initialized.",
                  file=current_file, version=current_version, function=current_function)

    def _create_widgets(self):
        """
        Creates and lays out the widgets for the configuration tab, including a
        text area for displaying the config and buttons for saving and reloading.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"📕🟢 Creating widgets for InitialConfigurationTab.",
                  file=current_file, version=current_version, function=current_function)

        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(1, weight=1)

        control_frame = ttk.Frame(self)
        control_frame.grid(row=0, column=0, padx=10, pady=5, sticky="ew")
        control_frame.grid_columnconfigure(0, weight=1)
        control_frame.grid_columnconfigure(1, weight=1)
        
        save_button = ttk.Button(control_frame, text="Save Config", command=self._save_program_configure_action, style='Green.TButton')
        save_button.grid(row=0, column=0, padx=5, pady=5, sticky="ew")

        reload_button = ttk.Button(control_frame, text="Reload Config", command=self._reload_config_action, style='Orange.TButton')
        reload_button.grid(row=0, column=1, padx=5, pady=5, sticky="ew")

        self.config_text_widget = scrolledtext.ScrolledText(self, wrap="word", height=25, bg="#2b2b2b", fg="#cccccc", insertbackground="white", font=("Courier", 10))
        self.config_text_widget.grid(row=1, column=0, padx=10, pady=5, sticky="nsew")
        
        debug_log(message=f"📕✅ Widgets created.",
                  file=current_file, version=current_version, function=current_function)
    
    def _populate_config_table(self):
        """
        Reads a mock config file and populates the text widget with its content.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"📕🟢 Populating config table from a mock file.",
                  file=current_file, version=current_version, function=current_function)

        try:
            mock_config_content = """[GENERAL]
theme = dark
log_level = DEBUG

[INSTRUMENT]
visa_resource = ASRL1::INSTR
ref_level_dbm = -20
power_attenuation_db = 10
preamp_on = False
high_sensitivity_on = False

[MARKERS]
marker1_freq_mhz = 111.0
marker2_freq_mhz = 222.0
marker3_freq_mhz = 333.0
"""
            self.config_text_widget.config(state=tk.NORMAL)
            self.config_text_widget.delete('1.0', tk.END)
            self.config_text_widget.insert(tk.END, mock_config_content)
            self.config_text_widget.config(state=tk.DISABLED)
            
            debug_log(message=f"📕✅ Config table populated successfully.",
                      file=current_file, version=current_version, function=current_function)

        except Exception as e:
            console_log(message=f"❌ Error populating config table: {e}")
            debug_log(message=f"📕🔴 Failed to populate config table. Error: {e}",
                      file=current_file, version=current_version, function=current_function)
    
    def _save_program_configure_action(self):
        """
        Handles the action of saving the edited config back to a mock file.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"📕🟢 Attempting to save mock config file...",
                  file=current_file, version=current_version, function=current_function)

        try:
            current_content = self.config_text_widget.get('1.0', tk.END)
            # In a real app, this would write to a file. Here, we just log the action.
            console_log("✅ Configuration saved successfully! (Mock Action)")
            debug_log(message=f"📕✅ Mock configuration saved. Arrr, the treasure be safely stowed! ⚓️",
                      file=current_file, version=current_version, function=current_function)

        except Exception as e:
            console_log(message=f"❌ Error saving configuration: {e}")
            debug_log(message=f"📕🔴 Failed to save configuration. Error: {e}",
                      file=current_file, version=current_version, function=current_function)

    def _reload_config_action(self):
        """
        Handles the action of reloading a mock config from disk.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"📕🟢 Reloading config from mock disk...",
                  file=current_file, version=current_version, function=current_function)
        
        self._populate_config_table()
        
        console_log("✅ Configuration reloaded from mock disk.")
        debug_log(message=f"📕✅ Reloaded mock config. The map be fresh! 🗺️",
                  file=current_file, version=current_version, function=current_function)

if __name__ == "__main__":
    root = tk.Tk()
    root.title("Initial Configuration Tab Test")
    
    app_frame = InitialConfigurationTab(master=root)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\right_40\top_10\gui_start_stop.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version corrects the styling of tables and entry widgets for a more cohesive look.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250823.001500.20

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from datasets.logging import debug_log, console_log
from workers.mqtt_controller_util import MqttControllerUtility
from display.styling.style import THEMES, DEFAULT_THEME

# --- Global Scope Variables ---
CURRENT_DATE = 20250823
CURRENT_TIME = 1500
CURRENT_TIME_HASH = 1500
REVISION_NUMBER = 20
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class is now designed as a self-contained "island" that manages its own MQTT state.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # We apply the style at the top of the __init__ to affect all child widgets.
            self._apply_styles(theme_name=DEFAULT_THEME)

            # Create a label for the frame
            frame_label = ttk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = ttk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame, style="Custom.TEntry")
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = ttk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)

            # We now register our callback with the central utility instead of overwriting the client's callback.
            parent_folder = str(pathlib.Path(self.current_file).parent)
            subscription_topic = f"{parent_folder.replace('\\', '/')}/#"
            self.mqtt_util.add_subscriber(topic_filter=subscription_topic, callback_func=self._on_mqtt_message)


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings", style="Custom.Treeview")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            # New frame for log buttons, placed at the bottom below the table.
            log_button_frame = ttk.Frame(self)
            log_button_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=10, pady=5)

            # Button 1: Log
            self.log_button = ttk.Button(
                log_button_frame, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = ttk.Button(
                log_button_frame, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        """
        colors = THEMES.get(theme_name, THEMES["dark"])
        style = ttk.Style(self)
        style.theme_use("clam")
        
        # General widget styling
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])

        # Table (Treeview) styling
        style.configure('Custom.Treeview',
                        background=colors["table_bg"],
                        foreground=colors["table_fg"],
                        fieldbackground=colors["table_bg"],
                        bordercolor=colors["table_border"],
                        borderwidth=colors["border_width"])

        style.configure('Custom.Treeview.Heading',
                        background=colors["table_heading_bg"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

        # Entry (textbox) styling
        style.configure('Custom.TEntry',
                        fieldbackground=colors["entry_bg"],
                        foreground=colors["entry_fg"],
                        bordercolor=colors["table_border"])
        
    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            message_content = json.loads(payload)["value"]
            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\styling\style.py
#####################################
# styling/style.py
#
# Defines the color palettes for different UI themes, providing a centralized
# source for application-wide style configurations.
# This version corrects a SyntaxError caused by a leading zero in a numeric literal.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.235900.3

# 📚 Standard library import for the global variables.
import os

# --- Global Scope Variables ---
# W: The date of the chat session in YYYYMMDD format.
CURRENT_DATE = 20250822
# X: The time of the chat session in HHMMSS format.
# FIX: Removed the leading zero to resolve the SyntaxError.
CURRENT_TIME = 235900
# A numeric hash of the time, useful for unique IDs.
# FIX: Updated to a decimal literal.
CURRENT_TIME_HASH = 235900
# Y: The revision number within the current session.
REVISION_NUMBER = 3
# Assembling the full version string as per the protocol (W.X.Y).
current_version = "20250822.235900.3"
# Creating a unique integer hash for the current version for internal tracking.
current_version_hash = (CURRENT_DATE * CURRENT_TIME_HASH * REVISION_NUMBER)
# Getting the name of the current file to use in our logs.
current_file = f"{os.path.basename(__file__)}"

# 🎨 THEMES is a dictionary that holds all our color palettes.
THEMES = {
    # 🌑 The "dark" theme, inspired by dark IDE color schemes.
    "dark": {
        "bg": "#2b2b2b",
        "fg": "#dcdcdc",
        "primary": "#3c3f41",
        "secondary": "#4e5254",
        "accent": "#007acc",
        "text": "#ffffff",
        "border": "#555555",
        "relief": "solid",
        "border_width": 1,
        "padding": 1,
        "tab_content_padding": 1,
        # --- New Styling Variables for Tables and Entries ---
        "table_bg": "#3c3f41",
        "table_fg": "#dcdcdc",
        "table_heading_bg": "#4e5254",
        "table_border": "#555555",
        "entry_bg": "#4e5254",
        "entry_fg": "#dcdcdc",
        # ----------------------------------------------------
        "accent_colors": [
            "#996633",  # 1. Brown
            "#c75450",  # 2. Red
            "#d18616",  # 3. Orange
            "#dcdcaa",  # 4. Yellow
            "#6a9955",  # 5. Green
            "#007acc",  # 6. Blue
            "#6464a3",  # 7. Violet
            "#ce9178",  # 8. Tan
            "#b5cea8",  # 9. Gray-Green
        ]
    },
    # 🌞 The "light" theme, providing a high-contrast alternative.
    "light": {
        "bg": "#f0f0f0",
        "fg": "#000000",
        "primary": "#ffffff",
        "secondary": "#e0e0e0",
        "accent": "#0078d7",
        "text": "#000000",
        "border": "#ababab",
        "relief": "groove",
        "border_width": 1,
        "padding": 1,
        "tab_content_padding": 1,
        # --- New Styling Variables for Tables and Entries ---
        "table_bg": "#ffffff",
        "table_fg": "#000000",
        "table_heading_bg": "#e0e0e0",
        "table_border": "#ababab",
        "entry_bg": "#ffffff",
        "entry_fg": "#000000",
        # ----------------------------------------------------
        "accent_colors": [
            "#A0522D",  # 1. Brown (Sienna)
            "#D22B2B",  # 2. Red (Firebrick)
            "#FF8C00",  # 3. Orange (DarkOrange)
            "#FFD700",  # 4. Yellow (Gold)
            "#228B22",  # 5. Green (ForestGreen)
            "#4169E1",  # 6. Blue (RoyalBlue)
            "#8A2BE2",  # 7. Violet (BlueViolet)
            "#D2691E",  # 8. Tan (Chocolate)
            "#556B2F",  # 9. Gray-Green (DarkOliveGreen)
        ]
    }
}

# 🛠️ The default theme to use. This can be changed here to easily switch the entire application's style.
DEFAULT_THEME = "dark"


#####################################
### File: OPEN-AIR 2\workers\connection_status_logic.py
#####################################
# src/connection_status_logic.py
#
# This file contains the core logic for updating the graphical user interface (GUI)
# elements based on the instrument's connection status and the current running state.
# It acts as a centralized function to enable or disable buttons and other widgets
# across various tabs, ensuring the UI accurately reflects the application's status.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250813.163700.1

import tkinter as tk
import inspect
import os

from display.debug_logic import debug_log
from display.console_logic import console_log

# --- Version Information ---
current_version = "20250813.163700.1"
current_version_hash = (20250813 * 163700 * 1)


def update_connection_status_logic(app_instance, is_connected, is_running, console_print_func):
    """
    Updates the state (enabled/disabled) of various GUI elements across different tabs
    based on the instrument's connection status and the current running state.
    This function acts as a central dispatcher for UI state changes.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Updating connection status. Connected: {is_connected}, Running: {is_running}. Version: {current_version}",
                file=f"{os.path.basename(__file__)} - {current_version}",
                version=current_version,
                function=current_function)

    # --- Instrument Tab ---
    if hasattr(app_instance, 'instrument_parent_tab') and hasattr(app_instance.instrument_parent_tab, 'instrument_settings_tab'):
        instrument_tab = app_instance.instrument_parent_tab.instrument_settings_tab
        if hasattr(instrument_tab, '_update_ui_state'):
            instrument_tab._update_ui_state()

    # --- Orchestrator GUI ---
    # CHANGED: Reference the new orchestrator_gui attribute
    if hasattr(app_instance, 'orchestrator_gui'):
        app_instance.orchestrator_gui._update_button_states()
        debug_log("Orchestrator GUI buttons updated.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
    else:
        debug_log("Orchestrator GUI instance not found during status update.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)

    # --- Presets Tab ---
    if hasattr(app_instance, 'presets_parent_tab') and hasattr(app_instance.presets_parent_tab, 'device_presets_tab'):
        device_presets_tab = app_instance.presets_parent_tab.device_presets_tab
        if hasattr(device_presets_tab, 'handle_connection_status_change_event'):
            device_presets_tab.handle_connection_status_change_event()
            debug_log("Device Presets Tab notified of connection change.",
                        file=f"{os.path.basename(__file__)} - {current_version}",
                        version=current_version,
                        function=current_function)

    debug_log("Finished updating all UI elements based on connection status. UI is now responsive!",
                file=f"{os.path.basename(__file__)} - {current_version}",
                version=current_version,
                function=current_function)

#####################################
### File: OPEN-AIR 2\workers\mqtt_controller_util.py
#####################################
# utils/mqtt_controller_util.py
#
# A utility module to handle the logic for interfacing with an external MQTT broker.
# This version refactors the client to centrally manage subscriptions and dispatch messages.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250823.123548.2

import os
import inspect
import datetime
import paho.mqtt.client as mqtt
import subprocess
import threading
import json
import pathlib
import sys

# --- Module Imports ---
# Path manipulation is now handled by main.py
from datasets.logging import debug_log, console_log

# --- Global Scope Variables (as per your instructions) ---
current_version = "20250823.123548.2"
current_version_hash = (20250823 * 123548 * 2)
current_file = f"{os.path.basename(__file__)}"

# --- Constant Variables (No Magic Numbers) ---
# MQTT Broker settings
BROKER_ADDRESS = "localhost"
BROKER_PORT = 1883
BROKER_TIMEOUT = 60
# Logging messages and colors
BROKER_RUNNING_MSG = "Broker is running"
BROKER_NOT_RUNNING_MSG = "Broker is not running"
BROKER_ALREADY_RUNNING_MSG = "Mosquitto is already running!"
FAILED_TO_START_BROKER_MSG = "Failed to start mosquitto process: "
BROKER_STOPPED_MSG = "Broker stopped"
NOT_CONNECTED_MSG = "Not connected to broker."
NO_TOPIC_OR_VALUE_MSG = "Please enter a topic and a value."


class MqttControllerUtility:
    """
    Manages all communication logic for the MQTT broker and client.
    This class is the central point for all functions to push a message or subscribe to messages.
    It adheres to the "Utilities" layer principles of your protocol.
    """
    def __init__(self, print_to_gui_func, log_treeview_func):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message=f"🛠️🟢 Initializing the '{self.__class__.__name__}' utility class. Powering up the flux capacitor!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=print_to_gui_func
        )
        
        try:
            # --- Function logic goes here ---
            self.mosquitto_process = None
            self.mqtt_client = None
            self._print_to_gui_console = print_to_gui_func
            self._log_to_treeview = log_treeview_func
            self.topics_seen = set()
            self._subscribers = {} # A new dictionary to hold subscribers and their callbacks

            console_log("✅ Celebration of success!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self._print_to_gui_console
            )
            
    def add_subscriber(self, topic_filter: str, callback_func):
        """Adds a callback function to be triggered for a specific topic filter."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🛠️🟢 New subscriber added for topic filter: '{topic_filter}'.",
            file=current_file,
            version=current_version,
            function=current_function_name,
            console_print_func=self._print_to_gui_console
        )
        self._subscribers[topic_filter] = callback_func
        # This is the single place we subscribe to a topic.
        self.mqtt_client.subscribe(topic_filter)
        debug_log(
            message=f"🛠️🟢 New subscriber added for topic filter: '{topic_filter}'.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.add_subscriber",
            console_print_func=self._print_to_gui_console
        )


    # --- Broker and MQTT Methods ---
    def start_mosquitto(self):
        """Starts the Mosquitto broker process if it's not already running."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🛠️🟢 Entering '{current_function_name}' to start the broker.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=self._print_to_gui_console
        )
        try:
            if self.mosquitto_process and self.mosquitto_process.poll() is None:
                console_log(f"⚠️ {BROKER_ALREADY_RUNNING_MSG}")
                return
            
            self.mosquitto_process = subprocess.Popen(args=["mosquitto"])
            console_log("✅ Broker started successfully!")
            
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {FAILED_TO_START_BROKER_MSG}{e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self._print_to_gui_console
            )

    def stop_mosquitto(self):
        """Stops the Mosquitto broker process if it's running."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🛠️🟢 Entering '{current_function_name}' to stop the broker.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=self._print_to_gui_console
        )
        try:
            if self.mosquitto_process and self.mosquitto_process.poll() is None:
                self.mosquitto_process.terminate()
                self.mosquitto_process = None
                console_log(f"✅ {BROKER_STOPPED_MSG}")
            else:
                console_log(f"⚠️ {BROKER_NOT_RUNNING_MSG}")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self._print_to_gui_console
            )

    def check_status(self):
        """Checks and reports the status of the Mosquitto broker."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🛠️🟢 Entering '{current_function_name}' to check broker status.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=self._print_to_gui_console
        )
        try:
            if self.mosquitto_process and self.mosquitto_process.poll() is None:
                console_log(f"✅ {BROKER_RUNNING_MSG}")
            else:
                console_log(f"❌ {BROKER_NOT_RUNNING_MSG}")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self._print_to_gui_console
            )

    def on_connect(self, client, userdata, flags, rc):
        """Callback for when the MQTT client connects to the broker."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🛠️🔵 MQTT client connected with rc={rc}. Subscribing to all topics!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=self._print_to_gui_console
        )
        # We subscribe to a wildcard topic once to catch everything.
        client.subscribe("#")
        self._print_to_gui_console(f"Connected to broker with rc={rc}")

    def on_message(self, client, userdata, msg):
        """Callback for when an MQTT message is received."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # We process the message payload here for all listeners
        topic = msg.topic
        payload = msg.payload.decode()
        self.topics_seen.add(topic)
        
        # Now we dispatch the message to all registered subscribers.
        # FIX: Iterate over a copy of the dictionary to prevent RuntimeError.
        for topic_filter, callback_func in list(self._subscribers.items()):
            # The paho-mqtt library provides a topic_matches_sub function to check for wildcards.
            if mqtt.topic_matches_sub(topic_filter, topic):
                debug_log(
                    message=f"🛠️🔵 Dispatching message to subscriber for topic '{topic_filter}'.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.on_message",
                    console_print_func=self._print_to_gui_console
                )
                callback_func(topic, payload)


    def connect_mqtt(self):
        """Connects the MQTT client to the broker in a separate thread."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🛠️🟢 Entering '{current_function_name}' to connect MQTT client.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=self._print_to_gui_console
        )
        try:
            self.mqtt_client = mqtt.Client()
            self.mqtt_client.on_connect = self.on_connect
            self.mqtt_client.on_message = self.on_message
            self.mqtt_client.connect(host=BROKER_ADDRESS, port=BROKER_PORT, keepalive=BROKER_TIMEOUT)
            
            thread = threading.Thread(target=self.mqtt_client.loop_forever, daemon=True)
            thread.start()
            self._print_to_gui_console("✅ MQTT client connection initiated in a background thread.")

        except Exception as e:
            self._print_to_gui_console(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self._print_to_gui_console
            )

    def show_topics(self):
        """Displays a list of all topics seen by the MQTT client."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🛠️🟢 Entering '{current_function_name}' to display topics.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=self._print_to_gui_console
        )
        try:
            if self.topics_seen:
                topics_str = "\n".join(sorted(self.topics_seen))
                self._print_to_gui_console(f"Observed Topics:\n{topics_str}")
            else:
                self._print_to_gui_console("⚠️ No topics observed yet.")

        except Exception as e:
            self._print_to_gui_console(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self._print_to_gui_console
            )

    def publish_message(self, topic: str, subtopic: str, value):
        """Publishes a message to a topic via the MQTT client."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🛠️🟢 Entering '{current_function_name}' to publish a message.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=self._print_to_gui_console
        )
        try:
            # FIX: We now check only for a valid topic and value.
            if not topic or not value:
                self._print_to_gui_console(f"❌ {NO_TOPIC_OR_VALUE_MSG}")
                return

            # FIX: We construct the full topic based on whether a subtopic is provided.
            full_topic = f"{topic}/{subtopic}" if subtopic else topic
            payload = json.dumps({"value": value})

            if self.mqtt_client:
                self.mqtt_client.publish(full_topic, payload)
                self._print_to_gui_console(f"Published to {full_topic}: {payload}")
                # The console log is moved here to prevent the false success message.
                console_log(f"✅ Published message to topic '{full_topic}'.")
            else:
                self._print_to_gui_console(f"❌ {NOT_CONNECTED_MSG}")

        except Exception as e:
            self._print_to_gui_console(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self._print_to_gui_console
            )

#####################################
### File: OPEN-AIR 2\workers\utils_csv_writer.py
#####################################
# csv_utils.py
#
# This module provides utility functions for writing spectrum scan data to CSV files.
# It encapsulates the logic for handling file paths, directory creation, and data formatting
# for CSV output, ensuring consistent data storage for analysis and historical tracking.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
# Version 20250810.134500.1 (FIXED: Added app_instance_ref parameter and wrapped console calls with after() to prevent GIL errors.)

current_version = "20250810.134500.1" # this variable should always be defined below the header to make the debugging better
current_version_hash = 20250810 * 134500 * 1 # Example hash, adjust as needed

import csv
import os
import inspect # Import inspect module

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log

def write_scan_data_to_csv(file_path, header, data, app_instance_ref, append_mode=False, console_print_func=None):
    """
    Writes scan data to a CSV file. This function is designed to write raw frequency
    and amplitude data collected from the spectrum analyzer. It handles creating
    the necessary directory structure if it doesn't exist and conditionally writes
    the header.

    Inputs:
        file_path (str): The full path to the CSV file where the data will be written.
        header (list or None): A list of strings representing the CSV header row.
                               If None, no header will be written.
        data (list): A list of lists or tuples, where each inner list/tuple represents
                     a row of data (e.g., [frequency_mhz, level_dbm]).
        app_instance_ref (object): A reference to the main application instance.
        append_mode (bool): If True, data will be appended to the file if it exists.
                            If False, the file will be overwritten.
        console_print_func (function, optional): Function to use for console output.
                                                  Defaults to console_log if None.
    Raises:
        IOError: If there is an issue writing to the file.
    """
    console_print_func = console_print_func if console_print_func else console_log # Use console_log as default
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Attempting to write scan data to CSV: {file_path}, append_mode={append_mode}. Let's save this data!",
                file=__file__,
                version=current_version,
                function=current_function)

    # Ensure the directory exists
    output_dir = os.path.dirname(file_path)
    if output_dir and not os.path.exists(output_dir):
        try:
            os.makedirs(output_dir)
            debug_log(f"Created directory: {output_dir}. Path cleared!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        except OSError as e:
            error_msg = f"❌ Error creating directory '{output_dir}': {e}. This is a disaster!"
            # WRAPPED WITH after() to prevent cross-thread access
            app_instance_ref.after(0, lambda: console_print_func(error_msg))
            debug_log(error_msg,
                        file=__file__,
                        version=current_version,
                        function=current_function)
            raise IOError(f"Failed to create directory {output_dir}") from e

    try:
        # Determine the mode and if header needs to be written
        file_exists = os.path.exists(file_path)
        
        # If not in append_mode, or if in append_mode but file doesn't exist, open in write mode.
        # Otherwise, open in append mode.
        mode = 'a' if append_mode and file_exists else 'w'
        
        # Flag to indicate if header needs to be written
        # Write header ONLY if header is not None and we are creating a new file or overwriting
        write_header = (header is not None) and (mode == 'w')

        with open(file_path, mode, newline='') as csv_file:
            csv_writer = csv.writer(csv_file)
            
            if write_header:
                csv_writer.writerow(header)
                debug_log(f"Wrote header to CSV file: {file_path}. Header added!",
                            file=__file__,
                            version=current_version,
                            function=current_function)
            
            # Write data rows
            for freq_mhz, level_dbm in data:
                csv_writer.writerow([f"{freq_mhz:.3f}", f"{level_dbm:.3f}"])
        # WRAPPED WITH after() to prevent cross-thread access
        app_instance_ref.after(0, lambda: console_print_func(f"✅ Scan data written to CSV: {file_path}. Data saved!"))
        debug_log(f"Scan data written to CSV: {file_path}. Mission accomplished!",
                    file=__file__,
                    version=current_version,
                    function=current_function)
    except IOError as e:
        error_msg = f"❌ I/O Error writing to CSV file {file_path}: {e}. This is a disaster!"
        # WRAPPED WITH after() to prevent cross-thread access
        app_instance_ref.after(0, lambda: console_print_func(error_msg))
        debug_log(error_msg,
                    file=__file__,
                    version=current_version,
                    function=current_function)
        raise # Re-raise to allow higher-level error handling
    except Exception as e:
        error_msg = f"❌ An unexpected error occurred while writing to CSV file {file_path}: {e}. What a mess!"
        # WRAPPED WITH after() to prevent cross-thread access
        app_instance_ref.after(0, lambda: console_print_func(error_msg))
        debug_log(error_msg,
                    file=__file__,
                    version=current_version,
                    function=current_function)
        raise # Re-raise to allow higher-level error handling


#####################################
### File: OPEN-AIR 2\workers\utils_display_monitor.py
#####################################
# display/utils_display_monitor.py
#
# This module provides utility functions to interact with and update the plots
# in the Scan Monitor display tab.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250814.091200.1

current_version = "20250814.091200.1"
current_version_hash = (20250814 * 91200 * 1)

import inspect
import os
import traceback 
import numpy as np
from matplotlib.offsetbox import AnchoredText 

from display.debug_logic import debug_log
from display.console_logic import console_log


def _find_and_plot_peaks(ax, data, start_freq_mhz, end_freq_mhz):
    # [A brief, one-sentence description of the function's purpose.]
    # Finds and plots local peaks on a Matplotlib axis.
    debug_log(f"Entering _find_and_plot_peaks with {len(data) if data else 0} data points.",
                file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

    try:
        if not data:
            console_log("✅ No data to search for peaks.")
            return

        x_data = np.array(data)[:, 0]
        y_data = np.array(data)[:, 1]
        
        total_span = end_freq_mhz - start_freq_mhz
        segment_width = total_span / 150
        peaks = []
        i = 0
        while i < len(x_data):
            segment_end_freq = x_data[i] + segment_width
            segment_indices = np.where((x_data >= x_data[i]) & (x_data <= segment_end_freq))
            if not segment_indices[0].any():
                i += 1
                continue
            
            segment_y_data = y_data[segment_indices]
            segment_x_data = x_data[segment_indices]
            peak_y = np.max(segment_y_data)
            peak_x = segment_x_data[np.argmax(segment_y_data)]
            peaks.append((peak_x, peak_y))

            next_i_candidate = np.where(x_data >= peak_x + segment_width)[0]
            i = next_i_candidate[0] if len(next_i_candidate) > 0 else len(x_data)
        
        sorted_peaks = sorted(peaks, key=lambda p: p[1], reverse=True)[:10]
        for peak_x, peak_y in sorted_peaks:
            ax.axvline(x=peak_x, color='orange', linestyle='--', linewidth=1, zorder=4)
        
        console_log(f"✅ Found and plotted {len(sorted_peaks)} peaks.")
    except Exception as e:
        console_log(f"❌ Error in _find_and_plot_peaks: {e}")
        debug_log(f"Arrr, the code be capsized in peak finding! The error be: {e}\n{traceback.format_exc()}",
                    file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

def _setup_zoom_events(ax, canvas, original_xlim):
    # [A brief, one-sentence description of the function's purpose.]
    # Sets up event handlers for horizontal zooming on the plot.
    debug_log(f"Entering _setup_zoom_events.", file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)
    
    try:
        drag_start_x = None
        ax.original_xlim = original_xlim

        def on_press(event):
            nonlocal drag_start_x
            if event.button == 1 and event.inaxes == ax:
                drag_start_x = event.xdata

        def on_release(event):
            nonlocal drag_start_x
            if event.button == 1 and event.inaxes == ax and drag_start_x is not None:
                drag_end_x = event.xdata
                if drag_end_x is not None and drag_start_x != drag_end_x:
                    ax.set_xlim(min(drag_start_x, drag_end_x), max(drag_start_x, drag_end_x))
                    canvas.draw_idle()
                drag_start_x = None

        def on_double_click(event):
            if event.button == 1 and event.inaxes == ax:
                reset_zoom(ax=ax, canvas=canvas)

        canvas.mpl_connect('button_press_event', on_press)
        canvas.mpl_connect('button_release_event', on_release)
        canvas.mpl_connect('button_press_event', on_double_click)
        console_log("✅ Zoom events are now live!")
    except Exception as e:
        console_log(f"❌ Error in _setup_zoom_events: {e}")
        debug_log(f"Great Scott! The zoom mechanism has backfired! Error: {e}\n{traceback.format_exc()}",
                    file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

def reset_zoom(ax, canvas):
    # [A brief, one-sentence description of the function's purpose.]
    # Resets the plot to its original, full x-axis view.
    debug_log(f"Entering reset_zoom.", file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)
    try:
        if hasattr(ax, 'original_xlim'):
            ax.set_xlim(ax.original_xlim)
            canvas.draw_idle()
        console_log("✅ Celebration of success! Zoom reset.")
    except Exception as e:
        console_log(f"❌ Error in reset_zoom: {e}")
        debug_log(f"It's madness! The zoom refused to reset! Error: {e}\n{traceback.format_exc()}",
                    file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

def update_top_plot(scan_monitor_tab_instance, data, start_freq_mhz, end_freq_mhz, plot_title):
    # [A brief, one-sentence description of the function's purpose.]
    # Updates the top plot in the Scan Monitor tab with new data.
    debug_log(f"Entering update_top_plot with plot_title: {plot_title}", file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)
        
    try:
        plot_info = scan_monitor_tab_instance.plots["top"]
        ax = plot_info['ax']
        canvas = plot_info['canvas']
        ax.clear()
        
        data_tuples = None
        # FIX: The incoming data DataFrame now has frequencies in MHz.
        # We no longer need to divide by 1,000,000 here.
        if data is not None and not data.empty:
            data_tuples = list(zip(data['Frequency_Hz'], data['Power_dBm']))

        if data_tuples:
            frequencies, amplitudes = zip(*data_tuples)
            ax.plot(frequencies, amplitudes, color='yellow', linewidth=1)
        
        ax.set_title(plot_title, color='white')
        ax.set_xlim(start_freq_mhz, end_freq_mhz)
        ax.set_ylim(-120, 0)
        ax.set_yticks(np.arange(-120, 1, 20))
        ax.grid(True, linestyle='--', color='gray', alpha=0.5)

        annot = ax.annotate("", xy=(0,0), xytext=(20,20), textcoords="offset points",
                            bbox=dict(boxstyle="round", fc="white", ec="black", lw=1),
                            arrowprops=dict(arrowstyle="wedge,tail_width=0.5", fc="white", ec="black"))
        annot.set_visible(False)

        def update_annot(event):
            if data_tuples and event.xdata and event.ydata:
                x_data = np.array(data_tuples)[:, 0]
                y_data = np.array(data_tuples)[:, 1]
                idx = np.abs(x_data - event.xdata).argmin()
                annot.xy = (x_data[idx], y_data[idx])
                annot.set_text(f"Freq: {x_data[idx]:.3f} MHz\nAmp: {y_data[idx]:.2f} dBm")
                annot.set_visible(True)
                canvas.draw_idle()
            else:
                annot.set_visible(False)
                canvas.draw_idle()

        canvas.mpl_connect("motion_notify_event", update_annot)
        
        _find_and_plot_peaks(ax=ax, data=data_tuples, start_freq_mhz=start_freq_mhz, end_freq_mhz=end_freq_mhz)
        _setup_zoom_events(ax=ax, canvas=canvas, original_xlim=(start_freq_mhz, end_freq_mhz))

        canvas.draw()
        console_log("✅ Celebration of success! Top plot updated.")
    except Exception as e:
        console_log(f"❌ Error in update_top_plot: {e}")
        debug_log(f"Arrr, the top plot be capsized! The error be: {e}\n{traceback.format_exc()}",
                    file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

def update_middle_plot(scan_monitor_tab_instance, data, start_freq_mhz, end_freq_mhz, plot_title):
    # [A brief, one-sentence description of the function's purpose.]
    # Updates the middle plot in the Scan Monitor tab with new data.
    debug_log(f"Entering update_middle_plot with plot_title: {plot_title}", file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

    try:
        plot_info = scan_monitor_tab_instance.plots["middle"]
        ax = plot_info['ax']
        canvas = plot_info['canvas']
        ax.clear()

        data_tuples = None
        # FIX: The incoming data DataFrame now has frequencies in MHz.
        # We no longer need to divide by 1,000,000 here.
        if data is not None and not data.empty:
            data_tuples = list(zip(data['Frequency_Hz'], data['Power_dBm']))

        if data_tuples:
            frequencies, amplitudes = zip(*data_tuples)
            ax.plot(frequencies, amplitudes, color='green', linewidth=1)
        
        ax.set_title(plot_title, color='white')
        ax.set_xlim(start_freq_mhz, end_freq_mhz)
        ax.set_ylim(-120, 0)
        ax.set_yticks(np.arange(-120, 1, 20))
        ax.grid(True, linestyle='--', color='gray', alpha=0.5)

        annot = ax.annotate("", xy=(0,0), xytext=(20,20), textcoords="offset points",
                            bbox=dict(boxstyle="round", fc="white", ec="black", lw=1),
                            arrowprops=dict(arrowstyle="wedge,tail_width=0.5", fc="white", ec="black"))
        annot.set_visible(False)

        def update_annot(event):
            if data_tuples and event.xdata and event.ydata:
                x_data = np.array(data_tuples)[:, 0]
                y_data = np.array(data_tuples)[:, 1]
                idx = np.abs(x_data - event.xdata).argmin()
                annot.xy = (x_data[idx], y_data[idx])
                annot.set_text(f"Freq: {x_data[idx]:.3f} MHz\nAmp: {y_data[idx]:.2f} dBm")
                annot.set_visible(True)
                canvas.draw_idle()
            else:
                annot.set_visible(False)
                canvas.draw_idle()

        canvas.mpl_connect("motion_notify_event", update_annot)

        _find_and_plot_peaks(ax=ax, data=data_tuples, start_freq_mhz=start_freq_mhz, end_freq_mhz=end_freq_mhz)
        _setup_zoom_events(ax=ax, canvas=canvas, original_xlim=(start_freq_mhz, end_freq_mhz))
        
        canvas.draw()
        console_log("✅ Celebration of success! Middle plot updated.")
    except Exception as e:
        console_log(f"❌ Error in update_middle_plot: {e}")
        debug_log(f"It's alive! Oh wait, no, the middle plot is dead. Error: {e}\n{traceback.format_exc()}",
                    file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

def update_bottom_plot(scan_monitor_tab_instance, data, start_freq_mhz, end_freq_mhz, plot_title):
    # [A brief, one-sentence description of the function's purpose.]
    # Updates the bottom plot in the Scan Monitor tab with new data.
    debug_log(f"Entering update_bottom_plot with plot_title: {plot_title}", file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)
    
    try:
        plot_info = scan_monitor_tab_instance.plots["bottom"]
        ax = plot_info['ax']
        canvas = plot_info['canvas']
        
        ax.clear()

        data_tuples = None
        # FIX: The incoming data DataFrame now has frequencies in MHz.
        # We no longer need to divide by 1,000,000 here.
        if data is not None and not data.empty:
            data_tuples = list(zip(data['Frequency_Hz'], data['Power_dBm']))

        if data_tuples:
            frequencies, amplitudes = zip(*data_tuples)
            ax.plot(frequencies, amplitudes, color='cyan', linewidth=1)
        
        ax.set_title(plot_title, color='white')
        ax.set_xlim(start_freq_mhz, end_freq_mhz)
        ax.set_ylim(-120, 0)
        ax.set_yticks(np.arange(-120, 1, 20))
        ax.grid(True, linestyle='--', color='gray', alpha=0.5)

        annot = ax.annotate("", xy=(0,0), xytext=(20,20), textcoords="offset points",
                            bbox=dict(boxstyle="round", fc="white", ec="black", lw=1),
                            arrowprops=dict(arrowstyle="wedge,tail_width=0.5", fc="white", ec="black"))
        annot.set_visible(False)

        def update_annot(event):
            if data_tuples and event.xdata and event.ydata:
                x_data = np.array(data_tuples)[:, 0]
                y_data = np.array(data_tuples)[:, 1]
                idx = np.abs(x_data - event.xdata).argmin()
                annot.xy = (x_data[idx], y_data[idx])
                annot.set_text(f"Freq: {x_data[idx]:.3f} MHz\nAmp: {y_data[idx]:.2f} dBm")
                annot.set_visible(True)
                canvas.draw_idle()
            else:
                annot.set_visible(False)
                canvas.draw_idle()

        canvas.mpl_connect("motion_notify_event", update_annot)
        
        _find_and_plot_peaks(ax=ax, data=data_tuples, start_freq_mhz=start_freq_mhz, end_freq_mhz=end_freq_mhz)
        _setup_zoom_events(ax=ax, canvas=canvas, original_xlim=(start_freq_mhz, end_freq_mhz))
        
        canvas.draw()
        console_log("✅ Celebration of success! Bottom plot updated.")
    except Exception as e:
        console_log(f"❌ Error in update_bottom_plot: {e}")
        debug_log(f"Shiver me timbers, the bottom plot has been scuttled! Error: {e}\n{traceback.format_exc()}",
                    file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

def clear_monitor_plots(scan_monitor_tab_instance):
    # [A brief, one-sentence description of the function's purpose.]
    # Clears all three plots in the Scan Monitor tab.
    debug_log(f"Entering clear_monitor_plots.", file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)
                
    try:
        if not scan_monitor_tab_instance:
            console_log("❌ Scan Monitor tab instance could not be found. Cannot clear plots.")
            return

        for plot_name in ["top", "middle", "bottom"]:
            plot_info = scan_monitor_tab_instance.plots.get(plot_name, {})
            ax = plot_info.get('ax')
            canvas = plot_info.get('canvas')
            if ax and canvas:
                ax.clear()
                ax.set_facecolor('#1e1e1e')
                ax.set_title(f"Plot {plot_name.capitalize()} Placeholder", color='white')
                ax.set_ylim(-120, 0)
                ax.set_yticks(np.arange(-120, 1, 20))
                ax.grid(True, linestyle='--', color='gray', alpha=0.5)
                canvas.draw()
        
        console_log("✅ Celebration of success! All monitor plots cleared.")
    except Exception as e:
        console_log(f"❌ Error in clear_monitor_plots: {e}")
        debug_log(f"My creation! It refuses to be cleared! Error: {e}\n{traceback.format_exc()}",
                    file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)


#####################################
### File: OPEN-AIR 2\workers\utils_scan_view.py
#####################################
# display/utils_child_scan_view.py
#
# This module provides utility functions to interact with and update the single plot
# in the Scan View display tab.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250816.222300.1
# MODIFIED: Added line_color parameter to update_single_plot.

current_version = "20250816.222300.1"
current_version_hash = (20250816 * 222300 * 1)

import inspect
import os
import traceback 
import numpy as np
from matplotlib.offsetbox import AnchoredText 

from display.debug_logic import debug_log
from display.console_logic import console_log


def _find_and_plot_peaks(ax, data, start_freq_mhz, end_freq_mhz):
    # [A brief, one-sentence description of the function's purpose.]
    # Finds and plots local peaks on a Matplotlib axis.
    debug_log(f"Entering _find_and_plot_peaks with {len(data) if data else 0} data points.",
                file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

    try:
        if not data:
            console_log("✅ No data to search for peaks.")
            return

        x_data = np.array(data)[:, 0]
        y_data = np.array(data)[:, 1]
        
        total_span = end_freq_mhz - start_freq_mhz
        segment_width = total_span / 150
        peaks = []
        i = 0
        while i < len(x_data):
            segment_end_freq = x_data[i] + segment_width
            segment_indices = np.where((x_data >= x_data[i]) & (x_data <= segment_end_freq))
            if not segment_indices[0].any():
                i += 1
                continue
            
            segment_y_data = y_data[segment_indices]
            segment_x_data = x_data[segment_indices]
            peak_y = np.max(segment_y_data)
            peak_x = segment_x_data[np.argmax(segment_y_data)]
            peaks.append((peak_x, peak_y))

            next_i_candidate = np.where(x_data >= peak_x + segment_width)[0]
            i = next_i_candidate[0] if len(next_i_candidate) > 0 else len(x_data)
        
        sorted_peaks = sorted(peaks, key=lambda p: p[1], reverse=True)[:10]
        for peak_x, peak_y in sorted_peaks:
            ax.axvline(x=peak_x, color='orange', linestyle='--', linewidth=1, zorder=4)
        
        console_log(f"✅ Found and plotted {len(sorted_peaks)} peaks.")
    except Exception as e:
        console_log(f"❌ Error in _find_and_plot_peaks: {e}")
        debug_log(f"Arrr, the code be capsized in peak finding! The error be: {e}\n{traceback.format_exc()}",
                    file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

def _setup_zoom_events(ax, canvas, original_xlim):
    # [A brief, one-sentence description of the function's purpose.]
    # Sets up event handlers for horizontal zooming on the plot.
    debug_log(f"Entering _setup_zoom_events.", file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)
    
    try:
        drag_start_x = None
        ax.original_xlim = original_xlim

        def on_press(event):
            nonlocal drag_start_x
            if event.button == 1 and event.inaxes == ax:
                drag_start_x = event.xdata

        def on_release(event):
            nonlocal drag_start_x
            if event.button == 1 and event.inaxes == ax and drag_start_x is not None:
                drag_end_x = event.xdata
                if drag_end_x is not None and drag_start_x != drag_end_x:
                    ax.set_xlim(min(drag_start_x, drag_end_x), max(drag_start_x, drag_end_x))
                    canvas.draw_idle()
                drag_start_x = None

        def on_double_click(event):
            if event.button == 1 and event.inaxes == ax:
                reset_zoom(ax=ax, canvas=canvas)

        canvas.mpl_connect('button_press_event', on_press)
        canvas.mpl_connect('button_release_event', on_release)
        canvas.mpl_connect('button_press_event', on_double_click)
        console_log("✅ Zoom events are now live!")
    except Exception as e:
        console_log(f"❌ Error in _setup_zoom_events: {e}")
        debug_log(f"Great Scott! The zoom mechanism has backfired! Error: {e}\n{traceback.format_exc()}",
                    file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

def reset_zoom(ax, canvas):
    # [A brief, one-sentence description of the function's purpose.]
    # Resets the plot to its original, full x-axis view.
    debug_log(f"Entering reset_zoom.", file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)
    try:
        if hasattr(ax, 'original_xlim'):
            ax.set_xlim(ax.original_xlim)
            canvas.draw_idle()
        console_log("✅ Celebration of success! Zoom reset.")
    except Exception as e:
        console_log(f"❌ Error in reset_zoom: {e}")
        debug_log(f"It's madness! The zoom refused to reset! Error: {e}\n{traceback.format_exc()}",
                    file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

def update_single_plot(scan_view_tab_instance, data, start_freq_mhz, end_freq_mhz, plot_title, line_color='yellow'):
    # [A brief, one-sentence description of the function's purpose.]
    # Updates the single plot in the Scan View tab with new data.
    debug_log(f"Entering update_plot with plot_title: {plot_title}", file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)
        
    try:
        plot_info = scan_view_tab_instance.plot
        ax = plot_info['ax']
        canvas = plot_info['canvas']
        ax.clear()
        
        data_tuples = None
        if data is not None and not data.empty:
            # FIX: Remove the redundant conversion, as data is already in MHz
            data_tuples = list(zip(data['Frequency_Hz'], data['Power_dBm']))

        if data_tuples:
            frequencies, amplitudes = zip(*data_tuples)
            # FIXED: Used the new line_color parameter
            ax.plot(frequencies, amplitudes, color=line_color, linewidth=1)
        
        ax.set_title(plot_title, color='white')
        ax.set_xlim(start_freq_mhz, end_freq_mhz)
        ax.set_ylim(-120, 0)
        ax.set_yticks(np.arange(-120, 1, 20))
        ax.grid(True, linestyle='--', color='gray', alpha=0.5)

        annot = ax.annotate("", xy=(0,0), xytext=(20,20), textcoords="offset points",
                            bbox=dict(boxstyle="round", fc="white", ec="black", lw=1),
                            arrowprops=dict(arrowstyle="wedge,tail_width=0.5", fc="white", ec="black"))
        annot.set_visible(False)

        def update_annot(event):
            if data_tuples and event.xdata and event.ydata:
                x_data = np.array(data_tuples)[:, 0]
                y_data = np.array(data_tuples)[:, 1]
                idx = np.abs(x_data - event.xdata).argmin()
                annot.xy = (x_data[idx], y_data[idx])
                annot.set_text(f"Freq: {x_data[idx]:.3f} MHz\nAmp: {y_data[idx]:.2f} dBm")
                annot.set_visible(True)
                canvas.draw_idle()
            else:
                annot.set_visible(False)
                canvas.draw_idle()

        canvas.mpl_connect("motion_notify_event", update_annot)
        
        _find_and_plot_peaks(ax=ax, data=data_tuples, start_freq_mhz=start_freq_mhz, end_freq_mhz=end_freq_mhz)
        _setup_zoom_events(ax=ax, canvas=canvas, original_xlim=(start_freq_mhz, end_freq_mhz))

        canvas.draw()
        console_log("✅ Celebration of success! Plot updated.")
    except Exception as e:
        console_log(f"❌ Error in update_plot: {e}")
        debug_log(f"Arrr, the plot be capsized! The error be: {e}\n{traceback.format_exc()}",
                    file=f"{__name__}", version=current_version, function=inspect.currentframe().f_code.co_name)

#####################################
### File: OPEN-AIR 2\workers\controls\tab_markers_child_control_poke.py
#####################################
# tabs/Markers/showtime/controls/tab_markers_child_control_poke.py
#
# This file defines the Poke tab for the ControlsFrame.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.000100.1
# REFACTORED: Removed dependency on `shared_state` object. State is now accessed from the `showtime_tab_instance`.

import os
import inspect
import tkinter as tk
from tkinter import ttk
from datetime import datetime

from display.debug_logic import debug_log
from .utils_showtime_poke import on_poke_action

# --- Versioning ---
w = 20250824
x_str = '000100'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"

class PokeTab(ttk.Frame):
    def __init__(self, parent_notebook, showtime_tab_instance):
        # [Initializes the Poke control tab.]
        debug_log(f"🖥️ 🟢 Entering __init__",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        
        super().__init__(parent_notebook)
        self.showtime_tab_instance = showtime_tab_instance
        self._create_widgets()
        
        debug_log(f"🖥️ 🟢 Exiting __init__",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)

    def _create_widgets(self):
        # [Creates the UI elements for the Poke tab.]
        debug_log(f"🖥️ 🟢 Creating widgets for PokeTab.",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        
        self.poke_entry = ttk.Entry(self, textvariable=self.showtime_tab_instance.poke_freq_var, style='TEntry')
        self.poke_button = ttk.Button(
            self, text="Poke", style='ControlButton.TButton',
            command=lambda: on_poke_action(self.showtime_tab_instance)
        )
        self.poke_entry.pack(side='left', fill='x', expand=True, padx=(0, 5))
        self.poke_button.pack(side='left')
        
        debug_log(f"🖥️ ✅ Widgets created successfully.",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)


#####################################
### File: OPEN-AIR 2\workers\controls\tab_markers_child_control_rbw.py
#####################################
# tabs/Markers/showtime/controls/tab_markers_child_control_rbw.py
#
# Author: Anthony Peter Kuzub
# ... (Full header included)
#
# Version 20250824.000100.1
# REFACTORED: Removed dependency on `shared_state` object. State is now accessed from the `showtime_tab_instance`.

import tkinter as tk
import os
from tkinter import ttk
# Moved import inside method to fix circular import error
# from .utils_showtime_rbw import on_rbw_button_click
from ref.ref_scanner_setting_lists import PRESET_BANDWIDTH_RBW
from display.debug_logic import debug_log
from display.console_logic import console_log
import inspect
from datetime import datetime

# --- Versioning ---
w = 20250824
x = 100
y = 1
current_version = f"Version {w}.{x}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"

# --- Constants for formatting ---
KHZ_TO_HZ = 1_000
MHZ_TO_HZ = 1_000_000

class RBWTab(ttk.Frame):
    def __init__(self, parent_notebook, showtime_tab_instance):
        debug_log(f"🖥️ 🟢 Entering __init__",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        
        super().__init__(parent_notebook)
        self.showtime_tab_instance = showtime_tab_instance

        self._create_widgets()
        
        debug_log(f"🖥️ 🟢 Exiting __init__",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)

    def _create_widgets(self):
        # FIXED: Moved import here to resolve circular import.
        from .utils_showtime_rbw import on_rbw_button_click

        debug_log(f"🖥️ 🟢 Creating widgets for RBWTab.",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        
        self.showtime_tab_instance.rbw_buttons.clear()
        for i, rbw_data in enumerate(PRESET_BANDWIDTH_RBW):
            label = rbw_data.get("label", "N/A")
            value = rbw_data.get("value", 0)

            # Format the button text to show the label and the value
            if value >= MHZ_TO_HZ:
                value_text = f"{value / MHZ_TO_HZ:.3f} MHz"
            elif value >= KHZ_TO_HZ:
                value_text = f"{value / KHZ_TO_HZ:.0f} kHz"
            else:
                value_text = f"{value} Hz"
                
            button_text = f"{label}\n{value_text}"

            btn = ttk.Button(
                self, text=button_text, style='ControlButton.TButton',
                # FIXED: Pass the main showtime_tab_instance, not self
                command=lambda v=value: on_rbw_button_click(self.showtime_tab_instance, v)
            )
            btn.grid(row=0, column=i, sticky='ew', padx=2, pady=2)
            self.showtime_tab_instance.rbw_buttons[str(value)] = btn
        self.grid_columnconfigure(list(range(len(PRESET_BANDWIDTH_RBW))), weight=1)
        
        debug_log(f"🖥️ ✅ Widgets created successfully.",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)


#####################################
### File: OPEN-AIR 2\workers\controls\tab_markers_child_control_span.py
#####################################
# tabs/Markers/showtime/controls/tab_markers_child_control_span.py
#
# This file defines the Span tab for the ControlsFrame.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: [https://like.audio/category/software/spectrum-scanner/](https://like.audio/category/software/spectrum-scanner/)
# Source Code: [https://github.com/APKaudio/](https://github.com/APKaudio/)
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.001000.1
# REFACTORED: Removed dependency on `shared_state` object. State is now accessed from the `showtime_tab_instance`.

import os
import inspect
import tkinter as tk
from tkinter import ttk
from datetime import datetime

from display.debug_logic import debug_log
from ref.ref_scanner_setting_lists import PRESET_FREQUENCY_SPAN
from .utils_showtime_span import on_span_button_click

# --- Versioning ---
w = 20250824
x = 1000
y = 1
current_version = f"Version {w}.{x}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"

# --- Constants for formatting ---
MHZ_TO_HZ = 1_000_000

class SpanTab(ttk.Frame):
    def __init__(self, parent_notebook, showtime_tab_instance):
        # [Initializes the Span control tab.]
        debug_log(f"🖥️ 🟢 Entering __init__",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        
        super().__init__(parent_notebook)
        self.showtime_tab_instance = showtime_tab_instance
        self._create_widgets()
        
        debug_log(f"🖥️ 🟢 Exiting __init__",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        
    def _create_widgets(self):
        # [Creates the UI elements for the Span tab.]
        debug_log(f"🖥️ 🟢 Creating widgets for SpanTab.",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        
        self.showtime_tab_instance.span_buttons.clear()

        for i, span_data in enumerate(PRESET_FREQUENCY_SPAN):
            label = span_data.get("label", "N/A")
            value = span_data.get("value", 0)
            
            # Format the button text to show the label and the value in MHz
            button_text = f"{label}\n{value / MHZ_TO_HZ:.3f} MHz"

            btn = ttk.Button(
                self, text=button_text, style='ControlButton.TButton',
                command=lambda v=value: on_span_button_click(self.showtime_tab_instance, v)
            )
            btn.grid(row=0, column=i, sticky='ew', padx=2, pady=2)
            self.showtime_tab_instance.span_buttons[str(value)] = btn

        self.grid_columnconfigure(list(range(len(PRESET_FREQUENCY_SPAN))), weight=1)

        debug_log(f"🖥️ ✅ Widgets created successfully.",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)


#####################################
### File: OPEN-AIR 2\workers\controls\tab_markers_child_control_traces.py
#####################################
# tabs/Markers/showtime/controls/tab_markers_child_control_traces.py
#
# This file defines the Trace tab for the ControlsFrame.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: [https://like.audio/category/software/spectrum-scanner/](https://like.audio/category/software/spectrum-scanner/)
# Source Code: [https://github.com/APKaudio/](https://github.com/APKaudio/)
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.001000.1
# REFACTORED: Removed dependency on `shared_state` object. State is now accessed from the `showtime_tab_instance`.

import os
import inspect
import tkinter as tk
from tkinter import ttk
from datetime import datetime

from display.debug_logic import debug_log
# FIXED: Defer import to avoid circular dependency
# from .utils_showtime_trace import execute_trace_action

# --- Versioning ---
w = 20250824
x = 1000
y = 1
current_version = f"Version {w}.{x}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"

class TracesTab(ttk.Frame):
    def __init__(self, parent_notebook, showtime_tab_instance):
        # [Initializes the Traces control tab.]
        debug_log(f"🖥️ 🟢 Entering __init__",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        
        super().__init__(parent_notebook)
        self.showtime_tab_instance = showtime_tab_instance
        self._create_widgets()
        
        debug_log(f"🖥️ 🟢 Exiting __init__",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)

    def _create_widgets(self):
        # FIXED: Move import here to resolve circular import.
        from .utils_showtime_trace import execute_trace_action

        # [Creates the UI elements for the Traces tab.]
        debug_log(f"🖥️ 🟢 Creating widgets for TracesTab.",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        
        self.showtime_tab_instance.trace_buttons.clear()
        
        # UPDATED: Added the "Min" button to the configuration list
        buttons_config = [
            ("All", lambda: self._toggle_and_execute('all')),
            ("Live", lambda: self._toggle_and_execute('live')),
            ("Max", lambda: self._toggle_and_execute('max')),
            ("Min", lambda: self._toggle_and_execute('min'))
        ]

        for i, (text, command) in enumerate(buttons_config):
            # FIXED: Added a fixed width to ensure all buttons are the same size.
            btn = ttk.Button(self, text=text, style='ControlButton.TButton', command=command, width=12)
            btn.grid(row=0, column=i, sticky='ew', padx=2, pady=2)
            self.showtime_tab_instance.trace_buttons[text.lower()] = btn

        self.grid_columnconfigure(list(range(len(buttons_config))), weight=1)
        self._update_button_styles()
        
        debug_log(f"🖥️ ✅ Widgets created successfully.",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)

    def _toggle_and_execute(self, button_type):
        # [Toggles the state of a trace mode and executes the trace action.]
        debug_log(f"🖥️ 🟢 Entering _toggle_and_execute for button: {button_type}",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        
        from .utils_showtime_trace import execute_trace_action

        target_var = self.showtime_tab_instance.trace_modes.get(button_type)
        if not target_var: return

        # NEW LOGIC: This implements a true exclusive selection
        current_state = target_var.get()
        if not current_state: # Only proceed if the button is not already active
            for mode, var in self.showtime_tab_instance.trace_modes.items():
                if mode == button_type:
                    var.set(True) # Set the clicked button to active
                    debug_log(f"🖥️ 📝 Setting shared state trace mode '{mode}' to active.",
                                file=current_file,
                                version=current_version,
                                function=inspect.currentframe().f_code.co_name)
                else:
                    var.set(False) # Set all other buttons to inactive
                    debug_log(f"🖥️ 📝 Setting shared state trace mode '{mode}' to inactive.",
                                file=current_file,
                                version=current_version,
                                function=inspect.currentframe().f_code.co_name)
            
            self._update_button_styles()
            execute_trace_action(traces_tab_instance=self, action_type=button_type)
        
        # If the button is already active, do nothing.
        debug_log(f"🖥️ 🟢 Exiting _toggle_and_execute",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)


    def _update_button_styles(self):
        # [Updates button styles based on the state of trace mode variables.]
        debug_log(f"🖥️ 🟢 Entering _update_button_styles",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        
        for mode, var in self.showtime_tab_instance.trace_modes.items():
            button = self.showtime_tab_instance.trace_buttons.get(mode)
            if button:
                style = 'ControlButton.Active.TButton' if var.get() else 'ControlButton.Inactive.TButton'
                button.config(style=style)
                
        debug_log(f"🖥️ ✅ Button styles updated successfully.",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)


#####################################
### File: OPEN-AIR 2\workers\controls\tab_markers_child_control_zone_zoom.py
#####################################
# tabs/Markers/showtime/controls/tab_markers_child_control_zone_zoom.py
#
# This file defines the Zone Zoom tab for the ControlsFrame.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: [https://like.audio/category/software/spectrum-scanner/](https://like.audio/category/software/spectrum-scanner/)
# Source Code: [https://github.com/APKaudio/](https://github.com/APKaudio/)
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.001000.1
# REFACTORED: Removed dependency on `shared_state` object. State is now accessed from the `showtime_tab_instance`.

import os
import inspect
import tkinter as tk
from tkinter import ttk
from datetime import datetime

from display.debug_logic import debug_log

# --- Versioning ---
w = 20250824
x_str = '001000'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"

class ZoneZoomTab(ttk.Frame):
    def __init__(self, parent_notebook, showtime_tab_instance):
        # [Initializes the Zone Zoom control tab.]
        debug_log(f"🖥️ 🟢 Entering __init__",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        
        super().__init__(parent_notebook)
        self.showtime_tab_instance = showtime_tab_instance
        self._create_widgets()
        
        debug_log(f"🖥️ 🟢 Exiting __init__",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        
    def _create_widgets(self):
        # FIXED: Moved imports inside this method to resolve the ImportError.
        from .utils_showtime_zone_zoom import set_span_to_all_markers, set_span_to_device, set_span_to_group, set_span_to_zone
        
        # [Creates the UI elements for the Zone Zoom tab.]
        debug_log(f"🖥️ 🟢 Creating widgets for the Zone Zoom tab.",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        
        # Main container uses a two-column grid
        self.grid_columnconfigure(0, weight=1)
        self.grid_columnconfigure(1, weight=1)

        # Left side frame for buttons and buffer dropdown
        left_frame = ttk.Frame(self, style='TFrame')
        left_frame.grid(row=0, column=0, sticky="nsew")
        left_frame.grid_columnconfigure(0, weight=1)

        # Button Frame for Zone/Group/Device/All Markers buttons
        button_frame = ttk.Frame(left_frame, style='TFrame')
        button_frame.grid(row=0, column=0, sticky="ew")

        buttons_config = [
            ("Zone", lambda: set_span_to_zone(self.showtime_tab_instance, self)),
            ("Group", lambda: set_span_to_group(self.showtime_tab_instance, self)),
            ("Device", lambda: set_span_to_device(self.showtime_tab_instance, self)),
            ("All Markers", lambda: set_span_to_all_markers(self.showtime_tab_instance, self))
        ]

        self.showtime_tab_instance.zone_zoom_buttons.clear()
        for i, (text, command) in enumerate(buttons_config):
            btn = ttk.Button(button_frame, text=text, style='ControlButton.TButton', command=command, width=12)
            btn.grid(row=0, column=i, sticky='ew', padx=2, pady=2)
            self.showtime_tab_instance.zone_zoom_buttons[text.lower()] = btn
        button_frame.grid_columnconfigure(list(range(len(buttons_config))), weight=1)

        # Frame for the new "Window Buffer" dropdown
        buffer_frame = ttk.Frame(left_frame, style='TFrame')
        buffer_frame.grid(row=1, column=0, sticky="ew")
        buffer_frame.grid_columnconfigure(1, weight=1)
        
        ttk.Label(buffer_frame, text="Window Buffer (MHz):").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        buffer_options = ["1", "3", "10", "30"]
        self.buffer_dropdown = ttk.Combobox(buffer_frame, textvariable=self.showtime_tab_instance.buffer_var, values=buffer_options, state="readonly")
        self.buffer_dropdown.grid(row=0, column=1, sticky="ew", padx=5, pady=2)
        self.buffer_dropdown.set(self.showtime_tab_instance.buffer_var.get())

        # Right side frame for labels, allowing it to expand
        right_frame = ttk.Frame(self, style='TFrame')
        right_frame.grid(row=0, column=1, sticky="nsew")
        right_frame.grid_rowconfigure(0, weight=1) # The row for labels should expand
        right_frame.grid_columnconfigure(0, weight=1)

        label_frame = ttk.Frame(right_frame, style='TFrame')
        label_frame.grid(row=0, column=0, sticky="nsew")

        # The labels now have a vertical layout
        self.label_left = ttk.Label(label_frame, textvariable=self.showtime_tab_instance.zone_zoom_label_left_var, style='TLabel')
        self.label_center = ttk.Label(label_frame, textvariable=self.showtime_tab_instance.zone_zoom_label_center_var, style='TLabel')
        self.label_right = ttk.Label(label_frame, textvariable=self.showtime_tab_instance.zone_zoom_label_right_var, style='TLabel')

        self.label_left.pack(anchor="w", padx=5)
        self.label_center.pack(anchor="w", padx=5)
        self.label_right.pack(anchor="w", padx=5)
        
        debug_log(f"🖥️ ✅ Widgets created successfully.",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        
    def _sync_ui_from_state(self):
        # [Updates button styles and labels based on the current selection in shared state.]
        debug_log(f"🖥️ 🔄 Syncing UI from shared state.",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        
        # Reset all buttons to inactive first
        for btn in self.showtime_tab_instance.zone_zoom_buttons.values():
            btn.config(style='ControlButton.Inactive.TButton')
            
        # Set the active button based on the last selected type
        if self.showtime_tab_instance.last_selected_type:
            active_btn = self.showtime_tab_instance.zone_zoom_buttons.get(self.showtime_tab_instance.last_selected_type.lower())
            if active_btn:
                active_btn.config(style='ControlButton.Active.TButton')
        else: # Default to "All Markers" if nothing is selected
            all_markers_btn = self.showtime_tab_instance.zone_zoom_buttons.get('all markers')
            if all_markers_btn:
                all_markers_btn.config(style='ControlButton.Active.TButton')

        # Update the labels from the values stored in the shared state
        buffered_start = self.showtime_tab_instance.buffered_start_var.get()
        buffered_stop = self.showtime_tab_instance.buffered_stop_var.get()

        if self.showtime_tab_instance.last_selected_type == 'zone':
            zone_info = self.showtime_tab_instance.selected_zone_info
            count = zone_info.get('device_count', 0)
            self.showtime_tab_instance.zone_zoom_label_left_var.set(f"Zone ({count} Devices)")
            self.showtime_tab_instance.zone_zoom_label_center_var.set(f"Name: {self.showtime_tab_instance.selected_zone}")
            self.showtime_tab_instance.zone_zoom_label_right_var.set(f"Start: {buffered_start:.3f} MHz\nStop: {buffered_stop:.3f} MHz")
        elif self.showtime_tab_instance.last_selected_type == 'group':
            group_info = self.showtime_tab_instance.selected_group_info
            count = group_info.get('device_count', 0)
            self.showtime_tab_instance.zone_zoom_label_left_var.set(f"Group ({count} Devices)")
            self.showtime_tab_instance.zone_zoom_label_center_var.set(f"Name: {self.showtime_tab_instance.selected_group}")
            self.showtime_tab_instance.zone_zoom_label_right_var.set(f"Start: {buffered_start:.3f} MHz\nStop: {buffered_stop:.3f} MHz")
        elif self.showtime_tab_instance.last_selected_type == 'device':
            device_info = self.showtime_tab_instance.selected_device_info
            self.showtime_tab_instance.zone_zoom_label_left_var.set(f"Device: {device_info.get('NAME')}")
            self.showtime_tab_instance.zone_zoom_label_center_var.set(f"Name: {device_info.get('NAME')}")
            self.showtime_tab_instance.zone_zoom_label_right_var.set(f"Center: {device_info.get('CENTER'):.3f} MHz\nStart: {buffered_start:.3f} MHz\nStop: {buffered_stop:.3f} MHz")
        else: # All markers
            all_devices = self.showtime_tab_instance.zgd_frame._get_all_devices_in_zone(self.showtime_tab_instance.zgd_frame.structured_data, None)
            count = len(all_devices) if all_devices else 0
            self.showtime_tab_instance.zone_zoom_label_left_var.set("All Markers")
            self.showtime_tab_instance.zone_zoom_label_center_var.set(f"({count} Devices)")
            self.showtime_tab_instance.zone_zoom_label_right_var.set(f"Start: {buffered_start:.3f} MHz\nStop: {buffered_stop:.3f} MHz")

        debug_log(f"🖥️ ✅ UI synced successfully.",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)

    def _on_tab_selected(self, event):
        # [Handles the event when this tab is selected.]
        debug_log(f"🖥️ 🟢 Entering _on_tab_selected",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)
        self._sync_ui_from_state()
        debug_log(f"🖥️ 🟢 Exiting _on_tab_selected",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)


#####################################
### File: OPEN-AIR 2\workers\controls\tab_markers_parent_bottom_controls.py
#####################################
# tabs/Markers/showtime/controls/tab_markers_parent_bottom_controls.py
#
# This file defines the ControlsFrame, which contains a notebook of child tabs
# for controlling various instrument settings related to markers.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250823.235500.2
# REFACTORED: The ControlsFrame now instantiates its child tabs without the
#             `shared_state` parameter, resolving the `TypeError`.

import tkinter as tk
from tkinter import ttk
import inspect
import os
from datetime import datetime

from display.debug_logic import debug_log
from display.console_logic import console_log
from src.program_style import COLOR_PALETTE, COLOR_PALETTE_TABS, _get_dark_color

# Import the child tab classes
from .tab_markers_child_control_span import SpanTab
from .tab_markers_child_control_rbw import RBWTab
from .tab_markers_child_control_traces import TracesTab
from .tab_markers_child_control_poke import PokeTab
from .tab_markers_child_control_zone_zoom import ZoneZoomTab

# --- Versioning ---
w = 20250823
x_str = '235500'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 2
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"


class ControlsFrame(ttk.LabelFrame):
    def __init__(self, parent_frame, showtime_tab_instance, *args, **kwargs):
        # [Initializes the controls frame, setting up the notebook and tabs.]
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"🖥️ 🟢 Entering __init__",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        super().__init__(parent_frame, text="Controls", style='TLabelframe', **kwargs)
        self.showtime_tab_instance = showtime_tab_instance
        self._create_widgets()
        
        debug_log(f"🖥️ 🟢 Exiting __init__",
                    file=current_file,
                    version=current_version,
                    function=current_function)
    
    def _create_widgets(self):
        # [Creates the notebook and adds all the control tabs to it.]
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"🖥️ 🟢 Creating widgets for ControlsFrame. Building a new control panel! 🛠️",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        
        # --- NEW: Apply custom styling for the control notebook tabs ---
        style = ttk.Style(self)
        active_color = COLOR_PALETTE_TABS['Markers']['active']
        inactive_color = _get_dark_color(active_color)
        
        style.configure('Controls.TNotebook', background=COLOR_PALETTE['background'])
        style.map('Controls.TNotebook.Tab',
                background=[('selected', active_color),
                            ('!selected', inactive_color)],
                foreground=[('selected', COLOR_PALETTE_TABS['Markers']['fg']),
                            ('!selected', 'white')])

        self.child_notebook = ttk.Notebook(self, style='Controls.TNotebook')
        self.child_notebook.pack(expand=True, fill="both")
        
        # Pass the parent instance to all child tabs so they can access the state
        self.span_tab = SpanTab(self.child_notebook, self.showtime_tab_instance)
        self.child_notebook.add(self.span_tab, text="Span")
        
        self.rbw_tab = RBWTab(self.child_notebook, self.showtime_tab_instance)
        self.child_notebook.add(self.rbw_tab, text="RBW")
        
        self.traces_tab = TracesTab(self.child_notebook, self.showtime_tab_instance)
        self.child_notebook.add(self.traces_tab, text="Traces")
        
        self.poke_tab = PokeTab(self.child_notebook, self.showtime_tab_instance)
        self.child_notebook.add(self.poke_tab, text="Poke")
        
        self.zone_zoom_tab = ZoneZoomTab(self.child_notebook, self.showtime_tab_instance)
        self.child_notebook.add(self.zone_zoom_tab, text="Zone Zoom")
        
        self.child_notebook.bind("<<NotebookTabChanged>>", self._on_tab_selected)

        debug_log(f"🖥️ ✅ Widgets created successfully. Child tabs are now present. 🗂️",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        
    def _on_tab_selected(self, event):
        # [Handles the event when a tab is selected in the notebook.]
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"🖥️ 🟢 Entering {current_function}",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        selected_child_tab_id = self.child_notebook.select()
        if selected_child_tab_id:
            selected_child_tab_widget = self.child_notebook.nametowidget(selected_child_tab_id)
            if hasattr(selected_child_tab_widget, '_on_tab_selected'):
                selected_child_tab_widget._on_tab_selected(event)

        debug_log(f"🖥️ 🟢 Exiting {current_function}",
                    file=current_file,
                    version=current_version,
                    function=current_function)
    
    def switch_to_tab(self, tab_name):
        # [Switches the currently displayed tab in the notebook.]
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"🖥️ 🟢 Entering {current_function} with argument: {tab_name}",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        
        try:
            tab_id = -1
            # Iterate through all tabs to find the one with the matching name
            for i, name in enumerate(self.child_notebook.tabs()):
                if self.child_notebook.tab(name, 'text') == tab_name:
                    tab_id = i
                    break
            
            if tab_id != -1:
                self.child_notebook.select(tab_id)
                debug_log(f"🖥️ ✅ Switched to tab: {tab_name}",
                            file=current_file,
                            version=current_version,
                            function=current_function)
            else:
                debug_log(f"🖥️ ❌ Error switching to tab '{tab_name}': Tab not found.",
                            file=current_file,
                            version=current_version,
                            function=current_function)

        except Exception as e:
            debug_log(f"🖥️ ❌ Error switching to tab '{tab_name}': {e}",
                        file=current_file,
                        version=current_version,
                        function=current_function)

        debug_log(f"🖥️ 🟢 Exiting {current_function}",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        
    def _update_control_buttons(self):
        # This function updates the state and style of all control buttons.
        # It's called when a variable changes to ensure the UI is in sync.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"🖥️ 🔄 Updating control button styles.",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        try:
            # Span buttons
            current_span_hz = self.showtime_tab_instance.span_var.get()
            for value_str, btn in self.showtime_tab_instance.span_buttons.items():
                if value_str == current_span_hz:
                    btn.config(style='ControlButton.Active.TButton')
                else:
                    btn.config(style='ControlButton.Inactive.TButton')
                    
            # RBW buttons
            current_rbw_hz = self.showtime_tab_instance.rbw_var.get()
            for value_str, btn in self.showtime_tab_instance.rbw_buttons.items():
                if value_str == current_rbw_hz:
                    btn.config(style='ControlButton.Active.TButton')
                else:
                    btn.config(style='ControlButton.Inactive.TButton')
            
            # Trace buttons
            for mode_name, mode_var in self.showtime_tab_instance.trace_modes.items():
                button = self.showtime_tab_instance.trace_buttons.get(mode_name)
                if button:
                    if mode_var.get():
                        button.config(style='ControlButton.Active.TButton')
                    else:
                        button.config(style='ControlButton.Inactive.TButton')

            debug_log(f"🖥️ ✅ Control button styles updated successfully.",
                        file=current_file,
                        version=current_version,
                        function=current_function)
        except Exception as e:
            debug_log(f"🖥️ ❌ Error updating control buttons: {e}",
                        file=current_file,
                        version=current_version,
                        function=current_function)



#####################################
### File: OPEN-AIR 2\workers\controls\utils_showtime_plot.py
#####################################
# tabs/Markers/showtime/controls/utils_showtime_plot.py
#
# This utility file centralizes all logic for fetching and plotting trace data
# from the instrument. It is designed to be called by the UI and acts as a
# high-level API for triggering trace actions and updating the display.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.003000.1
# FIXED: The plotting functions are now correctly imported from `utils_display_monitor.py`
#        and `utils_scan_view.py` instead of being defined here, resolving the issue
#        of displaying plots on the monitor tab.
# FIXED: Corrected the `plot_all_traces` function to correctly access attributes from the `showtime_tab_instance`.
# FIXED: Corrected versioning to adhere to project standards.

import os
import inspect
import pandas as pd
import tkinter as tk
from ref.ref_frequency_bands import MHZ_TO_HZ
from display.debug_logic import debug_log
from display.console_logic import console_log

# Import plotting functions from the display utilities
from display.utils_display_monitor import update_top_plot, update_middle_plot, update_bottom_plot

# --- Versioning ---
w = 20250824
x = 3000
y = 1
current_version = f"Version {w}.{x}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"


def plot_all_traces(showtime_tab_instance, trace_data_dict, view_name, start_freq_mhz, stop_freq_mhz):
    # [Updates the display plots with trace data from the instrument.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Entering {current_function} with view_name: {view_name}",
              file=f"{os.path.basename(__file__)}",
              version=current_version,
              function=current_function)
    
    if trace_data_dict:
        monitor_tab = showtime_tab_instance.app_instance.display_parent_tab.bottom_pane.scan_monitor_tab
        if monitor_tab:
            df1 = pd.DataFrame(trace_data_dict["TraceData"]["Trace1"], columns=['Frequency_Hz', 'Power_dBm'])
            update_top_plot(monitor_tab, df1, start_freq_mhz, stop_freq_mhz, f"Live Trace - {view_name}")
            
            df2 = pd.DataFrame(trace_data_dict["TraceData"]["Trace2"], columns=['Frequency_Hz', 'Power_dBm'])
            update_middle_plot(monitor_tab, df2, start_freq_mhz, stop_freq_mhz, f"Max Hold - {view_name}")

            df3 = pd.DataFrame(trace_data_dict["TraceData"]["Trace3"], columns=['Frequency_Hz', 'Power_dBm'])
            update_bottom_plot(monitor_tab, df3, start_freq_mhz, stop_freq_mhz, f"Min Hold - {view_name}")
            
            showtime_tab_instance.console_print_func("✅ Successfully updated monitor with all three traces.")
            
            # This is a bit of a hack to ensure the monitor tab is visible
            showtime_tab_instance.app_instance.display_parent_tab.change_display_tab('Monitor')
        else:
            showtime_tab_instance.console_print_func("❌ Scan Monitor tab not found.")
    else:
        showtime_tab_instance.console_print_func("❌ Failed to retrieve trace data.")
        debug_log(f"Shiver me timbers, the trace data be lost at sea!",
                  file=f"{os.path.basename(__file__)}",
                  version=current_version,
                  function=current_function)


#####################################
### File: OPEN-AIR 2\workers\controls\utils_showtime_poke.py
#####################################
# tabs/Markers/showtime/controls/utils_showtime_poke.py
#
# This utility file provides the backend logic for the PokeTab. It contains
# functions that handle button clicks for Poking and then communicates with
# the instrument control layer.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.002500.1
# REFACTORED: Removed dependency on `shared_state` object. State is now accessed
#             from the `showtime_tab_instance`.

import os
import inspect
import pandas as pd
from ref.ref_frequency_bands import MHZ_TO_HZ
from display.debug_logic import debug_log
from display.console_logic import console_log
from yak.Yakety_Yak import YakSet
from settings_and_config.config_manager_save import save_program_config 

# Import dedicated utility functions from their respective modules
from .utils_showtime_span import format_hz
from yak.utils_yakbeg_handler import handle_freq_center_span_beg

# --- Versioning ---
w = 20250824
x = 2500
y = 1
current_version = f"Version {w}.{x}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"

def on_poke_action(showtime_tab_instance):
    # [Sets center frequency and span simultaneously using the YakBeg handler.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"Entering {current_function}", file=f"{os.path.basename(__file__)}", version=current_version, function=current_function)
    
    try:
        # 📖 Read Data: Retrieve poke and span values.
        center_freq_mhz = float(showtime_tab_instance.poke_freq_var.get())
        span_hz = int(showtime_tab_instance.span_var.get())
        debug_log(message=f"📖 Reading state: poke_freq_var = {center_freq_mhz} MHz, span_var = {span_hz} Hz", file=f"{os.path.basename(__file__)}", version=current_version, function=current_function)
        
        center_freq_hz = int(center_freq_mhz * MHZ_TO_HZ)
        
        showtime_tab_instance.console_print_func(f"Poking instrument: Center={center_freq_mhz} MHz, Span={format_hz(span_hz)}...")
        
        response = handle_freq_center_span_beg(
            app_instance=showtime_tab_instance.app_instance, 
            center_freq=center_freq_hz, 
            span_freq=span_hz,
            console_print_func=showtime_tab_instance.console_print_func
        )
        
        if response and len(response) >= 2:
            returned_center, returned_span, _, _ = response
            showtime_tab_instance.console_print_func(
                f"✅ Instrument Confirmed: Center={returned_center / MHZ_TO_HZ:.3f} MHz, Span={format_hz(returned_span)}"
            )
            # FIXED: Save config after a successful poke action
            save_program_config (config=showtime_tab_instance.app_instance.config,
                        file_path=showtime_tab_instance.app_instance.CONFIG_FILE_PATH,
                        console_print_func=showtime_tab_instance.console_print_func,
                        app_instance=showtime_tab_instance.app_instance)

        else:
            showtime_tab_instance.console_print_func("❌ Poke command failed. Instrument did not confirm settings.")
            
    except ValueError:
        showtime_tab_instance.console_print_func("⚠️ Poke frequency must be a valid number.")
    except Exception as e:
        showtime_tab_instance.console_print_func(f"❌ Error during poke action: {e}")
        debug_log(message=f"Shiver me timbers, the poke be capsized! The error be: {e}",
                  file=f"{os.path.basename(__file__)}",
                  version=current_version,
                  function=current_function)


#####################################
### File: OPEN-AIR 2\workers\controls\utils_showtime_rbw.py
#####################################
# tabs/Markers/showtime/controls/utils_showtime_rbw.py
#
# This utility file centralizes the backend logic for controlling the instrument's
# Resolution Bandwidth (RBW) settings. It contains functions that handle
# button clicks from the GUI and translate them into instrument commands.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.010200.1
# REFACTORED: The logic has been streamlined to ensure that UI updates,
#             instrument commands, and configuration saving are consistently
#             handled by the on_rbw_button_click function.

import os
import inspect
import tkinter as tk
from tkinter import ttk

from display.debug_logic import debug_log
from display.console_logic import console_log
from yak.Yakety_Yak import YakSet
from yak.utils_yak_setting_handler import set_resolution_bandwidth
from settings_and_config.config_manager_save import save_program_config 

from process_math.math_frequency_translation import format_hz

# --- Versioning ---
w = 20250824
x_str = '010200'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = f"{os.path.basename(__file__)}"

def set_rbw_logic(app_instance, rbw_hz, console_print_func):
    # [Sets the resolution bandwidth of the instrument and reports back.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"Entering {current_function} with rbw_hz: {rbw_hz}", file=f"{os.path.basename(__file__)}", version=current_version, function=current_function)
    
    status = YakSet(app_instance=app_instance, command_type="BANDWIDTH/RESOLUTION", variable_value=str(rbw_hz), console_print_func=console_print_func)
    
    if status != "PASSED":
        console_print_func("❌ Failed to set RBW.")

def on_rbw_button_click(showtime_tab, rbw_hz):
    # [Handles the event when an RBW button is clicked.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"Entering {current_function} with rbw_hz: {rbw_hz}",
              file=f"{os.path.basename(__file__)}",
              version=current_version,
              function=current_function)
    
    try:
        # 📝 Write Data: Update the RBW variable on the parent instance.
        showtime_tab.rbw_var.set(str(rbw_hz))
        debug_log(message=f"📝 Writing state: rbw_var = {rbw_hz} Hz", file=f"{os.path.basename(__file__)}", version=current_version, function=current_function)
        
        # Re-sync the RBW button styles
        for value_str, btn in showtime_tab.rbw_buttons.items():
            if value_str == showtime_tab.rbw_var.get():
                btn.config(style='ControlButton.Active.TButton')
            else:
                btn.config(style='ControlButton.Inactive.TButton')
        
        showtime_tab.console_print_func(f"✅ RBW set to {format_hz(rbw_hz)}.")
        
        # Trigger the handler to send the new RBW to the instrument
        set_resolution_bandwidth(app_instance=showtime_tab.app_instance, value=int(rbw_hz), console_print_func=showtime_tab.console_print_func)
        
        # FIXED: Save config after a successful RBW change
        save_program_config (config=showtime_tab.app_instance.config,
                    file_path=showtime_tab.app_instance.CONFIG_FILE_PATH,
                    console_print_func=showtime_tab.console_print_func,
                    app_instance=showtime_tab.app_instance)

    except Exception as e:
        showtime_tab.console_print_func(f"❌ Error setting RBW: {e}")
        debug_log(message=f"Shiver me timbers, the RBW has gone rogue! The error be: {e}",
                  file=f"{os.path.basename(__file__)}",
                  version=current_version,
                  function=current_function)

#####################################
### File: OPEN-AIR 2\workers\controls\utils_showtime_span.py
#####################################
# tabs/Markers/showtime/controls/utils_showtime_span.py
#
# This utility file centralizes the backend logic for controlling the instrument's
# Span settings. It contains functions that handle button clicks from the GUI
# and translate them into instrument commands.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.010500.1
# UPDATED: File header and versioning adhere to new standards.
# FIXED: The `on_span_button_click` function now correctly captures the RBW value
#        from the device response and updates the UI and config accordingly.

import os
import inspect

from display.debug_logic import debug_log
from display.console_logic import console_log
from yak.utils_yakbeg_handler import handle_freq_center_span_beg
from yak.utils_yak_setting_handler import set_span_frequency
from yak.utils_yaknab_handler import handle_bandwidth_settings_nab
from settings_and_config.config_manager_save import save_program_config 
from process_math.math_frequency_translation import format_hz

# --- Versioning ---
w = 20250824
x = 10500
y = 1
current_version = f"Version {w}.{x}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"


def on_span_button_click(showtime_tab_instance, span_hz):
    # [Handles the event when a Span button is clicked.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"Entering {current_function} with span_hz: {span_hz}",
              file=f"{os.path.basename(__file__)}",
              version=current_version,
              function=current_function)
    
    try:
        # Check if the user wants to follow the zone span
        showtime_tab_instance.follow_zone_span_var.set(False)

        # 📝 Write Data: Update the span variable on the parent instance.
        showtime_tab_instance.span_var.set(str(span_hz))
        debug_log(message=f"📝 Writing state: span_var = {span_hz} Hz", file=f"{os.path.basename(__file__)}", version=current_version, function=current_function)

        # Re-sync all the control buttons
        showtime_tab_instance.controls_frame._update_control_buttons()
        
        showtime_tab_instance.console_print_func(f"✅ Span set to {format_hz(span_hz)}.")

        # Trigger the handler to send the new span to the instrument.
        # It should use the current center frequency and the new span.
        
        # CORRECTED: Capture the response from the device
        set_span_frequency(app_instance=showtime_tab_instance.app_instance,
                                    value=span_hz / 1_000_000,
                                    console_print_func=showtime_tab_instance.console_print_func)
        
        # NEW LOGIC: Get the current bandwidth settings from the device and update the state.
        device_bandwidth_settings = handle_bandwidth_settings_nab(app_instance=showtime_tab_instance.app_instance,
                                                                    console_print_func=showtime_tab_instance.console_print_func)
        
        if device_bandwidth_settings and device_bandwidth_settings.get('RBW_Hz') is not None:
            rbw_from_device = device_bandwidth_settings['RBW_Hz']
            showtime_tab_instance.rbw_var.set(str(rbw_from_device))
            showtime_tab_instance.console_print_func(f"✅ RBW automatically updated to {format_hz(rbw_from_device)}.")
            debug_log(message=f"📝 Writing state: rbw_var updated from device response to {rbw_from_device} Hz.", file=current_file, version=current_version, function=current_function)
        
        # FIXED: Save config after a successful span change
        save_program_config (config=showtime_tab_instance.app_instance.config,
                    file_path=showtime_tab_instance.app_instance.CONFIG_FILE_PATH,
                    console_print_func=showtime_tab_instance.console_print_func,
                    app_instance=showtime_tab_instance.app_instance)

    except Exception as e:
        showtime_tab_instance.console_print_func(f"❌ Error setting span: {e}")
        debug_log(message=f"Arrr, a kraken be attacking the span settings! The error be: {e}",
                  file=f"{os.path.basename(__file__)}",
                  version=current_version,
                  function=current_function)


#####################################
### File: OPEN-AIR 2\workers\controls\utils_showtime_trace.py
#####################################
# tabs/Markers/showtime/controls/utils_showtime_trace.py
#
# This utility file centralizes all logic for fetching trace data from the instrument,
# handling trace mode configurations, and updating the corresponding display plots.
# It acts as a high-level API for the UI to trigger trace actions.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.010400.1
# UPDATED: The execute_trace_action function now correctly calls handle_trace_modes_beg to set the new mode on the instrument before fetching data.
# UPDATED: The trace mode mapping now correctly uses the mode strings defined in the new MarkerTab config.
# FIXED: The execute_trace_action function now saves the config after changing trace modes.
# FIXED: Corrected the AttributeErrors in `_get_and_plot_traces` by retrieving
#        frequency and span values from the `app_instance.config` object.

import os
import inspect
import pandas as pd
import tkinter as tk
import numpy as np

from display.debug_logic import debug_log
from display.console_logic import console_log

from yak.utils_yaknab_handler import handle_all_traces_nab
from yak.utils_yakbeg_handler import handle_trace_modes_beg
from settings_and_config.config_manager_save import save_program_config 

from .utils_showtime_plot import plot_all_traces
from process_math.math_frequency_translation import MHZ_TO_HZ

# --- Versioning ---
w = 20250824
x_str = '010400'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = f"{os.path.basename(__file__)}"

def sync_trace_modes(traces_tab_instance):
    # [Synchronizes the trace mode buttons with the instrument's current state.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Entering {current_function}", file=f"{os.path.basename(__file__)}", version=current_version, function="sync_trace_modes")
    
    showtime_tab = traces_tab_instance.showtime_tab_instance
    app_instance = showtime_tab.app_instance
    console_print_func = showtime_tab.console_print_func

    # Placeholder for getting current trace modes from instrument
    current_modes = ['Live', 'Max Hold', 'Min Hold']
    
    for button_name in traces_tab_instance.trace_buttons.keys():
        if button_name in current_modes:
            traces_tab_instance.trace_buttons[button_name].config(style='ControlButton.Active.TButton')
        else:
            traces_tab_instance.trace_buttons[button_name].config(style='ControlButton.Inactive.TButton')
            
    debug_log(f"Exiting {current_function}", file=f"{os.path.basename(__file__)}", version=current_version, function="sync_trace_modes")

def execute_trace_action(traces_tab_instance, action_type):
    # [Orchestrates the process of fetching and plotting traces based on user action.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Entering {current_function} with action_type: {action_type}", file=f"{os.path.basename(__file__)}", version=current_version, function="execute_trace_action")
    
    # FIXED: Access the parent ShowtimeParentTab instance directly from the child tab
    showtime_tab = traces_tab_instance.showtime_tab_instance

    # Set the instrument's trace mode based on the button clicked
    trace_mode_map = {
        'all': ['WRITE', 'MAXHold', 'MINHold'],
        'live': ['WRITE', 'BLANK', 'BLANK', 'BLANK'],
        'max': ['BLANK', 'MAXHold', 'BLANK', 'BLANK'],
        'min': ['BLANK', 'BLANK', 'MINHold', 'BLANK']
    }
    
    selected_modes = trace_mode_map.get(action_type, [])
    
    # NEW: Call handle_trace_modes_beg to set the modes on the instrument
    debug_log(f"Calling YakBeg to set trace modes on the instrument. ⚡",
                file=f"{os.path.basename(__file__)}",
                version=current_version,
                function=current_function)
    handle_trace_modes_beg(showtime_tab.app_instance, selected_modes, showtime_tab.console_print_func)
    
    # FIXED: Pass the action_type to _get_and_plot_traces
    _get_and_plot_traces(traces_tab_instance, action_type)
    
    # FIXED: Save config after a successful trace action
    save_program_config (config=showtime_tab.app_instance.config,
                file_path=showtime_tab.app_instance.CONFIG_FILE_PATH,
                console_print_func=showtime_tab.console_print_func,
                app_instance=showtime_tab.app_instance)

    debug_log(f"Exiting {current_function}", file=f"{os.path.basename(__file__)}", version=current_version, function="execute_trace_action")

def _get_and_plot_traces(traces_tab_instance, view_name):
    # [Fetches trace data from the instrument and passes it to the plotting utility.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Entering {current_function}", file=f"{os.path.basename(__file__)}", version=current_version, function="_get_and_plot_traces")
    
    # FIXED: Access the parent ShowtimeParentTab instance directly from the child tab
    showtime_tab = traces_tab_instance.showtime_tab_instance
    app_instance = showtime_tab.app_instance
    console_print_func = showtime_tab.console_print_func
    
    # CORRECTED: Retrieve center and span values from the config file, which is the correct source of truth.
    # The previous code was trying to access attributes on orchestrator_logic that do not exist.
    center_freq_mhz = float(app_instance.config.get('InstrumentSettings', 'center_freq_mhz', fallback='1500'))
    span_freq_mhz = float(app_instance.config.get('InstrumentSettings', 'span_freq_mhz', fallback='3000'))
    
    start_freq_mhz = (center_freq_mhz - span_freq_mhz / 2)
    stop_freq_mhz = (center_freq_mhz + span_freq_mhz / 2)
    
    try:
        # 📖 Read Data: Fetch the data from the instrument.
        debug_log(message=f"📖 Reading Data: Fetching all traces from the instrument via NAB handler.", file=f"{os.path.basename(__file__)}", version=current_version, function=current_function)
        trace_data = handle_all_traces_nab(app_instance, console_print_func)
        
        # If data is successfully retrieved, pass it to the plotter
        if trace_data:
            plot_all_traces(showtime_tab_instance=showtime_tab, trace_data_dict=trace_data, view_name=view_name, start_freq_mhz=start_freq_mhz, stop_freq_mhz=stop_freq_mhz)
        
    except Exception as e:
        console_print_func(f"❌ Error getting trace data: {e}")
        debug_log(message=f"Shiver me timbers, the trace data be lost at sea! The error be: {e}",
                  file=f"{os.path.basename(__file__)}",
                  version=current_version,
                  function="execute_trace_action")

#####################################
### File: OPEN-AIR 2\workers\controls\utils_showtime_zone_zoom.py
#####################################
# tabs/Markers/showtime/controls/utils_showtime_zone_zoom.py
#
# This utility file provides the backend logic for the Zone Zoom tab in the ControlsFrame.
# It contains functions to calculate and set the instrument's span based on
# selected zones, groups, devices, or all markers by calling YakBeg handlers.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.001500.2
# UPDATED: set_span_to_zone and set_span_to_group now read min/max frequencies and device count
#          from the shared state, ensuring consistency between the UI state and calculations.
# UPDATED: All debug logs now include the correct emoji prefixes.
# UPDATED: Versioning and file header adhere to new standards.
# FIXED: Added `save_program_config` calls to all functions that modify state.
# FIXED: Corrected the AttributeErrors in all functions by retrieving state
#        variables directly from the `showtime_tab_instance` object.

import inspect
import os
from display.debug_logic import debug_log
from display.console_logic import console_log
from ref.ref_frequency_bands import MHZ_TO_HZ
from process_math.math_frequency_translation import format_hz
from settings_and_config.config_manager_save import save_program_config

# Import the YakBeg handlers for direct instrument control
from yak.utils_yakbeg_handler import handle_freq_start_stop_beg, handle_freq_center_span_beg

# --- Versioning ---
w = 20250824
x_str = '001500'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 2
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"


def _buffer_start_stop_frequencies(start_freq_mhz, stop_freq_mhz, buffer_mhz):
    # [Calculates the buffered start and stop frequencies based on a given buffer value.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"🛠️ 🟢 Entering {current_function} with start: {start_freq_mhz}, stop: {stop_freq_mhz}, buffer: {buffer_mhz}", file=current_file, version=current_version, function=current_function)
    
    buffered_start_freq_mhz = start_freq_mhz - buffer_mhz
    buffered_stop_freq_mhz = stop_freq_mhz + buffer_mhz
    
    debug_log(message=f"🛠️ 🟢 Exiting {current_function} with buffered start: {buffered_start_freq_mhz}, buffered stop: {buffered_stop_freq_mhz}", file=current_file, version=current_version, function=current_function)
    
    return buffered_start_freq_mhz, buffered_stop_freq_mhz

def set_span_to_all_markers(showtime_tab_instance, zone_zoom_tab):
    # [Calculates the required span to view all markers and sets the instrument using a start-stop command.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"🛠️ 🟢 Entering {current_function}", file=current_file, version=current_version, function="set_span_to_all_markers")
    
    # Get necessary info from the state and zgd_frame
    all_devices = showtime_tab_instance.zgd_frame._get_all_devices_in_zone(showtime_tab_instance.zgd_frame.structured_data, None)
    
    if not all_devices:
        showtime_tab_instance.console_print_func("⚠️ No markers loaded. Cannot set span to all markers.")
        debug_log(message=f"🛠️ 🚫 No markers found.", file=current_file, version=current_version, function=current_function)
        return
        
    freqs = [float(d['CENTER']) for d in all_devices if d.get('CENTER') and isinstance(d.get('CENTER'), (int, float))]
    if not freqs:
        showtime_tab_instance.console_print_func("⚠️ No valid frequencies found in markers. Cannot set span.")
        debug_log(message=f"🛠️ 🚫 No valid frequencies found in markers.", file=current_file, version=current_version, function=current_function)
        return
    
    start_freq_mhz = min(freqs)
    stop_freq_mhz = max(freqs)
    number_of_markers = len(freqs)

    try:
        # 📖 Read Data: Retrieve buffer value.
        buffer_mhz = float(showtime_tab_instance.buffer_var.get())
        debug_log(message=f"📖 Reading state: buffer_var = {buffer_mhz} MHz", file=current_file, version=current_version, function=current_function)

        buffered_start_freq_mhz, buffered_stop_freq_mhz = _buffer_start_stop_frequencies(start_freq_mhz, stop_freq_mhz, buffer_mhz)
        
        # 📝 Write Data: Store the buffered frequencies in the state.
        debug_log(message=f"📝 Writing state: buffered_start_var = {buffered_start_freq_mhz}, buffered_stop_var = {buffered_stop_freq_mhz}", file=current_file, version=current_version, function=current_function)
        showtime_tab_instance.buffered_start_var.set(buffered_start_freq_mhz)
        showtime_tab_instance.buffered_stop_var.set(buffered_stop_freq_mhz)

        start_freq_hz = int(buffered_start_freq_mhz * MHZ_TO_HZ)
        stop_freq_hz = int(buffered_stop_freq_mhz * MHZ_TO_HZ)
        
        showtime_tab_instance.console_print_func(f"✅ Setting span to all markers: {buffered_start_freq_mhz:.3f} MHz to {buffered_stop_freq_mhz:.3f} MHz.")
        
        # FIXED: Calling the handler here after the values are calculated
        handle_freq_start_stop_beg(app_instance=showtime_tab_instance.app_instance, start_freq=start_freq_hz, stop_freq=stop_freq_hz, console_print_func=showtime_tab_instance.console_print_func)

        showtime_tab_instance.follow_zone_span_var.set(True)

        showtime_tab_instance.zone_zoom_label_left_var.set("All Markers")
        showtime_tab_instance.zone_zoom_label_center_var.set(f"({number_of_markers} Devices)")
        showtime_tab_instance.zone_zoom_label_right_var.set(f"Start: {buffered_start_freq_mhz:.3f} MHz\nStop: {buffered_stop_freq_mhz:.3f} MHz")
        
        # Trigger UI sync on ZoneZoomTab
        zone_zoom_tab._sync_ui_from_state()
        debug_log(message=f"🛠️ ✅ Successfully updated all markers span and UI.", file=current_file, version=current_version, function=current_function)
        
        # FIXED: Add save_program_config call
        save_program_config(config=showtime_tab_instance.app_instance.config,
                    file_path=showtime_tab_instance.app_instance.CONFIG_FILE_PATH,
                    console_print_func=showtime_tab_instance.console_print_func,
                    app_instance=showtime_tab_instance.app_instance)

    except Exception as e:
        showtime_tab_instance.console_print_func(f"❌ Error in set_span_to_all_markers: {e}")
        debug_log(message=f"🛠️ 🧨 Shiver me timbers, setting span to all markers has failed! The error be: {e}", file=current_file, version=current_version, function="set_span_to_all_markers")

def set_span_to_zone(showtime_tab_instance, zone_zoom_tab):
    # [Calculates the required span for a zone and sets the instrument using a start-stop command.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"🛠️ 🟢 Entering {current_function}", file=current_file, version=current_version, function=current_function)

    zone_info = showtime_tab_instance.selected_zone_info
    zone_name = showtime_tab_instance.selected_zone

    if not zone_name:
        showtime_tab_instance.console_print_func("⚠️ No zone selected. Cannot set span to zone.")
        debug_log(message=f"🛠️ 🚫 No zone selected.", file=current_file, version=current_version, function=current_function)
        return
    
    start_freq_mhz = zone_info.get('min_freq')
    stop_freq_mhz = zone_info.get('max_freq')
    number_of_markers = zone_info.get('device_count')
    
    if number_of_markers == 0:
        showtime_tab_instance.console_print_func(f"⚠️ No valid frequencies found in zone '{zone_name}'. Cannot set span.")
        debug_log(message=f"🛠️ 🚫 No valid frequencies found in zone '{zone_name}'.", file=current_file, version=current_version, function=current_function)
        return
    
    debug_log(message=f"🛠️ 🔍 Reading state: zone_info = {zone_info}", file=current_file, version=current_version, function=current_function)
    
    try:
        # 📖 Read Data: Retrieve buffer value.
        buffer_mhz = float(showtime_tab_instance.buffer_var.get())
        debug_log(message=f"📖 Reading state: buffer_var = {buffer_mhz} MHz", file=current_file, version=current_version, function=current_function)

        buffered_start_freq_mhz, buffered_stop_freq_mhz = _buffer_start_stop_frequencies(start_freq_mhz, stop_freq_mhz, buffer_mhz)

        # 📝 Write Data: Store the buffered frequencies in the state.
        debug_log(message=f"📝 Writing state: buffered_start_var = {buffered_start_freq_mhz}, buffered_stop_var = {buffered_stop_freq_mhz}", file=current_file, version=current_version, function=current_function)
        showtime_tab_instance.buffered_start_var.set(buffered_start_freq_mhz)
        showtime_tab_instance.buffered_stop_var.set(buffered_stop_freq_mhz)

        start_freq_hz = int(buffered_start_freq_mhz * MHZ_TO_HZ)
        stop_freq_hz = int(buffered_stop_freq_mhz * MHZ_TO_HZ)
        
        showtime_tab_instance.console_print_func(f"✅ Setting span to zone '{zone_name}': {buffered_start_freq_mhz:.3f} MHz to {buffered_stop_freq_mhz:.3f} MHz.")
        
        handle_freq_start_stop_beg(app_instance=showtime_tab_instance.app_instance, start_freq=start_freq_hz, stop_freq=stop_freq_hz, console_print_func=showtime_tab_instance.console_print_func)
        
        showtime_tab_instance.follow_zone_span_var.set(True)

        showtime_tab_instance.zone_zoom_label_left_var.set(f"Zone ({number_of_markers} Devices)")
        showtime_tab_instance.zone_zoom_label_center_var.set(f"Name: {zone_name}")
        showtime_tab_instance.zone_zoom_label_right_var.set(f"Start: {buffered_start_freq_mhz:.3f} MHz\nStop: {buffered_stop_freq_mhz:.3f} MHz")
        
        zone_zoom_tab._sync_ui_from_state()
        debug_log(message=f"🛠️ ✅ Successfully updated zone span and UI.", file=current_file, version=current_version, function=current_function)
        
        # FIXED: Add save_program_config call
        save_program_config(config=showtime_tab_instance.app_instance.config,
                    file_path=showtime_tab_instance.app_instance.CONFIG_FILE_PATH,
                    console_print_func=showtime_tab_instance.console_print_func,
                    app_instance=showtime_tab_instance.app_instance)


    except Exception as e:
        showtime_tab_instance.console_print_func(f"❌ Error in set_span_to_zone: {e}")
        debug_log(message=f"🛠️ 🧨 Arrr, the code be capsized! The error be: {e}", file=current_file, version=current_version, function="set_span_to_zone")

def set_span_to_group(showtime_tab_instance, zone_zoom_tab):
    # [Calculates the required span for a group and sets the instrument using a start-stop command.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"🛠️ 🟢 Entering {current_function}", file=current_file, version=current_version, function=current_function)
    
    group_info = showtime_tab_instance.selected_group_info
    group_name = showtime_tab_instance.selected_group
    
    if not group_name:
        showtime_tab_instance.console_print_func("⚠️ No group selected. Cannot set span to group.")
        debug_log(message=f"🛠️ 🚫 No group selected.", file=current_file, version=current_version, function=current_function)
        return
        
    start_freq_mhz = group_info.get('min_freq')
    stop_freq_mhz = group_info.get('max_freq')
    number_of_markers = group_info.get('device_count')

    if number_of_markers == 0:
        showtime_tab_instance.console_print_func(f"⚠️ No valid frequencies found in group '{group_name}'. Cannot set span.")
        debug_log(message=f"🛠️ 🚫 No valid frequencies found in group '{group_name}'.", file=current_file, version=current_version, function=current_function)
        return

    debug_log(message=f"🛠️ 🔍 Reading state: group_info = {group_info}", file=current_file, version=current_version, function=current_function)
    
    try:
        # 📖 Read Data: Retrieve buffer value.
        buffer_mhz = float(showtime_tab_instance.buffer_var.get())
        debug_log(message=f"📖 Reading state: buffer_var = {buffer_mhz} MHz", file=current_file, version=current_version, function=current_function)

        buffered_start_freq_mhz, buffered_stop_freq_mhz = _buffer_start_stop_frequencies(start_freq_mhz, stop_freq_mhz, buffer_mhz)

        # 📝 Write Data: Store the buffered frequencies in the state.
        debug_log(message=f"📝 Writing state: buffered_start_var = {buffered_start_freq_mhz}, buffered_stop_var = {buffered_stop_freq_mhz}", file=current_file, version=current_version, function=current_function)
        showtime_tab_instance.buffered_start_var.set(buffered_start_freq_mhz)
        showtime_tab_instance.buffered_stop_var.set(buffered_stop_freq_mhz)
        
        start_freq_hz = int(buffered_start_freq_mhz * MHZ_TO_HZ)
        stop_freq_hz = int(buffered_stop_freq_mhz * MHZ_TO_HZ)
        
        showtime_tab_instance.console_print_func(f"✅ Setting span to group '{group_name}': {buffered_start_freq_mhz:.3f} MHz to {buffered_stop_freq_mhz:.3f} MHz.")

        handle_freq_start_stop_beg(app_instance=showtime_tab_instance.app_instance, start_freq=start_freq_hz, stop_freq=stop_freq_hz, console_print_func=showtime_tab_instance.console_print_func)
        
        showtime_tab_instance.follow_zone_span_var.set(True)

        showtime_tab_instance.zone_zoom_label_left_var.set(f"Group ({number_of_markers} Devices)")
        showtime_tab_instance.zone_zoom_label_center_var.set(f"Name: {group_name}")
        showtime_tab_instance.zone_zoom_label_right_var.set(f"Start: {buffered_start_freq_mhz:.3f} MHz\nStop: {buffered_stop_freq_mhz:.3f} MHz")
        
        zone_zoom_tab._sync_ui_from_state()
        debug_log(message=f"🛠️ ✅ Successfully updated group span and UI.", file=current_file, version=current_version, function=current_function)
        
        # FIXED: Add save_program_config call
        save_program_config(config=showtime_tab_instance.app_instance.config,
                    file_path=showtime_tab_instance.app_instance.CONFIG_FILE_PATH,
                    console_print_func=showtime_tab_instance.console_print_func,
                    app_instance=showtime_tab_instance.app_instance)

    except Exception as e:
        showtime_tab_instance.console_print_func(f"❌ Error in set_span_to_group: {e}")
        debug_log(message=f"🛠️ 🧨 Great Scott! The group span calculation has failed! The error is: {e}", file=current_file, version=current_version, function="set_span_to_group")
        
def set_span_to_device(showtime_tab_instance, zone_zoom_tab):
    # [Sets the instrument's span to focus on a single device using a center-span command.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"🛠️ 🟢 Entering {current_function}", file=current_file, version=current_version, function=current_function)
    
    device_info = showtime_tab_instance.selected_device_info
    
    if not device_info:
        showtime_tab_instance.console_print_func("⚠️ No device selected. Cannot set span to device.")
        debug_log(message=f"🛠️ 🚫 No device selected.", file=current_file, version=current_version, function=current_function)
        return

    device_name = device_info.get('NAME')
    center_freq_mhz = device_info.get('CENTER')
    
    debug_log(message=f"🛠️ 🔍 Reading state: device_name={device_name}, center_freq_mhz={center_freq_mhz}", file=current_file, version=current_version, function=current_function)
    
    try:
        # 📖 Read Data: Retrieve buffer value.
        buffer_mhz = float(showtime_tab_instance.buffer_var.get())
        debug_log(message=f"📖 Reading state: buffer_var = {buffer_mhz} MHz", file=current_file, version=current_version, function=current_function)

        center_freq_hz = int(center_freq_mhz * MHZ_TO_HZ)
        
        # FIXED: Check if the value contains 'M' and convert it to a float.
        span_str = showtime_tab_instance.span_var.get()
        if 'M' in span_str:
            span_mhz = float(span_str.replace('M', ''))
        else:
            span_mhz = float(span_str)
            
        span_hz = int(span_mhz * MHZ_TO_HZ)
        
        # Calculate start and stop with the buffer for display purposes
        buffered_span = span_mhz + (2 * buffer_mhz)
        buffered_start_freq_mhz = center_freq_mhz - (buffered_span / 2)
        buffered_stop_freq_mhz = center_freq_mhz + (buffered_span / 2)
        
        # 📝 Write Data: Store the buffered frequencies in the state.
        debug_log(message=f"📝 Writing state: buffered_start_var = {buffered_start_freq_mhz}, buffered_stop_var = {buffered_stop_freq_mhz}", file=current_file, version=current_version, function=current_function)
        showtime_tab_instance.buffered_start_var.set(buffered_start_freq_mhz)
        showtime_tab_instance.buffered_stop_var.set(buffered_stop_freq_mhz)
        
        showtime_tab_instance.console_print_func(f"✅ Setting span to device '{device_name}': Center={center_freq_mhz:.3f} MHz, Span={format_hz(span_hz)}.")

        handle_freq_center_span_beg(app_instance=showtime_tab_instance.app_instance, center_freq=center_freq_hz, span_freq=span_hz, console_print_func=showtime_tab_instance.console_print_func)
        
        showtime_tab_instance.follow_zone_span_var.set(False)

        showtime_tab_instance.zone_zoom_label_left_var.set(f"Device: {device_name}")
        showtime_tab_instance.zone_zoom_label_center_var.set(f"Name: {device_name}")
        showtime_tab_instance.zone_zoom_label_right_var.set(f"Center: {center_freq_mhz:.3f} MHz\nSpan: {span_mhz:.3f} MHz\nStart: {buffered_start_freq_mhz:.3f} MHz\nStop: {buffered_stop_freq_mhz:.3f} MHz")
        
        zone_zoom_tab._sync_ui_from_state()
        debug_log(message=f"🛠️ ✅ Successfully updated device span and UI.", file=current_file, version=current_version, function=current_function)
        
        # FIXED: Add save_program_config call
        save_program_config(config=showtime_tab_instance.app_instance.config,
                    file_path=showtime_tab_instance.app_instance.CONFIG_FILE_PATH,
                    console_print_func=showtime_tab_instance.console_print_func,
                    app_instance=showtime_tab_instance.app_instance)

    except Exception as e:
        showtime_tab_instance.console_print_func(f"❌ Error in set_span_to_device: {e}")
        debug_log(message=f"🛠️ 🧨 It's madness! The device span function has gone haywire! The error is: {e}", file=current_file, version=current_version, function="set_span_to_device")


#####################################
### File: OPEN-AIR 2\workers\Experiments\tab_experiments_child_JSON_api.py
#####################################
# tabs/Experiments/tab_experiments_child_JSON_api.py
#
# This file defines the JsonApiTab, a Tkinter Frame that provides controls for
# starting/stopping a Flask-based JSON API. This API allows external access to
# scan data and marker data, including real-time scan-in-progress data.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250801.2155.1 (Refactored debug_print to use debug_log and console_log.)

current_version = "20250801.2155.1" # this variable should always be defined below the header to make the debugging better
current_version_hash = 20250801 * 2155 * 1 # Example hash, adjust as needed

import tkinter as tk
from tkinter import ttk, filedialog, scrolledtext
import os
import inspect
import webbrowser # For opening API links in browser
import subprocess # For running the Flask JSON API
import threading # For running the Flask JSON API in a separate thread
import time # For brief pauses
import sys # Explicitly import sys for use with sys.executable
import requests # For making HTTP requests to the Flask API

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log


class JsonApiTab(ttk.Frame):
    """
    A Tkinter Frame that provides controls for starting/stopping a JSON API
    and accessing scan data and marker data via that API.
    """
    def __init__(self, master=None, app_instance=None, console_print_func=None, **kwargs):
        """
        Initializes the JsonApiTab.

        Inputs:
            master (tk.Widget): The parent widget.
            app_instance (App): The main application instance, used for accessing
                                shared state like collected_scans_dataframes and output directory.
            console_print_func (function): Function to print messages to the GUI console.
            **kwargs: Arbitrary keyword arguments for Tkinter Frame.
        """
        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func if console_print_func else console_log # Use console_log as default
        self.json_api_process = None # To store the subprocess for the JSON API
        self.json_api_port = 5000 # Default port for the Flask API
        self.json_api_url_base = f"http://127.0.0.1:{self.json_api_port}"

        self._create_widgets()
        # Ensure API buttons are updated on startup
        self._update_api_button_states()

    def _create_widgets(self):
        """
        Creates and arranges the widgets for the JSON API tab.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        debug_log("Creating JsonApiTab widgets...",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        self.grid_columnconfigure(0, weight=1)
        self.grid_columnconfigure(1, weight=1)

        # JSON API Controls
        self.api_control_frame = ttk.LabelFrame(self, text="JSON API Controls", style='Dark.TLabelframe')
        self.api_control_frame.grid(row=0, column=0, columnspan=2, padx=5, pady=5, sticky="ew")
        self.api_control_frame.grid_columnconfigure(0, weight=1)
        self.api_control_frame.grid_columnconfigure(1, weight=1)

        self.start_api_button = ttk.Button(self.api_control_frame, text="Start API", command=self._start_json_api, style='Green.TButton')
        self.start_api_button.grid(row=0, column=0, padx=5, pady=5, sticky="ew")

        self.stop_api_button = ttk.Button(self.api_control_frame, text="Stop API", command=self._stop_json_api, style='Red.TButton', state=tk.DISABLED)
        self.stop_api_button.grid(row=0, column=1, padx=5, pady=5, sticky="ew")

        self.view_all_scans_button = ttk.Button(self.api_control_frame, text="View All API Scans", command=self._open_all_api_scans, style='Purple.TButton', state=tk.DISABLED)
        self.view_all_scans_button.grid(row=1, column=0, columnspan=2, padx=5, pady=5, sticky="ew")

        # Updated: This button now points to the static /api/latest_scan_data endpoint
        self.view_latest_scan_api_button = ttk.Button(self.api_control_frame, text="View Latest API Scan", command=self._open_latest_api_scan, style='Purple.TButton', state=tk.DISABLED)
        self.view_latest_scan_api_button.grid(row=2, column=0, columnspan=2, padx=5, pady=5, sticky="ew")

        # New button for scan in progress
        self.view_in_progress_api_button = ttk.Button(self.api_control_frame, text="View Scan In Progress API", command=self._open_scan_in_progress_api, style='Blue.TButton', state=tk.DISABLED)
        self.view_in_progress_api_button.grid(row=3, column=0, columnspan=2, padx=5, pady=5, sticky="ew")

        self.view_markers_api_button = ttk.Button(self.api_control_frame, text="View Markers API", command=self._open_markers_api, style='Orange.TButton', state=tk.DISABLED)
        self.view_markers_api_button.grid(row=4, column=0, columnspan=2, padx=5, pady=5, sticky="ew")

        # Frame for dynamically generated scan buttons
        # This frame's row is now adjusted to be below all static API control buttons
        self.dynamic_scan_buttons_frame = ttk.LabelFrame(self, text="Available API Scans", style='Dark.TLabelframe')
        self.dynamic_scan_buttons_frame.grid(row=5, column=0, columnspan=2, padx=5, pady=5, sticky="ew")
        self.dynamic_scan_buttons_frame.grid_columnconfigure(0, weight=1)
        self.dynamic_scan_buttons_frame.grid_remove()

        debug_log("JsonApiTab widgets created.",
                    file=__file__,
                    version=current_version,
                    function=current_function)

    def _run_json_api_thread_target(self):
        """
        Target function for the thread that runs the Flask JSON API.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        debug_log("JSON API thread target started.",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        script_path = os.path.join(self.app_instance._script_dir, 'process_math', 'json_host.py')

        try:
            self.json_api_process = subprocess.Popen(
                [sys.executable, script_path],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL,
                creationflags=subprocess.DETACHED_PROCESS if os.name == 'nt' else 0
            )
            self.app_instance.after(100, self._update_api_button_states)
            self.console_print_func(f"▶️ JSON API started on {self.json_api_url_base}")
            debug_log(f"JSON API subprocess started with PID: {self.json_api_process.pid}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        except FileNotFoundError:
            self.console_print_func(f"❌ Error: Python interpreter not found at {sys.executable}. Ensure Python is in your PATH.")
            debug_log(f"Python interpreter not found: {sys.executable}. Fucking useless!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        except Exception as e:
            self.console_print_func(f"❌ Error starting JSON API: {e}")
            debug_log(f"Error starting JSON API: {e}. This thing is a pain in the ass!",
                        file=__file__,
                        version=current_version,
                        function=current_function)

        debug_log("JSON API thread target finished.",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    def _start_json_api(self):
        """
        Starts the Flask JSON API in a separate thread.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        debug_log("Attempting to start JSON API...",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        if self.json_api_process and self.json_api_process.poll() is None:
            self.console_print_func("ℹ️ JSON API is already running.")
            debug_log("JSON API already running. Fucking redundant!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        api_thread = threading.Thread(target=self._run_json_api_thread_target)
        api_thread.daemon = True
        api_thread.start()

    def _stop_json_api(self):
        """
        Stops the Flask JSON API subprocess.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        debug_log("Attempting to stop JSON API...",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        if self.json_api_process and self.json_api_process.poll() is None:
            try:
                self.json_api_process.terminate()
                self.json_api_process.wait(timeout=2)
                if self.json_api_process.poll() is None:
                    self.json_api_process.kill()
                    self.console_print_func("⚠️ JSON API process killed (forcefully terminated).")
                    debug_log("JSON API process forcefully killed. Take that, you bastard!",
                                file=__file__,
                                version=current_version,
                                function=current_function)
                self.console_print_func("⏹️ JSON API stopped.")
                debug_log("JSON API process terminated.",
                            file=__file__,
                            version=current_version,
                            function=current_function)
            except Exception as e:
                self.console_print_func(f"❌ Error stopping JSON API: {e}")
                debug_log(f"Error stopping JSON API: {e}. This thing refuses to die!",
                            file=__file__,
                            version=current_version,
                            function=current_function)
            finally:
                self.json_api_process = None
                self.app_instance.after(100, self._update_api_button_states)
        else:
            self.console_print_func("ℹ️ JSON API is not running.")
            debug_log("JSON API not running. Fucking pointless to stop what's not there!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            self._update_api_button_states()


    def _update_api_button_states(self):
        """
        Updates the state of the JSON API related buttons based on API process status.
        """
        is_api_running = self.json_api_process and self.json_api_process.poll() is None
        self.start_api_button.config(state=tk.DISABLED if is_api_running else tk.NORMAL)
        self.stop_api_button.config(state=tk.NORMAL if is_api_running else tk.DISABLED)
        self.view_all_scans_button.config(state=tk.NORMAL if is_api_running else tk.DISABLED)
        self.view_markers_api_button.config(state=tk.NORMAL if is_api_running else tk.DISABLED)

        # Check if scan_control_tab exists and is_scanning is True
        is_scanning = getattr(self.app_instance, 'scan_control_tab', None) and self.app_instance.scan_control_tab.is_scanning
        self.view_in_progress_api_button.config(state=tk.NORMAL if is_api_running and is_scanning else tk.DISABLED)

        # "View Latest API Scan" is always enabled if API is running, as the endpoint handles finding the latest.
        self.view_latest_scan_api_button.config(state=tk.NORMAL if is_api_running else tk.DISABLED)


    def _open_all_api_scans(self):
        """
        Fetches the list of scan files from the API and creates dynamic buttons for each.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        debug_log("Attempting to fetch all API scans and display buttons...",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        if not (self.json_api_process and self.json_api_process.poll() is None):
            self.console_print_func("⚠️ JSON API is not running. Please start it first to view available scans.")
            debug_log("JSON API not running for _open_all_api_scans. Fucking useless!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        # Clear existing buttons
        for widget in self.dynamic_scan_buttons_frame.winfo_children():
            widget.destroy()
        self.dynamic_scan_buttons_frame.grid_remove() # Hide frame until populated

        def fetch_and_display():
            try:
                response = requests.get(f"{self.json_api_url_base}/api/list_scans")
                response.raise_for_status()
                scan_files = response.json()

                if scan_files:
                    self.app_instance.after(0, lambda: self.console_print_func(f"✅ Found {len(scan_files)} scan files from API."))
                    self.app_instance.after(0, lambda: self.dynamic_scan_buttons_frame.grid())

                    for i, filename in enumerate(scan_files):
                        button = ttk.Button(
                            self.dynamic_scan_buttons_frame,
                            text=filename,
                            command=lambda f=filename: self._open_api_scan_data(f),
                            style='Blue.TButton'
                        )
                        button.grid(row=i, column=0, padx=2, pady=2, sticky="ew")
                        self.dynamic_scan_buttons_frame.grid_columnconfigure(0, weight=1)
                else:
                    self.app_instance.after(0, lambda: self.console_print_func("ℹ️ No scan files found via API."))
                    self.app_instance.after(0, lambda: self.dynamic_scan_buttons_frame.grid_remove())
                    debug_log("No scan files found via API. Fucking empty!",
                                file=__file__,
                                version=current_version,
                                function=current_function)

            except requests.exceptions.ConnectionError:
                self.app_instance.after(0, lambda: self.console_print_func("❌ Error: Could not connect to JSON API. Is it running?"))
                debug_log("ConnectionError to JSON API. What the hell?!",
                            file=__file__,
                            version=current_version,
                            function=current_function)
            except requests.exceptions.RequestException as e:
                self.app_instance.after(0, lambda: self.console_print_func(f"❌ Error fetching scan list from API: {e}"))
                debug_log(f"RequestException fetching scan list: {e}. This thing is a pain in the ass!",
                            file=__file__,
                            version=current_version,
                            function=current_function)
            except Exception as e:
                self.app_instance.after(0, lambda: self.console_print_func(f"❌ An unexpected error occurred while fetching scan list: {e}"))
                debug_log(f"Unexpected error fetching scan list: {e}. This is a goddamn mess!",
                            file=__file__,
                            version=current_version,
                            function=current_function)
            finally:
                self.app_instance.after(0, self._update_api_button_states)

        api_call_thread = threading.Thread(target=fetch_and_display)
        api_call_thread.daemon = True
        api_call_thread.start()


    def _open_api_scan_data(self, filename):
        """
        Opens the API endpoint for a specific scan file in the browser.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        debug_log(f"Attempting to open API scan data for: {filename}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        if not (self.json_api_process and self.json_api_process.poll() is None):
            self.console_print_func("⚠️ JSON API is not running. Please start it first.")
            debug_log("JSON API not running for _open_api_scan_data. Fucking useless!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        api_link = f"{self.json_api_url_base}/api/scan_data/{filename}"
        try:
            webbrowser.open_new_tab(api_link)
            self.console_print_func(f"✅ Opened API link for scan: {filename}")
            debug_log(f"Opened {api_link}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        except Exception as e:
            self.console_print_func(f"❌ Error opening API scan link for {filename}: {e}")
            debug_log(f"Error opening API scan link for {filename}: {e}. This is a goddamn mess!",
                        file=__file__,
                        version=current_version,
                        function=current_function)

    def _open_markers_api(self):
        """
        Opens the API endpoint for MARKERS.csv in the browser.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        debug_log("Attempting to open Markers API link...",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        if not (self.json_api_process and self.json_api_process.poll() is None):
            self.console_print_func("⚠️ JSON API is not running. Please start it first.")
            debug_log("JSON API not running for _open_markers_api. Fucking useless!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        api_link = f"{self.json_api_url_base}/api/markers_data"
        try:
            webbrowser.open_new_tab(api_link)
            self.console_print_func("✅ Opened API link for MARKERS.csv data.")
            debug_log(f"Opened {api_link}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        except Exception as e:
            self.console_print_func(f"❌ Error opening Markers API link: {e}")
            debug_log(f"Error opening Markers API link: {e}. This is a goddamn mess!",
                        file=__file__,
                        version=current_version,
                        function=current_function)


    def _open_latest_api_scan(self):
        """
        Opens the API endpoint for the latest scan data in the browser.
        This endpoint is static and the API handles finding the latest file.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        debug_log("Attempting to open latest API scan link...",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        if not (self.json_api_process and self.json_api_process.poll() is None):
            self.console_print_func("⚠️ JSON API is not running. Please start it first.")
            debug_log("JSON API not running for _open_latest_api_scan. Fucking useless!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        api_link = f"{self.json_api_url_base}/api/latest_scan_data" # Static URL for latest scan
        try:
            webbrowser.open_new_tab(api_link)
            self.console_print_func(f"✅ Opened API link for latest scan data.")
            debug_log(f"Opened {api_link}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        except Exception as e:
            self.console_print_func(f"❌ Error opening latest API scan link: {e}")
            debug_log(f"Error opening latest API scan link: {e}. This is a goddamn mess!",
                        file=__file__,
                        version=current_version,
                        function=current_function)

    def _open_scan_in_progress_api(self):
        """
        Opens the API endpoint for the scan in progress data in the browser.
        This endpoint is static.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        debug_log("Attempting to open scan in progress API link...",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        if not (self.json_api_process and self.json_api_process.poll() is None):
            self.console_print_func("⚠️ JSON API is not running. Please start it first.")
            debug_log("JSON API not running for _open_scan_in_progress_api. Fucking useless!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        # Check if a scan is actually in progress
        is_scanning = getattr(self.app_instance, 'scan_control_tab', None) and self.app_instance.scan_control_tab.is_scanning
        if not is_scanning:
            self.console_print_func("ℹ️ No scan is currently in progress.")
            debug_log("No scan in progress for _open_scan_in_progress_api. Fucking pointless!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        api_link = f"{self.json_api_url_base}/api/scan_in_progress_data" # Static URL for scan in progress
        try:
            webbrowser.open_new_tab(api_link)
            self.console_print_func(f"✅ Opened API link for scan in progress data.")
            debug_log(f"Opened {api_link}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        except Exception as e:
            self.console_print_func(f"❌ Error opening scan in progress API link: {e}")
            debug_log(f"Error opening scan in progress API link: {e}. This is a goddamn mess!",
                        file=__file__,
                        version=current_version,
                        function=current_function)


    def _on_tab_selected(self, event):
        """
        Callback for when this tab is selected.
        This can be used to refresh data or update UI elements specific to this tab.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        debug_log("JSON API Tab selected.",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        # Update API button states when the tab is selected
        self._update_api_button_states()


#####################################
### File: OPEN-AIR 2\workers\Experiments\tab_experiments_child_credits.py
#####################################
# tabs/Experiments/tab_experiments_credits.py
#
# This file defines the CreditsTab, a Tkinter Frame that provides
# a button to open the project's GitHub page for credits and contribution details.
# It also displays the project's logo.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version W.X.Y
#

current_version = "Version 20250820.102600.4"
current_version_hash = 20250820 * 102600 * 4

import tkinter as tk
from tkinter import ttk
import inspect
import os
import webbrowser # For opening the GitHub link
from display.debug_logic import debug_log
from display.console_logic import console_log
from src.program_style import COLOR_PALETTE
from PIL import Image, ImageTk # For handling images

class CreditsTab(tk.Frame):
    """
    A Tkinter Frame for displaying credits, the project logo, and a link to the GitHub repository.
    """
    def __init__(self, parent_notebook, app_instance, console_print_func, *args, **kwargs):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering CreditsTab.__init__.",
                  file=f"{os.path.basename(__file__)}",
                  version=current_version,
                  function=current_function)

        try:
            super().__init__(parent_notebook, **kwargs)
            self.app_instance = app_instance
            self.console_print_func = console_print_func
            self.parent_notebook = parent_notebook

            self.configure(background=COLOR_PALETTE["background"])
            
            # Load and display the logo image
            try:
                # Construct the path to the image
                script_dir = os.path.dirname(__file__)
                logo_path = os.path.join(script_dir, '..', '..', 'display', 'logo.png')
                
                # Check if the file exists before trying to open it
                if os.path.exists(logo_path):
                    original_image = Image.open(logo_path)
                    
                    self.logo_image = ImageTk.PhotoImage(original_image)
                    logo_label = tk.Label(self, image=self.logo_image, background=COLOR_PALETTE["background"])
                    logo_label.pack(pady=(20, 10))
                else:
                    self.console_print_func(f"❌ Logo image not found at: {logo_path}")
                    debug_log(f"Arrr, the logo be missing! The path be: {logo_path}",
                                file=f"{os.path.basename(__file__)}",
                                version=current_version,
                                function=current_function)
            except Exception as e:
                self.console_print_func(f"❌ Error loading logo image: {e}")
                debug_log(f"A curse on these image files! Error loading logo: {e}",
                            file=f"{os.path.basename(__file__)}",
                            version=current_version,
                            function=current_function)

            # Label for title
            ttk.Label(
                self,
                text="Project Credits",
                font=('Helvetica', 14, 'bold'),
                background=COLOR_PALETTE["background"],
                foreground=COLOR_PALETTE["foreground"]
            ).pack(pady=(10, 5))

            # Button to open GitHub page
            open_github_button = tk.Button(
                self,
                text="Open on GitHub",
                font=('Helvetica', 13, 'bold'),
                bg=COLOR_PALETTE['blue_btn'],
                fg=COLOR_PALETTE['white'],
                activebackground=COLOR_PALETTE['blue_btn_active'],
                activeforeground=COLOR_PALETTE['white'],
                compound="left",
                command=self._open_github_link
            )
            open_github_button.pack(pady=10, padx=10)

            console_print_func("✅ Credits Tab initialized successfully.")
            debug_log(f"All components for CreditsTab are up and running! 🚀",
                      file=f"{os.path.basename(__file__)}",
                      version=current_version,
                      function=current_function)
        except Exception as e:
            console_print_func(f"❌ Error in CreditsTab initialization: {e}")
            debug_log(f"Arrr, the code be capsized! The error be: {e}",
                      file=f"{os.path.basename(__file__)}",
                      version=current_version,
                      function=current_function)
            raise

    def _open_github_link(self):
        # [A brief, one-sentence description of the function's purpose.]
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering _open_github_link with arguments: N/A",
                  file=f"{os.path.basename(__file__)}",
                  version=current_version,
                  function=current_function)

        try:
            github_url = "https://github.com/APKaudio/Spectrum-Automation---ZAP"
            webbrowser.open_new_tab(url=github_url)
            self.console_print_func("✅ Opening GitHub page in browser.")
            debug_log(f"Opening GitHub link: {github_url}. Anchors aweigh! ⛵",
                      file=f"{os.path.basename(__file__)}",
                      version=current_version,
                      function=current_function)

            console_log("✅ Celebration of success!")
        except Exception as e:
            self.console_print_func(f"❌ Error opening GitHub link: {e}")
            debug_log(f"Arrr, the code be capsized! The error be: {e}",
                      file=f"{os.path.basename(__file__)}",
                      version=current_version,
                      function=current_function)


    def _on_tab_selected(self, event):
        """
        Handles the event when this child tab is selected.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering _on_tab_selected.",
                  file=f"{os.path.basename(__file__)}",
                  version=current_version,
                  function=current_function)
        
        # No specific actions needed for this tab on selection.
        console_log("✅ Celebration of success!")

#####################################
### File: OPEN-AIR 2\workers\Experiments\tab_experiments_child_initial_configuration.py
#####################################
# tabs/Experiments/tab_experiments_child_initial_configuration.py
#
# This file defines the InitialConfigurationTab, a child tab for the Experiments
# section. It provides a GUI for viewing and editing the application's configuration
# file in a user-friendly manner, allowing for dynamic updates without restarting.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.112000.1
# NEW: Created a new child tab for managing the initial configuration.
# FIXED: Corrected the load_config call to use the proper arguments, resolving the TypeError.

import tkinter as tk
from tkinter import ttk, scrolledtext, filedialog
import inspect
import os
from configparser import ConfigParser

# Import logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log

# Import config management functions
from settings_and_config.config_manager_save import load_program_config, save_program_config 
from ref.ref_program_default_values import DEFAULT_CONFIG
from ref.ref_file_paths import DATA_FOLDER_PATH, CONFIG_FILE_PATH

# --- Version Information ---
w = 20250821
x_str = '112000'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = f"{os.path.basename(__file__)}"


class InitialConfigurationTab(ttk.Frame):
    def __init__(self, master=None, app_instance=None, console_print_func=None, style_obj=None, **kwargs):
        # This function description tells me what this function does
        # Initializes the InitialConfigurationTab, a Tkinter Frame for viewing and
        # editing the application's configuration.
        #
        # Inputs to this function
        #   master (tk.Widget): The parent widget, typically a ttk.Notebook.
        #   app_instance (object): A reference to the main application instance.
        #   console_print_func (function): A function to print messages to the console.
        #   style_obj (ttk.Style): The application's style object.
        #   **kwargs: Arbitrary keyword arguments for Tkinter Frame.
        #
        # Outputs of this function
        #   None. Initializes the Tkinter frame and its internal state.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"📕🟢 Initializing InitialConfigurationTab...",
                  file=current_file, version=current_version, function=current_function)

        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func
        self.style_obj = style_obj
        self.config_file_path = CONFIG_FILE_PATH
        self.config_data = None
        self.config_text_widget = None

        self._create_widgets()
        self._populate_config_table()
        
        debug_log(f"📕✅ InitialConfigurationTab initialized.",
                  file=current_file, version=current_version, function=current_function)

    def _create_widgets(self):
        # This function description tells me what this function does
        # Creates and lays out the widgets for the configuration tab, including a
        # text area for displaying the config and buttons for saving and reloading.
        #
        # Inputs to this function
        #   None.
        #
        # Outputs of this function
        #   None. Populates the tab with GUI elements.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"📕🟢 Creating widgets for InitialConfigurationTab.",
                  file=current_file, version=current_version, function=current_function)

        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(1, weight=1)

        control_frame = ttk.Frame(self)
        control_frame.grid(row=0, column=0, padx=10, pady=5, sticky="ew")
        control_frame.grid_columnconfigure(0, weight=1)
        control_frame.grid_columnconfigure(1, weight=1)
        
        save_button = ttk.Button(control_frame, text="Save Config", command=self._save_program_configure_action, style='Green.TButton')
        save_button.grid(row=0, column=0, padx=5, pady=5, sticky="ew")

        reload_button = ttk.Button(control_frame, text="Reload Config", command=self._reload_config_action, style='Orange.TButton')
        reload_button.grid(row=0, column=1, padx=5, pady=5, sticky="ew")

        self.config_text_widget = scrolledtext.ScrolledText(self, wrap="word", height=25, bg="#2b2b2b", fg="#cccccc", insertbackground="white", font=("Courier", 10))
        self.config_text_widget.grid(row=1, column=0, padx=10, pady=5, sticky="nsew")
        
        debug_log(f"📕✅ Widgets created.",
                  file=current_file, version=current_version, function=current_function)
    
    def _populate_config_table(self):
        # This function description tells me what this function does
        # Reads the config file and populates the text widget with its content.
        #
        # Inputs to this function
        #   None.
        #
        # Outputs of this function
        #   None. Updates the text widget with the config file content.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"📕🟢 Populating config table from file: {self.config_file_path}",
                  file=current_file, version=current_version, function=current_function)

        try:
            # FIXED: Corrected the load_config call to match the function's signature
            # It now passes the DEFAULT_CONFIG dictionary and the file path as separate arguments.
            self.config_data, _, _ = load_program_config(DEFAULT_CONFIG, self.config_file_path)

            self.config_text_widget.config(state=tk.NORMAL)
            self.config_text_widget.delete('1.0', tk.END)
            
            with open(self.config_file_path, 'r') as f:
                content = f.read()
                self.config_text_widget.insert(tk.END, content)
            
            self.config_text_widget.config(state=tk.DISABLED)
            
            debug_log(f"📕✅ Config table populated successfully.",
                      file=current_file, version=current_version, function=current_function)

        except Exception as e:
            console_log(f"❌ Error populating config table: {e}")
            debug_log(f"📕🔴 Failed to populate config table. Error: {e}",
                      file=current_file, version=current_version, function=current_function)
    
    def _save_program_configure_action(self):
        # This function description tells me what this function does
        # Handles the action of saving the edited config back to the file.
        #
        # Inputs to this function
        #   None.
        #
        # Outputs of this function
        #   None. Saves the config file.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"📕🟢 Attempting to save config file...",
                  file=current_file, version=current_version, function=current_function)

        try:
            current_content = self.config_text_widget.get('1.0', tk.END)
            # This is a dangerous operation - it overwrites the config
            # We'll re-implement a safer save later, but for now this works.
            with open(CONFIG_FILE_PATH, 'w') as f:
                f.write(current_content)
            
            console_log(f"✅ Configuration saved successfully! You'll need to restart to see all changes take effect.")
            debug_log(f"📕✅ Configuration saved. Arrr, the treasure be safely stowed! ⚓️",
                      file=current_file, version=current_version, function=current_function)

        except Exception as e:
            console_log(f"❌ Error saving configuration: {e}")
            debug_log(f"📕🔴 Failed to save configuration. Error: {e}",
                      file=current_file, version=current_version, function=current_function)

    def _reload_config_action(self):
        # This function description tells me what this function does
        # Handles the action of reloading the config file from disk.
        #
        # Inputs to this function
        #   None.
        #
        # Outputs of this function
        #   None. Reloads the config file and updates the text widget.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"📕🟢 Reloading config from disk...",
                  file=current_file, version=current_version, function=current_function)
        
        self._populate_config_table()
        
        console_log("✅ Configuration reloaded from disk.")
        debug_log(f"📕✅ Reloaded config. The map be fresh! 🗺️",
                  file=current_file, version=current_version, function=current_function)

#####################################
### File: OPEN-AIR 2\workers\Experiments\tab_experiments_child_intermod.py
#####################################
# tabs/Experiments/tab_experiments_child_intermod.py
#
# This file defines the InterModTab, a Tkinter Frame for Intermodulation Distortion analysis.
# It allows users to select a markers CSV file, calculate IMD products based on various
# options (e.g., 3rd/5th order, in-band filtering), display results in a Treeview,
# and generate/open an HTML plot of the intermodulation zones.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250801.2150.1 (Refactored debug_print to use debug_log and console_log.)

current_version = "20250801.2150.1" # this variable should always be defined below the header to make the debugging better
current_version_hash = 20250801 * 2150 * 1 # Example hash, adjust as needed

import tkinter as tk
from tkinter import ttk, filedialog, scrolledtext
import inspect
import pandas as pd
import os
import subprocess
from typing import Dict, List, Tuple
from tkinter.font import Font
import sys

# Import the intermodulation calculation and plotting functions - CORRECTED PATHS
from process_math.calculate_intermod import multi_zone_intermods, ZoneData
from process_math.ploting_intermod_zones import plot_zones

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log

class InterModTab(ttk.Frame):
    """
    A Tkinter Frame that contains controls and display for Intermodulation Distortion analysis.
    """
    def __init__(self, master=None, app_instance=None, console_print_func=None, **kwargs):
        """
        Initializes the InterModTab.
        """
        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func if console_print_func else console_log # Use console_log as default

        self.markers_file_path_var = tk.StringVar(self, value="")
        self.intermod_results_csv_path = "INTERMOD.csv"
        self.zones_dashboard_html_path = "zones_dashboard.html"

        self.filter_in_band_enabled_var = tk.BooleanVar(self, value=False)
        self.in_band_min_freq_var = tk.DoubleVar(self, value=470.0)
        self.in_band_max_freq_var = tk.DoubleVar(self, value=608.0)
        self.include_3rd_order_var = tk.BooleanVar(self, value=True)
        self.include_5th_order_var = tk.BooleanVar(self, value=True)
        self.color_code_severity_var = tk.BooleanVar(self, value=True)
        self.export_filtered_csv_var = tk.BooleanVar(self, value=True)

        # Variable to store the last loaded/generated DataFrame for sorting/plotting
        self.last_imd_df = pd.DataFrame()

        self._create_widgets()

    def _create_widgets(self):
        """
        Creates and arranges the widgets for the Inter Mod tab.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        debug_log("Creating widgets for InterModTab...",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(0, weight=0)
        self.grid_rowconfigure(1, weight=0)
        self.grid_rowconfigure(2, weight=0)
        self.grid_rowconfigure(3, weight=1)

        # --- CSV File Selection Frame ---
        file_selection_frame = ttk.LabelFrame(self, text="Marker CSV File Selection", style='Dark.TLabelframe')
        file_selection_frame.grid(row=0, column=0, padx=10, pady=10, sticky="ew")
        file_selection_frame.grid_columnconfigure(1, weight=1)

        ttk.Label(file_selection_frame, text="Markers CSV Path:", style='TLabel').grid(row=0, column=0, sticky="w", padx=5, pady=2)
        ttk.Entry(file_selection_frame, textvariable=self.markers_file_path_var, style='TEntry', state='readonly').grid(row=0, column=1, sticky="ew", padx=5, pady=2)
        ttk.Button(file_selection_frame, text="Browse MARKERS.CSV", command=self._browse_markers_file, style='Blue.TButton').grid(row=0, column=2, padx=5, pady=2)

        # --- IMD Calculation Options Frame ---
        options_frame = ttk.LabelFrame(self, text="Intermodulation Calculation Options", style='Dark.TLabelframe')
        options_frame.grid(row=1, column=0, padx=10, pady=10, sticky="ew")
        options_frame.grid_columnconfigure(0, weight=1)
        options_frame.grid_columnconfigure(1, weight=1)

        row_idx = 0
        ttk.Checkbutton(options_frame, text="Filter In-Band (MHz)", variable=self.filter_in_band_enabled_var, style='TCheckbutton').grid(row=row_idx, column=0, sticky="w", padx=5, pady=2)
        in_band_frame = ttk.Frame(options_frame, style='Dark.TFrame')
        in_band_frame.grid(row=row_idx, column=1, sticky="ew", padx=5, pady=2)
        in_band_frame.grid_columnconfigure(0, weight=1)
        in_band_frame.grid_columnconfigure(1, weight=1)
        ttk.Label(in_band_frame, text="Min:", style='TLabel').grid(row=0, column=0, sticky="w")
        ttk.Entry(in_band_frame, textvariable=self.in_band_min_freq_var, style='TEntry', width=8).grid(row=0, column=0, sticky="e", padx=(0,5))
        ttk.Label(in_band_frame, text="Max:", style='TLabel').grid(row=0, column=1, sticky="w")
        ttk.Entry(in_band_frame, textvariable=self.in_band_max_freq_var, style='TEntry', width=8).grid(row=0, column=1, sticky="e")
        row_idx += 1

        ttk.Checkbutton(options_frame, text="Include 3rd Order IMD (2f1-f2, 2f2-f1)", variable=self.include_3rd_order_var, style='TCheckbutton').grid(row=row_idx, column=0, columnspan=2, sticky="w", padx=5, pady=2); row_idx += 1
        ttk.Checkbutton(options_frame, text="Include 5th Order IMD (3f1-2f2, 3f2-2f1)", variable=self.include_5th_order_var, style='TCheckbutton').grid(row=row_idx, column=0, columnspan=2, sticky="w", padx=5, pady=2); row_idx += 1
        ttk.Checkbutton(options_frame, text="Color-Code Plot by Severity", variable=self.color_code_severity_var, style='TCheckbutton').grid(row=row_idx, column=0, columnspan=2, sticky="w", padx=5, pady=2); row_idx += 1
        ttk.Checkbutton(options_frame, text="Export Filtered CSV", variable=self.export_filtered_csv_var, style='TCheckbutton').grid(row=row_idx, column=0, columnspan=2, sticky="w", padx=5, pady=2); row_idx += 1


        # --- Action Buttons Frame ---
        action_buttons_frame = ttk.Frame(self, style='Dark.TFrame')
        action_buttons_frame.grid(row=2, column=0, padx=10, pady=10, sticky="ew")
        action_buttons_frame.grid_columnconfigure(0, weight=1)
        action_buttons_frame.grid_columnconfigure(1, weight=1)
        action_buttons_frame.grid_columnconfigure(2, weight=1)
        action_buttons_frame.grid_columnconfigure(3, weight=1) # Added for new buttons

        ttk.Button(action_buttons_frame, text="Calculate IMD", command=self._process_imd, style='Green.TButton').grid(row=0, column=0, padx=5, pady=5, sticky="ew")
        ttk.Button(action_buttons_frame, text="Open Intermod CSV", command=self._open_intermod_csv, style='Blue.TButton').grid(row=0, column=1, padx=5, pady=5, sticky="ew")
        ttk.Button(action_buttons_frame, text="Plot Results", command=self._plot_imd_results, style='Purple.TButton').grid(row=0, column=2, padx=5, pady=5, sticky="ew")
        ttk.Button(action_buttons_frame, text="Load Intermod CSV", command=self._load_intermod_csv, style='Orange.TButton').grid(row=0, column=3, padx=5, pady=5, sticky="ew")


        # --- Treeview for IMD Results Display ---
        results_frame = ttk.LabelFrame(self, text="Intermodulation Results (INTERMOD.csv)", style='Dark.TLabelframe')
        results_frame.grid(row=3, column=0, padx=10, pady=10, sticky="nsew")
        results_frame.grid_rowconfigure(0, weight=1)
        results_frame.grid_columnconfigure(0, weight=1)

        self.imd_treeview = ttk.Treeview(results_frame, show="headings")
        self.imd_treeview.grid(row=0, column=0, sticky="nsew")

        # Scrollbars for Treeview
        tree_scrollbar_y = ttk.Scrollbar(results_frame, orient="vertical", command=self.imd_treeview.yview)
        tree_scrollbar_y.grid(row=0, column=1, sticky="ns")
        self.imd_treeview.configure(yscrollcommand=tree_scrollbar_y.set)

        tree_scrollbar_x = ttk.Scrollbar(results_frame, orient="horizontal", command=self.imd_treeview.xview)
        tree_scrollbar_x.grid(row=1, column=0, sticky="ew")
        self.imd_treeview.configure(xscrollcommand=tree_scrollbar_x.set)

        # Bind click event for column sorting
        self.imd_treeview.bind("<Button-1>", self._on_treeview_header_click)

        debug_log("InterModTab widgets created.",
                    file=__file__,
                    version=current_version,
                    function=current_function)

    def _browse_markers_file(self):
        """Opens a file dialog to select the MARKERS.CSV file."""
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        file_path = filedialog.askopenfilename(
            title="Select MARKERS.CSV",
            filetypes=[("CSV files", "*.csv")]
        )
        if file_path:
            self.markers_file_path_var.set(file_path)
            self.console_print_func(f"Selected Markers CSV: {file_path}")
            debug_log(f"Selected Markers CSV: {file_path}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        else:
            self.console_print_func("No Markers CSV file selected.")
            debug_log("No Markers CSV file selected. What a waste of a click!",
                        file=__file__,
                        version=current_version,
                        function=current_function)

    def _parse_markers_csv(self, csv_path: str) -> ZoneData:
        """
        Parses the markers CSV file to extract zone data, including frequencies and associated devices.
        Returns:
            zones_data: dict
              Keys = zone names from 'ZONE' column
              Values = tuple of (list of (frequency, device_name) tuples, (x, y) coordinates)
        """
        import random
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        debug_log(f"Parsing {csv_path}...",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        zones_data = {}
        try:
            df = pd.read_csv(csv_path)

            # Ensure required columns exist
            required_columns = ["ZONE", "FREQ", "DEVICE", "NAME"]
            if not all(col in df.columns for col in required_columns):
                raise ValueError(f"CSV must contain columns: {', '.join(required_columns)}")

            for zone_name in df["ZONE"].unique():
                zone_df = df[df["ZONE"] == zone_name].dropna(subset=["FREQ"])

                # Combine DEVICE and NAME for a more descriptive device_name
                # Handle cases where DEVICE or NAME might be missing/NaN
                freq_device_pairs = []
                for _, row in zone_df.iterrows():
                    freq = row["FREQ"]
                    device = str(row["DEVICE"]) if pd.notna(row["DEVICE"]) else "Unknown Device"
                    name = str(row["NAME"]) if pd.notna(row["NAME"]) else "Unknown Name"

                    # If both DEVICE and NAME are "None - None - G10" or similar, just use the NAME
                    if "None - None" in device and "None" in name:
                        device_name = name
                    elif "None - None" in device:
                        device_name = name
                    elif "None" in name:
                        device_name = device
                    else:
                        device_name = f"{device} - {name}"

                    freq_device_pairs.append((freq, device_name))

                # Assign dummy coordinates if not available in CSV
                # You should replace this with your actual coordinate lookup if available!
                x = hash(zone_name) % 100
                y = (hash(zone_name) // 100) % 100
                zones_data[zone_name] = (freq_device_pairs, (x, y))

            self.console_print_func(f"Successfully parsed {len(zones_data)} zones from CSV.")
            debug_log(f"Parsed zones data: {zones_data}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return zones_data

        except Exception as e:
            self.console_print_func(f"❌ Failed to parse markers CSV: {e}")
            debug_log(f"Error parsing markers CSV: {e}. This CSV is a stubborn bastard!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return {}

    def _display_imd_results(self, df: pd.DataFrame):
        """Displays the intermodulation results DataFrame in the Treeview."""
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        debug_log(f"Displaying IMD results. DataFrame has {len(df)} rows.",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        # Clear existing data
        for item in self.imd_treeview.get_children():
            self.imd_treeview.delete(item)

        if df.empty:
            self.console_print_func("No IMD results to display.")
            debug_log("IMD DataFrame is empty, no results to display. Fucking empty!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        # Define the desired order of columns for display
        display_columns = [
            "Zone_1", "Device_1", "Parent_Freq1",
            "Zone_2", "Device_2", "Parent_Freq2",
            "Type", "Order", "Distance", "Frequency_MHz", "Severity"
        ]

        # Ensure all display_columns exist in the DataFrame, add missing ones if necessary
        for col in display_columns:
            if col not in df.columns:
                df[col] = "N/A"

        # Set columns for Treeview
        self.imd_treeview["columns"] = display_columns
        for col in display_columns:
            self.imd_treeview.heading(col, text=col.replace('_', ' '), anchor="center")
            self.imd_treeview.column(col, width=Font().measure(col.replace('_', ' ')) + 15, anchor="center")

        # Insert data and adjust column widths
        for index, row in df.iterrows():
            try:
                values_to_insert = []
                for col in display_columns:
                    value = row[col]
                    if isinstance(value, (int, float)):
                        if col == "Frequency_MHz" or col == "Parent_Freq1" or col == "Parent_Freq2":
                            str_value = f"{value:.3f}"
                        elif col == "Distance":
                            str_value = f"{value:.2f}"
                        else:
                            str_value = str(value)
                    else:
                        str_value = str(value)

                    values_to_insert.append(str_value)

                    current_width = self.imd_treeview.column(col, "width")
                    new_width = Font().measure(str_value) + 15
                    if new_width > current_width:
                        self.imd_treeview.column(col, width=new_width)

                self.imd_treeview.insert("", "end", values=values_to_insert)
            except Exception as e:
                self.console_print_func(f"❌ Error displaying IMD row (index {index}): {row.to_dict()} - {e}")
                debug_log(f"Error inserting row into Treeview (index {index}): {row.to_dict()} - {e}. This row is a pain in the ass!",
                            file=__file__,
                            version=current_version,
                            function=current_function)
                continue
        self.console_print_func(f"Displayed {len(df)} IMD products.")
        self.last_imd_df = df.copy()


    def _process_imd(self):
        """
        Initiates the IMD calculation and plot generation based on selected options.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        self.console_print_func("\n--- Starting IMD Calculation & Plot Generation ---")
        debug_log("Starting IMD Calculation & Plot Generation...",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        markers_csv_path = self.markers_file_path_var.get()
        if not markers_csv_path or not os.path.exists(markers_csv_path):
            self.console_print_func("Error: Please select a valid MARKERS.CSV file first.")
            debug_log("No valid Markers CSV selected. Fucking useless!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        try:
            # 1. Parse Markers CSV to ZoneData
            zones = self._parse_markers_csv(markers_csv_path)
            if not zones:
                self.console_print_func("IMD calculation aborted due to empty or invalid zone data.")
                debug_log("Empty or invalid zone data after parsing. What the hell?!",
                            file=__file__,
                            version=current_version,
                            function=current_function)
                return

            # Determine output paths relative to the markers CSV
            output_dir = os.path.dirname(markers_csv_path)
            intermod_csv_output = os.path.join(output_dir, self.intermod_results_csv_path)
            zones_html_output = os.path.join(output_dir, self.zones_dashboard_html_path)

            # 2. Calculate Intermodulation Products
            self.console_print_func("Calculating intermodulation products...")
            debug_log(f"Calling multi_zone_intermods with zones: {zones}",
                        file=__file__,
                        version=current_version,
                        function=current_function)

            imd_results_df = multi_zone_intermods(
                zones=zones,
                include_cross_zone=True,
                export_csv=intermod_csv_output,
                filter_in_band=self.filter_in_band_enabled_var.get(),
                in_band_min_freq=self.in_band_min_freq_var.get(),
                in_band_max_freq=self.in_band_max_freq_var.get(),
                include_3rd_order=self.include_3rd_order_var.get(),
                include_5th_order=self.include_5th_order_var.get()
            )
            debug_log(f"multi_zone_intermods returned DataFrame. Type: {type(imd_results_df)}, Shape: {imd_results_df.shape}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            debug_log(f"First 5 rows of IMD DataFrame:\n{imd_results_df.head().to_string()}",
                        file=__file__,
                        version=current_version,
                        function=current_function)


            self.console_print_func(f"IMD calculation complete. Results saved to: {intermod_csv_output}")
            self.console_print_func(f"Total IMD products found (after filters): {len(imd_results_df)}")

            # 3. Display results in Treeview
            self._display_imd_results(imd_results_df)
            self.console_print_func("✅ IMD analysis results displayed.")

            self.console_print_func("--- IMD Analysis Complete! ---")
            debug_log("IMD Analysis Complete. Fucking awesome!",
                        file=__file__,
                        version=current_version,
                        function=current_function)

        except Exception as e:
            self.console_print_func(f"❌ An error occurred during IMD analysis: {e}")
            debug_log(f"Error during IMD analysis: {e}. This bugger is being problematic!",
                        file=__file__,
                        version=current_version,
                        function=current_function)

    def _open_intermod_map(self):
        """
        Opens the generated HTML intermod map in the default web browser.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log

        markers_csv_path = self.markers_file_path_var.get()
        if not markers_csv_path:
            self.console_print_func("Error: Please select a Markers CSV file and run IMD calculation first to generate the map.")
            debug_log("No Markers CSV selected, cannot open map. Fucking useless!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        output_dir = os.path.dirname(markers_csv_path)
        html_file_path = os.path.join(output_dir, self.zones_dashboard_html_path)

        if not os.path.exists(html_file_path):
            self.console_print_func(f"Error: Intermod map HTML file not found at {html_file_path}. Please run IMD calculation first.")
            debug_log(f"HTML map not found: {html_file_path}. Where the hell is it?!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        try:
            if sys.platform == "win32":
                os.startfile(html_file_path)
            elif sys.platform == "darwin": # macOS
                subprocess.Popen(["open", html_file_path])
            else: # Linux
                subprocess.Popen(["xdg-open", html_file_path])
            self.console_print_func(f"✅ Opened Intermod Map: {html_file_path}")
            debug_log(f"Opened Intermod Map: {html_file_path}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        except Exception as e:
            self.console_print_func(f"❌ Failed to open Intermod Map: {e}")
            debug_log(f"Error opening Intermod Map: {e}. This is a goddamn mess!",
                        file=__file__,
                        version=current_version,
                        function=current_function)

    def _open_intermod_csv(self):
        """
        Opens the generated INTERMOD.csv file in the default associated application.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log

        markers_csv_path = self.markers_file_path_var.get()
        if not markers_csv_path:
            self.console_print_func("Error: Please select a Markers CSV file and run IMD calculation first to generate the CSV.")
            debug_log("No Markers CSV selected, cannot open intermod CSV. Fucking useless!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        output_dir = os.path.dirname(markers_csv_path)
        csv_file_path = os.path.join(output_dir, self.intermod_results_csv_path)

        if not os.path.exists(csv_file_path):
            self.console_print_func(f"Error: Intermod CSV file not found at {csv_file_path}. Please run IMD calculation first.")
            debug_log(f"Intermod CSV file not found: {csv_file_path}. Where the hell is it?!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        try:
            if sys.platform == "win32":
                os.startfile(csv_file_path)
            elif sys.platform == "darwin": # macOS
                subprocess.Popen(["open", csv_file_path])
            else: # Linux
                subprocess.Popen(["xdg-open", csv_file_path])
            self.console_print_func(f"✅ Opened Intermod CSV: {csv_file_path}")
            debug_log(f"Opened Intermod CSV: {csv_file_path}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        except Exception as e:
            self.console_print_func(f"❌ Failed to open Intermod CSV: {e}")
            debug_log(f"Error opening Intermod CSV: {e}. This is a goddamn mess!",
                        file=__file__,
                        version=current_version,
                        function=current_function)

    def _plot_imd_results(self):
        """
        Generates and opens the Plotly HTML dashboard based on the last calculated/loaded IMD results.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log

        if self.last_imd_df.empty:
            self.console_print_func("Error: No IMD results available to plot. Please calculate or load results first.")
            debug_log("No IMD data to plot. Fucking empty!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        markers_csv_path = self.markers_file_path_var.get()
        if not markers_csv_path or not os.path.exists(markers_csv_path):
            self.console_print_func("Error: Markers CSV path is required to generate the plot (for zone coordinates). Please select it.")
            debug_log("Markers CSV path missing for plotting. Fucking useless!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        try:
            zones = self._parse_markers_csv(markers_csv_path)
            if not zones:
                self.console_print_func("Error: Cannot plot without valid zone data from Markers CSV.")
                debug_log("No zones parsed for plotting. What the hell?!",
                            file=__file__,
                            version=current_version,
                            function=current_function)
                return

            output_dir = os.path.dirname(markers_csv_path)
            zones_html_output = os.path.join(output_dir, self.zones_dashboard_html_path)

            self.console_print_func("Generating Plotly dashboard...")
            plot_zones(
                zones=zones,
                imd_df=self.last_imd_df,
                html_filename=zones_html_output,
                color_code_severity=self.color_code_severity_var.get()
            )
            self.console_print_func(f"Plotly dashboard generated: {zones_html_output}")
            self._open_intermod_map() # Reuse existing method to open the HTML
            self.console_print_func("✅ Intermodulation map opened in browser.")

        except Exception as e:
            self.console_print_func(f"❌ An error occurred during plot generation: {e}")
            debug_log(f"Error during plot generation: {e}. This bugger is being problematic!",
                        file=__file__,
                        version=current_version,
                        function=current_function)

    def _load_intermod_csv(self):
        """
        Loads an existing INTERMOD.csv file into the Treeview for display and makes it available for plotting.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log

        file_path = filedialog.askopenfilename(
            title="Select Intermod Results CSV",
            filetypes=[("CSV files", "*.csv")],
            initialdir=os.path.dirname(self.markers_file_path_var.get()) if self.markers_file_path_var.get() else os.getcwd()
        )
        if not file_path:
            self.console_print_func("No Intermod CSV file selected for loading.")
            debug_log("No Intermod CSV selected for loading. Fucking useless!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        try:
            df = pd.read_csv(file_path)
            self._display_imd_results(df)
            self.console_print_func(f"✅ Loaded IMD results from: {file_path}")
            debug_log(f"Loaded IMD results from: {file_path}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        except Exception as e:
            self.console_print_func(f"❌ Failed to load Intermod CSV: {e}")
            debug_log(f"Error loading Intermod CSV: {e}. This CSV is a stubborn bastard!",
                        file=__file__,
                        version=current_version,
                        function=current_function)


    def _on_treeview_header_click(self, event):
        """
        Handles clicks on Treeview column headers to sort the data.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log

        region = self.imd_treeview.identify("region", event.x, event.y)
        if region == "heading":
            col = self.imd_treeview.identify_column(event.x)
            column_id = int(col.replace('#', '')) - 1

            if 0 <= column_id < len(self.imd_treeview["columns"]):
                column_name = self.imd_treeview["columns"][column_id]
                debug_log(f"Header '{column_name}' clicked for sorting.",
                            file=__file__,
                            version=current_version,
                            function=current_function)

                if not hasattr(self, '_sort_order'):
                    self._sort_order = {}

                current_sort_order = self._sort_order.get(column_name, 'ascending')
                new_sort_order = 'descending' if current_sort_order == 'ascending' else 'ascending'
                self._sort_order[column_name] = new_sort_order

                self._sort_treeview(column_name, new_sort_order)
            else:
                debug_log(f"Clicked column ID {column_id} is out of bounds for current columns. What the hell?!",
                            file=__file__,
                            version=current_version,
                            function=current_function)
        else:
            debug_log(f"Click not on heading region: {region}. Fucking useless click!",
                        file=__file__,
                        version=current_version,
                        function=current_function)

    def _sort_treeview(self, col_name, order):
        """
        Sorts the Treeview content by the given column and order.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        debug_log(f"Sorting Treeview by column '{col_name}' in '{order}' order.",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        if self.last_imd_df.empty:
            self.console_print_func("No data to sort.")
            debug_log("No data in last_imd_df to sort. Fucking empty!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        if col_name not in self.last_imd_df.columns:
            self.console_print_func(f"Error: Cannot sort by column '{col_name}' as it does not exist in the data.")
            debug_log(f"Column '{col_name}' not found for sorting. What the hell?!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        ascending = (order == 'ascending')

        numeric_cols = ["Frequency_MHz", "Parent_Freq1", "Parent_Freq2", "Distance"]
        for num_col in numeric_cols:
            if num_col in self.last_imd_df.columns:
                self.last_imd_df[num_col] = pd.to_numeric(self.last_imd_df[num_col], errors='coerce')

        sorted_df = self.last_imd_df.sort_values(by=col_name, ascending=ascending, na_position='last')

        self._display_imd_results(sorted_df)
        self.console_print_func(f"Sorted results by '{col_name}' ({order}).")

    def _on_tab_selected(self, event):
        """
        Called when this tab is selected in the notebook.
        Can be used to refresh data or update UI elements specific to this tab.
        """
        current_function = inspect.currentframe().f_code.co_name
        # current_file will be derived from __file__ in debug_log
        debug_log("Inter Mod Tab selected.",
                    file=__file__,
                    version=current_version,
                    function=current_function)


#####################################
### File: OPEN-AIR 2\workers\Experiments\tab_experiments_child_yak_beg.py
#####################################
# tabs/Experiments/tab_experiments_child_YakBeg.py
#
# This file defines the YakBegTab, a Tkinter Frame that provides functionality
# to test and demonstrate the new YakBeg command. It includes UI elements for
# configuring and querying frequency, span, trace modes, and trace data in a
# single, efficient operation.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250818.193300.1 (NEW: Initial version to test the YakBeg function.)
# Version 20250818.193600.1 (FIXED: Moved YakBeg import inside methods to resolve circular import error.)
# Version 20250818.194000.1 (FIXED: Corrected _on_trace_data_beg to use YakBeg with correct command type from CSV.)
# Version 20250818.194100.1 (FIXED: Corrected the parsing of the trace data response string from the BEG command.)
# Version 20250818.194200.1 (FIXED: The _on_trace_data_beg function was updated to correctly parse the mixed separator response.)
# Version 20250818.194500.1 (FIXED: Corrected the parsing of the trace data response string from the BEG command to handle mixed separators.)
# Version 20250818.194600.1 (FIXED: Implemented parsing logic to correctly handle the semicolon-separated frequency values and comma-separated trace data.)
# Version 20250818.194800.1 (FIXED: The _on_trace_data_beg function was updated to correctly parse the comma-separated response with known start/stop frequencies.)
# Version 20250818.195000.1 (NEW: Added "Push to Monitor" button and functionality.)
# Version 20250818.195200.1 (FIXED: Corrected the command_type for TRACE/DATA to use the correct format from the CSV.)
# Version 20250818.195300.1 (FIXED: The _on_trace_data_beg function was updated to use the correct hardcoded command type from the CSV.)
# Version 20250818.195500.1 (NEW: Added MARKER/PLACE/ALL experiment.)
# Version 20250818.195700.1 (FIXED: Corrected the trace data parsing to use the comma separator, and added a marker experiment frame.)
# Version 20250818.200000.1 (FIXED: Corrected the command type string for trace data to match the CSV file, fixing the persistent KeyError.)
# Version 20250818.200200.1 (FIXED: Added logic to turn markers on before a YakBeg call and off afterwards.)
# Version 20250818.200300.1 (FIXED: The trace data command type string was corrected to use the hardcoded command from the CSV, not a dynamic string, fixing the KeyError.)
# Version 20250818.200500.1 (FIXED: Corrected frequency conversions to integers to fix instrument communication errors.)
# Version 20250818.201500.1 (REFACTORED: Moved all core logic to utils_yakbeg_handler.py to decouple UI from business logic.)
# Version 20250818.202500.1 (REFACTORED: Updated UI layer to call new handler functions and correctly process their return values.)
# Version 20250818.202800.1 (FIXED: Corrected the _on_marker_place_all_beg function to extract string values from StringVar objects before passing to handler.)

current_version = "20250818.202800.1"
current_version_hash = (20250818 * 202800 * 1)

import tkinter as tk
from tkinter import ttk, scrolledtext
import inspect
import os
import numpy as np

# Import the new handler module
from yak.utils_yakbeg_handler import (
    handle_freq_start_stop_beg,
    handle_freq_center_span_beg,
    handle_marker_place_all_beg,
    handle_trace_modes_beg,
    handle_trace_data_beg)
from display.debug_logic import debug_log
from display.console_logic import console_log

class YakBegTab(ttk.Frame):
    def __init__(self, master=None, app_instance=None, console_print_func=None, **kwargs):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Initializing YakBegTab. Version: {current_version}. Get ready to beg for some data! 🙏",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)

        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func

        # Tkinter variables for frequency settings
        self.freq_start_var = tk.DoubleVar(value=500000000)
        self.freq_stop_var = tk.DoubleVar(value=1000000000)
        self.freq_center_var = tk.DoubleVar(value=750000000)
        self.freq_span_var = tk.DoubleVar(value=500000000)

        # Tkinter variables for trace modes
        self.trace_mode_options = ["VIEW", "MAXHold", "MINHold", "WRITe", "BLANK"]
        self.trace1_mode_var = tk.StringVar(value=self.trace_mode_options[3])
        self.trace2_mode_var = tk.StringVar(value=self.trace_mode_options[1])
        self.trace3_mode_var = tk.StringVar(value=self.trace_mode_options[2])
        self.trace4_mode_var = tk.StringVar(value=self.trace_mode_options[0])

        # Tkinter variables for trace data
        self.trace_data_start_freq_var = tk.DoubleVar(value=500)
        self.trace_data_stop_freq_var = tk.DoubleVar(value=1000)
        self.trace_select_var = tk.StringVar(value="1")
        self.trace_data_count_var = tk.StringVar(value="0")
        
        # Tkinter variables for Marker/Place/All
        self.marker_freq_vars = [tk.StringVar(self, value="111"), tk.StringVar(self, value="222"),
                                 tk.StringVar(self, value="333"), tk.StringVar(self, value="444"),
                                 tk.StringVar(self, value="555"), tk.StringVar(self, value="666")]
        self.marker_place_all_result_var = tk.StringVar(self, value="Result: N/A")

        self.edit_entry = None
        self.current_edit_cell = None

        self._create_widgets()

        debug_log(f"YakBegTab initialized. The Begging begins! Version: {current_version}",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)

    def _create_widgets(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log("Creating YakBegTab widgets...",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)

        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(3, weight=1)

        # --- FREQUENCY/START-STOP Frame ---
        freq_ss_frame = ttk.LabelFrame(self, text="FREQUENCY/START-STOP", padding=10)
        freq_ss_frame.grid(row=0, column=0, padx=10, pady=5, sticky="ew")
        freq_ss_frame.grid_columnconfigure(1, weight=1)

        ttk.Label(freq_ss_frame, text="Start Frequency (Hz):").grid(row=0, column=0, padx=5, pady=2, sticky="w")
        ttk.Entry(freq_ss_frame, textvariable=self.freq_start_var).grid(row=0, column=1, padx=5, pady=2, sticky="ew")

        ttk.Label(freq_ss_frame, text="Stop Frequency (Hz):").grid(row=1, column=0, padx=5, pady=2, sticky="w")
        ttk.Entry(freq_ss_frame, textvariable=self.freq_stop_var).grid(row=1, column=1, padx=5, pady=2, sticky="ew")

        self.freq_ss_result_var = tk.StringVar(value="Result: N/A")
        ttk.Label(freq_ss_frame, textvariable=self.freq_ss_result_var, style="Dark.TLabel.Value").grid(row=2, column=0, columnspan=2, padx=5, pady=2, sticky="ew")

        ttk.Button(freq_ss_frame, text="YakBeg - FREQUENCY/START-STOP", command=self._on_freq_start_stop_beg).grid(row=3, column=0, columnspan=2, padx=5, pady=5, sticky="ew")


        # --- FREQUENCY/CENTER-SPAN Frame ---
        freq_cs_frame = ttk.LabelFrame(self, text="FREQUENCY/CENTER-SPAN", padding=10)
        freq_cs_frame.grid(row=1, column=0, padx=10, pady=5, sticky="ew")
        freq_cs_frame.grid_columnconfigure(1, weight=1)

        ttk.Label(freq_cs_frame, text="Center Frequency (Hz):").grid(row=0, column=0, padx=5, pady=2, sticky="w")
        ttk.Entry(freq_cs_frame, textvariable=self.freq_center_var).grid(row=0, column=1, padx=5, pady=2, sticky="ew")

        ttk.Label(freq_cs_frame, text="Span (Hz):").grid(row=1, column=0, padx=5, pady=2, sticky="w")
        ttk.Entry(freq_cs_frame, textvariable=self.freq_span_var).grid(row=1, column=1, padx=5, pady=2, sticky="ew")

        self.freq_cs_result_var = tk.StringVar(value="Result: N/A")
        ttk.Label(freq_cs_frame, textvariable=self.freq_cs_result_var, style="Dark.TLabel.Value").grid(row=2, column=0, columnspan=2, padx=5, pady=2, sticky="ew")

        ttk.Button(freq_cs_frame, text="YakBeg - FREQUENCY/CENTER-SPAN", command=self._on_freq_center_span_beg).grid(row=3, column=0, columnspan=2, padx=5, pady=5, sticky="ew")
        
        # --- MARKER/PLACE/ALL Frame ---
        marker_place_all_frame = ttk.LabelFrame(self, text="MARKER/PLACE/ALL", padding=10)
        marker_place_all_frame.grid(row=4, column=0, padx=10, pady=5, sticky="ew")
        marker_place_all_frame.grid_columnconfigure((0, 1, 2, 3, 4, 5), weight=1)

        for i in range(6):
            ttk.Label(marker_place_all_frame, text=f"M{i+1} Freq (MHz):").grid(row=0, column=i, padx=5, pady=2, sticky="w")
            ttk.Entry(marker_place_all_frame, textvariable=self.marker_freq_vars[i]).grid(row=1, column=i, padx=5, pady=2, sticky="ew")

        self.marker_place_all_result_var = tk.StringVar(value="Result: N/A")
        ttk.Label(marker_place_all_frame, textvariable=self.marker_place_all_result_var, style="Dark.TLabel.Value").grid(row=2, column=0, columnspan=6, padx=5, pady=2, sticky="ew")

        ttk.Button(marker_place_all_frame, text="YakBeg - MARKER/PLACE/ALL", command=self._on_marker_place_all_beg).grid(row=3, column=0, columnspan=6, padx=5, pady=5, sticky="ew")


        # --- TRACE/MODES Frame ---
        trace_modes_frame = ttk.LabelFrame(self, text="TRACE/MODES", padding=10)
        trace_modes_frame.grid(row=5, column=0, padx=10, pady=5, sticky="ew")
        trace_modes_frame.grid_columnconfigure(0, weight=1)
        trace_modes_frame.grid_columnconfigure(1, weight=1)
        trace_modes_frame.grid_columnconfigure(2, weight=1)
        trace_modes_frame.grid_columnconfigure(3, weight=1)

        ttk.Label(trace_modes_frame, text="Trace 1 Mode:").grid(row=0, column=0, padx=5, pady=2, sticky="w")
        self.trace1_combo = ttk.Combobox(trace_modes_frame, textvariable=self.trace1_mode_var, values=self.trace_mode_options, state="readonly")
        self.trace1_combo.grid(row=1, column=0, padx=5, pady=2, sticky="ew")
        ttk.Label(trace_modes_frame, text="Trace 2 Mode:").grid(row=0, column=1, padx=5, pady=2, sticky="w")
        self.trace2_combo = ttk.Combobox(trace_modes_frame, textvariable=self.trace2_mode_var, values=self.trace_mode_options, state="readonly")
        self.trace2_combo.grid(row=1, column=1, padx=5, pady=2, sticky="ew")
        ttk.Label(trace_modes_frame, text="Trace 3 Mode:").grid(row=0, column=2, padx=5, pady=2, sticky="w")
        self.trace3_combo = ttk.Combobox(trace_modes_frame, textvariable=self.trace3_mode_var, values=self.trace_mode_options, state="readonly")
        self.trace3_combo.grid(row=1, column=2, padx=5, pady=2, sticky="ew")
        ttk.Label(trace_modes_frame, text="Trace 4 Mode:").grid(row=0, column=3, padx=5, pady=2, sticky="w")
        self.trace4_combo = ttk.Combobox(trace_modes_frame, textvariable=self.trace4_mode_var, values=self.trace_mode_options, state="readonly")
        self.trace4_combo.grid(row=1, column=3, padx=5, pady=2, sticky="ew")
        
        self.trace_modes_result_var = tk.StringVar(value="Result: N/A")
        ttk.Label(trace_modes_frame, textvariable=self.trace_modes_result_var, style="Dark.TLabel.Value").grid(row=2, column=0, columnspan=4, padx=5, pady=2, sticky="ew")
        
        ttk.Button(trace_modes_frame, text="YakBeg - TRACE/MODES", command=self._on_trace_modes_beg).grid(row=3, column=0, columnspan=4, padx=5, pady=5, sticky="ew")


        # --- TRACE/DATA Frame ---
        trace_data_frame = ttk.LabelFrame(self, text="TRACE/DATA", padding=10)
        trace_data_frame.grid(row=6, column=0, padx=10, pady=5, sticky="nsew")
        trace_data_frame.grid_columnconfigure(0, weight=1)
        trace_data_frame.grid_rowconfigure(2, weight=1)
        
        trace_data_controls_frame = ttk.Frame(trace_data_frame)
        trace_data_controls_frame.grid(row=0, column=0, sticky="ew")
        trace_data_controls_frame.grid_columnconfigure(0, weight=1)
        trace_data_controls_frame.grid_columnconfigure(1, weight=1)
        trace_data_controls_frame.grid_columnconfigure(2, weight=1)

        ttk.Label(trace_data_controls_frame, text="Trace #:", style="TLabel").grid(row=0, column=0, padx=5, pady=2, sticky="w")
        self.trace_select_combo = ttk.Combobox(trace_data_controls_frame, textvariable=self.trace_select_var, values=["1", "2", "3", "4"], state="readonly")
        self.trace_select_combo.grid(row=0, column=1, padx=5, pady=2, sticky="ew")
        self.trace_select_combo.set("1")

        ttk.Label(trace_data_controls_frame, text="# of points:", style="TLabel").grid(row=0, column=2, padx=5, pady=2, sticky="w")
        ttk.Label(trace_data_controls_frame, textvariable=self.trace_data_count_var, style="Dark.TLabel.Value").grid(row=0, column=3, padx=5, pady=2, sticky="ew")

        ttk.Label(trace_data_controls_frame, text="Start Freq (MHz):", style="TLabel").grid(row=1, column=0, padx=5, pady=2, sticky="w")
        ttk.Entry(trace_data_controls_frame, textvariable=self.trace_data_start_freq_var).grid(row=1, column=1, padx=5, pady=2, sticky="ew")

        ttk.Label(trace_data_controls_frame, text="Stop Freq (MHz):", style="TLabel").grid(row=1, column=2, padx=5, pady=2, sticky="w")
        ttk.Entry(trace_data_controls_frame, textvariable=self.trace_data_stop_freq_var).grid(row=1, column=3, padx=5, pady=2, sticky="ew")
        
        ttk.Button(trace_data_controls_frame, text="YakBeg - TRACE/DATA", command=self._on_trace_data_beg).grid(row=2, column=0, columnspan=4, padx=5, pady=5, sticky="ew")

        # Table to display trace data
        columns = ("Frequency (MHz)", "Value (dBm)")
        self.trace_data_tree = ttk.Treeview(trace_data_frame, columns=columns, show="headings", style='Treeview')
        self.trace_data_tree.heading("Frequency (MHz)", text="Frequency (MHz)", anchor=tk.W)
        self.trace_data_tree.heading("Value (dBm)", text="Value (dBm)", anchor=tk.W)
        self.trace_data_tree.grid(row=1, column=0, sticky="nsew", padx=5, pady=5)
        
        vsb = ttk.Scrollbar(trace_data_frame, orient="vertical", command=self.trace_data_tree.yview)
        vsb.grid(row=1, column=1, sticky="ns")
        self.trace_data_tree.configure(yscrollcommand=vsb.set)
        
        # New button to push data to monitor
        ttk.Button(self, text="Push Trace Data to Monitor", command=self._on_push_to_monitor, style="Green.TButton").grid(row=7, column=0, padx=10, pady=5, sticky="ew")

    def _on_freq_start_stop_beg(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"YakBeg for FREQUENCY/START-STOP triggered.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)

        from yak.utils_yakbeg_handler import handle_freq_start_stop_beg # Lazy import

        start_freq = self.freq_start_var.get()
        stop_freq = self.freq_stop_var.get()

        start_resp, stop_resp, span_resp, center_resp = handle_freq_start_stop_beg(self.app_instance, start_freq, stop_freq, self.console_print_func)

        if start_resp is not None and stop_resp is not None:
            self.freq_start_var.set(start_resp)
            self.freq_stop_var.set(stop_resp)
            self.freq_ss_result_var.set(f"Result: {start_resp} Hz; {stop_resp} Hz")
        else:
            self.freq_ss_result_var.set("Result: FAILED")


    def _on_freq_center_span_beg(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"YakBeg for FREQUENCY/CENTER-SPAN triggered.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)
        
        center_freq = self.freq_center_var.get()
        span_freq = self.freq_span_var.get()
        
        center_resp, span_resp = handle_freq_center_span_beg(self.app_instance, center_freq, span_freq, self.console_print_func)

        if center_resp is not None and span_resp is not None:
            self.freq_center_var.set(center_resp)
            self.freq_span_var.set(span_resp)
            self.freq_cs_result_var.set(f"Result: {center_resp} Hz; {span_resp} Hz")
        else:
            self.freq_cs_result_var.set("Result: FAILED")


    def _on_marker_place_all_beg(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"YakBeg for MARKER/PLACE/ALL triggered.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)
        
        # FIXED: Get the string value from each StringVar before passing to the handler.
        marker_freqs_mhz = [v.get() for v in self.marker_freq_vars]
        
        response = handle_marker_place_all_beg(self.app_instance, marker_freqs_mhz, self.console_print_func)
        self.marker_place_all_result_var.set(f"Result: {response}")


    def _on_trace_modes_beg(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"YakBeg for TRACE/MODES triggered.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)
        
        trace_modes = [
            self.trace1_mode_var.get(),
            self.trace2_mode_var.get(),
            self.trace3_mode_var.get(),
            self.trace4_mode_var.get()
        ]
        
        response = handle_trace_modes_beg(self.app_instance, trace_modes, self.console_print_func)
        self.trace_modes_result_var.set(f"Result: {response}")


    def _on_trace_data_beg(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"YakBeg for TRACE/DATA triggered.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)
        
        trace_number = self.trace_select_var.get()
        start_freq_mhz = self.trace_data_start_freq_var.get()
        stop_freq_mhz = self.trace_data_stop_freq_var.get()
        
        processed_data = handle_trace_data_beg(self.app_instance, trace_number, start_freq_mhz, stop_freq_mhz, self.console_print_func)

        if processed_data:
            self.trace_data_count_var.set(str(len(processed_data)))
            self.trace_data_tree.delete(*self.trace_data_tree.get_children())
            
            for freq, value in processed_data:
                self.trace_data_tree.insert("", "end", values=(f"{freq:.3f}", f"{value:.2f}"))
            
            self.console_print_func(f"✅ Received and displayed {len(processed_data)} data points.")
        else:
            self.trace_data_count_var.set("0")
            self.trace_data_tree.delete(*self.trace_data_tree.get_children())
            self.console_print_func("❌ Trace data retrieval failed.")

    def _on_tab_selected(self, event):
        """Called when this tab is selected."""
        pass # No specific actions needed on selection
        
    def _on_push_to_monitor(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Push to Monitor button clicked. Let's see if we can get this trace on screen! 🖥️",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)
        
        trace_number = self.trace_select_var.get()
        data = []
        for item in self.trace_data_tree.get_children():
            values = self.trace_data_tree.item(item, 'values')
            data.append((float(values[0]), float(values[1])))
        
        start_freq_mhz = self.trace_data_start_freq_var.get()
        stop_freq_mhz = self.trace_data_stop_freq_var.get()
        
      # handle_push_to_monitor(self.app_instance, self.trace_select_var, self.trace_data_tree, start_freq_mhz, stop_freq_mhz, self.console_print_func)


#####################################
### File: OPEN-AIR 2\workers\Experiments\tab_experiments_colouring.py
#####################################
# tabs/Experiments/tab_experiments_colouring.py
#
# This file defines the ColouringTab, a Tkinter Frame that provides
# functionality to read and display the color palette defined in style.py.
# It will show each color variable's name and a small colored box.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
#
#
# Version 20250816.200000.12 (FIXED: The tab now dynamically reads and displays all colors and styles from `program_style.py`, with clear labels and live previews of buttons.)

current_version = "20250816.200000.12"
current_version_hash = 20250816 * 200000 * 12

import tkinter as tk
from tkinter import ttk, TclError
import inspect
import os
import re

# Import the COLOR_PALETTE and other styles from style.py
from src.program_style import COLOR_PALETTE, COLOR_PALETTE_TABS, _get_dark_color
from display.debug_logic import debug_log
from display.console_logic import console_log

class ColouringTab(ttk.Frame):
    """
    A Tkinter Frame that displays the color palette defined in style.py.
    It shows each color variable's name and a small colored box representing its value,
    along with sections for font sizes and common UI element styles.
    """
    def __init__(self, master=None, app_instance=None, console_print_func=None, **kwargs):
        """
        Initializes the ColouringTab.

        Inputs:
            master (tk.Widget): The parent widget.
            app_instance (App): The main application instance.
            console_print_func (function): Function to print messages to the GUI console.
            **kwargs: Arbitrary keyword arguments for Tkinter Frame.
        """
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__)
        debug_log(f"Initializing ColouringTab...",
                    file=f"{current_file} - {current_version}",
                    version=current_version,
                    function=current_function)

        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func if console_print_func else console_log

        self._create_widgets()

        debug_log(f"ColouringTab initialized. Ready to display colors and styles!",
                    file=f"{current_file} - {current_version}",
                    version=current_version,
                    function=current_function)

    def _create_widgets(self):
        """
        Creates the widgets for the Colouring tab, including a scrollable frame
        to display the color variables, font sizes, and common UI element styles.
        """
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__)
        debug_log(f"Creating ColouringTab widgets...",
                    file=f"{current_file} - {current_version}",
                    version=current_version,
                    function=current_function)

        # Create a Canvas and a Scrollbar for scrollable content
        self.canvas = tk.Canvas(self, background=COLOR_PALETTE['background'], highlightthickness=0)
        self.scrollbar = ttk.Scrollbar(self, orient="vertical", command=self.canvas.yview)
        self.scrollable_frame = ttk.Frame(self.canvas, style='Dark.TFrame')

        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: self.canvas.configure(
                scrollregion=self.canvas.bbox("all")
            )
        )
        # Bind mouse wheel for scrolling
        self.canvas.bind_all("<MouseWheel>", self._on_mousewheel) # For Windows/macOS
        self.canvas.bind_all("<Button-4>", self._on_mousewheel) # For Linux (scroll up)
        self.canvas.bind_all("<Button-5>", self._on_mousewheel) # For Linux (scroll down)


        self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")
        self.canvas.configure(yscrollcommand=self.scrollbar.set)

        self.canvas.pack(side="left", fill="both", expand=True)
        self.scrollbar.pack(side="right", fill="y")

        self._populate_content()

    def _on_mousewheel(self, event):
        """Handles mouse wheel scrolling for the canvas."""
        if self.canvas.winfo_exists(): # Check if canvas still exists
            if event.num == 4 or event.delta > 0: # Scroll up
                self.canvas.yview_scroll(-1, "unit")
            elif event.num == 5 or event.delta < 0: # Scroll down
                self.canvas.yview_scroll(1, "unit")

    def _populate_content(self):
        """
        Populates the scrollable frame with color palette, font sizes, and common styles.
        """
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__)
        debug_log(f"Populating ColouringTab content...",
                    file=f"{current_file} - {current_version}",
                    version=current_version,
                    function=current_function)

        # Clear any existing widgets in the scrollable frame
        for widget in self.scrollable_frame.winfo_children():
            widget.destroy()

        row_idx = 0

        # --- Section 1: Color Palette (Grouped Horizontally) ---
        color_palette_main_frame = ttk.LabelFrame(self.scrollable_frame, text="Color Palette", style='Dark.TLabelframe', padding=(10, 10))
        color_palette_main_frame.grid(row=row_idx, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        color_palette_main_frame.grid_columnconfigure(0, weight=1)
        color_palette_main_frame.grid_columnconfigure(1, weight=1)
        color_palette_main_frame.grid_columnconfigure(2, weight=1)
        row_idx += 1

        # Frame for Defaults/Globals
        defaults_frame = ttk.LabelFrame(color_palette_main_frame, text="Defaults / Globals", style='Dark.TLabelframe', padding=(5, 5))
        defaults_frame.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)
        defaults_frame.grid_columnconfigure(0, weight=1) # For color name label
        defaults_frame.grid_columnconfigure(1, weight=0) # For color box

        # Frame for Buttons
        buttons_color_frame = ttk.LabelFrame(color_palette_main_frame, text="Button Colors", style='Dark.TLabelframe', padding=(5, 5))
        buttons_color_frame.grid(row=0, column=1, sticky="nsew", padx=5, pady=5)
        buttons_color_frame.grid_columnconfigure(0, weight=1)
        buttons_color_frame.grid_columnconfigure(1, weight=0)

        # Frame for Parent Tabs
        parent_tabs_color_frame = ttk.LabelFrame(color_palette_main_frame, text="Parent Tab Colors", style='Dark.TLabelframe', padding=(5, 5))
        parent_tabs_color_frame.grid(row=0, column=2, sticky="nsew", padx=5, pady=5)
        parent_tabs_color_frame.grid_columnconfigure(0, weight=1)
        parent_tabs_color_frame.grid_columnconfigure(1, weight=0)


        default_row_idx = 0
        button_row_idx = 0
        parent_tab_row_idx = 0

        for color_name, color_value in COLOR_PALETTE.items():
            if '_btn' in color_name: # Simple check for button related colors
                self._add_color_display_row(buttons_color_frame, f"{color_name}: {color_value}", color_value, button_row_idx)
                button_row_idx += 1
            elif color_name in ['white', 'black']:
                self._add_color_display_row(defaults_frame, f"{color_name}: {color_value}", color_value, default_row_idx)
                default_row_idx += 1
            else: # Defaults/Globals
                self._add_color_display_row(defaults_frame, f"{color_name}: {color_value}", color_value, default_row_idx)
                default_row_idx += 1
        
        # New loop for COLOR_PALETTE_TABS
        for tab_name, tab_colors in COLOR_PALETTE_TABS.items():
            ttk.Label(parent_tabs_color_frame, text=f"--- {tab_name.replace('_', ' ').title()} ---",
                      style='Dark.TLabel.Value', font=('Helvetica', 11, 'bold')).grid(row=parent_tab_row_idx, column=0, columnspan=2, pady=(10, 2), sticky="w", padx=5)
            parent_tab_row_idx += 1
            for state_name, hex_code in tab_colors.items():
                self._add_color_display_row(parent_tabs_color_frame, f"{state_name}: {hex_code}", hex_code, parent_tab_row_idx, indent=1)
                parent_tab_row_idx += 1
                if state_name == 'active':
                    # Add inactive color as well for clarity
                    inactive_color = _get_dark_color(hex_code)
                    self._add_color_display_row(parent_tabs_color_frame, f"inactive: {inactive_color}", inactive_color, parent_tab_row_idx, indent=1)
                    parent_tab_row_idx += 1


        # --- Section 2: Font Sizes ---
        font_sizes_frame = ttk.LabelFrame(self.scrollable_frame, text="Common Font Sizes (Helvetica)", style='Dark.TLabelframe', padding=(10, 10))
        font_sizes_frame.grid(row=row_idx, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        font_sizes_frame.grid_columnconfigure(0, weight=1)
        row_idx += 1

        common_font_sizes = [9, 10, 11, 12, 13, 14, 25, 100] # Based on style.py analysis
        current_font_row = 0
        for size in common_font_sizes:
            ttk.Label(font_sizes_frame, text=f"Font Size {size}pt", # Removed "Example Text"
                      background=COLOR_PALETTE['background'],
                      foreground=COLOR_PALETTE['foreground'],
                      font=('Helvetica', size, 'bold' if size >= 12 else '')).grid(row=current_font_row, column=0, sticky="w", padx=5, pady=2)
            current_font_row += 1

        # --- Section 3: Common UI Element Styles ---
        ui_styles_frame = ttk.LabelFrame(self.scrollable_frame, text="Common UI Element Styles", style='Dark.TLabelframe', padding=(10, 10))
        ui_styles_frame.grid(row=row_idx, column=0, columnspan=2, sticky="ew", padx=10, pady=10)
        ui_styles_frame.grid_columnconfigure(0, weight=1)
        ui_styles_frame.grid_columnconfigure(1, weight=1)
        row_idx += 1

        # Define some conceptual styles based on style.py
        common_ui_styles = {
            "TLabel (Default)": {"widget_type": "label", "style_name": "TLabel"},
            "Dark.TLabel.Value": {"widget_type": "label", "style_name": "Dark.TLabel.Value"},
            "Red.TLabel.Value": {"widget_type": "label", "style_name": "Red.TLabel.Value"},
            "TEntry (Default)": {"widget_type": "entry", "style_name": "TEntry"},
            "TButton (Default)": {"widget_type": "button", "style_name": "TButton"},
            "Green.TButton": {"widget_type": "button", "style_name": "Green.TButton"},
            "Red.TButton": {"widget_type": "button", "style_name": "Red.TButton"},
            "Orange.TButton": {"widget_type": "button", "style_name": "Orange.TButton"},
            "Blue.TButton": {"widget_type": "button", "style_name": "Blue.TButton"},
            "Purple.TButton": {"widget_type": "button", "style_name": "Purple.TButton"},
            "StartScan.TButton": {"widget_type": "button", "style_name": "StartScan.TButton"},
            "PauseScan.TButton": {"widget_type": "button", "style_name": "PauseScan.TButton"},
            "StopScan.TButton": {"widget_type": "button", "style_name": "StopScan.TButton"},
            "LocalPreset.TButton": {"widget_type": "button", "style_name": "LocalPreset.TButton"},
            "SelectedPreset.Orange.TButton": {"widget_type": "button", "style_name": "SelectedPreset.Orange.TButton"},
            "DeviceButton.Blinking.TButton": {"widget_type": "button", "style_name": "DeviceButton.Blinking.TButton"},
            "ControlButton.Active.TButton": {"widget_type": "button", "style_name": "ControlButton.Active.TButton"},
            "Band.Low.TButton": {"widget_type": "button", "style_name": "Band.Low.TButton"},
            "Band.Medium.TButton": {"widget_type": "button", "style_name": "Band.Medium.TButton"},
            "Band.High.TButton": {"widget_type": "button", "style_name": "Band.High.TButton"},
        }
        
        current_ui_row = 0
        for display_name, properties in common_ui_styles.items():
            try:
                style_name = properties['style_name']
                # FIXED: Changed `self.app_instance.style` to `self.app_instance.style_obj`
                style_spec = self.app_instance.style_obj.lookup(style_name, 'font')
                if style_spec:
                    style_font = style_spec
                else:
                    style_font = ("Helvetica", 9)
            except TclError:
                style_font = ("Helvetica", 9)

            style_box = ttk.Frame(ui_styles_frame, style='Dark.TFrame', relief="solid", borderwidth=1)
            style_box.grid(row=current_ui_row, column=0, columnspan=2, sticky="ew", padx=5, pady=5)
            style_box.grid_columnconfigure(0, weight=1) # For the label/button inside the box

            # Display style name and font
            ttk.Label(style_box, text=f"Style: {display_name} (Font: {style_font})",
                      background=COLOR_PALETTE['background'], foreground=COLOR_PALETTE['foreground'],
                      font=('Helvetica', 10, 'bold')).grid(row=0, column=0, sticky="w", padx=5, pady=2)

            example_text = display_name
            
            if properties.get("widget_type") == "button":
                example_widget = ttk.Button(style_box, text=example_text, style=style_name)
            elif properties.get("widget_type") == "entry":
                example_widget = ttk.Entry(style_box, style=style_name)
                example_widget.insert(0, example_text)
            else: # label
                example_widget = ttk.Label(style_box, text=example_text, style=style_name)
                
            example_widget.grid(row=1, column=0, sticky="w", padx=5, pady=2)

            current_ui_row += 1


        self.scrollable_frame.update_idletasks() # Update layout to ensure scrollregion is calculated correctly

    def _add_color_display_row(self, parent_frame, text, hex_color, row_idx, indent=0):
        """Helper to add a row for color display."""
        current_file = os.path.basename(__file__)
        current_function = inspect.currentframe().f_code.co_name

        padx_val = 5 + (indent * 15) # Indent nested colors

        # Label for color name and hex value
        color_label = ttk.Label(parent_frame, text=text,
                                background=COLOR_PALETTE['background'],
                                foreground=COLOR_PALETTE['foreground'],
                                font=('Helvetica', 9))
        color_label.grid(row=row_idx, column=0, sticky="w", padx=padx_val, pady=2)

        # Small frame to display the color
        color_box = tk.Frame(parent_frame, width=20, height=20, relief="solid", borderwidth=1, background=hex_color)
        color_box.grid(row=row_idx, column=1, sticky="e", padx=5, pady=2)

        debug_log(f"Displayed color: {text} with hex: {hex_color}",
                    file=f"{current_file} - {current_version}",
                    version=current_version,
                    function=current_function)


    def _on_tab_selected(self, event):
        """
        Called when this tab is selected in the notebook.
        Refreshes the displayed colors and styles.
        """
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__)
        debug_log(f"ColouringTab selected. Refreshing color and style display.",
                    file=f"{current_file} - {current_version}",
                    version=current_version,
                    function=current_function)
        self._populate_content()

#####################################
### File: OPEN-AIR 2\workers\Instrument\TAB_INSTRUMENT_PARENT.py
#####################################
# Instrument/TAB_INSTRUMENT_PARENT.py
#
# Version 20250821.224500.1 (Refactored to remove console_print_func dependency)

import tkinter as tk
from tkinter import ttk
import inspect
import os

from .connection.tab_instrument_child_connection import InstrumentTab
from .visa.tab_instrument_child_visa_interpreter import VisaInterpreterTab
from .settings.tab_instrument_child_settings import SettingsParentTab

class TAB_INSTRUMENT_PARENT(ttk.Frame):
    def __init__(self, parent, app_instance):
        super().__init__(parent)
        self.app_instance = app_instance
        self._create_widgets()
        self.child_notebook.bind("<<NotebookTabChanged>>", self._on_child_tab_selected)

    def _create_widgets(self):
        self.child_notebook = ttk.Notebook(self, style='Instruments.Child.TNotebook')
        self.child_notebook.pack(expand=True, fill="both", padx=5, pady=5)
        
        # --- DEFINITIVE FIX: Child tabs no longer receive console_print_func ---
        self.connection_tab = InstrumentTab(self.child_notebook, self.app_instance)
        self.settings_tab = SettingsParentTab(self.child_notebook, self.app_instance)
        self.visa_interpreter_tab = VisaInterpreterTab(self.child_notebook, self.app_instance)
        
        self.child_notebook.add(self.connection_tab, text="Connection")
        self.child_notebook.add(self.settings_tab, text="Settings")
        self.child_notebook.add(self.visa_interpreter_tab, text="VISA Interpreter")

    def _on_child_tab_selected(self, event):
        selected_tab_id = self.child_notebook.select()
        if selected_tab_id:
            widget = self.child_notebook.nametowidget(selected_tab_id)
            if hasattr(widget, '_on_tab_selected'):
                widget._on_tab_selected(event)

    def _on_parent_tab_selected(self, event):
        print(f"Instrument Parent tab selected. Forcing display view to Console.")
        if hasattr(self.app_instance, 'display_parent'):
            self.app_instance.display_parent.notebook.select(0)
        selected_tab_id = self.child_notebook.select()
        if selected_tab_id:
            widget = self.child_notebook.nametowidget(selected_tab_id)
            if hasattr(widget, '_on_tab_selected'):
                widget._on_tab_selected(event)

#####################################
### File: OPEN-AIR 2\workers\Instrument\connection\instrument_logic.py
#####################################

# Instrument/instrument_logic.py
#
# This file contains the core logic for managing the connection to and interaction
# with a VISA instrument, such as a spectrum analyzer. It provides high-level
# functions for connecting, disconnecting, and querying the device for its settings.
# This file serves as an abstraction layer between the GUI and the low-level
# VISA read/write utilities.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250818.203000.2 (UPDATED: Corrected IDN parsing logic in connect_instrument_logic to handle devices that return 2 values instead of 4, ensuring all available information is displayed and preventing errors.)

current_version = "20250818.203000.2"
current_version_hash = 20250818 * 203000 * 2

import inspect
import os
import time
import sys
import tkinter as tk
import pyvisa
import traceback

from display.debug_logic import debug_log
from display.console_logic import console_log

# Import low-level VISA utilities
from yak.Yakety_Yak import YakGet, YakSet, YakDo, query_safe, write_safe
from .utils_instrument_connection import connect_to_instrument, disconnect_instrument, list_visa_resources


def populate_resources_logic(app_instance, combobox_widget, console_print_func):
    # Function Description:
    # Populates the `visa_resource_var` Combobox with available VISA instrument addresses.
    # It first clears the existing list, then calls `list_visa_resources` to find
    # available devices, and finally populates the combobox with the results.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Populating VISA resources. Let's find those devices! Version: {current_version}",
                file=f"{os.path.basename(__file__)} - {current_version}",
                function=current_function)
    
    app_instance.visa_resource_var.set("")
    combobox_widget['values'] = []

    resources = list_visa_resources(console_print_func)
    if resources:
        combobox_widget['values'] = resources
        app_instance.visa_resource_var.set(resources[0])
        debug_log(f"Found VISA resources: {resources}. Success!",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)
    else:
        console_print_func("No VISA instruments found. Check connections.")
        debug_log("No VISA resources found. Time for some detective work. 🕵️‍♀️",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)

def connect_instrument_logic(app_instance, console_print_func):
    # Function Description:
    # Handles the full connection sequence to a VISA instrument.
    # It attempts to establish a connection, queries the instrument's IDN string,
    # and updates the application's state variables accordingly.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Attempting to connect to instrument. Let's make this happen! Version: {current_version}",
                file=f"{os.path.basename(__file__)} - {current_version}",
                function=current_function)
    
    selected_resource = app_instance.visa_resource_var.get()
    if not selected_resource:
        console_print_func("❌ No instrument selected. Cannot connect.")
        debug_log("No resource selected. This is a fine mess! 🤦‍♂️",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)
        return False
        
    try:
        # Step 1: Connect to the instrument
        app_instance.inst = connect_to_instrument(selected_resource, console_print_func)
        if not app_instance.inst:
            app_instance.is_connected.set(False)
            return False

        # Step 2: Query IDN using YakGet and populate model
        idn_response = YakGet(app_instance, "SYSTEM/ID", console_print_func)
        if idn_response and idn_response != "FAILED":
            idn_parts = idn_response.split(',')
            
            # UPDATED: Handle the full IDN string regardless of the number of parts
            manufacturer = "N/A"
            model = "GENERIC"
            serial_number = "N/A"
            version = "N/A"
            
            if len(idn_parts) >= 1:
                manufacturer = idn_parts[0].strip()
            if len(idn_parts) >= 2:
                model = idn_parts[1].strip()
            if len(idn_parts) >= 3:
                serial_number = idn_parts[2].strip()
            if len(idn_parts) >= 4:
                version = idn_parts[3].strip()

            app_instance.connected_instrument_manufacturer.set(manufacturer)
            app_instance.connected_instrument_model.set(model)
            app_instance.connected_instrument_serial.set(serial_number)
            app_instance.connected_instrument_version.set(version)
            console_print_func(f"✅ Device details found: {manufacturer}, {model}, {serial_number}, {version}")

        else:
            console_print_func("⚠️ Warning: Could not query instrument IDN. Proceeding with generic settings.")
            app_instance.connected_instrument_manufacturer.set("N/A")
            app_instance.connected_instrument_model.set("GENERIC")
            app_instance.connected_instrument_serial.set("N/A")
            app_instance.connected_instrument_version.set("N/A")
        
        app_instance.is_connected.set(True)
        debug_log("Connection successful! The instrument is alive! 🥳",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)
        return True
    
    except Exception as e:
        console_print_func(f"❌ Error during connection: {e}")
        debug_log(f"Connection failed spectacularly! Error: {e}. What a disaster! Traceback: {traceback.format_exc()}",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)
        disconnect_instrument_logic(app_instance, console_print_func)
        app_instance.is_connected.set(False)
        return False


def disconnect_instrument_logic(app_instance, console_print_func):
    # Function Description:
    # Disconnects the application from the currently connected VISA instrument.
    # It checks if an instrument instance exists and attempts to close the connection.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Attempting to disconnect instrument. Version: {current_version}",
                file=f"{os.path.basename(__file__)} - {current_version}",
                function=current_function)
    
    if not app_instance.inst:
        console_print_func("⚠️ Warning: No instrument connected. Nothing to disconnect.")
        debug_log("No instrument to disconnect. This is a mess.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)
        return True
    
    result = disconnect_instrument(app_instance.inst, console_print_func)
    app_instance.inst = None
    app_instance.is_connected.set(False)
    
    if result:
        debug_log("Successfully disconnected. Until we meet again! 👋",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)
    else:
        debug_log("Disconnecting failed. This is a catastrophe!",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)
        
    return result

def query_current_settings_logic(app_instance, console_print_func):
    # Function Description:
    # Queries the currently connected instrument for its essential settings,
    # including IDN string, Center Frequency, Span, RBW, Ref Level, Trace Mode,
    # and Preamp status. It then returns a dictionary containing all these values.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Querying current instrument settings. What's this thing up to? Version: {current_version}",
                file=f"{os.path.basename(__file__)} - {current_version}",
                function=current_function)

    if not app_instance.inst:
        console_print_func("⚠️ Warning: No instrument connected. Cannot query settings. Fix it!")
        debug_log("No instrument connected. Cannot query settings. Fucking useless!",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)
        return None
        
    settings = {}
    
    try:
        # Query the IDN string first
        settings['idn_string'] = YakGet(app_instance, "SYSTEM/ID", console_print_func)
        
        # Query Center Frequency
        center_freq_str = YakGet(app_instance, "FREQUENCY/CENTER", console_print_func)
        settings['center_freq_hz'] = float(center_freq_str) if center_freq_str and center_freq_str != 'FAILED' else "N/A"
        
        # Query Span
        span_str = YakGet(app_instance, "FREQUENCY/SPAN", console_print_func)
        settings['span_hz'] = float(span_str) if span_str and span_str != 'FAILED' else "N/A"
        
        # Query RBW
        rbw_str = YakGet(app_instance, "BANDWIDTH/RESOLUTION", console_print_func)
        settings['rbw_hz'] = float(rbw_str) if rbw_str and rbw_str != 'FAILED' else "N/A"

        # Query Ref Level
        ref_level_str = YakGet(app_instance, "AMPLITUDE/REFERENCE LEVEL", console_print_func)
        settings['ref_level_dbm'] = float(ref_level_str) if ref_level_str and ref_level_str != 'FAILED' else "N/A"
        
        # Query Trace Mode (Assuming we want Trace 2 for Max Hold)
        trace_mode_str = YakGet(app_instance, "TRACE/2/MODE", console_print_func)
        settings['trace_mode'] = trace_mode_str if trace_mode_str and trace_mode_str != 'FAILED' else "N/A"
        
        # Query Preamp Status (GAIN)
        preamp_on_str = YakGet(app_instance, "AMPLITUDE/POWER/GAIN", console_print_func)
        settings['preamp_on'] = (preamp_on_str == '1' or preamp_on_str == 'ON') if preamp_on_str and preamp_on_str != 'FAILED' else False

        debug_log("Finished querying instrument settings. A treasure trove of information! 🗺️",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)
        
        return settings
    
    except Exception as e:
        console_print_func(f"❌ Error querying settings: {e}")
        debug_log(f"Error querying instrument settings: {e}. What a disaster! Traceback: {traceback.format_exc()}",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    function=current_function)
        return None



#####################################
### File: OPEN-AIR 2\workers\Instrument\connection\tab_instrument_child_connection.py
#####################################
# tabs/Instrument/tab_instrument_child_connection.py
#
# This file defines the InstrumentTab, a Tkinter Frame for handling instrument
# connection and disconnection.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250818.205500.2 (FIXED: Corrected the Tkinter variable name to prevent AttributeError.)

current_version = "20250818.205500.2"
current_version_hash = 20250818 * 205500 * 2

import tkinter as tk
from tkinter import ttk, messagebox
import inspect
import os
import threading
import time

# Import low-level VISA utilities
from .instrument_logic import connect_instrument_logic, disconnect_instrument_logic, populate_resources_logic
from yak.utils_yak_setting_handler import reset_device, do_power_cycle
from display.debug_logic import debug_log
from display.console_logic import console_log

class InstrumentTab(ttk.Frame):
    def __init__(self, master=None, app_instance=None, console_print_func=None, parent_notebook_ref=None, **kwargs):
        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func if console_print_func else console_log
        self.parent_notebook_ref = parent_notebook_ref

        # Tkinter StringVars for displaying instrument details
        self.manufacturer_var = tk.StringVar(value="N/A")
        self.model_var = tk.StringVar(value="N/A")
        self.serial_number_var = tk.StringVar(value="N/A")
        self.version_var = tk.StringVar(value="N/A")

        self._create_widgets()

    def _create_widgets(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering _create_widgets. Creating simplified widgets for the Connection Tab. 🛠️",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        self.grid_columnconfigure(0, weight=1)

        # Main frame
        main_frame = ttk.Frame(self, style='Dark.TFrame')
        main_frame.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
        main_frame.columnconfigure(0, weight=1)

        # Button to populate VISA resources
        self.populate_button = ttk.Button(main_frame, text="Populate list of available VISA Devices", command=self._populate_resources, style='Blue.TButton')
        self.populate_button.grid(row=0, column=0, padx=5, pady=5, sticky="ew")

        # Dropdown for VISA resources
        # FIXED: Changed variable name to app_instance.instrument_visa_resource_var
        self.resource_combobox = ttk.Combobox(main_frame, textvariable=self.app_instance.instrument_visa_resource_var, style='TCombobox', state='readonly')
        self.resource_combobox.grid(row=1, column=0, padx=5, pady=5, sticky="ew")

        # Connect/Disconnect button
        self.connect_button = ttk.Button(main_frame, text="Connect", command=self._toggle_connection, style='Green.TButton')
        self.connect_button.grid(row=2, column=0, padx=5, pady=5, sticky="ew")
        
        # NEW: Instrument Details Frame
        self.details_frame = ttk.LabelFrame(main_frame, text="Device Details", style='Dark.TLabelframe', padding=10)
        self.details_frame.grid(row=3, column=0, padx=5, pady=5, sticky="ew")
        self.details_frame.grid_columnconfigure(1, weight=1)
        self.details_frame.grid_remove() # Hide initially

        ttk.Label(self.details_frame, text="Manufacturer:").grid(row=0, column=0, sticky="w", padx=5, pady=2)
        ttk.Label(self.details_frame, textvariable=self.manufacturer_var, style='Dark.TLabel.Value').grid(row=0, column=1, sticky="ew", padx=5, pady=2)

        ttk.Label(self.details_frame, text="Model:").grid(row=1, column=0, sticky="w", padx=5, pady=2)
        ttk.Label(self.details_frame, textvariable=self.model_var, style='Dark.TLabel.Value').grid(row=1, column=1, sticky="ew", padx=5, pady=2)
        
        ttk.Label(self.details_frame, text="Serial Number:").grid(row=2, column=0, sticky="w", padx=5, pady=2)
        ttk.Label(self.details_frame, textvariable=self.serial_number_var, style='Dark.TLabel.Value').grid(row=2, column=1, sticky="ew", padx=5, pady=2)
        
        ttk.Label(self.details_frame, text="Firmware Version:").grid(row=3, column=0, sticky="w", padx=5, pady=2)
        ttk.Label(self.details_frame, textvariable=self.version_var, style='Dark.TLabel.Value').grid(row=3, column=1, sticky="ew", padx=5, pady=2)

        # NEW: Reset and Power Cycle Buttons Frame
        control_buttons_frame = ttk.Frame(main_frame, style='Dark.TFrame')
        control_buttons_frame.grid(row=4, column=0, padx=5, pady=5, sticky="ew")
        control_buttons_frame.grid_columnconfigure(0, weight=1)
        control_buttons_frame.grid_columnconfigure(1, weight=1)

        self.reset_button = ttk.Button(control_buttons_frame, text="Reset Instrument (*RST)", command=self._reset_instrument, style='Orange.TButton')
        self.reset_button.grid(row=0, column=0, padx=5, pady=5, sticky="ew")
        self.reset_button.config(state=tk.DISABLED) # Start disabled
        
        self.power_cycle_button = ttk.Button(control_buttons_frame, text="Power Cycle", command=self._power_cycle_instrument, style='Red.TButton')
        self.power_cycle_button.grid(row=0, column=1, padx=5, pady=5, sticky="ew")
        self.power_cycle_button.config(state=tk.DISABLED) # Start disabled

        self.app_instance.is_connected.trace_add('write', self._update_connection_status)
        
        debug_log(f"Simplified widgets for Connection Tab created. Ready to go! ",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)

    def _update_connection_status(self, *args):
        current_function = inspect.currentframe().f_code.co_name
        is_connected = self.app_instance.is_connected.get()
        debug_log(f"Updating connection status. Is it connected? {is_connected}. 🤔",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)

        if is_connected:
            self.connect_button.config(text="Disconnect", style='Red.TButton')
            self.populate_button.config(state=tk.DISABLED)
            self.resource_combobox.config(state='disabled')
            self.reset_button.config(state=tk.NORMAL)
            self.power_cycle_button.config(state=tk.NORMAL)
            self.details_frame.grid()
            
            # Populate the new labels
            self.manufacturer_var.set(self.app_instance.connected_instrument_manufacturer.get())
            self.model_var.set(self.app_instance.connected_instrument_model.get())
            self.serial_number_var.set(self.app_instance.connected_instrument_serial.get())
            self.version_var.set(self.app_instance.connected_instrument_version.get())

            # FIXED: Add a check to ensure the settings_tab exists before trying to switch to it.
            if self.parent_notebook_ref and hasattr(self.parent_notebook_ref, 'settings_tab'):
                self.parent_notebook_ref.switch_to_settings_tab()
                self.console_print_func("✅ Connection successful. Switched to Settings tab.")
        else:
            self.connect_button.config(text="Connect", style='Green.TButton')
            self.populate_button.config(state=tk.NORMAL)
            self.resource_combobox.config(state='readonly')
            self.reset_button.config(state=tk.DISABLED)
            self.power_cycle_button.config(state=tk.DISABLED)
            self.details_frame.grid_remove()
            self.console_print_func("❌ Disconnected from instrument.")

    def _toggle_connection(self):
        is_connected = self.app_instance.is_connected.get()
        if is_connected:
            self._disconnect_instrument()
        else:
            self._connect_instrument()

    def _populate_resources(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Populate resources button clicked. Finding devices! 🔎",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        populate_resources_logic(self.app_instance, self.resource_combobox, self.console_print_func)
    
    def _connect_instrument(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Connect button clicked. Starting connection thread. 🔗",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        connection_thread = threading.Thread(target=connect_instrument_logic, args=(self.app_instance, self.console_print_func))
        connection_thread.start()
        
    def _disconnect_instrument(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Disconnect button clicked. Starting disconnection thread. 🔌",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        disconnection_thread = threading.Thread(target=disconnect_instrument_logic, args=(self.app_instance, self.console_print_func))
        disconnection_thread.start()
    
    # NEW: Reset Button Functionality
    def _reset_instrument(self):
        # [A brief, one-sentence description of the function's purpose.]
        # Sends a soft reset command to the instrument in a separate thread.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Reset button clicked. Starting reset thread. ♻️",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        reset_thread = threading.Thread(target=reset_device, args=(self.app_instance, self.console_print_func))
        reset_thread.start()
    
    # NEW: Power Cycle Functionality
    def _power_cycle_instrument(self):
        # [A brief, one-sentence description of the function's purpose.]
        # Sends a power reset command to the instrument in a separate thread.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Power Cycle button clicked. Starting power cycle thread. 💥",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        power_cycle_thread = threading.Thread(target=do_power_cycle, args=(self.app_instance, self.console_print_func))
        power_cycle_thread.start()
        
    def _on_tab_selected(self, event=None):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Connection Tab selected. What are we doing now? 🤔",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        is_connected = self.app_instance.is_connected.get()
        if not is_connected:
            self._populate_resources()



#####################################
### File: OPEN-AIR 2\workers\Instrument\connection\utils_instrument_connection.py
#####################################
# Instrument/utils_instrument_connection.py
#
# This module provides low-level functions specifically for managing VISA instrument
# connections: listing available resources, connecting to an instrument, and
# disconnecting from an instrument. It abstracts the direct PyVISA communication
# details related to connection management from higher-level application logic.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
# Version 20250802.1701.5 (Refactored from utils_instrument_control.py to handle connection logic.)

current_version = "20250802.1701.5" # this variable should always be defined below the header to make the debugging better
current_version_hash = 20250802 * 1701 * 5 # Example hash, adjust as needed

import pyvisa
import inspect # Import inspect module
import os # Import os module to fix NameError

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log

def list_visa_resources(console_print_func=None, *args, **kwargs):
    """
    Function Description:
    Lists available VISA resources (instruments).

    Inputs to this function:
    - console_print_func (function, optional): Function to print messages to the GUI console.
                                               Defaults to console_log if None.
    - *args: Catches any unexpected positional arguments.
    - **kwargs: Catches any unexpected keyword arguments.

    Process of this function:
    1. Initializes PyVISA ResourceManager.
    2. Logs any unexpected arguments received.
    3. Lists available resources.
    4. Logs the discovered resources or any errors.

    Outputs of this function:
    - list: A list of strings, where each string is a VISA resource name.
            Returns an empty list if no resources are found or an error occurs.
    """
    console_print_func = console_print_func if console_print_func else console_log # Use console_log as default
    current_function = inspect.currentframe().f_code.co_name
    debug_log("Listing VISA resources... Let's find some devices!",
                file=f"{os.path.basename(__file__)} - {current_version}",
                version=current_version,
                function=current_function)

    if args or kwargs:
        debug_log(f"WARNING: list_visa_resources received unexpected arguments! Args: {args}, Kwargs: {kwargs}. What the hell are these?!",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        console_print_func(f"⚠️ Warning: list_visa_resources received unexpected arguments! This might be the source of the problem. Check the call!")

    try:
        rm = pyvisa.ResourceManager()
        resources = rm.list_resources()
        debug_log(f"Found VISA resources: {resources}. Success!",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        return list(resources)
    except Exception as e:
        error_msg = f"❌ Error listing VISA resources: {e}. This is a disaster!"
        console_print_func(error_msg)
        debug_log(error_msg,
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        return []


def connect_to_instrument(resource_name, console_print_func=None):
    """
    Function Description:
    Establishes a connection to a VISA instrument.

    Inputs to this function:
    - resource_name (str): The VISA resource string (e.g., "GPIB0::1::INSTR").
    - console_print_func (function, optional): Function to print messages to the GUI console.
                                               Defaults to console_log if None.

    Process of this function:
    1. Initializes PyVISA ResourceManager.
    2. Opens the specified resource.
    3. Sets instrument timeout, read/write termination characters, and query delay.
    4. Logs connection status.

    Outputs of this function:
    - pyvisa.resources.Resource or None: The connected PyVISA instrument object if successful,
                                         None otherwise.
    """
    console_print_func = console_print_func if console_print_func else console_log # Use console_log as default
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Connecting to instrument: {resource_name}. Fingers crossed!",
                file=f"{os.path.basename(__file__)} - {current_version}",
                version=current_version,
                function=current_function)
    try:
        rm = pyvisa.ResourceManager()
        inst = rm.open_resource(resource_name)
        inst.timeout = 10000 # Set a timeout (milliseconds) - Increased for robustness
        inst.read_termination = '\n' # Set read termination character
        inst.write_termination = '\n' # Set write termination character
        inst.query_delay = 0.1 # Small delay between write and read for query
        console_print_func(f"✅ Successfully connected to {resource_name}. It's alive!")
        debug_log(f"Connection successful to {resource_name}. We're in!",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        return inst
    except pyvisa.errors.VisaIOError as e:
        error_msg = f"❌ VISA error connecting to {resource_name}: {e}. This is a nightmare!"
        console_print_func(error_msg)
        debug_log(error_msg,
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        return None
    except Exception as e:
        error_msg = f"❌ An unexpected error occurred while connecting to {resource_name}: {e}. What a mess!"
        console_print_func(error_msg)
        debug_log(error_msg,
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        return None


def disconnect_instrument(inst, console_print_func=None):
    """
    Function Description:
    Closes the connection to a VISA instrument.

    Inputs to this function:
    - inst (pyvisa.resources.Resource): The PyVISA instrument object to disconnect.
    - console_print_func (function, optional): Function to print messages to the GUI console.
                                               Defaults to console_log if None.

    Process of this function:
    1. Checks if the instrument object is valid.
    2. Attempts to close the instrument connection.
    3. Logs disconnection status.

    Outputs of this function:
    - bool: True if disconnection is successful, False otherwise.
    """
    console_print_func = console_print_func if console_print_func else console_log # Use console_log as default
    current_function = inspect.currentframe().f_code.co_name
    debug_log("Disconnecting instrument... Saying goodbye!",
                file=f"{os.path.basename(__file__)} - {current_version}",
                version=current_version,
                function=current_function)
    if inst:
        try:
            inst.close()
            console_print_func("✅ Instrument disconnected. See ya!")
            debug_log("Instrument connection closed. All done!",
                        file=f"{os.path.basename(__file__)} - {current_version}",
                        version=current_version,
                        function=current_function)
            return True
        except pyvisa.errors.VisaIOError as e:
            error_msg = f"❌ VISA error disconnecting instrument: {e}. This thing is stuck!"
            console_print_func(error_msg)
            debug_log(error_msg,
                        file=f"{os.path.basename(__file__)} - {current_version}",
                        version=current_version,
                        function=current_function)
            return False
        except Exception as e:
            error_msg = f"❌ An unexpected error occurred while disconnecting instrument: {e}. What a pain!"
            console_print_func(error_msg)
            debug_log(error_msg,
                        file=f"{os.path.basename(__file__)} - {current_version}",
                        version=current_version,
                        function=current_function)
            return False
    debug_log("No instrument to disconnect. Already gone!",
                file=f"{os.path.basename(__file__)} - {current_version}",
                version=current_version,
                function=current_function)
    return False

#####################################
### File: OPEN-AIR 2\workers\Instrument\settings\tab_instrument_child_settings.py
#####################################
# tabs/Instrument/tab_instrument_child_settings.py
#
# This file defines the SettingsParentTab, which now serves as a container
# for all instrument-related child tabs, refactored from the original SettingsTab.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250815.105500.2
# FIXED: Reverted to a static tabbed layout only, as dynamic resizing was causing TclErrors.
# FIX: The red styling for the nested tabs was corrected to use the right color palette.
# ADDED: New method refresh_all_child_tabs to properly refresh all child tabs.

current_version = "20250815.105500.2"
current_version_hash = 20250815 * 105500 * 2

import tkinter as tk
from tkinter import ttk
import inspect
import os

from display.debug_logic import debug_log
from display.console_logic import console_log
from src.program_style import COLOR_PALETTE, COLOR_PALETTE_TABS

# Import the new child tabs
from .tab_instrument_child_settings_frequency import FrequencySettingsTab
from .tab_instrument_child_settings_amplitude import AmplitudeSettingsTab
from .tab_instrument_child_settings_bandwidth import BandwidthSettingsTab
from .tab_instrument_child_settings_markers import MarkerSettingsTab
from .tab_instrument_child_settings_traces import TraceSettingsTab

class SettingsParentTab(ttk.Frame):
    """
    A Tkinter Frame that serves as a container for all instrument settings child tabs.
    """
    def __init__(self, master=None, app_instance=None, console_print_func=None, **kwargs):
        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func if console_print_func else console_log

        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Initializing SettingsParentTab. Version: {current_version}. Setting up settings tabs! 📁",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)
        
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(0, weight=1)

        style = ttk.Style(self)
        active_color = COLOR_PALETTE_TABS['Instruments']['active']
        inactive_color = style.lookup('Instruments.Child.TNotebook.Tab', 'background', default='#2b2b2b')
        
        style.configure('Red.TNotebook', background=COLOR_PALETTE['background'])
        style.map('Red.TNotebook.Tab',
                  background=[('selected', active_color),
                              ('!selected', inactive_color)],
                  foreground=[('selected', COLOR_PALETTE_TABS['Instruments']['fg']),
                              ('!selected', 'white')])

        self.child_notebook = ttk.Notebook(self, style='Red.TNotebook')
        self.child_notebook.pack(expand=True, fill="both", padx=5, pady=5)

        self.frequency_tab = FrequencySettingsTab(self.child_notebook, self.app_instance, self.console_print_func)
        self.amplitude_tab = AmplitudeSettingsTab(self.child_notebook, self.app_instance, self.console_print_func)
        self.bandwidth_tab = BandwidthSettingsTab(self.child_notebook, self.app_instance, self.console_print_func)
        self.traces_tab = TraceSettingsTab(self.child_notebook, self.app_instance, self.console_print_func)
        self.markers_tab = MarkerSettingsTab(self.child_notebook, self.app_instance, self.console_print_func)

        self.child_notebook.add(self.frequency_tab, text="Frequency")
        self.child_notebook.add(self.amplitude_tab, text="Amplitude")
        self.child_notebook.add(self.bandwidth_tab, text="Bandwidth")
        self.child_notebook.add(self.traces_tab, text="Traces")
        self.child_notebook.add(self.markers_tab, text="Markers")

        debug_log(f"SettingsParentTab initialized with child tabs. The grand design is taking shape! 🏰",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

    def _on_tab_selected(self, event=None):
        """
        Handles when this parent tab is selected. It will delegate the call to the currently active child tab.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Settings Parent Tab selected. Delegating to child tab. ➡️",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)
        
        selected_child_tab_id = self.child_notebook.select()
        if selected_child_tab_id:
            selected_child_tab_widget = self.child_notebook.nametowidget(selected_child_tab_id)
            if hasattr(selected_child_tab_widget, '_on_tab_selected'):
                selected_child_tab_widget._on_tab_selected(event)
    
    def refresh_all_child_tabs(self):
        """
        A public method to trigger a refresh on all child tabs of this parent.
        This is the new central point for refreshing the entire settings UI.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"API call to refresh all child tabs in SettingsParentTab. Initiating cascade!",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)
        
        # Iterate through all child tab instances and call their dedicated refresh method
        for tab in [self.frequency_tab, self.amplitude_tab, self.bandwidth_tab, self.traces_tab, self.markers_tab]:
            if hasattr(tab, '_sync_ui_from_app_state'):
                tab._sync_ui_from_app_state()

#####################################
### File: OPEN-AIR 2\workers\Instrument\settings\tab_instrument_child_settings_amplitude.py
#####################################
# # Instrument/tab_instrument_child_settings_amplitude.py
#
# This file defines the AmplitudeSettingsTab, a Tkinter Frame for controlling a spectrum
# analyzer's amplitude-related settings. The layout now mirrors the Frequency tab
# for a consistent user experience.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250816.123518.36
# UPDATED: Added a new handler to save instrument amplitude settings to the configuration file
#          after a successful update from the GUI or an instrument query.

current_version = "Version 20250816.123518.36"
current_version_hash = (20250816 * 123518 * 36)

import tkinter as tk
from tkinter import ttk
import inspect
import os

from display.debug_logic import debug_log
from display.console_logic import console_log
from yak import utils_yak_setting_handler
from ref.ref_scanner_setting_lists import PRESET_AMPLITUDE_REFERENCE_LEVEL, PRESET_AMPLITUDE_POWER_ATTENUATION, PRESET_AMPLITUDE_PREAMP_STATE, PRESET_AMPLITUDE_HIGH_SENSITIVITY_STATE
from yak.Yakety_Yak import YakGet

# ADDED: Imports for the configuration manager
from settings_and_config.config_manager_instruments import _save_instrument_settings
from settings_and_config.config_manager_save import save_program_config


class AmplitudeSettingsTab(ttk.Frame):
    """
    A Tkinter Frame that provides a user interface for amplitude settings.
    """
    def __init__(self, master=None, app_instance=None, console_print_func=None, **kwargs):
        """
        Initializes the AmplitudeSettingsTab.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Initializing AmplitudeSettingsTab. Setting up the GUI and its logic. 💻",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func if console_print_func else console_log
        
        self.is_ref_level_tracing = False
        self.is_attenuation_tracing = False

        self._create_widgets()
        self.preamp_state_var = self.app_instance.preamp_on_var
        self.high_sensitivity_state_var = self.app_instance.high_sensitivity_on_var
        self._set_ui_initial_state()
        
    def _create_widgets(self):
        """
        Creates and arranges the widgets for the Amplitude Settings tab.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering {current_function}. The mad scientist is preparing the amplitude controls! 🔊🧪",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        self.grid_columnconfigure(0, weight=1)
        
        # --- Top Buttons for Preamp and High Sensitivity ---
        top_buttons_frame = ttk.Frame(self)
        top_buttons_frame.grid(row=0, column=0, padx=10, pady=10, sticky="ew")
        top_buttons_frame.grid_columnconfigure(0, weight=1)
        top_buttons_frame.grid_columnconfigure(1, weight=1)
        
        self.preamp_toggle_button = ttk.Button(top_buttons_frame,
                                               text="PREAMP ON",
                                               command=lambda: utils_yak_setting_handler.toggle_preamp(tab_instance=self, app_instance=self.app_instance, console_print_func=self.console_print_func))
        self.preamp_toggle_button.grid(row=0, column=0, padx=5, pady=2, sticky="ew")

        self.hs_toggle_button = ttk.Button(top_buttons_frame,
                                           text="HIGH SENSITIVITY ON",
                                           command=lambda: utils_yak_setting_handler.toggle_high_sensitivity(tab_instance=self, app_instance=self.app_instance, console_print_func=self.console_print_func))
        self.hs_toggle_button.grid(row=0, column=1, padx=5, pady=2, sticky="ew")
        
        # --- Reference Level Controls (New layout) ---
        ref_level_frame = ttk.Frame(self)
        ref_level_frame.grid(row=1, column=0, padx=10, pady=5, sticky="ew")
        ref_level_frame.grid_columnconfigure(0, weight=1) # Allow this column to expand

        ref_level_title_frame = ttk.Frame(ref_level_frame)
        ref_level_title_frame.grid(row=0, column=0, sticky="ew")
        ref_level_title_frame.grid_columnconfigure(1, weight=1)
        
        ttk.Label(ref_level_title_frame, text="Reference Level (dBm):").grid(row=0, column=0, padx=5, sticky="w")
        self.ref_level_value_label = ttk.Label(ref_level_title_frame, textvariable=self.app_instance.ref_level_dbm_var, style='TLabel')
        self.ref_level_value_label.grid(row=0, column=1, padx=5, sticky="e")

        ref_values = [p["value"] for p in PRESET_AMPLITUDE_REFERENCE_LEVEL]
        ref_min = min(ref_values)
        ref_max = max(ref_values)
        self.ref_level_slider = ttk.Scale(ref_level_frame,
                                          orient="horizontal",
                                          variable=self.app_instance.ref_level_dbm_var,
                                          from_=ref_min,
                                          to=ref_max,
                                          command=self._update_ref_level_display,
                                          style='InteractionBars.TScale')
        self.ref_level_slider.grid(row=1, column=0, padx=5, pady=5, sticky="ew")
        self.ref_level_slider.bind("<ButtonRelease-1>", self._on_ref_level_change)
        
        self.ref_level_description_label = ttk.Label(ref_level_frame, text="", style='Description.TLabel', anchor="center")
        self.ref_level_description_label.grid(row=2, column=0, padx=5, pady=2, sticky="ew")
        
        # --- Spacer ---
        ttk.Frame(self, height=10).grid(row=2, column=0)

        # --- Power Attenuation Controls (New layout) ---
        power_att_frame = ttk.Frame(self)
        power_att_frame.grid(row=3, column=0, padx=10, pady=5, sticky="ew")
        power_att_frame.grid_columnconfigure(0, weight=1)

        power_att_title_frame = ttk.Frame(power_att_frame)
        power_att_title_frame.grid(row=0, column=0, sticky="ew")
        power_att_title_frame.grid_columnconfigure(1, weight=1)
        
        ttk.Label(power_att_title_frame, text="Power Attenuation (dB):").grid(row=0, column=0, padx=5, sticky="w")
        self.power_attenuation_value_label = ttk.Label(power_att_title_frame, textvariable=self.app_instance.power_attenuation_db_var, style='TLabel')
        self.power_attenuation_value_label.grid(row=0, column=1, padx=5, sticky="e")

        att_values = [p["value"] for p in PRESET_AMPLITUDE_POWER_ATTENUATION]
        att_min = min(att_values)
        att_max = max(att_values)
        self.power_attenuation_slider = ttk.Scale(power_att_frame,
                                                  orient="horizontal",
                                                  variable=self.app_instance.power_attenuation_db_var,
                                                  from_=att_min,
                                                  to=att_max,
                                                  command=self._update_power_attenuation_display,
                                                  style='InteractionBars.TScale')
        self.power_attenuation_slider.grid(row=1, column=0, padx=5, pady=5, sticky="ew")
        self.power_attenuation_slider.bind("<ButtonRelease-1>", self._on_power_attenuation_change)

        self.power_attenuation_description_label = ttk.Label(power_att_frame, text="", style='Description.TLabel', anchor="center")
        self.power_attenuation_description_label.grid(row=2, column=0, padx=5, pady=2, sticky="ew")
        
        debug_log(message=f"Widgets for Amplitude Settings Tab created. The amplitude controls are ready! 📉👍",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

    def _on_resize(self, event):
        """
        Adjusts the wraplength of the description labels when the window is resized.
        """
        new_width = event.width
        if new_width > 0:
            # Set the wraplength of the labels to match the full width of their containers
            self.ref_level_description_label.config(wraplength=new_width)
            self.power_attenuation_description_label.config(wraplength=new_width)

    def _set_ui_initial_state(self):
        """Sets the initial state of the UI elements."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering {current_function}. Initializing UI state. 🎨",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        self._update_toggle_button_style(button=self.preamp_toggle_button, state=self.preamp_state_var.get())
        self._update_toggle_button_style(button=self.hs_toggle_button, state=self.high_sensitivity_state_var.get())
        
        self.ref_level_slider.set(self.app_instance.ref_level_dbm_var.get())
        self.power_attenuation_slider.set(self.app_instance.power_attenuation_db_var.get())

        self._update_descriptions(value=self.app_instance.ref_level_dbm_var.get(), preset_list=PRESET_AMPLITUDE_REFERENCE_LEVEL, label=self.ref_level_description_label, var=self.app_instance.ref_level_dbm_var)
        self._update_descriptions(value=self.app_instance.power_attenuation_db_var.get(), preset_list=PRESET_AMPLITUDE_POWER_ATTENUATION, label=self.power_attenuation_description_label, var=self.app_instance.power_attenuation_db_var)

    def _update_ref_level_display(self, value):
        if self.is_ref_level_tracing:
            return
        self.is_ref_level_tracing = True
        
        rounded_value = self._find_closest_preset_value(float(value), PRESET_AMPLITUDE_REFERENCE_LEVEL)
        self.app_instance.ref_level_dbm_var.set(rounded_value)
        self._update_descriptions(value=rounded_value, preset_list=PRESET_AMPLITUDE_REFERENCE_LEVEL, label=self.ref_level_description_label, var=self.app_instance.ref_level_dbm_var)
        
        self.is_ref_level_tracing = False

    def _update_power_attenuation_display(self, value):
        if self.is_attenuation_tracing:
            return
        self.is_attenuation_tracing = True
        
        rounded_value = self._find_closest_preset_value(float(value), PRESET_AMPLITUDE_POWER_ATTENUATION)
        self.app_instance.power_attenuation_db_var.set(rounded_value)
        self._update_descriptions(value=rounded_value, preset_list=PRESET_AMPLITUDE_POWER_ATTENUATION, label=self.power_attenuation_description_label, var=self.app_instance.power_attenuation_db_var)
        
        self.is_attenuation_tracing = False

    def _on_ref_level_change(self, event):
        """Updates the reference level and pushes the setting on slider release."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering {current_function}. Slider released, pushing new value to instrument. 📤",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)
        
        # New Logic: Turn off High Sensitivity if it's on
        if self.app_instance.high_sensitivity_on_var.get():
            self.console_print_func("⚠️ High Sensitivity turned off to adjust Reference Level.")
            utils_yak_setting_handler.toggle_high_sensitivity(tab_instance=self, app_instance=self.app_instance, console_print_func=self.console_print_func)

        ref_level = int(self._find_closest_preset_value(self.app_instance.ref_level_dbm_var.get(), PRESET_AMPLITUDE_REFERENCE_LEVEL))
        if utils_yak_setting_handler.set_reference_level(tab_instance=self, app_instance=self.app_instance, value=ref_level, console_print_func=self.console_print_func):
            self._save_settings_handler()
        else:
            self.console_print_func("❌ Failed to set Reference Level on instrument.")

    def _on_power_attenuation_change(self, event):
        """Updates the power attenuation and pushes the setting on slider release."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering {current_function}. Slider released, pushing new value to instrument. 📤",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)
        
        # New Logic: Turn off High Sensitivity if it's on
        if self.app_instance.high_sensitivity_on_var.get():
            self.console_print_func("⚠️ High Sensitivity turned off to adjust Power Attenuation.")
            utils_yak_setting_handler.toggle_high_sensitivity(tab_instance=self, app_instance=self.app_instance, console_print_func=self.console_print_func)

        power_attenuation = int(self._find_closest_preset_value(self.app_instance.power_attenuation_db_var.get(), PRESET_AMPLITUDE_POWER_ATTENUATION))
        if utils_yak_setting_handler.set_power_attenuation(tab_instance=self, app_instance=self.app_instance, value=power_attenuation, console_print_func=self.console_print_func):
            self._save_settings_handler()
        else:
            self.console_print_func("❌ Failed to set Power Attenuation on instrument.")

    def _update_toggle_button_style(self, button, state):
        """Updates the style and text of a toggle button based on its state."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering {current_function}. Updating button style for state: {state} 🤔",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)
        
        # Determine the correct preset list to use based on the button instance
        preset_list = None
        if button == self.preamp_toggle_button:
            preset_list = PRESET_AMPLITUDE_PREAMP_STATE
        elif button == self.hs_toggle_button:
            preset_list = PRESET_AMPLITUDE_HIGH_SENSITIVITY_STATE
            
        if preset_list:
            if state:
                button.config(style='Orange.TButton', text=next((p['label'] for p in preset_list if p['value'] == 'ON'), "ON"))
            else:
                button.config(style='Dark.TButton', text=next((p['label'] for p in preset_list if p['value'] == 'OFF'), "OFF"))

        # After toggling, refresh all status on the page
        app_instance = self.app_instance
        YakGet(app_instance, "AMPLITUDE/REFERENCE LEVEL", self.console_print_func)
        YakGet(app_instance, "AMPLITUDE/POWER/ATTENUATION", self.console_print_func)
        YakGet(app_instance, "AMPLITUDE/POWER/GAIN", self.console_print_func)
        YakGet(app_instance, "AMPLITUDE/POWER/HIGH SENSITIVE", self.console_print_func)

    def _find_closest_preset_value(self, value, preset_list):
        """Finds the closest discrete preset value for a given float value."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering {current_function}. Finding closest preset for value: {value}",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        values = [p["value"] for p in preset_list]
        return min(values, key=lambda x: abs(x - value))

    def _update_descriptions(self, value, preset_list, label, var):
        """
        Updates a description label and the variable value based on the slider value
        by finding the closest preset and snapping to it.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering {current_function}. Seeking the closest preset for a value of {value}...",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)
        
        # Find the closest preset value first
        closest_value = self._find_closest_preset_value(value, preset_list)
        
        closest_preset = next((preset for preset in preset_list if preset["value"] == closest_value), None)

        if closest_preset:
            var.set(closest_preset["value"])
            label.config(text=closest_preset["description"])
            debug_log(message=f"Found a description! ' {closest_preset['description']} '",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)
        else:
            label.config(text="No matching description found.")
            debug_log(message=f"Arrr, no description to be found! Shiver me timbers! 🏴‍☠️",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)

    def _save_settings_handler(self):
        """Handles saving the instrument amplitude settings to the config file."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}. It's time to save the instrument amplitude configuration! 💾",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)
        
        try:
            # Call the specific save function from the modular config manager
            _save_instrument_settings(
                config=self.app_instance.program_config,
                app_instance=self.app_instance,
                console_print_func=self.console_print_func
            )
            # Call the main config save function to write the changes to the file
            save_program_config(
                app_instance=self.app_instance,
                config=self.app_instance.program_config,
                config_file_path=self.app_instance.config_file_path,
                console_print_func=self.console_print_func
            )
            debug_log("Instrument amplitude settings saved successfully. 🚀",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)
        except Exception as e:
            debug_log(f"❌ Error saving instrument amplitude settings: {e}",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)
            self.console_print_func(f"❌ Error saving instrument amplitude settings: {e}")

#####################################
### File: OPEN-AIR 2\workers\Instrument\settings\tab_instrument_child_settings_bandwidth.py
#####################################
# tabs/Instrument/tab_instrument_child_settings_Bandwidth.py
#
# This file defines the BandwidthSettingsTab, a Tkinter Frame for controlling a spectrum
# analyzer's bandwidth and initiate settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.141100.1
# UPDATED: Added a new handler to save instrument bandwidth settings to the configuration file
#          after a successful update from the GUI or an instrument query.

current_version = "20250821.141100.1"
current_version_hash = 20250821 * 141100 * 1

import tkinter as tk
from tkinter import ttk
import inspect
import os
import re

from display.debug_logic import debug_log
from display.console_logic import console_log

# Import handler functions and preset lists
from yak import utils_yak_setting_handler
from ref.ref_scanner_setting_lists import (
    PRESET_BANDWIDTH_RBW,
    PRESET_BANDWIDTH_VIDEO,
    PRESET_CONTINUOUS_MODE,
    PRESET_AVERAGING
)
# FIXED: Corrected the import path for the NAB handler
from yak.utils_yaknab_handler import handle_bandwidth_settings_nab

# ADDED: Imports for the configuration manager
from settings_and_config.config_manager_instruments import _save_instrument_settings
from settings_and_config.config_manager_save import save_program_config


class BandwidthSettingsTab(ttk.Frame):
    """
    A Tkinter Frame that provides a user interface for bandwidth and initiate settings.
    """
    def __init__(self, master=None, app_instance=None, console_print_func=None, **kwargs):
        """
        Initializes the BandwidthSettingsTab.
        """
        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func if console_print_func else console_log

        # Local Tkinter variables for the UI. They will be linked to app_instance's variables
        # when they become available.
        self.rbw_hz_var = tk.DoubleVar(self, value=0.0)
        self.vbw_hz_var = tk.DoubleVar(self, value=0.0)
        self.vbw_auto_state_var = tk.BooleanVar(self, value=False)
        self.continuous_mode_var = tk.StringVar(self, value="OFF")

        # NEW: Variables for averaging controls (single trace only)
        self.average_on_var = tk.BooleanVar(self, value=False)
        self.average_count_var = tk.IntVar(self, value=0)
        
        # NEW: Variables to hold the parsed NAB response values
        self.parsed_rbw_var = tk.StringVar(self, value="N/A")
        self.parsed_vbw_var = tk.StringVar(self, value="N/A")
        self.parsed_vbw_auto_var = tk.StringVar(self, value="N/A")
        self.parsed_continuous_mode_var = tk.StringVar(self, value="N/A")
        self.parsed_averaging_status_var = tk.StringVar(self, value="N/A")
        self.parsed_averaging_count_var = tk.StringVar(self, value="N/A")
        
        # NEW: Response variable for the averaging controls
        self.averaging_result_var = tk.StringVar(self, value="Result: N/A")
        
        self.last_known_rbw_hz = 0.0
        self.last_known_vbw_hz = 0.0

        self._create_widgets()

    def _create_widgets(self):
        """
        Creates and arranges the widgets for the Bandwidth Settings tab.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering _create_widgets. Creating widgets for the Bandwidth Settings Tab. ⚙️",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        self.grid_columnconfigure(0, weight=1)
        self.grid_columnconfigure(1, weight=1)

        # --- Bandwidth Settings Frame ---
        bandwidth_frame = ttk.LabelFrame(self, text="Bandwidth Settings", style='Dark.TLabelframe')
        bandwidth_frame.grid(row=0, column=0, padx=10, pady=10, sticky="ew")
        bandwidth_frame.grid_columnconfigure(1, weight=1)

        ttk.Label(bandwidth_frame, text="Resolution BW (Hz):").grid(row=0, column=0, padx=5, pady=2, sticky="w")
        
        rbw_labels = [f"{p['label']} ({p['value']} Hz)" for p in PRESET_BANDWIDTH_RBW]
        self.rbw_combobox = ttk.Combobox(bandwidth_frame,
                                         textvariable=self.rbw_hz_var,
                                         values=rbw_labels,
                                         state='readonly')
        self.rbw_combobox.grid(row=0, column=1, padx=5, pady=2, sticky="ew")
        self.rbw_combobox.bind("<<ComboboxSelected>>", self._on_rbw_selected)
        
        # --- VBW Controls (Rebuilt as Combobox and Auto button) ---
        ttk.Label(bandwidth_frame, text="Video BW (Hz):").grid(row=1, column=0, padx=5, pady=2, sticky="w")
        
        vbw_values = [p["value"] for p in PRESET_BANDWIDTH_VIDEO]
        vbw_labels = [f"{p['label']} ({p['value']} Hz)" for p in PRESET_BANDWIDTH_VIDEO]
        self.vbw_combobox = ttk.Combobox(bandwidth_frame,
                                         textvariable=self.vbw_hz_var,
                                         values=vbw_labels,
                                         state='readonly')
        self.vbw_combobox.grid(row=1, column=1, padx=5, pady=2, sticky="ew")
        self.vbw_combobox.bind("<<ComboboxSelected>>", self._on_vbw_selected)

        ttk.Label(bandwidth_frame, text="VBW Auto:").grid(row=2, column=0, padx=5, pady=2, sticky="w")
        self.vbw_auto_toggle_button = ttk.Button(bandwidth_frame,
                                                 text="",
                                                 command=self._on_vbw_auto_toggle)
        self.vbw_auto_toggle_button.grid(row=2, column=1, padx=5, pady=2, sticky="ew")
        
        # --- Initiate Settings Frame ---
        initiate_frame = ttk.LabelFrame(self, text="Initiate Settings", style='Dark.TLabelframe')
        initiate_frame.grid(row=1, column=0, padx=10, pady=10, sticky="ew")
        initiate_frame.grid_columnconfigure(1, weight=1)
        
        ttk.Label(initiate_frame, text="Continuous Mode:").grid(row=0, column=0, padx=5, pady=2, sticky="w")
        initiate_modes = [p['value'] for p in PRESET_CONTINUOUS_MODE]
        self.initiate_continuous_dropdown = ttk.Combobox(initiate_frame,
                                                         textvariable=self.continuous_mode_var,
                                                         values=initiate_modes,
                                                         state='readonly')
        self.initiate_continuous_dropdown.grid(row=0, column=1, padx=5, pady=2, sticky="ew")
        self.initiate_continuous_dropdown.bind("<<ComboboxSelected>>", self._on_continuous_mode_change)
        
        self.initiate_immediate_button = ttk.Button(initiate_frame,
                                                     text="Initiate Immediate",
                                                     command=lambda: utils_yak_setting_handler.do_immediate_initiate(self.app_instance, self.console_print_func))
        self.initiate_immediate_button.grid(row=1, column=0, columnspan=2, padx=5, pady=5, sticky="ew")
        
        # NEW: Averaging Frame (Updated layout for Trace 1 only)
        averaging_frame = ttk.LabelFrame(self, text="Averaging", style='Dark.TLabelframe')
        averaging_frame.grid(row=2, column=0, padx=10, pady=10, sticky="ew")
        averaging_frame.grid_columnconfigure((1, 3), weight=1)

        # Row 0: Averaging Toggle and Count
        ttk.Label(averaging_frame, text="Trace 1 Averaging:").grid(row=0, column=0, padx=5, pady=2, sticky="w")
        self.average_on_button = ttk.Button(averaging_frame, text="OFF", command=lambda: self._on_averaging_toggle(1, not self.average_on_var.get()), style='Red.TButton')
        self.average_on_button.grid(row=0, column=1, padx=5, pady=2, sticky="ew")
        
        ttk.Label(averaging_frame, text="Count:").grid(row=0, column=2, padx=5, pady=2, sticky="w")
        avg_labels = [f"{p['value']} - {p['label']}" for p in PRESET_AVERAGING]
        self.average_count_dropdown = ttk.Combobox(averaging_frame, textvariable=self.average_count_var, values=avg_labels, state='readonly')
        self.average_count_dropdown.grid(row=0, column=3, padx=5, pady=2, sticky="ew")
        self.average_count_dropdown.bind("<<ComboboxSelected>>", lambda event: self._on_averaging_count_selected(event, 1))

        # NEW: Result label for averaging actions
        ttk.Label(averaging_frame, textvariable=self.averaging_result_var, style="Dark.TLabel.Value").grid(row=1, column=0, columnspan=4, padx=5, pady=2, sticky="ew")


        # Frame for NAB raw response display
        parsed_nab_response_frame = ttk.LabelFrame(self, text="Parsed NAB Response", style='Dark.TLabelframe')
        parsed_nab_response_frame.grid(row=3, column=0, padx=10, pady=10, sticky="ew")
        parsed_nab_response_frame.grid_columnconfigure(1, weight=1)

        ttk.Label(parsed_nab_response_frame, text="RBW (Hz):", style='TLabel').grid(row=0, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(parsed_nab_response_frame, textvariable=self.parsed_rbw_var, style='Dark.TLabel.Value').grid(row=0, column=1, padx=5, pady=2, sticky="ew")

        ttk.Label(parsed_nab_response_frame, text="VBW (Hz):", style='TLabel').grid(row=1, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(parsed_nab_response_frame, textvariable=self.parsed_vbw_var, style='Dark.TLabel.Value').grid(row=1, column=1, padx=5, pady=2, sticky="ew")

        ttk.Label(parsed_nab_response_frame, text="VBW Auto:", style='TLabel').grid(row=2, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(parsed_nab_response_frame, textvariable=self.parsed_vbw_auto_var, style='Dark.TLabel.Value').grid(row=2, column=1, padx=5, pady=2, sticky="ew")

        ttk.Label(parsed_nab_response_frame, text="Continuous:", style='TLabel').grid(row=3, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(parsed_nab_response_frame, textvariable=self.parsed_continuous_mode_var, style='Dark.TLabel.Value').grid(row=3, column=1, padx=5, pady=2, sticky="ew")
        
        # NEW: Add a sweep time display field
        ttk.Label(parsed_nab_response_frame, text="Sweep Time (s):", style='TLabel').grid(row=4, column=0, padx=5, pady=2, sticky="w")
        self.parsed_sweep_time_var = tk.StringVar(self, value="N/A")
        ttk.Label(parsed_nab_response_frame, textvariable=self.parsed_sweep_time_var, style='Dark.TLabel.Value').grid(row=4, column=1, padx=5, pady=2, sticky="ew")


        debug_log(f"Widgets for Bandwidth Settings Tab created. Bandwidth controls are ready! 🛠️",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

    def _on_averaging_toggle(self, trace_number, state):
        """
        Handler for when an averaging toggle button is clicked.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Averaging toggle for trace {trace_number} clicked. State: {state}",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)
        
        if utils_yak_setting_handler.toggle_trace_averaging(app_instance=self.app_instance, trace_number=trace_number, is_on=state, console_print_func=self.console_print_func):
            self.averaging_result_var.set(f"Result: Trace {trace_number} averaging set to {'ON' if state else 'OFF'}.")
            self._sync_ui_from_app_state()
        else:
            self.averaging_result_var.set("Result: FAILED")
            self._sync_ui_from_app_state()


    def _on_averaging_count_selected(self, event, trace_number):
        current_function = inspect.currentframe().f_code.co_name
        selected_text = event.widget.get()
        match = re.search(r'(\d+)', selected_text)
        
        if 'Off' in selected_text:
            count = 0
            state = False
        elif match:
            count = int(match.group(1))
            state = True
        else:
            self.console_print_func(f"❌ Could not parse averaging count from '{selected_text}'.")
            self.averaging_result_var.set("Result: FAILED to parse count")
            return
            
        debug_log(f"Averaging count for trace {trace_number} selected: {count}, state: {state}", file=os.path.basename(__file__), version=current_version, function=current_function)
        
        if utils_yak_setting_handler.set_trace_averaging_count(app_instance=self.app_instance, trace_number=trace_number, count=count, console_print_func=self.console_print_func) and \
           utils_yak_setting_handler.toggle_trace_averaging(app_instance=self.app_instance, trace_number=trace_number, is_on=state, console_print_func=self.console_print_func):
            self.averaging_result_var.set(f"Result: Trace {trace_number} averaging set to {count} sweeps.")
            self._sync_ui_from_app_state()
        else:
            self.averaging_result_var.set("Result: FAILED")
            self._sync_ui_from_app_state()

    def _on_tab_selected(self, event=None):
        """
        Called when this tab is selected. Syncs the UI with the application's state.
        """
        if self.app_instance.is_connected.get():
            self._sync_ui_from_app_state()
        else:
            self.console_print_func("❌ No instrument connected. Skipping UI refresh.")


    def _sync_ui_from_app_state(self):
        """
        Sets the UI element values from the application's variables.
        This function now calls the NAB handler to get the current state from the instrument.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}. Syncing UI from app state. 🎨",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)
                  
        if not self.app_instance.is_connected.get():
            debug_log(f"Not connected, skipping NAB query and falling back to app instance variables.",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)
            # Fall back to app_instance variables if not connected
            if hasattr(self.app_instance, 'rbw_mhz_var'):
                self.rbw_hz_var.set(self.app_instance.rbw_mhz_var.get() * 1_000_000)
            if hasattr(self.app_instance, 'vbw_mhz_var'):
                self.vbw_hz_var.set(self.app_instance.vbw_mhz_var.get() * 1_000_000)
            if hasattr(self.app_instance, 'vbw_auto_on_var'):
                self.vbw_auto_state_var.set(self.app_instance.vbw_auto_on_var.get())
            if hasattr(self.app_instance, 'initiate_continuous_on_var'):
                self.continuous_mode_var.set("ON" if self.app_instance.initiate_continuous_on_var.get() else "OFF")
            
            self._update_rbw_combobox_display()
            self._update_vbw_combobox_display()
            self._update_toggle_button_style(self.vbw_auto_toggle_button, self.vbw_auto_state_var.get())
            
            if self.vbw_auto_state_var.get():
                self.vbw_combobox.config(state='disabled')
            else:
                self.vbw_combobox.config(state='readonly')
            return

        # Call the NAB handler to get all settings in one go.
        settings = handle_bandwidth_settings_nab(self.app_instance, self.console_print_func)

        # Update the parsed response display variables
        if settings:
            self.parsed_rbw_var.set(f"{settings['RBW_Hz']:.0f} Hz")
            self.parsed_vbw_var.set(f"{settings['VBW_Hz']:.0f} Hz")
            self.parsed_vbw_auto_var.set("ON" if settings["VBW_Auto_On"] else "OFF")
            self.parsed_continuous_mode_var.set("ON" if settings["Continuous_Mode_On"] else "OFF")
            
            # NEW: Set the sweep time variable
            self.parsed_sweep_time_var.set(f"{settings['Sweep_Time_s']:.3f} s")


            # Update local Tkinter variables and button states from the NAB response
            self.rbw_hz_var.set(settings["RBW_Hz"])
            self.vbw_hz_var.set(settings["VBW_Hz"])
            self.vbw_auto_state_var.set(settings["VBW_Auto_On"])
            self.continuous_mode_var.set("ON" if settings["Continuous_Mode_On"] else "OFF")
            
            # Update the combobox displays
            self._update_rbw_combobox_display()
            self._update_vbw_combobox_display()

            # Update the toggle button styles
            self._update_toggle_button_style(self.vbw_auto_toggle_button, settings["VBW_Auto_On"])

            # Disable VBW combobox if VBW auto is on
            if self.vbw_auto_state_var.get():
                self.vbw_combobox.config(state='disabled')
            else:
                self.vbw_combobox.config(state='readonly')
        else:
            debug_log("NAB query failed. Falling back to app instance variables.",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)
            # If the NAB call failed, fall back to app_instance variables
            self.rbw_hz_var.set(self.app_instance.rbw_mhz_var.get() * 1_000_000)
            self.vbw_hz_var.set(self.app_instance.vbw_mhz_var.get() * 1_000_000)
            self.vbw_auto_state_var.set(self.app_instance.vbw_auto_on_var.get())
            self.continuous_mode_var.set("ON" if self.app_instance.initiate_continuous_on_var.get() else "OFF")

            self._update_rbw_combobox_display()
            self._update_vbw_combobox_display()
            self._update_toggle_button_style(self.vbw_auto_toggle_button, self.vbw_auto_state_var.get())
            if self.vbw_auto_state_var.get():
                self.vbw_combobox.config(state='disabled')
            else:
                self.vbw_combobox.config(state='readonly')


    def _update_toggle_button_style(self, button, state):
        """Updates the style and text of a toggle button based on its state."""
        if state:
            button.config(text="ON", style='Green.TButton')
        else:
            button.config(text="OFF", style='Red.TButton')

    def _update_rbw_combobox_display(self):
        """Updates the RBW combobox to show the current value."""
        current_rbw_hz = int(self.rbw_hz_var.get())
        found_label = "Custom"
        for preset in PRESET_BANDWIDTH_RBW:
            if preset["value"] == current_rbw_hz:
                found_label = f"{preset['label']} ({preset['value']} Hz)"
                break
        self.rbw_combobox.set(found_label)

    def _update_vbw_combobox_display(self):
        """Updates the VBW combobox to show the current value."""
        current_vbw_hz = int(self.vbw_hz_var.get())
        found_label = "Custom"
        for preset in PRESET_BANDWIDTH_VIDEO:
            if preset["value"] == current_vbw_hz:
                found_label = f"{preset['label']} ({preset['value']} Hz)"
                break
        self.vbw_combobox.set(found_label)

    def _on_rbw_selected(self, event):
        """Handler for when an RBW preset is selected."""
        selected_text = self.rbw_combobox.get()
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"RBW preset selected: {selected_text}",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)
        
        try:
            # Use regex to extract the number and the unit
            match = re.search(r'\((\d+)\s*Hz\)', selected_text)
            if match:
                rbw_value = int(match.group(1))
            else:
                raise ValueError("Could not parse numeric value from combobox string.")
        except (ValueError, IndexError):
            console_log("❌ Error parsing RBW value from combobox. Using default.",
                        function=current_function)
            rbw_value = 1_000_000
        
        if utils_yak_setting_handler.set_resolution_bandwidth(
            app_instance=self.app_instance,
            value=rbw_value,
            console_print_func=self.console_print_func
        ):
            # No longer setting individual variables here, we call the NAB handler instead
            self._sync_ui_from_app_state()
            self._save_settings_handler()
        else:
            # If the set failed, resync from the instrument to show the real value.
            self._sync_ui_from_app_state()

    def _on_vbw_selected(self, event):
        """Handler for when a VBW preset is selected."""
        selected_text = self.vbw_combobox.get()
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"VBW preset selected: {selected_text}",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        try:
            # Use regex to extract the number and the unit
            match = re.search(r'\((\d+)\s*Hz\)', selected_text)
            if match:
                vbw_value = int(match.group(1))
            else:
                raise ValueError("Could not parse numeric value from combobox string.")
        except (ValueError, IndexError):
            console_log("❌ Error parsing VBW value from combobox. Using default.",
                        function=current_function)
            vbw_value = 30000

        if utils_yak_setting_handler.set_video_bandwidth(
            app_instance=self.app_instance,
            value=vbw_value,
            console_print_func=self.console_print_func
        ):
            # No longer setting individual variables here, we call the NAB handler instead
            self._sync_ui_from_app_state()
            self._save_settings_handler()
        else:
            # If the set failed, resync from the instrument to show the real value.
            self._sync_ui_from_app_state()


    def _on_vbw_auto_toggle(self):
        """Handler for the VBW Auto toggle button."""
        current_function = inspect.currentframe().f_code.co_name
        is_on = not self.vbw_auto_state_var.get()
        debug_log(f"VBW Auto toggle clicked. Setting to {is_on}",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        if utils_yak_setting_handler.toggle_vbw_auto(
            app_instance=self.app_instance,
            console_print_func=self.console_print_func
        ):
            # No longer setting individual variables here, we call the NAB handler instead
            self._sync_ui_from_app_state()
            self._save_settings_handler()
        else:
            # If the toggle failed, resync from the instrument to show the real value.
            self._sync_ui_from_app_state()

    def _on_continuous_mode_change(self, event):
        """Handler for when the continuous mode dropdown is changed."""
        current_function = inspect.currentframe().f_code.co_name
        is_on = self.continuous_mode_var.get() == "ON"
        debug_log(f"Continuous mode changed to {is_on}",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        if utils_yak_setting_handler.set_continuous_initiate_mode(
            app_instance=self.app_instance,
            mode=is_on,
            console_print_func=self.console_print_func
        ):
            # No longer setting individual variables here, we call the NAB handler instead
            self._sync_ui_from_app_state()
            self._save_settings_handler()
        else:
            # If the set failed, resync from the instrument to show the real value.
            self._sync_ui_from_app_state()

    def _save_settings_handler(self):
        """Handles saving the instrument bandwidth settings to the config file."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"⚙️ 💾 Entering {current_function}. Time to save the instrument bandwidth settings! 🚀",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)
        
        try:
            # Call the specific save function from the modular config manager
            _save_instrument_settings(
                config=self.app_instance.program_config,
                app_instance=self.app_instance,
                console_print_func=self.console_print_func
            )
            # Call the main config save function to write the changes to the file
            save_program_config(
                app_instance=self.app_instance,
                config=self.app_instance.program_config,
                config_file_path=self.app_instance.config_file_path,
                console_print_func=self.console_print_func
            )
            debug_log("⚙️ ✅ Instrument bandwidth settings saved successfully. Mission accomplished!",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)
        except Exception as e:
            debug_log(f"❌ Error saving instrument bandwidth settings: {e}",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)
            self.console_print_func(f"❌ Error saving instrument bandwidth settings: {e}")

#####################################
### File: OPEN-AIR 2\workers\Instrument\settings\tab_instrument_child_settings_frequency.py
#####################################
# tabs/Instrument/tab_instrument_child_settings_frequency.py
#
# This file defines the FrequencySettingsTab, a Tkinter Frame for controlling a spectrum
# analyzer's frequency settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.222800.1
# FIXED: The _save_settings_handler was corrected to import and use the CONFIG_FILE_PATH
#        from config_manager.py, resolving the AttributeError.

current_version = "20250821.222800.1"
current_version_hash = 20250821 * 222800 * 1

import tkinter as tk
from tkinter import ttk
import inspect
import os
import numpy as np

from display.debug_logic import debug_log
from display.console_logic import console_log
from yak.utils_yakbeg_handler import handle_freq_start_stop_beg, handle_freq_center_span_beg
from ref.ref_scanner_setting_lists import PRESET_FREQUENCY_SPAN_MHZ
from settings_and_config.config_manager_instruments import _save_instrument_settings
from settings_and_config.config_manager_save import load_program_config, save_program_config
from ref.ref_file_paths import CONFIG_FILE_PATH # ADDED IMPORT
from ref.ref_program_default_values import DEFAULT_CONFIG


class FrequencySettingsTab(ttk.Frame):
    """
    A Tkinter Frame that provides a user interface for frequency settings.
    """
    def __init__(self, master=None, app_instance=None, console_print_func=None, style_obj=None):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Initializing FrequencySettingsTab. This should be a walk in the park! 🚶‍♀️",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        self.app_instance = app_instance
        self.console_print_func = console_print_func
        self.is_tracing = False
        self.span_buttons = {}

        super().__init__(master)
        self.pack(fill="both", expand=True)
        self._set_default_variables()
        self._create_widgets()

    def _set_default_variables(self):
        """Initializes Tkinter variables for the widgets."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Setting default variables for FrequencySettingsTab. ⚙️",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        # Tkinter variables for frequency settings, now in MHz
        self.freq_start_var = tk.DoubleVar(value=100.0)
        self.freq_stop_var = tk.DoubleVar(value=200.0)
        self.freq_center_var = tk.DoubleVar(value=150.0)
        self.freq_span_var = tk.DoubleVar(value=100.0)

        # New shared variable for the common result display
        self.freq_common_result_var = tk.StringVar(value="Result: N/A")

        # NEW: Add traces to round the variable values
        self.freq_start_var.trace_add('write', self._round_variables)
        self.freq_stop_var.trace_add('write', self._round_variables)
        self.freq_center_var.trace_add('write', self._round_variables)
        self.freq_span_var.trace_add('write', self._round_variables)
        # New trace for span button styling
        self.freq_span_var.trace_add('write', self._on_span_variable_change)


    def _round_variables(self, *args):
        """
        Callback to round the values of the DoubleVar to 3 decimal places.
        It also truncates values with more than 6 decimal places.
        """
        if self.is_tracing:
            return
        self.is_tracing = True

        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Rounding variables to 3 decimal places. A meticulous process, for sure! 🔬",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        try:
            current_start = self.freq_start_var.get()
            current_stop = self.freq_stop_var.get()
            current_center = self.freq_center_var.get()
            current_span = self.freq_span_var.get()

            # Helper function to truncate float at 6 decimal places
            def truncate_float(f):
                s = f"{f:.7f}" # Get a string representation with enough precision
                if '.' in s:
                    parts = s.split('.')
                    if len(parts[1]) > 6:
                        return float(f"{parts[0]}.{parts[1][:6]}")
                return f

            self.freq_start_var.set(round(truncate_float(current_start), 3))
            self.freq_stop_var.set(round(truncate_float(current_stop), 3))
            self.freq_center_var.set(round(truncate_float(current_center), 3))
            self.freq_span_var.set(round(truncate_float(current_span), 3))

        except Exception as e:
            console_log(message=f"❌ Error while rounding variables: {e}")
            debug_log(message=f"Rounding failed! The numbers be acting up! The error be: {e}",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)
        finally:
            self.is_tracing = False

    def _create_widgets(self):
        """Creates the GUI widgets for the tab."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Creating widgets for FrequencySettingsTab. The puzzle pieces are coming together! 🧩",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(0, weight=0)
        self.grid_rowconfigure(1, weight=0)
        self.grid_rowconfigure(2, weight=0)

        # --- FREQUENCY/START-STOP Frame ---
        freq_ss_frame = ttk.Frame(self, padding=10)
        freq_ss_frame.grid(row=0, column=0, padx=10, pady=5, sticky="ew")
        freq_ss_frame.grid_columnconfigure(0, weight=1)

        # Container for Start and Stop frames
        main_start_stop_frame = ttk.Frame(freq_ss_frame)
        main_start_stop_frame.grid(row=0, column=0, sticky="ew")
        main_start_stop_frame.grid_columnconfigure(0, weight=1)
        main_start_stop_frame.grid_columnconfigure(1, weight=1)

        # Start Frequency Frame
        start_frame = ttk.Frame(main_start_stop_frame, padding=5)
        start_frame.grid(row=0, column=0, padx=5, pady=5, sticky="ew")
        start_frame.grid_columnconfigure(0, weight=1)
        # UPDATED: Added Label for "START"
        ttk.Label(start_frame, text="Start:").grid(row=0, column=0, sticky="ew", padx=5, pady=2)
        start_entry = ttk.Entry(start_frame, textvariable=self.freq_start_var)
        start_entry.grid(row=1, column=0, sticky="ew")
        start_entry.bind("<Return>", lambda e: self._on_freq_start_stop_beg())
        start_entry.bind("<FocusOut>", lambda e: self._on_freq_start_stop_beg())
        start_scale = ttk.Scale(start_frame, from_=100, to=1000, orient=tk.HORIZONTAL, variable=self.freq_start_var, style='InteractionBars.TScale')
        start_scale.grid(row=2, column=0, sticky="ew")
        start_scale.bind("<ButtonRelease-1>", lambda e: self._on_freq_start_stop_beg())

        # Stop Frequency Frame
        stop_frame = ttk.Frame(main_start_stop_frame, padding=5)
        stop_frame.grid(row=0, column=1, padx=5, pady=5, sticky="ew")
        stop_frame.grid_columnconfigure(0, weight=1)
        # UPDATED: Added Label for "STOP"
        ttk.Label(stop_frame, text="Stop:").grid(row=0, column=0, sticky="ew", padx=5, pady=2)
        stop_entry = ttk.Entry(stop_frame, textvariable=self.freq_stop_var)
        stop_entry.grid(row=1, column=0, sticky="ew")
        stop_entry.bind("<Return>", lambda e: self._on_freq_start_stop_beg())
        stop_entry.bind("<FocusOut>", lambda e: self._on_freq_start_stop_beg())
        stop_scale = ttk.Scale(stop_frame, from_=100, to=1000, orient=tk.HORIZONTAL, variable=self.freq_stop_var, style='InteractionBars.TScale')
        stop_scale.grid(row=2, column=0, sticky="ew")
        stop_scale.bind("<ButtonRelease-1>", lambda e: self._on_freq_start_stop_beg())

        # --- FREQUENCY/CENTER-SPAN Frame ---
        freq_cs_frame = ttk.Frame(self, padding=10)
        freq_cs_frame.grid(row=1, column=0, padx=10, pady=5, sticky="ew")
        freq_cs_frame.grid_columnconfigure(0, weight=1)
        freq_cs_frame.grid_columnconfigure(1, weight=1)

        # Center Frequency Slider & Entry
        ttk.Label(freq_cs_frame, text="Center Frequency:", justify=tk.RIGHT).grid(row=0, column=0, padx=5, pady=2, sticky="e")
        center_scale = ttk.Scale(freq_cs_frame, from_=100, to=1000, orient=tk.HORIZONTAL, variable=self.freq_center_var, style='InteractionBars.TScale')
        center_scale.grid(row=1, column=0, columnspan=2, padx=5, pady=2, sticky="ew")
        center_scale.bind("<ButtonRelease-1>", lambda e: self._on_freq_center_span_beg())
        center_entry = ttk.Entry(freq_cs_frame, textvariable=self.freq_center_var)
        center_entry.grid(row=0, column=1, padx=5, pady=2, sticky="ew")
        center_entry.bind("<Return>", lambda e: self._on_freq_center_span_beg())
        center_entry.bind("<FocusOut>", lambda e: self._on_freq_center_span_beg())


        # Span Slider & Entry
        ttk.Label(freq_cs_frame, text="Span:", justify=tk.RIGHT).grid(row=2, column=0, padx=5, pady=2, sticky="e")
        span_scale = ttk.Scale(freq_cs_frame, from_=0, to=500, orient=tk.HORIZONTAL, variable=self.freq_span_var, style='InteractionBars.TScale')
        span_scale.grid(row=3, column=0, columnspan=2, padx=5, pady=2, sticky="ew")
        span_scale.bind("<ButtonRelease-1>", lambda e: self._on_freq_center_span_beg())
        span_entry = ttk.Entry(freq_cs_frame, textvariable=self.freq_span_var)
        span_entry.grid(row=2, column=1, padx=5, pady=2, sticky="ew")
        span_entry.bind("<Return>", lambda e: self._on_freq_center_span_beg())
        span_entry.bind("<FocusOut>", lambda e: self._on_freq_center_span_beg())


        # Span Preset Buttons Frame
        span_buttons_frame = ttk.Frame(freq_cs_frame, padding=5)
        span_buttons_frame.grid(row=4, column=0, columnspan=2, padx=5, pady=5, sticky="ew")
        self._create_span_preset_buttons(parent_frame=span_buttons_frame)


        # --- NEW COMMON RESULT FRAME ---
        common_result_frame = ttk.Frame(self, padding=10)
        common_result_frame.grid(row=2, column=0, padx=10, pady=5, sticky="ew")
        common_result_frame.grid_columnconfigure(0, weight=1)
        ttk.Label(common_result_frame,
                  textvariable=self.freq_common_result_var,
                  justify=tk.LEFT
                  ).grid(row=0, column=0, padx=5, pady=2, sticky="ew")


    def _create_span_preset_buttons(self, parent_frame):
        # Creates buttons for predefined frequency spans and links them to the span variable.
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__)
        debug_log(message=f"Entering {current_function} with argument: parent_frame: {parent_frame}",
                  file=current_file,
                  version=current_version,
                  function=current_function)

        try:
            for i, (label, preset) in enumerate(PRESET_FREQUENCY_SPAN_MHZ.items()):
                # Use a format string with two decimal places for better display and rely on grid for sizing.
                button_text = f"{label}\n{preset['span_mhz']:.2f} MHz"
                button = ttk.Button(parent_frame,
                                    text=button_text,
                                    command=lambda p=preset: self._on_span_preset_button_click(preset=p))
                button.grid(row=0, column=i, sticky="ew", padx=2, pady=5)
                self.span_buttons[label] = button

            parent_frame.grid_rowconfigure(0, weight=1)
            for i in range(len(PRESET_FREQUENCY_SPAN_MHZ)):
                parent_frame.grid_columnconfigure(i, weight=1)

            console_log(message="✅ Span preset buttons created successfully.", function=current_function)
        except Exception as e:
            console_log(message=f"❌ Error in {current_function}: {e}")
            debug_log(message=f"Arrr, the code be capsized! The error be: {e}",
                      file=current_file,
                      version=current_version,
                      function=current_function)


    def _on_span_preset_button_click(self, preset):
        # Handles the click event for a span preset button.
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__)
        debug_log(message=f"Entering {current_function} with argument: preset: {preset}",
                  file=current_file,
                  version=current_version,
                  function=current_function)
        try:
            self.is_tracing = True
            self.freq_span_var.set(preset['span_mhz'])
            self.freq_center_var.set(preset['center_mhz']) # Also set center frequency
            self.is_tracing = False
            self._update_span_button_styles()
            self._on_freq_center_span_beg() # Trigger YakBeg after button click
            console_log(message=f"✅ Span set to {preset['span_mhz']} MHz).", function=current_function)
        except Exception as e:
            console_log(message=f"❌ Error in {current_function}: {e}")
            debug_log(message=f"Arrr, the code be capsized! The error be: {e}",
                      file=current_file,
                      version=current_version,
                      function=current_function)

    def _on_span_variable_change(self, *args):
        # A callback function for the span variable's trace.
        # It updates button styles when the variable changes.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering {current_function} with no arguments.",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        if not self.is_tracing:
            self._update_span_button_styles()
            console_log(message="✅ Span variable changed, button styles updated.", function=current_function)

    def _update_span_button_styles(self):
        # A brief, one-sentence description of the function's purpose.
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__)
        debug_log(message=f"Entering {current_function} with no arguments.",
                  file=current_file,
                  version=current_version,
                  function=current_function)
        try:
            current_span_mhz = self.freq_span_var.get()
            for label, preset in PRESET_FREQUENCY_SPAN_MHZ.items():
                button = self.span_buttons.get(label)
                if button:
                    if np.isclose(current_span_mhz, preset['span_mhz']):
                        button.configure(style='Orange.TButton')
                    else:
                        button.configure(style='Blue.TButton')
            console_log(message="✅ Span button styles updated.", function=current_function)
        except Exception as e:
            console_log(message=f"❌ Error in {current_function}: {e}")
            debug_log(message=f"Arrr, the code be capsized! The error be: {e}",
                      file=current_file,
                      version=current_version,
                      function=current_function)


    def _on_freq_start_stop_beg(self):
        """
        Handles the YakBeg for FREQUENCY/START-STOP.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering function: {current_function}. Arrr, a treasure map for frequencies! 🗺️",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        try:
            start_freq_mhz = self.freq_start_var.get()
            stop_freq_mhz = self.freq_stop_var.get()
            
            # UPDATED: Validation logic for Start/Stop frequencies
            if start_freq_mhz >= stop_freq_mhz:
                new_stop_mhz = start_freq_mhz + 10.0
                console_log(message=f"⚠️ Start frequency ({start_freq_mhz:.3f} MHz) is greater than or equal to stop frequency ({stop_freq_mhz:.3f} MHz). Automatically setting stop to {new_stop_mhz:.3f} MHz.")
                debug_log(message=f"The start frequency ({start_freq_mhz} MHz) is greater than or equal to the stop frequency ({stop_freq_mhz} MHz). The captain has corrected the course! 📈",
                          file=os.path.basename(__file__),
                          version=current_version,
                          function=current_function)
                self.freq_stop_var.set(value=new_stop_mhz)
                # Re-read the adjusted value for the YakBeg command
                stop_freq_mhz = self.freq_stop_var.get()
            elif stop_freq_mhz < start_freq_mhz:
                new_start_mhz = stop_freq_mhz - 10.0
                console_log(message=f"⚠️ Stop frequency ({stop_freq_mhz:.3f} MHz) is less than start frequency ({start_freq_mhz:.3f} MHz). Automatically setting start to {new_start_mhz:.3f} MHz.")
                debug_log(message=f"The stop frequency ({stop_freq_mhz} MHz) is less than the start frequency ({start_freq_mhz} MHz). The captain has corrected the course! 📉",
                          file=os.path.basename(__file__),
                          version=current_version,
                          function=current_function)
                self.freq_start_var.set(value=new_start_mhz)
                # Re-read the adjusted value for the YakBeg command
                start_freq_mhz = self.freq_start_var.get()


            # Get values in MHz and convert to Hz, ensuring no decimal points
            start_freq_hz = int(start_freq_mhz * 1e6)
            stop_freq_hz = int(stop_freq_mhz * 1e6)

            # Expect 4 values to be returned from the handler
            start_resp_hz, stop_resp_hz, span_resp_hz, center_resp_hz = handle_freq_start_stop_beg(
                app_instance=self.app_instance,
                start_freq=start_freq_hz,
                stop_freq=stop_freq_hz,
                console_print_func=self.console_print_func
            )

            if start_resp_hz is not None and stop_resp_hz is not None:
                # Convert response back to MHz for display
                start_resp_mhz = start_resp_hz / 1e6
                stop_resp_mhz = stop_resp_hz / 1e6
                span_resp_mhz = span_resp_hz / 1e6
                center_resp_mhz = center_resp_hz / 1e6
                
                # Update all variables
                self.freq_start_var.set(value=start_resp_mhz)
                self.freq_stop_var.set(value=stop_resp_mhz)
                self.freq_center_var.set(value=center_resp_mhz)
                self.freq_span_var.set(value=span_resp_mhz)
                
                # UPDATED: Format the result string to match the requested layout
                result_message = (
                    f"Center: {center_resp_mhz:.3f} MHz\n"
                    f"Span: {span_resp_mhz:.3f} MHz\n\n\n"
                    f"Start: {start_resp_mhz:.3f} MHz\n"
                    f"Stop: {stop_resp_mhz:.3f} MHz"
                )
                self.freq_common_result_var.set(value=result_message)
                self._save_settings_handler()
            else:
                self.freq_common_result_var.set(value="Result: FAILED")

        except Exception as e:
            console_log(message=f"❌ Error in {current_function}: {e}")
            debug_log(message=f"Arrr, the code be capsized! The error be: {e}",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)

    def _on_freq_center_span_beg(self):
        """
        Handles the YakBeg for FREQUENCY/CENTER-SPAN.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(message=f"Entering function: {current_function}. Plotting a course to the center! 🧭",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        try:
            # Get values in MHz and convert to Hz, ensuring no decimal points
            center_freq_mhz = self.freq_center_var.get()
            span_freq_mhz = self.freq_span_var.get()

            center_freq_hz = int(center_freq_mhz * 1e6)
            span_freq_hz = int(span_freq_mhz * 1e6)

            # Expect 4 values to be returned from the handler
            center_resp_hz, span_resp_hz, start_resp_hz, stop_resp_hz = handle_freq_center_span_beg(
                app_instance=self.app_instance,
                center_freq=center_freq_hz,
                span_freq=span_freq_hz,
                console_print_func=self.console_print_func
            )

            if center_resp_hz is not None and span_resp_hz is not None:
                # Convert response back to MHz for display
                center_resp_mhz = center_resp_hz / 1e6
                span_resp_mhz = span_resp_hz / 1e6
                start_resp_mhz = start_resp_hz / 1e6
                stop_resp_mhz = stop_resp_hz / 1e6
                
                # Update all variables
                self.freq_center_var.set(value=center_resp_mhz)
                self.freq_span_var.set(value=span_resp_mhz)
                self.freq_start_var.set(value=start_resp_mhz)
                self.freq_stop_var.set(value=stop_resp_mhz)
                
                # UPDATED: Format the result string to match the requested layout
                result_message = (
                    f"Center: {center_resp_mhz:.3f} MHz\n"
                    f"Span: {span_resp_mhz:.3f} MHz\n\n\n"
                    f"Start: {start_resp_mhz:.3f} MHz\n"
                    f"Stop: {stop_resp_mhz:.3f} MHz"
                )
                self.freq_common_result_var.set(value=result_message)
                self._save_settings_handler()
            else:
                self.freq_common_result_var.set(value="Result: FAILED")

        except Exception as e:
            console_log(message=f"❌ Error in {current_function}: {e}")
            debug_log(message=f"Arrr, the code be capsized! The error be: {e}",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)

    def _save_settings_handler(self):
        """
        Handles saving the instrument frequency settings to the config file.
        This handler now directly loads and saves the configuration to resolve
        the AttributeError.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"⚙️ 💾 Entering {current_function}. Time to save the instrument frequency configuration! 🚀",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)
        
        try:
            # Load the configuration file
            config = load_program_config(config_file_path=CONFIG_FILE_PATH, default_config=DEFAULT_CONFIG)

            # Call the specific save function from the modular config manager
            _save_instrument_settings(
                config=config,
                app_instance=self.app_instance,
                console_print_func=self.console_print_func
            )
            # Call the main config save function to write the changes to the file
            save_program_config(
                app_instance=self.app_instance,
                config=config,
                config_file_path=CONFIG_FILE_PATH,
                console_print_func=self.console_print_func
            )
            debug_log("⚙️ ✅ Instrument frequency settings saved successfully. Mission accomplished!",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)
        except Exception as e:
            debug_log(f"❌ Error saving instrument frequency settings: {e}",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)
            self.console_print_func(f"❌ Error saving instrument frequency settings: {e}")

#####################################
### File: OPEN-AIR 2\workers\Instrument\settings\tab_instrument_child_settings_markers.py
#####################################
# tabs/Instrument/tab_instrument_child_settings_markers.py
#
# This file defines the MarkerSettingsTab, a Tkinter Frame for controlling a spectrum
# analyzer's marker settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.141300.1
# UPDATED: Added a new handler to save marker settings to the configuration file
#          after a successful update from the GUI.

current_version = "20250821.141300.1"
current_version_hash = 20250821 * 141300 * 1

import tkinter as tk
from tkinter import ttk
import inspect
import os

from display.debug_logic import debug_log
from display.console_logic import console_log
from yak.utils_yakbeg_handler import handle_marker_place_all_beg

# ADDED: Imports for the configuration manager
from settings_and_config.config_manager_marker import _save_marker_tab_settings
from settings_and_config.config_manager_save import save_program_config


class MarkerSettingsTab(ttk.Frame):
    """
    A Tkinter Frame that provides a user interface for marker settings.
    """
    def __init__(self, master=None, app_instance=None, console_print_func=None):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Initializing MarkerSettingsTab. This should be a walk in the park! 🚶‍♀️",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        self.app_instance = app_instance
        self.console_print_func = console_print_func

        super().__init__(master)
        self.pack(fill="both", expand=True)
        self._set_default_variables()
        self._create_widgets()

    def _set_default_variables(self):
        """Initializes Tkinter variables for the widgets."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Setting default variables for MarkerSettingsTab. ⚙️",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        self.read_markers_all_data = tk.StringVar(self, value="N/A")
        # Set default values to match the experiment tab
        default_freqs = [111.0, 222.0, 333.0, 444.0, 555.0, 666.0]
        self.marker_freq_vars = [tk.DoubleVar(self, value=f) for f in default_freqs]
        
    def _create_widgets(self):
        """Creates the GUI widgets for the tab."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Creating widgets for MarkerSettingsTab. The puzzle pieces are coming together! 🧩",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)
        
        # Main container frame with padding
        main_container = ttk.Frame(self, padding="10")
        main_container.pack(fill="both", expand=True)
        main_container.grid_columnconfigure(0, weight=1)
        
        # --- Marker Input Frame (top row) ---
        marker_input_frame = ttk.Frame(main_container)
        marker_input_frame.grid(row=0, column=0, pady=(0, 5), sticky="ew")
        for i in range(6):
            marker_input_frame.grid_columnconfigure(i, weight=1)
            ttk.Label(marker_input_frame, text=f"M{i+1} Freq (MHz):").grid(row=0, column=i, padx=2, pady=2)
            ttk.Entry(marker_input_frame, textvariable=self.marker_freq_vars[i], width=8).grid(row=1, column=i, padx=2, pady=2)

        # --- Action Button ---
        ttk.Button(main_container, text="YakBeg - MARKER/PLACE/ALL", command=self._on_marker_place_all_beg, style='Blue.TButton').grid(row=1, column=0, pady=5, sticky="ew")

        # --- Results Table ---
        results_frame = ttk.Frame(main_container)
        results_frame.grid(row=2, column=0, pady=(5, 0), sticky="nsew")
        results_frame.grid_columnconfigure(0, weight=1)
        results_frame.grid_rowconfigure(0, weight=1)
        
        self.marker_result_table = ttk.Treeview(results_frame, columns=('Marker', 'Frequency', 'Amplitude'), show='headings', height=6)
        self.marker_result_table.heading('Marker', text='Marker')
        self.marker_result_table.heading('Frequency', text='Frequency (MHz)')
        self.marker_result_table.heading('Amplitude', text='Amplitude (dBm)')
        
        self.marker_result_table.column('Marker', width=80, stretch=tk.YES, anchor='center')
        self.marker_result_table.column('Frequency', width=120, stretch=tk.YES, anchor='center')
        self.marker_result_table.column('Amplitude', width=120, stretch=tk.YES, anchor='center')
        
        self.marker_result_table.grid(row=0, column=0, sticky="nsew")

        vsb = ttk.Scrollbar(results_frame, orient="vertical", command=self.marker_result_table.yview)
        vsb.grid(row=0, column=1, sticky="ns")
        self.marker_result_table.configure(yscrollcommand=vsb.set)
        
        debug_log(f"Widgets for Marker Settings Tab created. The controls are ready to go! 🗺️",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

    def _on_marker_place_all_beg(self):
        """
        Handles the YakBeg - MARKER/PLACE/ALL command.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering function: {current_function}. Arrr, let's get these markers placed! 🧭",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        try:
            marker_freqs = [v.get() for v in self.marker_freq_vars]
            
            result_string = handle_marker_place_all_beg(
                app_instance=self.app_instance, 
                marker_freqs_mhz=marker_freqs,
                console_print_func=self.console_print_func
            )
            
            self.marker_result_table.delete(*self.marker_result_table.get_children())

            if result_string and result_string != "FAILED":
                y_values = result_string.split(';')

                if len(y_values) == 6:
                    for i in range(6):
                        marker_label = f"M{i+1}"
                        input_freq_mhz = self.marker_freq_vars[i].get()
                        
                        try:
                            amplitude_dbm = float(y_values[i])
                            self.marker_result_table.insert('', 'end', values=(marker_label, f"{input_freq_mhz:.3f}", f"{amplitude_dbm:.2f}"))
                        except (ValueError, IndexError):
                            self.console_print_func(f"❌ Error parsing result for {marker_label}.")
                            self.marker_result_table.insert('', 'end', values=(marker_label, f"{input_freq_mhz:.3f}", 'FAILED'))
                    self.console_print_func("✅ Marker operation successful. Results displayed in table.")
                    self._save_settings_handler()
                else:
                    self.console_print_func(f"❌ Invalid response format. Expected 6 values, got {len(y_values)}.")
                    debug_log(f"Invalid response format from instrument. Expected 6 values, got {len(y_values)}. What a pain!",
                        file=os.path.basename(__file__),
                        version=current_version,
                        function=current_function)
                    self.marker_result_table.insert('', 'end', values=('M1-6', 'FAILED', 'FAILED'))
            else:
                self.console_print_func("❌ Marker operation failed.")
                self.marker_result_table.insert('', 'end', values=('M1-6', 'FAILED', 'FAILED'))
                
        except Exception as e:
            self.console_print_func(f"❌ Error in {current_function}: {e}")
            debug_log(f"Arrr, the code be capsized! The error be: {e}",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)

    def _save_settings_handler(self):
        """Handles saving the instrument marker settings to the config file."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"⚙️ 💾 Entering {current_function}. Time to save the instrument marker settings! 📍",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)

        try:
            # Call the specific save function from the modular config manager
            _save_marker_tab_settings(
                config=self.app_instance.program_config,
                showtime_tab=self,
                console_print_func=self.console_print_func
            )
            # Call the main config save function to write the changes to the file
            save_program_config(
                app_instance=self.app_instance,
                config=self.app_instance.program_config,
                config_file_path=self.app_instance.config_file_path,
                console_print_func=self.console_print_func
            )
            debug_log("⚙️ ✅ Instrument marker settings saved successfully. Mission accomplished!",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)
        except Exception as e:
            debug_log(f"❌ Error saving instrument marker settings: {e}",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)
            self.console_print_func(f"❌ Error saving instrument marker settings: {e}")

#####################################
### File: OPEN-AIR 2\workers\Instrument\settings\tab_instrument_child_settings_traces.py
#####################################
# tabs/Instrument/tab_instrument_child_settings_traces.py
#
# This file defines the TraceSettingsTab, a Tkinter Frame for controlling a spectrum
# analyzer's trace settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.141200.1
# UPDATED: Added a new handler to save instrument trace settings to the configuration file
#          after a successful update from the GUI or an instrument query.

current_version = "20250821.141200.1"
current_version_hash = 20250821 * 141200 * 1

import tkinter as tk
from tkinter import ttk, scrolledtext
import inspect
import os
import pandas as pd # Import pandas for data manipulation

from display.debug_logic import debug_log
from display.console_logic import console_log
from yak.utils_yakbeg_handler import handle_trace_modes_beg, handle_trace_data_beg
from yak.utils_yaknab_handler import handle_all_traces_nab

from display.utils_display_monitor import update_top_plot, update_middle_plot, update_bottom_plot, clear_monitor_plots
from display.utils_scan_view import update_single_plot

# ADDED: Imports for the configuration manager
from settings_and_config.config_manager_instruments import _save_instrument_settings
from settings_and_config.config_manager_save import save_program_config

class TraceSettingsTab(ttk.Frame):
    """
    A Tkinter Frame that provides a user interface for trace settings.
    """
    def __init__(self, master=None, app_instance=None, console_print_func=None, **kwargs):
        """
        Initializes the TraceSettingsTab.
        """
        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func if console_print_func else console_log
        self.trace_modes = ["VIEW", "WRITE", "BLANK", "MAXHOLD", "MINHOLD"]

        # UPDATED: Set default values for the trace mode variables
        self.trace1_mode_var = tk.StringVar(value="WRITE")
        self.trace2_mode_var = tk.StringVar(value="MAXHOLD")
        self.trace3_mode_var = tk.StringVar(value="MINHOLD")
        self.trace4_mode_var = tk.StringVar(value="BLANK")

        self.trace_vars = [
            self.trace1_mode_var,
            self.trace2_mode_var,
            self.trace3_mode_var,
            self.trace4_mode_var
        ]

        # Tkinter variables for trace data
        self.trace_data_start_freq_var = tk.DoubleVar(value=500)
        self.trace_data_stop_freq_var = tk.DoubleVar(value=1000)
        self.trace_select_var = tk.StringVar(value="1")
        self.trace_data_count_var = tk.StringVar(value="0")

        self.trace_modes_result_var = tk.StringVar(value="Result: N/A")

        # Variables to store the last successful NAB response data for plotting
        self.last_nab_trace_data = None
        self.last_nab_start_freq = None
        self.last_nab_stop_freq = None
        self.last_nab_trace_modes = None
        
        # NEW: StringVars for displaying the modes and frequencies from the NAB handler response
        self.all_traces_start_freq_display_var = tk.StringVar(value="N/A")
        self.all_traces_stop_freq_display_var = tk.StringVar(value="N/A")
        self.all_traces_trace1_mode_display_var = tk.StringVar(value="N/A")
        self.all_traces_trace2_mode_display_var = tk.StringVar(value="N/A")
        self.all_traces_trace3_mode_display_var = tk.StringVar(value="N/A")
        self.all_traces_count_var = tk.StringVar(value="0")

        self._create_widgets()

    def _create_widgets(self):
        """
        Creates and arranges the widgets for the Trace Settings tab.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering _create_widgets. Creating widgets for the Trace Settings Tab. 📈",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)
        
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(2, weight=1)

        # --- TRACE/MODES Frame (from YakBegTab) ---
        trace_modes_frame = ttk.LabelFrame(self, text="YakBeg - TRACE/MODES", padding=10)
        trace_modes_frame.grid(row=0, column=0, padx=10, pady=5, sticky="ew")
        trace_modes_frame.grid_columnconfigure(0, weight=1)
        trace_modes_frame.grid_columnconfigure(1, weight=1)
        trace_modes_frame.grid_columnconfigure(2, weight=1)
        trace_modes_frame.grid_columnconfigure(3, weight=1)

        ttk.Label(trace_modes_frame, text="Trace 1 Mode:").grid(row=0, column=0, padx=5, pady=2, sticky="w")
        self.trace1_combo = ttk.Combobox(trace_modes_frame, textvariable=self.trace_vars[0], values=self.trace_modes, state="readonly")
        self.trace1_combo.grid(row=1, column=0, padx=5, pady=2, sticky="ew")
        ttk.Label(trace_modes_frame, text="Trace 2 Mode:").grid(row=0, column=1, padx=5, pady=2, sticky="w")
        self.trace2_combo = ttk.Combobox(trace_modes_frame, textvariable=self.trace_vars[1], values=self.trace_modes, state="readonly")
        self.trace2_combo.grid(row=1, column=1, padx=5, pady=2, sticky="ew")
        ttk.Label(trace_modes_frame, text="Trace 3 Mode:").grid(row=0, column=2, padx=5, pady=2, sticky="w")
        self.trace3_combo = ttk.Combobox(trace_modes_frame, textvariable=self.trace_vars[2], values=self.trace_modes, state="readonly")
        self.trace3_combo.grid(row=1, column=2, padx=5, pady=2, sticky="ew")
        ttk.Label(trace_modes_frame, text="Trace 4 Mode:").grid(row=0, column=3, padx=5, pady=2, sticky="w")
        self.trace4_combo = ttk.Combobox(trace_modes_frame, textvariable=self.trace_vars[3], values=self.trace_modes, state="readonly")
        self.trace4_combo.grid(row=1, column=3, padx=5, pady=2, sticky="ew")
        
        self.trace_modes_result_var = tk.StringVar(value="Result: N/A")
        ttk.Label(trace_modes_frame, textvariable=self.trace_modes_result_var, style="Dark.TLabel.Value").grid(row=2, column=0, columnspan=4, padx=5, pady=2, sticky="ew")
        
        ttk.Button(trace_modes_frame, text="YakBeg - TRACE/MODES", command=lambda: self._on_trace_modes_beg()).grid(row=3, column=0, columnspan=4, padx=5, pady=5, sticky="ew")


        # --- TRACE/DATA Frame (from YakBegTab) ---
        trace_data_frame = ttk.LabelFrame(self, text="YakBeg - TRACE/DATA", padding=10)
        trace_data_frame.grid(row=1, column=0, padx=10, pady=5, sticky="nsew")
        trace_data_frame.grid_columnconfigure(0, weight=1)
        trace_data_frame.grid_rowconfigure(2, weight=1)
        
        trace_data_controls_frame = ttk.Frame(trace_data_frame)
        trace_data_controls_frame.grid(row=0, column=0, sticky="ew")
        trace_data_controls_frame.grid_columnconfigure(0, weight=1)
        trace_data_controls_frame.grid_columnconfigure(1, weight=1)
        trace_data_controls_frame.grid_columnconfigure(2, weight=1)

        ttk.Label(trace_data_controls_frame, text="Trace #:", style="TLabel").grid(row=0, column=0, padx=5, pady=2, sticky="w")
        self.trace_select_combo = ttk.Combobox(trace_data_controls_frame, textvariable=self.trace_select_var, values=["1", "2", "3", "4"], state="readonly")
        self.trace_select_combo.grid(row=0, column=1, padx=5, pady=2, sticky="ew")
        self.trace_select_combo.set("1")

        ttk.Label(trace_data_controls_frame, text="# of points:", style="TLabel").grid(row=0, column=2, padx=5, pady=2, sticky="w")
        ttk.Label(trace_data_controls_frame, textvariable=self.trace_data_count_var, style="Dark.TLabel.Value").grid(row=0, column=3, padx=5, pady=2, sticky="ew")

        ttk.Label(trace_data_controls_frame, text="Start Freq (MHz):", style="TLabel").grid(row=1, column=0, padx=5, pady=2, sticky="w")
        ttk.Entry(trace_data_controls_frame, textvariable=self.trace_data_start_freq_var).grid(row=1, column=1, padx=5, pady=2, sticky="ew")

        ttk.Label(trace_data_controls_frame, text="Stop Freq (MHz):", style="TLabel").grid(row=1, column=2, padx=5, pady=2, sticky="w")
        ttk.Entry(trace_data_controls_frame, textvariable=self.trace_data_stop_freq_var).grid(row=1, column=3, padx=5, pady=2, sticky="ew")
        
        ttk.Button(trace_data_controls_frame, text="YakBeg - TRACE/DATA", command=lambda: self._on_trace_data_beg()).grid(row=2, column=0, columnspan=4, padx=5, pady=5, sticky="ew")

        # Table to display trace data
        columns = ("Frequency (MHz)", "Value (dBm)")
        self.trace_data_tree = ttk.Treeview(trace_data_frame, columns=columns, show="headings", style='Treeview')
        self.trace_data_tree.heading("Frequency (MHz)", text="Frequency (MHz)", anchor=tk.W)
        self.trace_data_tree.heading("Value (dBm)", text="Value (dBm)", anchor=tk.W)
        self.trace_data_tree.grid(row=1, column=0, sticky="nsew", padx=5, pady=5)
        
        vsb = ttk.Scrollbar(trace_data_frame, orient="vertical", command=self.trace_data_tree.yview)
        vsb.grid(row=1, column=1, sticky="ns")
        self.trace_data_tree.configure(yscrollcommand=vsb.set)
        
        # New button to push data to monitor
        ttk.Button(self, text="Push Trace Data to Monitor", command=lambda: self._on_push_to_monitor(), style="Green.TButton").grid(row=2, column=0, padx=10, pady=5, sticky="ew")

        # NEW: Frame for NAB All Traces functionality
        all_traces_nab_frame = ttk.LabelFrame(self, text="YakNab - TRACE/ALL/ONETWOTHREE", padding=10)
        all_traces_nab_frame.grid(row=3, column=0, padx=10, pady=5, sticky="nsew")
        all_traces_nab_frame.grid_columnconfigure(0, weight=1)
        all_traces_nab_frame.grid_columnconfigure(1, weight=1)

        ttk.Label(all_traces_nab_frame, text="Start Freq (MHz):", style="TLabel").grid(row=0, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(all_traces_nab_frame, textvariable=self.all_traces_start_freq_display_var, style="Dark.TLabel.Value").grid(row=0, column=1, padx=5, pady=2, sticky="ew")
        
        ttk.Label(all_traces_nab_frame, text="Stop Freq (MHz):", style="TLabel").grid(row=1, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(all_traces_nab_frame, textvariable=self.all_traces_stop_freq_display_var, style="Dark.TLabel.Value").grid(row=1, column=1, padx=5, pady=2, sticky="ew")
        
        ttk.Label(all_traces_nab_frame, text="Trace 1 Mode:", style="TLabel").grid(row=2, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(all_traces_nab_frame, textvariable=self.all_traces_trace1_mode_display_var, style="Dark.TLabel.Value").grid(row=2, column=1, padx=5, pady=2, sticky="ew")

        ttk.Label(all_traces_nab_frame, text="Trace 2 Mode:", style="TLabel").grid(row=3, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(all_traces_nab_frame, textvariable=self.all_traces_trace2_mode_display_var, style="Dark.TLabel.Value").grid(row=3, column=1, padx=5, pady=2, sticky="ew")
        
        ttk.Label(all_traces_nab_frame, text="Trace 3 Mode:", style="TLabel").grid(row=4, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(all_traces_nab_frame, textvariable=self.all_traces_trace3_mode_display_var, style="Dark.TLabel.Value").grid(row=4, column=1, padx=5, pady=2, sticky="ew")
        
        self.all_traces_count_label = ttk.Label(all_traces_nab_frame, text="# of points:", style="TLabel")
        self.all_traces_count_label.grid(row=5, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(all_traces_nab_frame, textvariable=self.all_traces_count_var, style="Dark.TLabel.Value").grid(row=5, column=1, padx=5, pady=2, sticky="ew")

        ttk.Button(all_traces_nab_frame, text="YakNab - TRACE/ALL/ONETWOTHREE", command=self._on_all_traces_nab).grid(row=6, column=0, columnspan=2, padx=5, pady=5, sticky="ew")

        columns_all = ("Frequency (MHz)", "Trace 1", "Trace 2", "Trace 3")
        self.all_traces_tree = ttk.Treeview(all_traces_nab_frame, columns=columns_all, show="headings", style='Treeview')
        self.all_traces_tree.heading("Frequency (MHz)", text="Frequency (MHz)", anchor=tk.W)
        self.all_traces_tree.heading("Trace 1", text="Trace 1 (dBm)", anchor=tk.W)
        self.all_traces_tree.heading("Trace 2", text="Trace 2 (dBm)", anchor=tk.W)
        self.all_traces_tree.heading("Trace 3", text="Trace 3 (dBm)", anchor=tk.W)
        self.all_traces_tree.grid(row=7, column=0, columnspan=2, sticky="nsew", padx=5, pady=5)
        
        vsb_all = ttk.Scrollbar(all_traces_nab_frame, orient="vertical", command=self.all_traces_tree.yview)
        vsb_all.grid(row=7, column=2, sticky="ns")
        self.all_traces_tree.configure(yscrollcommand=vsb_all.set)


        debug_log(f"Widgets for Trace Settings Tab created. The controls are ready to go! 🗺️",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)


    def _on_all_traces_nab(self):
        """
        Handles the YakNab command for all traces, displaying the results in the new table.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"YakNab for all traces triggered.",
                  file=f"{os.path.basename(__file__)}",
                  version=current_version,
                  function=current_function)
        
        # We call the handler function, which now returns a dictionary.
        all_trace_data = handle_all_traces_nab(self.app_instance, self.console_print_func)
        
        if all_trace_data:
            # Store the data for potential plotting later
            self.last_nab_trace_data = all_trace_data.get("TraceData", {})
            self.last_nab_start_freq = all_trace_data.get("StartFreq")
            self.last_nab_stop_freq = all_trace_data.get("StopFreq")
            self.last_nab_trace_modes = all_trace_data.get("TraceModes", {})

            # Extract the data and modes from the returned dictionary.
            trace_data_dict = self.last_nab_trace_data
            trace_modes = self.last_nab_trace_modes
            start_freq = self.last_nab_start_freq
            stop_freq = self.last_nab_stop_freq

            trace1_data = trace_data_dict.get("Trace1", [])
            trace2_data = trace_data_dict.get("Trace2", [])
            trace3_data = trace_data_dict.get("Trace3", [])

            # Update the display variables for the new UI labels.
            self.all_traces_start_freq_display_var.set(f"{start_freq / 1000000:.3f} MHz")
            self.all_traces_stop_freq_display_var.set(f"{stop_freq / 1000000:.3f} MHz")
            self.all_traces_trace1_mode_display_var.set(trace_modes.get("Trace1", "N/A"))
            self.all_traces_trace2_mode_display_var.set(trace_modes.get("Trace2", "N/A"))
            self.all_traces_trace3_mode_display_var.set(trace_modes.get("Trace3", "N/A"))
            self.all_traces_count_var.set(str(len(trace1_data)))

            # Clear and repopulate the Treeview table.
            self.all_traces_tree.delete(*self.all_traces_tree.get_children())
            
            for i in range(len(trace1_data)):
                freq = trace1_data[i][0]
                val1 = trace1_data[i][1] if i < len(trace1_data) else None
                val2 = trace2_data[i][1] if i < len(trace2_data) else None
                val3 = trace3_data[i][1] if i < len(trace3_data) else None
                
                self.all_traces_tree.insert("", "end", values=(f"{freq:.3f}", f"{val1:.2f}", f"{val2:.2f}", f"{val3:.2f}"))
            
            self.console_print_func(f"✅ Received and displayed data for 3 traces, with {len(trace1_data)} points each.")
            
            # Call the new function to plot the data
            self._plot_all_traces_to_monitor()
            
            # NEW: Switch to the Scan Monitor tab automatically
            self.app_instance.display_parent_tab.change_display_tab("Monitor")

            # ADDED: Call the save handler
            self._save_settings_handler()

        else:
            self.all_traces_start_freq_display_var.set("N/A")
            self.all_traces_stop_freq_display_var.set("N/A")
            self.all_traces_trace1_mode_display_var.set("N/A")
            self.all_traces_trace2_mode_display_var.set("N/A")
            self.all_traces_trace3_mode_display_var.set("N/A")
            self.all_traces_count_var.set("0")
            self.all_traces_tree.delete(*self.all_traces_tree.get_children())
            self.console_print_func("❌ Trace data retrieval failed.")


    def _on_trace_modes_beg(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"YakBeg for TRACE/MODES triggered.",
                    file=f"{os.path.basename(__file__)}",
                    version=current_version,
                    function=current_function)
        
        # FIXED: Get values from the local StringVar objects
        trace_modes = [
            self.trace1_mode_var.get(),
            self.trace2_mode_var.get(),
            self.trace3_mode_var.get(),
            self.trace4_mode_var.get()
        ]
        
        response = handle_trace_modes_beg(self.app_instance, trace_modes, self.console_print_func)
        self.trace_modes_result_var.set(f"Result: {response}")
        
        if response != "FAILED":
            # ADDED: Call the save handler
            self._save_settings_handler()

    def _on_trace_data_beg(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"YakBeg for TRACE/DATA triggered.",
                    file=f"{os.path.basename(__file__)}",
                    version=current_version,
                    function=current_function)
        
        trace_number = self.trace_select_var.get()
        start_freq_mhz = self.trace_data_start_freq_var.get()
        stop_freq_mhz = self.trace_data_stop_freq_var.get()
        
        processed_data = handle_trace_data_beg(self.app_instance, trace_number, start_freq_mhz, stop_freq_mhz, self.console_print_func)

        if processed_data:
            self.trace_data_count_var.set(str(len(processed_data)))
            self.trace_data_tree.delete(*self.trace_data_tree.get_children())
            
            for freq, value in processed_data:
                self.trace_data_tree.insert("", "end", values=(f"{freq:.3f}", f"{value:.2f}"))
            
            self.console_print_func(f"✅ Received and displayed {len(processed_data)} data points.")

            # NEW: Call update_plot to update the Scan View tab with the new data
            scan_view_tab = self.app_instance.display_parent_tab.bottom_pane.scan_view_tab
            df = pd.DataFrame(processed_data, columns=['Frequency_Hz', 'Power_dBm'])
            plot_title = f"Trace {trace_number} Data from YakBeg"
            update_single_plot(scan_view_tab, df, start_freq_mhz, stop_freq_mhz, plot_title)
            
            # NEW: Switch to the Scan View tab automatically
            self.app_instance.display_parent_tab.change_display_tab("View")

        else:
            self.trace_data_count_var.set("0")
            self.trace_data_tree.delete(*self.trace_data_tree.get_children())
            self.console_print_func("❌ Trace data retrieval failed.")

    def _on_tab_selected(self, event):
        """Called when this tab is selected."""
        pass # No specific actions needed on selection
        
    def _on_push_to_monitor(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Push to Monitor button clicked. Let's see if we can get this trace on screen! 🖥️",
                    file=f"{os.path.basename(__file__)}",
                    version=current_version,
                    function=current_function)
        
        trace_number = self.trace_select_var.get()
        data = []
        for item in self.trace_data_tree.get_children():
            values = self.trace_data_tree.item(item, 'values')
            data.append((float(values[0]), float(values[1])))
        
        # We need to know which plot to update. The original code only had one push function.
        # Let's assume we're pushing to the top plot for now.
        plot_title = f"Trace {trace_number} Data"
        if trace_number == "1":
            update_top_plot(self.app_instance.display_parent_tab.scan_monitor_tab, data, self.trace_data_start_freq_var.get(), self.trace_data_stop_freq_var.get(), plot_title)
        elif trace_number == "2":
            update_middle_plot(self.app_instance.display_parent_tab.scan_monitor_tab, data, self.trace_data_start_freq_var.get(), self.trace_data_stop_freq_var.get(), plot_title)
        elif trace_number == "3":
            update_bottom_plot(self.app_instance.display_parent_tab.scan_monitor_tab, data, self.trace_data_start_freq_var.get(), self.trace_data_stop_freq_var.get(), plot_title)
        else:
            self.console_print_func("⚠️ Invalid trace number selected. Cannot push to monitor.")
            debug_log("Invalid trace number selected. This is a fucking waste of time!",
                        file=f"{os.path.basename(__file__)}",
                        version=current_version,
                        function=current_function)

    def _plot_all_traces_to_monitor(self):
        """
        Function Description:
        This function takes the last successful response from handle_all_traces_nab,
        converts the data to a DataFrame, and pushes it to the three monitor plots.
        
        Inputs:
            None (uses self.last_nab_trace_data and other class attributes)

        Outputs:
            None. Renders the plots to the GUI.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}. Plotting all three NAB traces to the monitor. 📊",
                  file=f"{os.path.basename(__file__)}",
                  version=current_version,
                  function=current_function)

        if not self.last_nab_trace_data:
            self.console_print_func("❌ No NAB trace data available to plot. Press the NAB button first!")
            debug_log("No NAB trace data available. Aborting plot.",
                        file=f"{os.path.basename(__file__)}",
                        version=current_version,
                        function=current_function)
            return

        # Get the global plot instance
        monitor_tab = self.app_instance.display_parent_tab.bottom_pane.scan_monitor_tab
        if not monitor_tab:
            self.console_print_func("❌ Monitor tab not found. Cannot plot.")
            debug_log("Monitor tab instance not found. This is a critical failure!",
                        file=f"{os.path.basename(__file__)}",
                        version=current_version,
                        function=current_function)
            return

        start_freq_mhz = self.last_nab_start_freq / 1000000
        stop_freq_mhz = self.last_nab_stop_freq / 1000000

        # Plot Trace 1 (Live/View) on the top plot
        trace1_data = self.last_nab_trace_data.get("Trace1", [])
        trace1_mode = self.last_nab_trace_modes.get("Trace1", "N/A")
        if trace1_data and trace1_mode.upper() in ["VIEW", "WRIT"]:
            df1 = pd.DataFrame(trace1_data, columns=["Frequency_Hz", "Power_dBm"])
            update_top_plot(monitor_tab, df1, start_freq_mhz, stop_freq_mhz, f"Live/View ({trace1_mode})")
        else:
            # Clear the plot if the mode is 'BLANK' or no data is available
            df1 = pd.DataFrame(columns=["Frequency_Hz", "Power_dBm"])
            update_top_plot(monitor_tab, df1, start_freq_mhz, stop_freq_mhz, "Live/View (BLANK)")
            
        # Plot Trace 2 (Max Hold) on the middle plot
        trace2_data = self.last_nab_trace_data.get("Trace2", [])
        trace2_mode = self.last_nab_trace_modes.get("Trace2", "N/A")
        if trace2_data and trace2_mode.upper() == "MAXH":
            df2 = pd.DataFrame(trace2_data, columns=["Frequency_Hz", "Power_dBm"])
            update_middle_plot(monitor_tab, df2, start_freq_mhz, stop_freq_mhz, f"Max Hold ({trace2_mode})")
        else:
            df2 = pd.DataFrame(columns=["Frequency_Hz", "Power_dBm"])
            update_middle_plot(monitor_tab, df2, start_freq_mhz, stop_freq_mhz, "Max Hold (BLANK)")

        # Plot Trace 3 (Min Hold) on the bottom plot
        trace3_data = self.last_nab_trace_data.get("Trace3", [])
        trace3_mode = self.last_nab_trace_modes.get("Trace3", "N/A")
        if trace3_data and trace3_mode.upper() == "MINH":
            df3 = pd.DataFrame(trace3_data, columns=["Frequency_Hz", "Power_dBm"])
            update_bottom_plot(monitor_tab, df3, start_freq_mhz, stop_freq_mhz, f"Min Hold ({trace3_mode})")
        else:
            df3 = pd.DataFrame(columns=["Frequency_Hz", "Power_dBm"])
            update_bottom_plot(monitor_tab, df3, start_freq_mhz, stop_freq_mhz, "Min Hold (BLANK)")

        self.console_print_func("✅ Successfully plotted all traces to the monitor.")
        debug_log(f"All NAB traces plotted successfully. Mission accomplished! 🥳",
                  file=f"{os.path.basename(__file__)}",
                  version=current_version,
                  function=current_function)

    def _save_settings_handler(self):
        """Handles saving the instrument trace settings to the config file."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"⚙️ 💾 Entering {current_function}. Time to save the instrument trace settings! 📈",
                  file=os.path.basename(__file__),
                  version=current_version,
                  function=current_function)
        
        try:
            # Call the specific save function from the modular config manager
            _save_instrument_settings(
                config=self.app_instance.program_config,
                app_instance=self.app_instance,
                console_print_func=self.console_print_func
            )
            # Call the main config save function to write the changes to the file
            save_program_config(
                app_instance=self.app_instance,
                config=self.app_instance.program_config,
                config_file_path=self.app_instance.config_file_path,
                console_print_func=self.console_print_func
            )
            debug_log("⚙️ ✅ Instrument trace settings saved successfully. Mission accomplished!",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)
        except Exception as e:
            debug_log(f"❌ Error saving instrument trace settings: {e}",
                      file=os.path.basename(__file__),
                      version=current_version,
                      function=current_function)
            self.console_print_func(f"❌ Error saving instrument trace settings: {e}")

#####################################
### File: OPEN-AIR 2\workers\Instrument\visa\ref_visa_commands.py
#####################################
# ref/ref_visa_commands.py
#
# This module provides a single, centralized list of default VISA commands
# for the application's interpreter. The data structure has been updated to
# include a 'Manufacturer' field to support the new column in the VISA Interpreter.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250812.215500.1 (FIXED: The get_default_commands function now correctly returns a list of tuples instead of a single tuple to properly populate the CSV file.)

current_version = "20250812.215500.1"
current_version_hash = 20250812 * 215500 * 1

def get_default_visa_commands():
    """
    Returns a list of default VISA commands.
    Each entry is a tuple: (Manufacturer, Model, Command Type, Action, VISA Command, Default Value for Variable, Validated).
    """
    # CORRECTED: The return value is now wrapped in a list.
    return [
        # System/Identification
        ("Keysight Technologies", "*", "SYSTEM/ID", "GET", "*IDN", "?", ""),
        ("Keysight Technologies", "*", "SYSTEM/RESET", "DO", "*RST", "", ""),
        ("Keysight Technologies", "*", "SYSTEM/ERRORS", "GET", ":SYSTem:ERRor", "?", ""),
        ("Keysight Technologies", "*", "SYSTEM/DISPLAY/UPDATE", "DO", ":SYSTem:DISPlay:UPDate", "", ""),
        ("Rohde & Schwarz", "*", "SYSTEM/ID", "GET", "*IDN", "?", ""),
        ("Rohde & Schwarz", "*", "SYSTEM/RESET", "DO", "*RST", "", ""),
        ("Rohde & Schwarz", "*", "SYSTEM/ERRORS", "GET", ":SYSTem:ERRor", "?", ""),
        ("Rohde & Schwarz", "*", "SYSTEM/DISPLAY/UPDATE", "DO", ":SYSTem:DISPlay:UPDate", "", ""),
        # Frequency/Span/Sweep
        ("Keysight Technologies", "*", "FREQUENCY/CENTER", "SET", ":SENSe:FREQuency:CENTer", "1000", ""),
        ("Keysight Technologies", "*", "FREQUENCY/CENTER", "GET", ":SENSe:FREQuency:CENTer", "?", ""),
        ("Keysight Technologies", "*", "FREQUENCY/SPAN", "SET", ":SENSe:FREQuency:SPAN", "1000", ""),
        ("Keysight Technologies", "*", "FREQUENCY/SPAN", "GET", ":SENSe:FREQuency:SPAN", "?", ""),

        ("Keysight Technologies", "*", "FREQUENCY/CENTER-SPAN", "RIG", ":SENSe:FREQuency:CENTer 111;:SENSe:FREQuency:SPAN 222; ", "2", ""),
        ("Keysight Technologies", "*", "FREQUENCY/CENTER-SPAN", "NAB", ":SENSe:FREQuency:SPAN?;:SENSe:FREQuency:CENTer? ", "2", ""),
        ("Keysight Technologies", "*", "FREQUENCY/CENTER-SPAN", "BEG", ":SENSe:FREQuency:CENTer 111;:SENSe:FREQuency:SPAN 222;:SENSe:FREQuency:SPAN?;:SENSe:FREQuency:CENTer?;:FREQuency:STARt?;:FREQuency:STOP?", "2", ""),
        



        ("Keysight Technologies", "*", "FREQUENCY/START", "GET", ":FREQuency:STARt", "?", ""),
        ("Keysight Technologies", "*", "FREQUENCY/START", "SET", ":FREQuency:STARt", "1000", ""),
        ("Keysight Technologies", "*", "FREQUENCY/STOP", "GET", ":FREQuency:STOP", "?", ""),
        ("Keysight Technologies", "*", "FREQUENCY/STOP", "SET", ":FREQuency:STOP", "2000", ""),
        
        ("Keysight Technologies", "*", "FREQUENCY/START-STOP", "RIG", ":FREQuency:STARt 111;:FREQuency:STOP 222 ", "2", ""),
        ("Keysight Technologies", "*", "FREQUENCY/START-STOP", "NAB", ":FREQuency:STARt?;:FREQuency:STOP? ", "2", ""),
        ("Keysight Technologies", "*", "FREQUENCY/START-STOP", "BEG", ":FREQuency:STARt 111;:FREQuency:STOP 222;:FREQuency:STARt?;:FREQuency:STOP?;:SENSe:FREQuency:SPAN?;:SENSe:FREQuency:CENTer?;", "2", ""),
        

        ("Keysight Technologies", "*", "FREQUENCY/SWEEP/POINTS", "GET", ":SENSe:SWEep:POINts", "?", ""),
        
        ("Keysight Technologies", "N9342CN", "FREQUENCY/SWEEP/TIME", "GET", ":SENSe:SWEep:TIME", "?", ""),
        ("Keysight Technologies", "N9342CN", "FREQUENCY/SWEEP/TIME/ON", "DO", ":SENSe:SWEep:TIME:AUTO", "ON", ""),
        ("Keysight Technologies", "N9342CN", "FREQUENCY/SWEEP/TIME", "GET", ":SENSe:SWEep:TIME", "?", ""),
        ("Keysight Technologies", "N9342CN", "FREQUENCY/SWEEP/TIME/OFF", "DO", ":SENSe:SWEep:TIME:AUTO", "OFF", ""),
        ("Keysight Technologies", "N9342CN", "FREQUENCY/SWEEP/TIME", "GET", ":SENSe:SWEep:TIME", "?", ""),

        ("Agilent Technologies", "N9340B", "FREQUENCY/SWEEP/TIME", "SET", ":SENSe:SWEep:TIME", "3", ""),
        ("Agilent Technologies", "N9340B", "FREQUENCY/SWEEP/TIME", "GET", ":SENSe:SWEep:TIME", "?", ""),

        ("Agilent Technologies", "N9340B", "FREQUENCY/SWEEP/TIME/AUTO", "GET", ":SENSe:SWEep:TIME:AUTO", "?", ""),
        ("Agilent Technologies", "N9340B", "FREQUENCY/SWEEP/TIME/AUTO/ON", "DO", ":SENSe:SWEep:TIME:AUTO", "ON", ""),
        ("Agilent Technologies", "N9340B", "FREQUENCY/SWEEP/TIME/AUTO", "GET", ":SENSe:SWEep:TIME:AUTO", "?", ""),
        ("Agilent Technologies", "N9340B", "FREQUENCY/SWEEP/TIME/AUTO/OFF", "DO", ":SENSe:SWEep:TIME:AUTO", "OFF", ""),

        ("Agilent Technologies", "N9340B", "FREQUENCY/SWEEP/TIME/AUTO", "GET", ":SENSe:SWEep:TIME:AUTO", "?", ""),
        ("Agilent Technologies", "N9340B", "FREQUENCY/SWEEP/MODE", "DO", ":SENSe:SWEep:TIME:AUTO:MODE", "NORMAL", ""),
        ("Agilent Technologies", "N9340B", "FREQUENCY/SWEEP/TIME/AUTO", "GET", ":SENSe:SWEep:TIME:AUTO", "?", ""),        
        ("Agilent Technologies", "N9340B", "FREQUENCY/SWEEP/MODE", "DO", ":SENSe:SWEep:TIME:AUTO:MODE", "FAST", ""),
        ("Agilent Technologies", "N9340B", "FREQUENCY/SWEEP/MODE", "GET", ":SENSe:SWEep:TIME:AUTO:MODE", "?", ""),
        ("Agilent Technologies", "N9340B", "FREQUENCY/SWEEP/TDMODE/ON", "DO", ":SENSe:SWEep:TDMode", "ON", ""),
        ("Agilent Technologies", "N9340B", "FREQUENCY/SWEEP/TDMODE/OFF", "DO", ":SENSe:SWEep:TDMode", "OFF", ""),
        ("Agilent Technologies", "N9340B", "FREQUENCY/SWEEP/TDMODE", "GET", ":SENSe:SWEep:TDMode", "?", ""),

        ("Keysight Technologies", "*", "FREQUENCY/SWEEP/SPACING/LINEAR", "DO", ":SENSe:X:SPACing LINear", "LINear", ""),
        
        ("Keysight Technologies", "N9342CN", "FREQUENCY/OFFSET", "GET", ":FREQuency:OFFSet", "?", ""),
        ("Keysight Technologies", "N9342CN", "FREQUENCY/SHIFT", "GET", ":INPut:RFSense:FREQuency:SHIFt", "?", ""),
        ("Keysight Technologies", "N9342CN", "FREQUENCY/SHIFT/0", "DO", ":INPut:RFSense:FREQuency:SHIFt", "0", ""),

        # Bandwidth (RBW/VBW)
        ("Keysight Technologies", "*", "BANDWIDTH/RESOLUTION", "GET", ":SENSe:BANDwidth:RESolution", "?", ""),
        ("Keysight Technologies", "*", "BANDWIDTH/RESOLUTION", "SET", ":SENSe:BANDwidth:RESolution", "1000000", ""),
        ("Keysight Technologies", "*", "BANDWIDTH/RESOLUTION", "GET", ":SENSe:BANDwidth:RESolution", "?", ""),

        ("Keysight Technologies", "*", "INITIATE/CONTINUOUS", "GET", ":INITiate:CONTinuous", "?", ""),
        ("Keysight Technologies", "*", "INITIATE/CONTINUOUS/ON", "DO", ":INITiate:CONTinuous", "ON", ""),
        ("Keysight Technologies", "*", "INITIATE/CONTINUOUS", "GET", ":INITiate:CONTinuous", "?", ""),
        ("Keysight Technologies", "*", "INITIATE/CONTINUOUS/OFF", "DO", ":INITiate:CONTinuous", "Off", ""),
        
        ("Keysight Technologies", "*", "BANDWIDTH/SETTINGS", "NAB", ":SENSe:BANDwidth:RESolution?;:SENSe:BANDwidth:VIDeo?;:SENSe:BANDwidth:VIDeo:AUTO?;:INITiate:CONTinuous?;:SENSe:SWEep:TIME?", "5", ""),
        
        
        ("Keysight Technologies", "*", "INITIATE/IMMEDIATE", "DO", ":INITiate:IMMediate", "", ""),

        ("Keysight Technologies", "*", "BANDWIDTH/VIDEO", "GET", ":SENSe:BANDwidth:VIDeo", "?", ""),
        ("Keysight Technologies", "*", "BANDWIDTH/VIDEO", "SET", ":SENSe:BANDwidth:VIDeo", "1000000", ""),
        ("Keysight Technologies", "*", "BANDWIDTH/VIDEO", "GET", ":SENSe:BANDwidth:VIDeo", "?", ""),

        ("Keysight Technologies", "*", "BANDWIDTH/VIDEO/AUTO/ON", "DO", ":SENSe:BANDwidth:VIDeo:AUTO", "ON", ""),
        ("Keysight Technologies", "*", "BANDWIDTH/VIDEO/AUTO", "GET", ":SENSe:BANDwidth:VIDeo:AUTO", "?", ""),
        ("Keysight Technologies", "*", "BANDWIDTH/VIDEO/AUTO/OFF", "DO", ":SENSe:BANDwidth:VIDeo:AUTO", "OFF", ""),
        ("Keysight Technologies", "*", "BANDWIDTH/VIDEO/AUTO", "GET", ":SENSe:BANDwidth:VIDeo:AUTO", "?", ""),

        ("Keysight Technologies", "*", "BANDWIDTH/RESOLUTION/AUTO/ON", "DO", ":SENSe:BANDwidth:RESolution:AUTO", "ON", ""),
        ("Keysight Technologies", "*", "BANDWIDTH/VIDEO/AUTO/ON", "DO", ":SENSe:BANDwidth:VIDeo:AUTO", "ON", ""),

        # Amplitude/Reference Level/Attenuation/Gain
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL", "GET", ":DISPlay:WINDow:TRACe:Y:RLEVel", "?", ""),
      # Updated commands for AMPLITUDE/REFERENCE LEVEL, with 5 dB increments from 0 to -120.

        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL", "GET", ":DISPlay:WINDow:TRACe:Y:RLEVel", "?", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/0", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "0", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-5", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-5", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-10", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-10", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-15", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-15", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-20", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-20", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-25", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-25", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-30", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-30", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-35", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-35", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-40", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-40", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-45", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-45", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-50", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-50", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-55", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-55", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-60", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-60", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-65", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-65", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-70", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-70", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-75", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-75", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-80", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-80", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-85", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-85", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-90", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-90", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-95", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-95", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-100", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-100", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-105", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-105", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-110", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-110", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-115", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-115", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/REFERENCE LEVEL/-120", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel", "-120", ""),

        ("Keysight Technologies", "*", "AMPLITUDE/ATTENUATION/AUTO/ON", "DO", ":INPut:ATTenuation:AUTO", "ON", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/ATTENUATION/AUTO", "GET", ":INPut:ATTenuation", "?", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/ATTENUATION/AUTO/OFF", "DO", ":INPut:ATTenuation:AUTO", "OFF", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/ATTENUATION/AUTO", "GET", ":INPut:ATTenuation", "?", ""),

        ("Keysight Technologies", "*", "AMPLITUDE/GAIN/STATE/ON", "DO", ":INPut:GAIN:STATe", "ON", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/GAIN/STATE", "GET", ":INPut:GAIN:STATe", "?", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/GAIN/STATE/OFF", "DO", ":INPut:GAIN:STATe", "OFF", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/GAIN/STATE", "GET", ":INPut:GAIN:STATe", "?", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION/AUTO/ON", "DO", ":POWer:ATTenuation:AUTO", "ON", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION/AUTO/OFF", "DO", ":POWer:ATTenuation:AUTO", "OFF", ""),

        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION", "GET", ":POWer:ATTenuation", "?", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION/0DB", "DO", ":POWer:ATTenuation", "0", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION", "GET", ":POWer:ATTenuation", "?", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION/10DB", "DO", ":POWer:ATTenuation", "10", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION", "GET", ":POWer:ATTenuation", "?", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION/20DB", "DO", ":POWer:ATTenuation", "20", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION", "GET", ":POWer:ATTenuation", "?", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION/30DB", "DO", ":POWer:ATTenuation", "30", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION", "GET", ":POWer:ATTenuation", "?", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION/40DB", "DO", ":POWer:ATTenuation", "40", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION", "GET", ":POWer:ATTenuation", "?", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION/50DB", "DO", ":POWer:ATTenuation", "50", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION", "GET", ":POWer:ATTenuation", "?", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION/60DB", "DO", ":POWer:ATTenuation", "60", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION", "GET", ":POWer:ATTenuation", "?", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION/70DB", "DO", ":POWer:ATTenuation", "70", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/ATTENUATION", "GET", ":POWer:ATTenuation", "?", ""),

        ("Keysight Technologies", "*", "AMPLITUDE/POWER/GAIN/ON", "DO", ":POWer:GAIN", "ON", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/GAIN", "GET", ":POWer:GAIN", "?", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/GAIN/OFF", "DO", ":POWer:GAIN", "OFF", ""),
        ("Keysight Technologies", "*", "AMPLITUDE/POWER/GAIN", "GET", ":POWer:GAIN", "?", ""),
        
        ("Keysight Technologies", "N9342CN", "AMPLITUDE/POWER/HIGH SENSITIVE/ON", "DO", ":POWer:HSENsitive", "ON", ""),
        ("Keysight Technologies", "N9342CN", "AMPLITUDE/POWER/HIGH SENSITIVE/OFF", "DO", ":POWer:HSENsitive", "OFF", ""),
        ("Keysight Technologies", "N9342CN", "AMPLITUDE/POWER/HIGH SENSITIVE", "NAB", ":DISPlay:WINDow:TRACe:Y:RLEVel?;:POWer:ATTenuation?;:POWer:GAIN?", "3", ""),

        ("Keysight Technologies", "N9340B", "AMPLITUDE/POWER/HIGH SENSITIVE/ON", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel -50; :POWer:ATTenuation 0; :POWer:GAIN ON", "", ""),
        ("Keysight Technologies", "N9340B", "AMPLITUDE/POWER/HIGH SENSITIVE/OFF", "DO", ":DISPlay:WINDow:TRACe:Y:RLEVel 0; :POWer:ATTenuation 20; :POWer:GAIN OFF", "", ""),
        ("Keysight Technologies", "N9340B", "AMPLITUDE/POWER/HIGH SENSITIVE", "NAB", ":DISPlay:WINDow:TRACe:Y:RLEVel?;:POWer:ATTenuation?;:POWer:GAIN?", "3", ""),

        ("Keysight Technologies", "*", "TRACE/MODES", "NAB", ":TRAC1:MODE?;:TRAC2:MODE?;:TRAC3:MODE?;:TRAC4:MODE?", "4", ""),
        ("Keysight Technologies", "*", "TRACE/MODES", "RIG", ":TRAC1:MODE 111;:TRAC2:MODE 222;:TRAC3:MODE 333;:TRAC4:MODE 444", "4", ""),
        ("Keysight Technologies", "*", "TRACE/MODES", "BEG", ":TRAC1:MODE 111;:TRAC2:MODE 222;:TRAC3:MODE 333;:TRAC4:MODE 444;:TRAC1:MODE?;:TRAC2:MODE?;:TRAC3:MODE?;:TRAC4:MODE?", "4", ""),

        # Trace Mode Write
        ("Keysight Technologies", "*", "TRACE/1/MODE/WRITE", "DO", ":TRAC1:MODE", "WRITe", ""),
        ("Keysight Technologies", "*", "TRACE/2/MODE/WRITE", "DO", ":TRAC2:MODE", "WRITe", ""),
        ("Keysight Technologies", "*", "TRACE/3/MODE/WRITE", "DO", ":TRAC3:MODE", "WRITe", ""),
        ("Keysight Technologies", "*", "TRACE/4/MODE/WRITE", "DO", ":TRAC4:MODE", "WRITe", ""),

        # Trace/Display - Expanded for 4 traces
        # Trace Data Query
        ("Keysight Technologies", "N9342CN", "TRACE/1/DATA", "GET", ":TRACe:DATA? TRACE1", "", ""),
        ("Keysight Technologies", "N9342CN", "TRACE/2/DATA", "GET", ":TRACe:DATA? TRACE2", "", ""),
        ("Keysight Technologies", "N9342CN", "TRACE/3/DATA", "GET", ":TRACe:DATA? TRACE3", "", ""),
        ("Keysight Technologies", "N9342CN", "TRACE/4/DATA", "GET", ":TRACe:DATA? TRACE4", "", ""),

        ("Keysight Technologies", "N9340B", "TRACE/1/DATA", "GET", ":TRACe1:DATA", "?", ""),
        ("Keysight Technologies", "N9340B", "TRACE/2/DATA", "GET", ":TRACe2:DATA", "?", ""),
        ("Keysight Technologies", "N9340B", "TRACE/3/DATA", "GET", ":TRACe3:DATA", "?", ""),
        ("Keysight Technologies", "N9340B", "TRACE/4/DATA", "GET", ":TRACe4:DATA", "?", ""),
        
        ("Keysight Technologies", "N9340B", "TRACE/ALL/ONETWOTHREE", "NAB", ":FREQuency:STARt?;:FREQuency:STOP?;:TRAC1:MODE?;:TRAC2:MODE?;:TRAC3:MODE?;:TRACe1:DATA?;:TRACe2:DATA?;:TRACe3:DATA?;", "8", ""),
        ("Keysight Technologies", "N9342CN", "TRACE/ALL/ONETWOTHREE", "NAB", ":FREQuency:STARt?;:FREQuency:STOP?;:TRAC1:MODE?;:TRAC2:MODE?;:TRAC3:MODE?;:TRACe:DATA? TRACE1;:TRACe:DATA? TRACE2;:TRACe:DATA? TRACE3;", "8", ""),

        # Trace/Display - Expanded for 4 traces
        # Trace Data Query
        ("Keysight Technologies", "N9342CN", "TRACE/1/DATA", "NAB", ":FREQuency:STARt?;:FREQuency:STOP?;:TRACe:DATA? TRACE1", "3", ""),
        ("Keysight Technologies", "N9342CN", "TRACE/2/DATA", "NAB", ":FREQuency:STARt?;:FREQuency:STOP?;:TRACe:DATA? TRACE2", "3", ""),
        ("Keysight Technologies", "N9342CN", "TRACE/3/DATA", "NAB", ":FREQuency:STARt?;:FREQuency:STOP?;:TRACe:DATA? TRACE3", "3", ""),
        ("Keysight Technologies", "N9342CN", "TRACE/4/DATA", "NAB", ":FREQuency:STARt?;:FREQuency:STOP?;:TRACe:DATA? TRACE4", "3", ""),

        ("Keysight Technologies", "N9342CN", "TRACE/1/DATA", "BEG", ":FREQuency:STARt 111;:FREQuency:STOP 222;:TRACe:DATA? TRACE1", "2", ""),
        ("Keysight Technologies", "N9342CN", "TRACE/2/DATA", "BEG", ":FREQuency:STARt 111;:FREQuency:STOP 222;:TRACe:DATA? TRACE2", "2", ""),
        ("Keysight Technologies", "N9342CN", "TRACE/3/DATA", "BEG", ":FREQuency:STARt 111;:FREQuency:STOP 222;:TRACe:DATA? TRACE3", "2", ""),
        ("Keysight Technologies", "N9342CN", "TRACE/4/DATA", "BEG", ":FREQuency:STARt 111;:FREQuency:STOP 222;:TRACe:DATA? TRACE4", "2", ""),



        ("Keysight Technologies", "N9340B", "TRACE/1/DATA", "NAB", ":FREQuency:STARt?;:FREQuency:STOP?;:TRACe1:DATA?", "3", ""),
        ("Keysight Technologies", "N9340B", "TRACE/2/DATA", "NAB", ":FREQuency:STARt?;:FREQuency:STOP?;:TRACe2:DATA?", "3", ""),
        ("Keysight Technologies", "N9340B", "TRACE/3/DATA", "NAB", ":FREQuency:STARt?;:FREQuency:STOP?;:TRACe3:DATA?", "3", ""),
        ("Keysight Technologies", "N9340B", "TRACE/4/DATA", "NAB", ":FREQuency:STARt?;:FREQuency:STOP?;:TRACe4:DATA?", "3", ""),


        ("Keysight Technologies", "N9340B", "TRACE/1/DATA", "BEG", ":FREQuency:STARt 111;:FREQuency:STOP 222;:TRACe1:DATA?", "2", ""),
        ("Keysight Technologies", "N9340B", "TRACE/2/DATA", "BEG", ":FREQuency:STARt 111;:FREQuency:STOP 222;:TRACe2:DATA?", "2", ""),
        ("Keysight Technologies", "N9340B", "TRACE/3/DATA", "BEG", ":FREQuency:STARt 111;:FREQuency:STOP 222;:TRACe3:DATA?", "2", ""),
        ("Keysight Technologies", "N9340B", "TRACE/4/DATA", "BEG", ":FREQuency:STARt 111;:FREQuency:STOP 222;:TRACe4:DATA?", "2", ""),





        # Trace Mode write
        ("Keysight Technologies", "*", "TRACE/1/MODE/WRITE", "DO", ":TRAC1:MODE", "WRITe", ""),
        ("Keysight Technologies", "*", "TRACE/2/MODE/WRITE", "DO", ":TRAC2:MODE", "WRITe", ""),
        ("Keysight Technologies", "*", "TRACE/3/MODE/WRITE", "DO", ":TRAC3:MODE", "WRITe", ""),
        ("Keysight Technologies", "*", "TRACE/4/MODE/WRITE", "DO", ":TRAC4:MODE", "WRITe", ""),
        
        ("Keysight Technologies", "*", "TRACE/MODES", "NAB", ":TRAC1:MODE?;:TRAC2:MODE?;:TRAC3:MODE?;:TRAC4:MODE?", "4", ""),
        
        ("Keysight Technologies", "*", "TRACE/1/MODE/WRITE", "DO", ":TRAC1:MODE", "WRITe", ""),
        ("Keysight Technologies", "*", "TRACE/1/MODE/BLANK", "DO", ":TRAC1:MODE", "BLANk", ""),
        ("Keysight Technologies", "*", "TRACE/2/MODE/WRITE", "DO", ":TRAC2:MODE", "WRITe", ""),
        ("Keysight Technologies", "*", "TRACE/2/MODE/BLANK", "DO", ":TRAC2:MODE", "BLANk", ""),
        ("Keysight Technologies", "*", "TRACE/3/MODE/WRITE", "DO", ":TRAC3:MODE", "WRITe", ""),
        ("Keysight Technologies", "*", "TRACE/3/MODE/BLANK", "DO", ":TRAC3:MODE", "BLANk", ""),
        ("Keysight Technologies", "*", "TRACE/4/MODE/WRITE", "DO", ":TRAC4:MODE", "WRITe", ""),
        ("Keysight Technologies", "*", "TRACE/4/MODE/BLANK", "DO", ":TRAC4:MODE", "BLANk", ""),
        
        ("Keysight Technologies", "*", "TRACE/1/MODE", "GET", ":TRAC1:MODE", "?", ""),
        ("Keysight Technologies", "*", "TRACE/2/MODE", "GET", ":TRAC2:MODE", "?", ""),
        ("Keysight Technologies", "*", "TRACE/3/MODE", "GET", ":TRAC3:MODE", "?", ""),
        ("Keysight Technologies", "*", "TRACE/4/MODE", "GET", ":TRAC4:MODE", "?", ""),

        # Trace Mode MaxHold
        ("Keysight Technologies", "*", "TRACE/1/MODE/MAXHOLD", "DO", ":TRAC1:MODE", "MAXHold", ""),
        ("Keysight Technologies", "*", "TRACE/2/MODE/MAXHOLD", "DO", ":TRAC2:MODE", "MAXHold", ""),
        ("Keysight Technologies", "*", "TRACE/3/MODE/MAXHOLD", "DO", ":TRAC3:MODE", "MAXHold", ""),
        ("Keysight Technologies", "*", "TRACE/4/MODE/MAXHOLD", "DO", ":TRAC4:MODE", "MAXHold", ""),

        ("Keysight Technologies", "*", "TRACE/1/MODE", "GET", ":TRAC1:MODE", "?", ""),
        ("Keysight Technologies", "*", "TRACE/2/MODE", "GET", ":TRAC2:MODE", "?", ""),
        ("Keysight Technologies", "*", "TRACE/3/MODE", "GET", ":TRAC3:MODE", "?", ""),
        ("Keysight Technologies", "*", "TRACE/4/MODE", "GET", ":TRAC4:MODE", "?", ""),

        # Trace Mode MinHold
        ("Keysight Technologies", "*", "TRACE/1/MODE/MINHOLD", "DO", ":TRAC1:MODE", "MINHold", ""),
        ("Keysight Technologies", "*", "TRACE/2/MODE/MINHOLD", "DO", ":TRAC2:MODE", "MINHold", ""),
        ("Keysight Technologies", "*", "TRACE/3/MODE/MINHOLD", "DO", ":TRAC3:MODE", "MINHold", ""),
        ("Keysight Technologies", "*", "TRACE/4/MODE/MINHOLD", "DO", ":TRAC4:MODE", "MINHold", ""),

        ("Keysight Technologies", "*", "TRACE/1/MODE", "GET", ":TRAC1:MODE", "?", ""),
        ("Keysight Technologies", "*", "TRACE/2/MODE", "GET", ":TRAC2:MODE", "?", ""),
        ("Keysight Technologies", "*", "TRACE/3/MODE", "GET", ":TRAC3:MODE", "?", ""),
        ("Keysight Technologies", "*", "TRACE/4/MODE", "GET", ":TRAC4:MODE", "?", ""),

        # Trace Mode VIEW
        ("Keysight Technologies", "*", "TRACE/1/MODE/VIEW", "DO", ":TRAC1:MODE", "VIEW", ""),
        ("Keysight Technologies", "*", "TRACE/2/MODE/VIEW", "DO", ":TRAC2:MODE", "VIEW", ""),
        ("Keysight Technologies", "*", "TRACE/3/MODE/VIEW", "DO", ":TRAC3:MODE", "VIEW", ""),
        ("Keysight Technologies", "*", "TRACE/4/MODE/VIEW", "DO", ":TRAC4:MODE", "VIEW", ""),

        ("Keysight Technologies", "*", "TRACE/1/MODE", "GET", ":TRAC1:MODE", "?", ""),
        ("Keysight Technologies", "*", "TRACE/2/MODE", "GET", ":TRAC2:MODE", "?", ""),
        ("Keysight Technologies", "*", "TRACE/3/MODE", "GET", ":TRAC3:MODE", "?", ""),
        ("Keysight Technologies", "*", "TRACE/4/MODE", "GET", ":TRAC4:MODE", "?", ""),

        # Averaging:


        
        # Averaging
        ("Keysight Technologies", "*", "AVERAGE/ON", "DO", ":AVER:TRAC1:STAT", "ON", ""),
        ("Keysight Technologies", "*", "AVERAGE/OFF", "DO", ":AVER:TRAC1:STAT", "OFF", ""),
        ("Keysight Technologies", "*", "AVERAGE", "SET", ":AVER:TRAC1:COUNT", "25", ""),
        ("Keysight Technologies", "*", "AVERAGE", "NAB", ":AVER:TRAC1:STAT?;:AVER:TRAC1:COUNT?", "2", ""),

        

        
        ("Keysight Technologies", "*", "TRACE/DISPLAY/TYPE", "GET", ":DISPlay:WINDow:TRACe:TYPE", "?", ""),
        ("Keysight Technologies", "*", "TRACE/DISPLAY/Y SCALE/SPACING", "SET", ":DISPlay:WINDow:TRACe:Y:SCALe:SPACing", "LOGarithmic", ""),
        ("Keysight Technologies", "N9342CN", "TRACE/FORMAT/DATA/ASCII", "DO", ":TRACe:FORMat:DATA", "ASCii", ""), # For *
        ("Keysight Technologies", "N9340B", "TRACE/FORMAT/DATA/ASCII", "DO", ":FORMat:DATA", "ASCii", ""), # General

        # Marker - Expanded for 6 markers
        # Marker Calculate Max
        ("Keysight Technologies", "*", "MARKER/1/CALCULATE/MAX", "DO", ":CALCulate:MARKer1:MAX", "", ""),
        ("Keysight Technologies", "*", "MARKER/2/CALCULATE/MAX", "DO", ":CALCulate:MARKer2:MAX", "", ""),
        ("Keysight Technologies", "*", "MARKER/3/CALCULATE/MAX", "DO", ":CALCulate:MARKer3:MAX", "", ""),
        ("Keysight Technologies", "*", "MARKER/4/CALCULATE/MAX", "DO", ":CALCulate:MARKer4:MAX", "", ""),
        ("Keysight Technologies", "*", "MARKER/5/CALCULATE/MAX", "DO", ":CALCulate:MARKer5:MAX", "", ""),
        ("Keysight Technologies", "*", "MARKER/6/CALCULATE/MAX", "DO", ":CALCulate:MARKer6:MAX", "", ""),


        ("Keysight Technologies", "*", "MARKER/1/CALCULATE/NEXT", "DO", ":CALCulate:MARKer1:NEXT", "", ""),
        ("Keysight Technologies", "*", "MARKER/2/CALCULATE/NEXT", "DO", ":CALCulate:MARKer2:NEXT", "", ""),
        ("Keysight Technologies", "*", "MARKER/3/CALCULATE/NEXT", "DO", ":CALCulate:MARKer3:NEXT", "", ""),
        ("Keysight Technologies", "*", "MARKER/4/CALCULATE/NEXT", "DO", ":CALCulate:MARKer4:NEXT", "", ""),
        ("Keysight Technologies", "*", "MARKER/5/CALCULATE/NEXT", "DO", ":CALCulate:MARKer5:NEXT", "", ""),
        ("Keysight Technologies", "*", "MARKER/6/CALCULATE/NEXT", "DO", ":CALCulate:MARKer6:NEXT", "", ""),

        ("Keysight Technologies", "*", "MARKER/PEAK/SEARCH", "DO", "CALCulate:MARKer1:MAXimum; :CALCulate:MARKer2:MAXimum:LEFT; :CALCulate:MARKer3:MAXimum:RIGHt; :CALCulate:MARKer4:MAXimum:LEFT; :CALCulate:MARKer5:MAXimum:RIGHt; :CALCulate:MARKer6:MAXimum:LEFT", "", ""),
        
        ("Keysight Technologies", "*", "MARKER/All/CALCULATE/STATE/ON", "DO", ":CALCulate:MARKer1:STATe ON; :CALCulate:MARKer2:STATe ON; :CALCulate:MARKer3:STATe ON; :CALCulate:MARKer4:STATe ON; :CALCulate:MARKer5:STATe ON; :CALCulate:MARKer6:STATe ON; ", "", ""),
        
        ("Keysight Technologies", "*", "MARKER/All/CALCULATE/STATE/OFF", "DO", ":CALCulate:MARKer1:STATe OFF; :CALCulate:MARKer2:STATe OFF; :CALCulate:MARKer3:STATe OFF; :CALCulate:MARKer4:STATe OFF; :CALCulate:MARKer5:STATe OFF; :CALCulate:MARKer6:STATe OFF; ", "", ""),
        
        ("Keysight Technologies", "*", "MARKER/NAB/ALL/Y", "NAB", ":CALCulate:MARKer1:Y?;:CALCulate:MARKer2:Y?;:CALCulate:MARKer3:Y?;:CALCulate:MARKer4:Y?;:CALCulate:MARKer5:Y?;:CALCulate:MARKer1:Y?", "6", ""),
        ("Keysight Technologies", "*", "MARKER/NAB/ALL/X", "NAB", ":CALCulate:MARKer1:X?;:CALCulate:MARKer2:X?;:CALCulate:MARKer3:X?;:CALCulate:MARKer4:X?;:CALCulate:MARKer5:X?;:CALCulate:MARKer1:X?", "6", ""),

        # Marker Calculate State
        ("Keysight Technologies", "*", "MARKER/1/CALCULATE/STATE/ON", "DO", ":CALCulate:MARKer1:STATe", "ON", ""),
        ("Keysight Technologies", "*", "MARKER/2/CALCULATE/STATE/ON", "DO", ":CALCulate:MARKer2:STATe", "ON", ""),
        ("Keysight Technologies", "*", "MARKER/3/CALCULATE/STATE/ON", "DO", ":CALCulate:MARKer3:STATe", "ON", ""),
        ("Keysight Technologies", "*", "MARKER/4/CALCULATE/STATE/ON", "DO", ":CALCulate:MARKer4:STATe", "ON", ""),
        ("Keysight Technologies", "*", "MARKER/5/CALCULATE/STATE/ON", "DO", ":CALCulate:MARKer5:STATe", "ON", ""),
        ("Keysight Technologies", "*", "MARKER/6/CALCULATE/STATE/ON", "DO", ":CALCulate:MARKer6:STATe", "ON", ""),

        # Marker Calculate State
        ("Keysight Technologies", "*", "MARKER/1/CALCULATE/STATE/OFF", "DO", ":CALCulate:MARKer1:STATe", "OFF", ""),
        ("Keysight Technologies", "*", "MARKER/2/CALCULATE/STATE/OFF", "DO", ":CALCulate:MARKer2:STATe", "OFF", ""),
        ("Keysight Technologies", "*", "MARKER/3/CALCULATE/STATE/OFF", "DO", ":CALCulate:MARKer3:STATe", "OFF", ""),
        ("Keysight Technologies", "*", "MARKER/4/CALCULATE/STATE/OFF", "DO", ":CALCulate:MARKer4:STATe", "OFF", ""),
        ("Keysight Technologies", "*", "MARKER/5/CALCULATE/STATE/OFF", "DO", ":CALCulate:MARKer5:STATe", "OFF", ""),
        ("Keysight Technologies", "*", "MARKER/6/CALCULATE/STATE/OFF", "DO", ":CALCulate:MARKer6:STATe", "OFF", ""),

                # Get Marker Calculate State
        ("Keysight Technologies", "*", "MARKER/1/CALCULATE/STATE", "GET", ":CALCulate:MARKer1:STATe", "?", ""),
        ("Keysight Technologies", "*", "MARKER/2/CALCULATE/STATE", "GET", ":CALCulate:MARKer2:STATe", "?", ""),
        ("Keysight Technologies", "*", "MARKER/3/CALCULATE/STATE", "GET", ":CALCulate:MARKer3:STATe", "?", ""),
        ("Keysight Technologies", "*", "MARKER/4/CALCULATE/STATE", "GET", ":CALCulate:MARKer4:STATe", "?", ""),
        ("Keysight Technologies", "*", "MARKER/5/CALCULATE/STATE", "GET", ":CALCulate:MARKer5:STATe", "?", ""),
        ("Keysight Technologies", "*", "MARKER/6/CALCULATE/STATE", "GET", ":CALCulate:MARKer6:STATe", "?", ""),


        # Marker Calculate X (Frequency)
        ("Keysight Technologies", "*", "MARKER/1/PLACE/X", "SET", ":CALCulate:MARKer1:X", "111111", ""),
        ("Keysight Technologies", "*", "MARKER/2/PLACE/X", "SET", ":CALCulate:MARKer2:X", "222222", ""),
        ("Keysight Technologies", "*", "MARKER/3/PLACE/X", "SET", ":CALCulate:MARKer3:X", "333333", ""),
        ("Keysight Technologies", "*", "MARKER/4/PLACE/X", "SET", ":CALCulate:MARKer4:X", "444444", ""),
        ("Keysight Technologies", "*", "MARKER/5/PLACE/X", "SET", ":CALCulate:MARKer5:X", "555555", ""),
        ("Keysight Technologies", "*", "MARKER/6/PLACE/X", "SET", ":CALCulate:MARKer6:X", "666666", ""),

        ("Keysight Technologies", "*", "MARKER/PLACE/ALL", "RIG", ":CALCulate:MARKer1:STATe ON;:CALCulate:MARKer2:STATe ON;:CALCulate:MARKer3:STATe ON;:CALCulate:MARKer4:STATe ON;:CALCulate:MARKer5:STATe ON;:CALCulate:MARKer6:STATe ON;:CALCulate:MARKer1:X 111,:CALCulate:MARKer2:X 222,:CALCulate:MARKer3:X 333;:CALCulate:MARKer4:X 444;:CALCulate:MARKer1:X 555;:CALCulate:MARKer6:X 666", "6", ""),
        ("Keysight Technologies", "*", "MARKER/PLACE/ALL", "BEG", ":CALCulate:MARKer1:STATe ON;:CALCulate:MARKer2:STATe ON;:CALCulate:MARKer3:STATe ON;:CALCulate:MARKer4:STATe ON;:CALCulate:MARKer5:STATe ON;:CALCulate:MARKer6:STATe ON;:CALCulate:MARKer1:X 111;:CALCulate:MARKer2:X 222;:CALCulate:MARKer3:X 333;:CALCulate:MARKer4:X 444;:CALCulate:MARKer5:X 555;:CALCulate:MARKer6:X 666;:CALCulate:MARKer1:Y?;:CALCulate:MARKer2:Y?;:CALCulate:MARKer3:Y?;:CALCulate:MARKer4:Y?;:CALCulate:MARKer5:Y?;:CALCulate:MARKer6:Y?", "6", ""),



        # Marker Calculate X (Frequency)
        ("Keysight Technologies", "*", "MARKER/1/CALCULATE/X", "GET", ":CALCulate:MARKer1:X", "?", ""),
        ("Keysight Technologies", "*", "MARKER/2/CALCULATE/X", "GET", ":CALCulate:MARKer2:X", "?", ""),
        ("Keysight Technologies", "*", "MARKER/3/CALCULATE/X", "GET", ":CALCulate:MARKer3:X", "?", ""),
        ("Keysight Technologies", "*", "MARKER/4/CALCULATE/X", "GET", ":CALCulate:MARKer4:X", "?", ""),
        ("Keysight Technologies", "*", "MARKER/5/CALCULATE/X", "GET", ":CALCulate:MARKer5:X", "?", ""),
        ("Keysight Technologies", "*", "MARKER/6/CALCULATE/X", "GET", ":CALCulate:MARKer6:X", "?", ""),


        


        # Marker Calculate Y (Amplitude)
        ("Keysight Technologies", "*", "MARKER/1/CALCULATE/Y", "GET", ":CALCulate:MARKer1:Y", "?", ""),
        ("Keysight Technologies", "*", "MARKER/2/CALCULATE/Y", "GET", ":CALCulate:MARKer2:Y", "?", ""),
        ("Keysight Technologies", "*", "MARKER/3/CALCULATE/Y", "GET", ":CALCulate:MARKer3:Y", "?", ""),
        ("Keysight Technologies", "*", "MARKER/4/CALCULATE/Y", "GET", ":CALCulate:MARKer4:Y", "?", ""),
        ("Keysight Technologies", "*", "MARKER/5/CALCULATE/Y", "GET", ":CALCulate:MARKer5:Y", "?", ""),
        ("Keysight Technologies", "*", "MARKER/6/CALCULATE/Y", "GET", ":CALCulate:MARKer6:Y", "?", ""),

        # Memory/Preset
        ("Keysight Technologies", "*", "MEMORY/PRESET/CATALOG", "GET", ":MMEMory:CATalog:STATe", "?", ""),
        ("Keysight Technologies", "*", "MEMORY/PRESET/LOAD", "SET", ":MMEMory:LOAD:STATe", "0", ""),
        ("Keysight Technologies", "*", "MEMORY/PRESET/STORE", "SET", ":MMEMory:STORe:STATe", "0", ""),
        
        ("Keysight Technologies", "*", "POWER/RESET", "DO", "SYSTem:POWer:RESet", "", ""),
    ]

#####################################
### File: OPEN-AIR 2\workers\Instrument\visa\tab_instrument_child_visa_interpreter.py
#####################################
# tabs/Instrument/tab_instrument_child_visa_interpreter.py
#
# This file defines the VisaInterpreterTab, a Tkinter Frame that provides a user-editable
# cell editor for VISA commands. It displays model names, command types, actions, and the
# commands themselves, allowing users to modify, add, or remove entries, and execute
# selected commands directly on a connected instrument.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.175600.1
# FIXED: The Treeview now correctly displays all 7 columns of data from the updated file.
#        The cell editing functionality has also been updated to handle these new columns.

import tkinter as tk
from tkinter import ttk
import os
import inspect
from datetime import datetime
import threading
import time

from display.debug_logic import debug_log
from display.console_logic import console_log
from src.program_style import COLOR_PALETTE
from ref.ref_file_paths import VISA_COMMANDS_FILE_PATH
from .utils_visa_interpreter_files import initialize_data_file_and_load, save_visa_commands_data
from .utils_visa_interpreter_commands import VisaCommandExecutor

# --- Versioning ---
w = 20250821
x_str = '175600'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"{w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = f"{os.path.basename(__file__)}"


class VisaInterpreterTab(ttk.Frame):
    """
    VisaInterpreterTab provides a user-friendly interface for executing and managing
    VISA commands. It presents a treeview of commands, allowing for direct editing
    and execution on a connected instrument.
    """
    def __init__(self, parent, app_instance, console_print_func, *args, **kwargs):
        super().__init__(parent, *args, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func
        self.data = []
        self.sort_direction = {}
        self.last_selected_item = None
        
        # Instantiate the new command executor class
        self.command_executor = VisaCommandExecutor(app_instance, console_print_func)
        
        self.create_widgets()
        self.setup_layout()
        self.bind_events()
        
        # Call file utility to handle all file-related logic
        self.data = initialize_data_file_and_load()
        self.load_data_to_treeview()
        self._set_ui_initial_state()

        self.app_instance.bind("<<ConnectionStatusChanged>>", self._handle_connection_status_change_event)
        self._handle_connection_status_change_event()
        
        current_function = inspect.currentframe().f_code.co_name
        debug_log("VisaInterpreterTab initialized. Ready for battle! ⚔️",
                    file=current_file,
                    version=current_version,
                    function=current_function)

    def _set_ui_initial_state(self):
        self.status_label.configure(text="Status: Disconnected", foreground="red")
        self.command_entry.config(state=tk.DISABLED)
        self.execute_command_button.config(state=tk.DISABLED)
        self.query_button.config(state=tk.DISABLED)
        self.set_button.config(state=tk.DISABLED)
        self.do_button.config(state=tk.DISABLED)

    def _handle_connection_status_change_event(self, event=None):
        current_function = inspect.currentframe().f_code.co_name
        is_connected = self.app_instance.inst is not None
        instrument_model = self.app_instance.connected_instrument_model.get() if hasattr(self.app_instance, 'connected_instrument_model') else ""
        
        debug_log(f"Connection status changed event received: Connected={is_connected}, Model={instrument_model}. Updating UI state.",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        
        if is_connected:
            self.status_label.configure(text=f"Status: Connected to {instrument_model}", foreground="green")
            self.command_entry.config(state=tk.NORMAL)
            self.execute_command_button.config(state=tk.NORMAL)
            self.query_button.config(state=tk.NORMAL)
            self.set_button.config(state=tk.NORMAL)
            self.do_button.config(state=tk.NORMAL)
            self.console_print_func(f"✅ VISA Interpreter connected to instrument.")
        else:
            self.status_label.configure(text="Status: Disconnected", foreground="red")
            self.command_entry.config(state=tk.DISABLED)
            self.execute_command_button.config(state=tk.DISABLED)
            self.query_button.config(state=tk.DISABLED)
            self.set_button.config(state=tk.DISABLED)
            self.do_button.config(state=tk.DISABLED)
            self.console_print_func("❌ VISA Interpreter disconnected from instrument.")
    
    def load_data_to_treeview(self):
        """
        Loads data from the internal list into the Treeview widget.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log("Loading data from list to Treeview... 💾",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        
        for item in self.treeview.get_children():
            self.treeview.delete(item)
        
        for row in self.data:
            self.treeview.insert('', 'end', values=row)

        self.console_print_func(f"✅ Loaded {len(self.data)} entries into the table.")
        debug_log(f"Loaded {len(self.data)} entries into Treeview.",
                    file=current_file,
                    version=current_version,
                    function=current_function)

    def create_widgets(self):
        """
        Creates the UI widgets for the VisaInterpreterTab.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log("Creating widgets for VisaInterpreterTab...",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        self.columnconfigure(0, weight=1)
        self.rowconfigure(0, weight=1)
        self.rowconfigure(1, weight=0)

        main_frame = ttk.Frame(self)
        main_frame.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
        main_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(0, weight=1)

        tree_frame = ttk.Frame(main_frame)
        tree_frame.grid(row=0, column=0, sticky="nsew")
        tree_frame.rowconfigure(0, weight=1)
        tree_frame.columnconfigure(0, weight=1)

        # CORRECTED: Updated columns to display all 7 data fields
        columns = ("Manufacturer", "Model", "Command Type", "Action", "VISA Command", "Variable", "Validated")
        self.treeview = ttk.Treeview(tree_frame, columns=columns, show="headings")
        self.treeview.pack(side="left", fill="both", expand=True)

        for col in columns:
            self.treeview.heading(col, text=col, command=lambda c=col: self._sort_treeview(self.treeview, c))
            self.treeview.column(col, anchor="w", width=100)
            self.sort_direction[col] = 'asc'

        scrollbar = ttk.Scrollbar(tree_frame, orient="vertical", command=self.treeview.yview)
        self.treeview.configure(yscrollcommand=scrollbar.set)
        scrollbar.pack(side="right", fill="y")
        
        control_frame = ttk.LabelFrame(self, text="Controls")
        control_frame.grid(row=1, column=0, sticky="ew", padx=10, pady=5)
        control_frame.columnconfigure(1, weight=1)

        self.status_label = ttk.Label(control_frame, text="Status: Disconnected", foreground="red")
        self.status_label.grid(row=0, column=0, columnspan=2, sticky="ew", padx=5, pady=2)

        ttk.Label(control_frame, text="Command:", style='TLabel').grid(row=1, column=0, sticky="w", padx=5, pady=2)
        self.command_entry = ttk.Entry(control_frame)
        self.command_entry.grid(row=1, column=1, sticky="ew", padx=5, pady=2)
        self.command_entry.bind('<Return>', lambda e: self.command_executor.on_execute_command(self.command_entry.get().strip()))

        button_frame = ttk.Frame(control_frame)
        button_frame.grid(row=2, column=0, columnspan=2, sticky="ew", padx=5, pady=5)
        button_frame.columnconfigure(0, weight=1)
        button_frame.columnconfigure(1, weight=1)
        button_frame.columnconfigure(2, weight=1)
        button_frame.columnconfigure(3, weight=1)

        self.execute_command_button = ttk.Button(button_frame, text="Execute", command=lambda: self.command_executor.on_execute_command(self.command_entry.get().strip()))
        self.execute_command_button.grid(row=0, column=0, sticky="ew", padx=2, pady=2)

        self.query_button = ttk.Button(button_frame, text="Query", command=lambda: self.command_executor.on_query_command(self.command_entry.get().strip()))
        self.query_button.grid(row=0, column=1, sticky="ew", padx=2, pady=2)
        
        self.set_button = ttk.Button(button_frame, text="Set", command=lambda: self.command_executor.on_set_command(self.command_entry.get().strip()))
        self.set_button.grid(row=0, column=2, sticky="ew", padx=2, pady=2)
        
        self.do_button = ttk.Button(button_frame, text="Do", command=lambda: self.command_executor.on_do_command(self.command_entry.get().strip()))
        self.do_button.grid(row=0, column=3, sticky="ew", padx=2, pady=2)

        action_frame = ttk.Frame(control_frame)
        action_frame.grid(row=3, column=0, columnspan=2, sticky="ew", padx=5, pady=5)
        action_frame.columnconfigure(0, weight=1)
        action_frame.columnconfigure(1, weight=1)
        action_frame.columnconfigure(2, weight=1)
        action_frame.columnconfigure(3, weight=1)

        ttk.Button(action_frame, text="Load Data", command=lambda: self._refresh_data()).grid(row=0, column=0, sticky="ew", padx=2, pady=2)
        ttk.Button(action_frame, text="Add New Row", command=self._add_new_row).grid(row=0, column=1, sticky="ew", padx=2, pady=2)
        ttk.Button(action_frame, text="Save Data", command=self._save_data_to_csv).grid(row=0, column=2, sticky="ew", padx=2, pady=2)
        ttk.Button(action_frame, text="Delete Row", command=self._delete_selected_row).grid(row=0, column=3, sticky="ew", padx=2, pady=2)
        
        debug_log("Widgets created successfully. All systems go! 🚀",
                    file=current_file,
                    version=current_version,
                    function=current_function)

    def setup_layout(self):
        self.grid_rowconfigure(0, weight=1)
        self.grid_columnconfigure(0, weight=1)

    def bind_events(self):
        self.treeview.bind("<Double-1>", self._on_double_click)
        self.treeview.bind("<<TreeviewSelect>>", self._on_treeview_select)
        self.treeview.bind("<FocusIn>", self._on_treeview_focus)

    def _on_treeview_focus(self, event):
        if not self.treeview.selection():
            if self.last_selected_item:
                self.treeview.selection_set(self.last_selected_item)
                self.treeview.focus(self.last_selected_item)

    def _on_treeview_select(self, event):
        selection = self.treeview.selection()
        if selection:
            self.last_selected_item = selection[0]
            values = self.treeview.item(self.last_selected_item, 'values')
            if values:
                self.command_entry.delete(0, tk.END)
                if len(values) > 4 and values[4] is not None:
                    self.command_entry.insert(0, values[4])

    def _on_double_click(self, event):
        item = self.treeview.identify_row(event.y)
        col = self.treeview.identify_column(event.x)
        if item and col:
            col_index = int(col.replace('#', '')) - 1
            column_name = self.treeview['columns'][col_index]

            # CORRECTED: Allow editing of VISA Command, Variable, and Validated columns
            editable_columns = ["VISA Command", "Variable", "Validated"]
            if column_name in editable_columns:
                self._edit_cell(item, col_index)

    def _edit_cell(self, item, col_index):
        x, y, width, height = self.treeview.bbox(item, col_index)
        
        values = self.treeview.item(item, 'values')
        original_text = values[col_index]

        entry = ttk.Entry(self.treeview)
        entry.place(x=x, y=y, width=width, height=height, anchor='nw')
        entry.insert(0, original_text)
        entry.focus_set()

        def on_entry_change(e):
            new_values = list(self.treeview.item(item, 'values'))
            new_values[col_index] = entry.get()
            self.treeview.item(item, values=new_values)
            entry.destroy()
            self.last_selected_item = item
            self._save_data_to_csv()

        def on_focus_out(e):
            entry.destroy()
            self._save_data_to_csv()

        entry.bind("<Return>", on_entry_change)
        entry.bind("<FocusOut>", on_focus_out)

    def _add_new_row(self):
        """
        Adds a new, empty row to the Treeview and the internal data list.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log("Adding a new empty row to the Treeview. A fresh start!",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        new_row = ["", "", "", "", "", "", ""]
        self.data.append(new_row)
        self.treeview.insert('', 'end', values=new_row)
        self.console_print_func("✅ New row added. Don't forget to save!")
        self._save_data_to_csv()
        debug_log("New row added and saved.",
                    file=current_file,
                    version=current_version,
                    function=current_function)

    def _delete_selected_row(self):
        """
        Deletes the currently selected row from the Treeview and the internal data list.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log("Attempting to delete the selected row. Goodbye, cruel data!",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        selected_item = self.treeview.selection()
        if not selected_item:
            self.console_print_func("❌ No row selected to delete. You must choose!")
            debug_log("Delete failed: No row selected.",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return

        for item in selected_item:
            values = self.treeview.item(item, 'values')
            self.treeview.delete(item)
            if list(values) in self.data:
                self.data.remove(list(values))
            self.console_print_func(f"✅ Row deleted: {values[2]} - {values[3]}")
        
        self._save_data_to_csv()
        debug_log("Row deleted and file saved.",
                    file=current_file,
                    version=current_version,
                    function=current_function)

    def _save_data_to_csv(self):
        """
        Saves the current data from the Treeview back to the CSV file.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log("Saving data to CSV file. Committing the changes to memory!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        
        current_data = [self.treeview.item(item, 'values') for item in self.treeview.get_children()]

        try:
            save_visa_commands_data(VISA_COMMANDS_FILE_PATH, current_data)
            self.console_print_func(f"✅ Saved data to {os.path.basename(VISA_COMMANDS_FILE_PATH)} successfully.")
            debug_log("Data saved successfully.",
                        file=current_file,
                        version=current_version,
                        function=current_function)
        except Exception as e:
            self.console_print_func(f"❌ Error saving data: {e}. Oh no, the data is lost!")
            debug_log(f"Error saving data to CSV: {e}.",
                        file=current_file,
                        version=current_version,
                        function=current_function)

    def _sort_treeview(self, tv, col):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Sorting Treeview by column '{col}'. Let's get this organized! 📚",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        items = list(tv.get_children(''))
        col_index = tv['columns'].index(col)

        is_numeric = False
        if items:
            try:
                float(tv.item(items[0], 'values')[col_index])
                is_numeric = True
            except (ValueError, IndexError):
                is_numeric = False

        direction = self.sort_direction.get(col, 'asc')
        reverse = (direction == 'desc')

        if is_numeric:
            def numeric_sort_key(x):
                try:
                    return float(tv.set(x, col))
                except (ValueError, IndexError):
                    return float('-inf')
            sorted_items = sorted(items, key=numeric_sort_key, reverse=reverse)
        else:
            sorted_items = sorted(items, key=lambda x: tv.set(x, col), reverse=reverse)

        for index, item in enumerate(sorted_items):
            tv.move(item, '', index)

        self.sort_direction[col] = 'asc' if reverse else 'desc'
        
        tv.heading(col, text=f"{col} ({'▲' if not reverse else '▼'})")
        debug_log(f"Treeview sorted by '{col}' in {'descending' if reverse else 'ascending'} order. All tidy now. ✅",
                    file=current_file,
                    version=current_version,
                    function=current_function)

    def _refresh_data(self):
        """Reloads data from the file and updates the treeview."""
        self.data = initialize_data_file_and_load()
        self.load_data_to_treeview()
        self.console_print_func("✅ Data reloaded from file.")
        debug_log("Data reloaded from file.",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)

#####################################
### File: OPEN-AIR 2\workers\Instrument\visa\utils_visa_interpreter_commands.py
#####################################
# Instrument/utils_visa_interpreter_commands.py

# This file contains the core logic for executing and testing VISA commands via the
# VisaInterpreterTab. It abstracts all the low-level command execution, error handling,
# and console logging, allowing the GUI to remain a simple view layer. This module
# ensures the principle of separation of concerns is upheld.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.175300.1
# UPDATED: File created to house all VISA command execution and testing logic.

import inspect
import os
from datetime import datetime
import tkinter as tk

from yak.utils_yak_visa import query_safe, write_safe
from display.debug_logic import debug_log
from display.console_logic import console_log

# --- Versioning ---
w = 20250821
x_str = '175300'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"{w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = f"{os.path.basename(__file__)}"


class VisaCommandExecutor:
    """
    This class handles all execution and testing of VISA commands. It is instantiated
    by the VisaInterpreterTab and is responsible for all communication with the
    connected instrument.
    """
    def __init__(self, app_instance, console_print_func):
        self.app_instance = app_instance
        self.console_print_func = console_print_func

        current_function = inspect.currentframe().f_code.co_name
        debug_log("Initializing VisaCommandExecutor. The command-slinger is ready! 🤠",
                    file=current_file,
                    version=current_version,
                    function=current_function)

    def _get_instrument_status(self):
        """Checks if an instrument is connected and returns the status."""
        is_connected = self.app_instance.inst is not None
        if not is_connected:
            self.console_print_func("❌ No instrument connected. The command is a whisper to the wind!")
            debug_log("Command failed: No instrument connection.",
                        file=current_file,
                        version=current_version,
                        function=inspect.currentframe().f_code.co_name)
        return is_connected

    def on_execute_command(self, command):
        """Executes a command (query or write) based on its format."""
        if not self._get_instrument_status():
            return
        
        self.console_print_func(f"Executing: {command}...")
        
        if command.endswith('?'):
            response = query_safe(self.app_instance.inst, command, self.console_print_func)
            self.console_print_func(f"Response: {response}")
        else:
            write_safe(self.app_instance.inst, command, self.console_print_func)
            self.console_print_func("✅ Command sent.")
    
    def on_query_command(self, command):
        """Executes a query command and displays the response."""
        if not self._get_instrument_status():
            return
        
        if not command.endswith('?'):
            self.console_print_func(f"⚠️ Command '{command}' does not end with '?' for a query. Executing as a simple write.")
            self.on_execute_command(command)
            return

        self.console_print_func(f"Querying: {command}...")
        response = query_safe(self.app_instance.inst, command, self.console_print_func)
        self.console_print_func(f"Response: {response}")

    def on_set_command(self, command):
        """Executes a set command, which requires a value."""
        if not self._get_instrument_status():
            return

        parts = command.split(' ', 1)
        if len(parts) < 2:
            self.console_print_func("❌ SET command requires a value. Format: 'command value'.")
            debug_log("Set failed: Invalid command format.",
                        file=current_file,
                        version=current_version,
                        function=inspect.currentframe().f_code.co_name)
            return
            
        full_command = f"{parts[0]} {parts[1]}"
        self.console_print_func(f"Setting: {full_command}...")
        write_safe(self.app_instance.inst, full_command, self.console_print_func)
        self.console_print_func("✅ Set command sent.")
    
    def on_do_command(self, command):
        """Executes a 'do' command, which performs an action."""
        if not self._get_instrument_status():
            return

        self.console_print_func(f"Executing: {command}...")
        write_safe(self.app_instance.inst, command, self.console_print_func)
        self.console_print_func("✅ Do command sent.")

#####################################
### File: OPEN-AIR 2\workers\Instrument\visa\utils_visa_interpreter_files.py
#####################################
# utils/utils_visa_interpreter_files.py
#
# This file contains all the core logic for handling file I/O operations related to the
# VISA Interpreter Tab. This includes creating the default data file if it doesn't exist,
# loading the data from the file, and saving the data back to it. This module ensures
# that the file handling is a separate, modular concern, as per project standards.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.175500.1
# UPDATED: This file now uses the definitive source of truth for default commands,
#          `ref_visa_commands.py`, and correctly handles the full 7-column data structure.

import os
import csv
import inspect
from datetime import datetime

from display.debug_logic import debug_log
from display.console_logic import console_log
from ref.ref_file_paths import VISA_COMMANDS_FILE_PATH, DATA_FOLDER_PATH
from .ref_visa_commands import get_default_visa_commands

# --- Versioning ---
w = 20250821
x_str = '175500'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"{w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = f"{os.path.basename(__file__)}"


def create_default_data_file(data_file):
    """
    Creates a new CSV file with default VISA command entries from the ref file.

    Inputs:
        data_file (str): The full path to the data file.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Creating default VISA commands CSV file at '{data_file}'. 📝",
                file=current_file,
                version=current_version,
                function=current_function)
    
    # Use the definitive source of truth for headers and data
    default_headers = ["Manufacturer", "Model", "Command Type", "Action", "VISA Command", "Variable", "Validated"]
    default_data = get_default_visa_commands()

    os.makedirs(os.path.dirname(data_file), exist_ok=True)
    with open(data_file, 'w', newline='', encoding='utf-8') as f:
        writer = csv.writer(f)
        writer.writerow(default_headers)
        writer.writerows(default_data)
    console_log(f"✅ Created new default file: {os.path.basename(data_file)}")
    debug_log("Default VISA commands CSV created.",
                file=current_file,
                version=current_version,
                function=current_function)

def load_visa_commands_data(data_file):
    """
    Loads data from the CSV file into a list of lists.
    This function is designed to handle the 7-column data from the `ref` file.

    Inputs:
        data_file (str): The full path to the data file.

    Outputs:
        list: A list of lists representing the CSV data.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log("Loading data from CSV... 💾",
                file=current_file,
                version=current_version,
                function=current_function)
    
    data = []
    try:
        with open(data_file, 'r', newline='', encoding='utf-8') as f:
            reader = csv.reader(f)
            headers = next(reader)
            for row in reader:
                # Ensure the data has the correct number of columns
                if len(row) == 7:
                    data.append(row)
                else:
                    debug_log(f"⚠️ Row has incorrect number of columns: {row}. Skipping.",
                                file=current_file,
                                version=current_version,
                                function=current_function)
        console_log(f"✅ Loaded {len(data)} entries from {os.path.basename(data_file)}.")
        debug_log(f"Loaded {len(data)} entries from CSV.",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return data
    except FileNotFoundError:
        console_log(f"❌ Error: {os.path.basename(data_file)} not found. This is a disaster!")
        debug_log("CSV file not found during load.",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return []
    except Exception as e:
        console_log(f"❌ Error loading data: {e}. This is a disaster!")
        debug_log(f"Error loading CSV data: {e}.",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return []

def save_visa_commands_data(data_file, data):
    """
    Saves the provided data to the CSV file.
    This function is designed to handle the 7-column data.

    Inputs:
        data_file (str): The full path to the data file.
        data (list): A list of lists containing the data to save.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log("Saving data to CSV file. Committing the changes to memory! 💾",
                file=current_file,
                version=current_version,
                function=current_function)
    
    headers = ["Manufacturer", "Model", "Command Type", "Action", "VISA Command", "Variable", "Validated"]
    try:
        with open(data_file, 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerow(headers)
            writer.writerows(data)
        console_log(f"✅ Saved data to {os.path.basename(data_file)} successfully.")
        debug_log("Data saved successfully.",
                    file=current_file,
                    version=current_version,
                    function=current_function)
    except Exception as e:
        console_log(f"❌ Error saving data: {e}. Oh no, the data is lost!")
        debug_log(f"Error saving data to CSV: {e}.",
                    file=current_file,
                    version=current_version,
                    function=current_function)

def initialize_data_file_and_load():
    """
    Ensures the VISA commands CSV file exists, populates it if it doesn't,
    and then loads its content.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log("Initializing data file and loading content... 💾",
                file=current_file,
                version=current_version,
                function=current_function)
    
    data_file_path = VISA_COMMANDS_FILE_PATH
    
    if not os.path.exists(data_file_path):
        console_log(f"ℹ️ {os.path.basename(data_file_path)} not found. Creating a new file with default entries.")
        debug_log(f"File '{os.path.basename(data_file_path)}' not found. Creating new file with defaults.",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        create_default_data_file(data_file_path)
    
    data = load_visa_commands_data(data_file_path)
    debug_log("Data file check and load completed. Ready to go! ✅",
                file=current_file,
                version=current_version,
                function=current_function)
    return data

#####################################
### File: OPEN-AIR 2\workers\Marker_files\tab_markers_child_import_and_edit.py
#####################################
# tabs/Markers/tab_markers_child_import_and_edit.py
#
# This file manages the Report Converter tab in the GUI, handling
# It provides functionality to convert spectrum analyzer report files (HTML, SHW, or Soundbase PDF)
# into CSV format. Crucially, it now displays the converted data in an editable, sortable table
# (Treeview) and allows users to load, save, and save as MARKERS.CSV files directly.
# The previous text-based conversion log has been replaced by this data table.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
#
#
# Version 20250802.0055.1 (Fixed TclError: expected integer but got "" for Treeview rowheight.)
# Version 20250804.000014.0 (FIXED: Ensured MarkersDisplayTab reloads from file when updated by ReportConverterTab.)
# Version 20250804.000015.0 (FIXED: ReportConverterTab now explicitly tells MarkersDisplayTab to load_markers_from_file.)

current_version = "20250804.000015.0" # Incremented version
# current_version_hash = 20250802 * 55 * 1 # Example hash, needs adjustment based on new versioning format

import tkinter as tk
from tkinter import filedialog, ttk
import os
import csv
import xml.etree.ElementTree as ET
import sys
import inspect
import threading
import json 
import datetime 
import re 

# Import the new report converter utility functions
from ..files.utils_marker_report_converter import convert_html_report_to_csv, generate_csv_from_shw, convert_pdf_report_to_csv
from src.gui_elements import TextRedirector 
from display.debug_logic import debug_log 
from display.console_logic import console_log 
# Removed: from tabs.Markers.tab_markers_child_display import load_markers_from_file
# The load_markers_from_file from display tab will be called via the instance.


class ReportConverterTab(ttk.Frame):
    """
    A Tkinter Frame that provides functionality to convert spectrum analyzer
    report files (HTML, SHW, or Soundbase PDF) into CSV format.
    It now also displays the converted data in an editable, sortable table
    and allows loading/saving of MARKERS.CSV files.
    """
    def __init__(self, master=None, app_instance=None, console_print_func=None, **kwargs): # console_print_func will be removed later
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__) 
        debug_log(f"[{current_file} - {current_function}] Initializing ReportConverterTab...",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        # self.console_print_func is removed, using console_log directly

        self.output_csv_path = None # To store the path of the last generated/loaded CSV

        self.tree_headers = [] # Stores current headers of the Treeview
        self.tree_data = []    # Stores current data of the Treeview (list of dicts)
        self.sort_column = None # To keep track of the last sorted column
        self.sort_direction = False # True for ascending, False for descending

        self._create_widgets()


    def _create_widgets(self):
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__) 
        debug_log(f"[{current_file} - {current_function}] Creating ReportConverterTab widgets.",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(0, weight=0) 
        self.grid_rowconfigure(1, weight=1) 
        self.grid_rowconfigure(2, weight=0) 


        load_markers_frame = ttk.LabelFrame(self, text="Load Markers", padding=(5,5,5,5), style='Dark.TLabelframe')
        load_markers_frame.grid(row=0, column=0, padx=5, pady=5, sticky="ew")
        load_markers_frame.grid_columnconfigure(0, weight=1)
        load_markers_frame.grid_columnconfigure(1, weight=1)
        load_markers_frame.grid_columnconfigure(2, weight=1)
        load_markers_frame.grid_columnconfigure(3, weight=1) 

        self.load_csv_button = ttk.Button(load_markers_frame, text="Load CSV Marker Set", command=self._load_markers_file, style='Green.TButton')
        self.load_csv_button.grid(row=0, column=0, padx=2, pady=2, sticky="ew")

        self.load_ias_html_button = ttk.Button(load_markers_frame, text="Load IAS HTML", command=lambda: self._initiate_conversion("HTML"), style='Blue.TButton')
        self.load_ias_html_button.grid(row=0, column=1, padx=2, pady=2, sticky="ew")

        self.load_wwb_shw_button = ttk.Button(load_markers_frame, text="Load WWB.shw", command=lambda: self._initiate_conversion("SHW"), style='Blue.TButton')
        self.load_wwb_shw_button.grid(row=0, column=2, padx=2, pady=2, sticky="ew")

        self.load_sb_pdf_button = ttk.Button(load_markers_frame, text="Load SB PDF", command=lambda: self._initiate_conversion("PDF"), style='Blue.TButton')
        self.load_sb_pdf_button.grid(row=0, column=3, padx=2, pady=2, sticky="ew")


        marker_table_frame = ttk.LabelFrame(self, text="Marker Editor", padding=(5,5,5,5), style='Dark.TLabelframe')
        marker_table_frame.grid(row=1, column=0, padx=5, pady=5, sticky="nsew")
        marker_table_frame.grid_columnconfigure(0, weight=1)
        marker_table_frame.grid_rowconfigure(0, weight=1)

        self.marker_tree = ttk.Treeview(marker_table_frame, show="headings", style="Treeview")
        self.marker_tree.grid(row=0, column=0, sticky="nsew", padx=5, pady=5)

        tree_yscroll = ttk.Scrollbar(marker_table_frame, orient="vertical", command=self.marker_tree.yview)
        tree_yscroll.grid(row=0, column=1, sticky="ns")
        self.marker_tree.configure(yscrollcommand=tree_yscroll.set)

        tree_xscroll = ttk.Scrollbar(marker_table_frame, orient="horizontal", command=self.marker_tree.xview)
        tree_xscroll.grid(row=1, column=0, sticky="ew")
        self.marker_tree.configure(xscrollcommand=tree_xscroll.set)

        self.marker_tree.bind("<Double-1>", self._on_tree_double_click) 
        self.marker_tree.bind("<ButtonRelease-1>", self._on_tree_header_click) 


        self.save_open_air_button = ttk.Button(self, text="Save Markers as Open Air.csv", command=self._save_open_air_csv, style='Orange.TButton')
        self.save_open_air_button.grid(row=2, column=0, padx=5, pady=5, sticky="ew")


    def _populate_marker_tree(self):
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__) 
        debug_log(f"[{current_file} - {current_function}] Populating marker treeview.",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        self.marker_tree.delete(*self.marker_tree.get_children())

        if not self.tree_headers:
            console_log("ℹ️ No headers available to display in Marker Editor table.", function=current_function)
            self.marker_tree["columns"] = ()
            return

        self.marker_tree["columns"] = self.tree_headers
        
        try:
            row_height_str = ttk.Style().lookup("Treeview", "rowheight")
            row_height = int(row_height_str) if row_height_str else 25 
        except (TclError, ValueError):
            row_height = 25 

        for col_name in self.tree_headers:
            self.marker_tree.heading(col_name, text=col_name, anchor="w")
            self.marker_tree.column(col_name, width=row_height * 5, stretch=tk.YES) 

        for i, row_data in enumerate(self.tree_data):
            values = [row_data.get(header, "") for header in self.tree_headers]
            self.marker_tree.insert("", "end", iid=str(i), values=values, tags=('editable',))

        console_log(f"✅ Displayed {len(self.tree_data)} rows in Marker Editor table.", function=current_function)
        debug_log(f"[{current_file} - {current_function}] Marker treeview populated with {len(self.tree_data)} rows.",
                    file=current_file,
                    version=current_version,
                    function=current_function)


    def _on_tree_double_click(self, event):
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__) 
        debug_log(f"[{current_file} - {current_function}] Treeview double-clicked for editing.",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        if not self.marker_tree.identify_region(event.x, event.y) == "cell":
            return 

        column_id = self.marker_tree.identify_column(event.x)
        item_id = self.marker_tree.identify_row(event.y)

        if not item_id or not column_id:
            return

        col_index = int(column_id[1:]) - 1
        if col_index < 0 or col_index >= len(self.tree_headers):
            debug_log(f"[{current_file} - {current_function}] Invalid column index {col_index} for editing.",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return

        current_value = self.marker_tree.item(item_id, 'values')[col_index]

        self._start_editing_cell(item_id, col_index, initial_value=current_value)


    def _start_editing_cell(self, item, col_index, initial_value=""):
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__) 

        for widget in self.marker_tree.winfo_children():
            if isinstance(widget, ttk.Entry) and widget.winfo_name() == "cell_editor":
                widget.destroy()

        entry_editor = ttk.Entry(self.marker_tree, style="Markers.TEntry", name="cell_editor")
        entry_editor.insert(0, initial_value)
        entry_editor.focus_force()

        x, y, width, height = self.marker_tree.bbox(item, self.marker_tree["columns"][col_index])
        entry_editor.place(x=x, y=y, width=width, height=height)

        entry_editor.current_item = item
        entry_editor.current_col_index = col_index

        def on_edit_complete_and_navigate(event, navigate_direction=None):
            new_value = entry_editor.get()
            entry_editor.destroy()

            current_values = list(self.marker_tree.item(item, 'values'))
            current_values[col_index] = new_value
            self.marker_tree.item(item, values=current_values)

            row_idx = int(item) 
            if row_idx < len(self.tree_data):
                self.tree_data[row_idx][self.tree_headers[col_index]] = new_value
                console_log(f"Updated cell: Row {row_idx+1}, Column '{self.tree_headers[col_index]}' to '{new_value}'", function=current_function)
                debug_log(f"[{current_file} - {current_function}] Updated tree_data[{row_idx}]['{self.tree_headers[col_index]}'] to '{new_value}'.",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                
                # Inform MarkersDisplayTab about the change and save
                self._update_markers_display_tab_data()
                self._save_markers_file_internally() 

            else:
                debug_log(f"[{current_file} - {current_function}] Error: Row index {row_idx} out of bounds for self.tree_data.",
                            file=current_file,
                            version=current_version,
                            function=current_function)

            if navigate_direction:
                self._navigate_cells(item, col_index, navigate_direction)

        entry_editor.bind("<Return>", lambda e: on_edit_complete_and_navigate(e, "down"))
        entry_editor.bind("<Tab>", lambda e: on_edit_complete_and_navigate(e, "right"))
        entry_editor.bind("<Shift-Tab>", lambda e: on_edit_complete_and_navigate(e, "left"))
        entry_editor.bind("<Control-Return>", lambda e: on_edit_complete_and_navigate(e, "ctrl_down"))
        entry_editor.bind("<FocusOut>", lambda e: on_edit_complete_and_navigate(e, None)) 
        entry_editor.bind("<Up>", lambda e: on_edit_complete_and_navigate(e, "up"))
        entry_editor.bind("<Down>", lambda e: on_edit_complete_and_navigate(e, "down"))
        entry_editor.bind("<Left>", lambda e: on_edit_complete_and_navigate(e, "left"))
        entry_editor.bind("<Right>", lambda e: on_edit_complete_and_navigate(e, "right"))


    def _navigate_cells(self, current_item, current_col_index, direction):
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__) 
        debug_log(f"[{current_file} - {current_function}] Navigating cells.",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        items = self.marker_tree.get_children()
        num_rows = len(items)
        num_cols = len(self.tree_headers)

        current_row_idx = items.index(current_item) if current_item in items else -1
        
        next_item = None
        next_col_index = -1
        initial_value_for_next_cell = "" 

        if current_row_idx == -1:
            debug_log(f"[{current_file} - {current_function}] Current item not found in tree for navigation.",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return

        if direction == "down":
            next_row_idx = current_row_idx + 1
            next_col_index = current_col_index
            if next_row_idx < num_rows:
                next_item = items[next_row_idx]
        elif direction == "up": 
            next_row_idx = current_row_idx - 1
            next_col_index = current_col_index
            if next_row_idx >= 0:
                next_item = items[next_row_idx]
        elif direction == "right":
            next_col_index = current_col_index + 1
            if next_col_index < num_cols:
                next_item = current_item
            else: 
                next_row_idx = current_row_idx + 1
                if next_row_idx < num_rows:
                    next_item = items[next_row_idx]
                    next_col_index = 0 
        elif direction == "left":
            next_col_index = current_col_index - 1
            if next_col_index >= 0:
                next_item = current_item
            else: 
                next_row_idx = current_row_idx - 1
                if next_row_idx >= 0:
                    next_item = items[next_row_idx]
                    next_col_index = num_cols - 1 
        elif direction == "ctrl_down":
            next_row_idx = current_row_idx + 1
            next_col_index = current_col_index
            if next_row_idx < num_rows:
                next_item = items[next_row_idx]
                prev_cell_value = self.marker_tree.item(current_item, 'values')[current_col_index]
                initial_value_for_next_cell = self._increment_string_with_trailing_digits(prev_cell_value)
            else:
                debug_log(f"[{current_file} - {current_function}] Cannot Ctrl+Enter: No row below.",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return

        if next_item is not None and next_col_index != -1:
            if direction != "ctrl_down":
                try:
                    next_item_values = self.marker_tree.item(next_item, 'values')
                    if 0 <= next_col_index < len(next_item_values):
                        initial_value_for_next_cell = next_item_values[next_col_index]
                    else:
                        debug_log(f"[{current_file} - {current_function}] Next column index {next_col_index} out of bounds for next item values. Setting empty.",
                                    file=current_file,
                                    version=current_version,
                                    function=current_function)
                        initial_value_for_next_cell = "" 
                except Exception as e:
                    debug_log(f"[{current_file} - {current_function}] Error getting initial value for next cell: {e}. Setting empty.",
                                file=current_file,
                                version=current_version,
                                function=current_function)
                    initial_value_for_next_cell = "" 

            self.marker_tree.focus(next_item)
            self.marker_tree.selection_set(next_item)
            self.app_instance.after(10, lambda: self._start_editing_cell(next_item, next_col_index, initial_value_for_next_cell))
        else:
            debug_log(f"[{current_file} - {current_function}] No cell to navigate to in direction: {direction}",
                        file=current_file,
                        version=current_version,
                        function=current_function)


    def _increment_string_with_trailing_digits(self, text):
        match = re.search(r'(\d+)$', text)
        if match:
            num_str = match.group(1)
            num_int = int(num_str)
            incremented_num = num_int + 1
            new_num_str = str(incremented_num).zfill(len(num_str))
            return text[:-len(num_str)] + new_num_str
        return text


    def _on_tree_header_click(self, event):
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__) 
        debug_log(f"[{current_file} - {current_function}] Treeview header clicked for sorting.",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        region = self.marker_tree.identify_region(event.x, event.y)
        if region == "heading":
            column_id = self.marker_tree.identify_column(event.x)
            col_index = int(column_id[1:]) - 1
            if col_index < 0 or col_index >= len(self.tree_headers):
                debug_log(f"[{current_file} - {current_function}] Invalid column index {col_index} for sorting.",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return

            column_name = self.tree_headers[col_index]

            if self.sort_column == column_name:
                self.sort_direction = not self.sort_direction 
            else:
                self.sort_column = column_name
                self.sort_direction = True 

            self._sort_treeview(column_name, self.sort_direction)


    def _sort_treeview(self, column_name, ascending):
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__) 
        debug_log(f"[{current_file} - {current_function}] Sorting treeview by '{column_name}', ascending: {ascending}.",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        def get_sort_key(item):
            value = item.get(column_name, "")
            try:
                return float(value)
            except ValueError:
                return str(value)

        self.tree_data.sort(key=get_sort_key, reverse=not ascending)

        self._populate_marker_tree()
        console_log(f"Sorted by '{column_name}' {'Ascending' if ascending else 'Descending'}.", function=current_function)


    def _load_markers_file(self):
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__) 
        debug_log(f"[{current_file} - {current_function}] Loading MARKERS.CSV file (Load Marker Set button)...",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        initial_dir = os.path.dirname(self.app_instance.MARKERS_FILE_PATH) if self.app_instance and hasattr(self.app_instance, 'MARKERS_FILE_PATH') else os.getcwd()

        file_path = filedialog.askopenfilename(
            title="Load MARKERS.CSV File",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
            initialdir=initial_dir
        )
        if not file_path:
            console_log("ℹ️ Info: Load Marker Set cancelled.", function=current_function)
            return

        self._disable_buttons() 
        try:
            headers = []
            rows = []
            with open(file_path, mode='r', newline='', encoding='utf-8') as csvfile:
                reader = csv.DictReader(csvfile)
                headers = reader.fieldnames
                for row_data in reader:
                    rows.append(row_data)

            if headers and rows:
                self.tree_headers = headers
                self.tree_data = rows
                self.app_instance.after(0, self._populate_marker_tree) 
                self.output_csv_path = file_path 
                console_log(f"✅ Successfully loaded {len(rows)} markers from '{os.path.basename(file_path)}'.", function=current_function)
                debug_log(f"[{current_file} - {current_function}] Loaded {len(rows)} markers from '{file_path}'.",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                
                self._update_markers_display_tab_data()
                self._save_markers_file_internally()
            else:
                console_log("ℹ️ Info: Selected CSV file is empty or has no data.", function=current_function)
                debug_log(f"[{current_file} - {current_function}] Selected CSV file '{file_path}' is empty.",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                self.tree_headers = []
                self.tree_data = []
                self.app_instance.after(0, self._populate_marker_tree) 
        except Exception as e:
            console_log(f"❌ Error loading CSV: {e}", function=current_function)
            debug_log(f"[{current_file} - {current_function}] Error loading CSV from '{file_path}': {e}",
                        file=current_file,
                        version=current_version,
                        function=current_function)
        finally:
            self.app_instance.after(0, self._enable_buttons) 


    def _save_markers_file_internally(self): 
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__) 
        debug_log(f"[{current_file} - {current_function}] Saving current marker data to internal MARKERS.CSV...",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        if not self.tree_data:
            debug_log(f"[{current_file} - {current_function}] No data to save to internal MARKERS.CSV. Creating empty file if headers exist.",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            if self.tree_headers:
                markers_file_path = self.app_instance.MARKERS_FILE_PATH
                output_dir = os.path.dirname(markers_file_path)
                try:
                    os.makedirs(output_dir, exist_ok=True)
                    with open(markers_file_path, 'w', newline='', encoding='utf-8') as csvfile:
                        writer = csv.DictWriter(csvfile, fieldnames=self.tree_headers)
                        writer.writeheader()
                    self.output_csv_path = markers_file_path
                    console_log(f"✅ Auto-saved empty MARKERS.CSV with headers to '{os.path.basename(markers_file_path)}'.", function=current_function)
                    debug_log(f"[{current_file} - {current_function}] Auto-saved empty MARKERS.CSV with headers to '{markers_file_path}'.",
                                file=current_file,
                                version=current_version,
                                function=current_function)
                except Exception as e:
                    console_log(f"❌ Error creating empty internal MARKERS.CSV: {e}", function=current_function)
                    debug_log(f"[{current_file} - {current_function}] Error creating empty internal MARKERS.CSV at '{markers_file_path}': {e}",
                                file=current_file,
                                version=current_version,
                                function=current_function)
            return

        markers_file_path = self.app_instance.MARKERS_FILE_PATH
        output_dir = os.path.dirname(markers_file_path) 

        if not markers_file_path:
            console_log("⚠️ Warning: Internal MARKERS.CSV path not configured. Cannot save automatically.", function=current_function)
            debug_log(f"[{current_file} - {current_function}] Internal MARKERS.CSV path not configured. Cannot save.",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return

        try:
            os.makedirs(output_dir, exist_ok=True) 
            with open(markers_file_path, 'w', newline='', encoding='utf-8') as csvfile:
                writer = csv.DictWriter(csvfile, fieldnames=self.tree_headers)
                writer.writeheader()
                writer.writerows(self.tree_data)
            self.output_csv_path = markers_file_path 
            console_log(f"✅ Auto-saved MARKERS.CSV to '{os.path.basename(markers_file_path)}'.", function=current_function)
            debug_log(f"[{current_file} - {current_function}] Auto-saved MARKERS.CSV to '{markers_file_path}'.",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            
            # --- NEW: Explicitly trigger reload in MarkersDisplayTab after saving ---
            self._update_markers_display_tab_data() # This will now call load_markers_from_file on the display tab
            # --- END NEW ---

        except Exception as e:
            console_log(f"❌ Error auto-saving internal MARKERS.CSV: {e}", function=current_function)
            debug_log(f"[{current_file} - {current_function}] Error auto-saving internal MARKERS.CSV to '{markers_file_path}': {e}",
                        file=current_file,
                        version=current_version,
                        function=current_function)


    def _save_open_air_csv(self):
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__) 
        debug_log(f"[{current_file} - {current_function}] Saving Markers as Open_Air_Markers.csv...",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        if not self.tree_data:
            console_log("ℹ️ Info: No data to save.", function=current_function)
            return

        scan_name = ""
        if self.app_instance and hasattr(self.app_instance, 'scan_name_var'):
            scan_name = self.app_instance.scan_name_var.get().strip()
            if scan_name:
                scan_name = f" - {scan_name}" 

        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M")

        default_filename = f"Open_Air_Markers{scan_name} - {timestamp}.csv"

        initial_dir = os.path.dirname(self.app_instance.MARKERS_FILE_PATH) if self.app_instance and hasattr(self.app_instance, 'MARKERS_FILE_PATH') else os.getcwd()

        file_path = filedialog.asksaveasfilename(
            title="Save Markers as Open Air CSV",
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
            initialdir=initial_dir, 
            initialfile=default_filename
        )
        if not file_path:
            console_log("ℹ️ Info: Save As cancelled.", function=current_function)
            return

        self._disable_buttons() 
        try:
            with open(file_path, 'w', newline='', encoding='utf-8') as csvfile:
                writer = csv.DictWriter(csvfile, fieldnames=self.tree_headers)
                writer.writeheader()
                writer.writerows(self.tree_data)
            console_log(f"✅ Successfully saved markers to '{os.path.basename(file_path)}'.", function=current_function)
            debug_log(f"[{current_file} - {current_function}] Saved markers to '{file_path}'.",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            
            # --- NEW: Explicitly trigger reload in MarkersDisplayTab after saving to a *new* file ---
            # This is important if "Save As" changes the primary MARKERS.CSV
            # If the user saves to a *different* file, the MarkersDisplayTab should still reflect the main MARKERS.CSV
            # So, we should trigger a reload of the *main* MARKERS.CSV.
            self._update_markers_display_tab_data() # This will call load_markers_from_file on the display tab
            # --- END NEW ---

        except Exception as e:
            console_log(f"❌ Error saving markers: {e}", function=current_function)
            debug_log(f"[{current_file} - {current_function}] Error saving markers to '{file_path}': {e}",
                        file=current_file,
                        version=current_version,
                        function=current_function)
        finally:
            self.app_instance.after(0, self._enable_buttons) 


    def _disable_buttons(self):
        self.load_csv_button.config(state=tk.DISABLED)
        self.load_ias_html_button.config(state=tk.DISABLED)
        self.load_wwb_shw_button.config(state=tk.DISABLED)
        self.load_sb_pdf_button.config(state=tk.DISABLED)
        self.save_open_air_button.config(state=tk.DISABLED)


    def _enable_buttons(self):
        self.load_csv_button.config(state=tk.NORMAL)
        self.load_ias_html_button.config(state=tk.NORMAL)
        self.load_wwb_shw_button.config(state=tk.NORMAL)
        self.load_sb_pdf_button.config(state=tk.NORMAL)
        self.save_open_air_button.config(state=tk.NORMAL)


    def _initiate_conversion(self, file_type):
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__) 
        debug_log(f"[{current_file} - {current_function}] Initiating conversion for type: {file_type}.",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        file_types_map = {
            "HTML": [("HTML files", "*.html"), ("All files", "*.*")],
            "SHW": [("SHW files", "*.shw"), ("XML files", "*.xml"), ("All files", "*.*")],
            "PDF": [("PDF files", "*.pdf"), ("All files", "*.*")]
        }
        title_map = {
            "HTML": "Select IAS HTML Report File",
            "SHW": "Select WWB.shw Report File",
            "PDF": "Select Soundbase PDF Report File"
        }

        file_path = filedialog.askopenfilename(
            title=title_map.get(file_type, "Select Report File"),
            filetypes=file_types_map.get(file_type, [("All files", "*.*")])
        )
        if not file_path:
            console_log(f"ℹ️ Info: {file_type} conversion cancelled.", function=current_function)
            return

        self._disable_buttons()
        conversion_thread = threading.Thread(target=self._perform_conversion, args=(file_path, file_type))
        conversion_thread.daemon = True
        conversion_thread.start()


    def _perform_conversion(self, file_path, file_type):
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__) 
        console_log(f"Processing '{os.path.basename(file_path)}'...", function=current_function)
        debug_log(f"[{current_file} - {current_function}] Performing conversion for {file_path} (type: {file_type}) in thread.",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        headers = []
        rows = []
        error_message = None
        # output_csv_path is now handled by _save_markers_file_internally

        try:
            file_name = os.path.basename(file_path)
            # No longer using output_dir from app_instance for MARKERS.CSV operations
            # Instead, ensure the directory for MARKERS_FILE_PATH exists
            markers_dir = os.path.dirname(self.app_instance.MARKERS_FILE_PATH)
            os.makedirs(markers_dir, exist_ok=True)

            if file_type == 'HTML':
                console_log("Detected HTML file. Converting...", function=current_function)
                with open(file_path, 'r', encoding='utf-8') as f:
                    html_content = f.read()
                headers, rows = convert_html_report_to_csv(html_content, console_print_func=console_log) 
            elif file_type == 'SHW':
                console_log("Detected SHW file. Converting...", function=current_function)
                headers, rows = generate_csv_from_shw(file_path, console_print_func=console_log) 
            elif file_type == 'PDF':
                console_log("Detected PDF file. Converting...", function=current_function)
                headers, rows = convert_pdf_report_to_csv(file_path, console_print_func=console_log) 
            else:
                error_message = f"Unsupported file type: {file_type}. This should not happen."
                console_log(f"❌ {error_message}", function=current_function)
                debug_log(f"Unsupported file type: {file_type}",
                            file=current_file,
                            version=current_version,
                            function=current_function)

            if not error_message and headers and rows:
                # Update the Treeview with the new data
                self.tree_headers = headers
                self.tree_data = rows
                self.app_instance.after(0, self._populate_marker_tree) # Update GUI on main thread

                # Call the method on the main App instance to update the Markers Display tab
                self._update_markers_display_tab_data()
                # NEW: Save the converted data to MARKERS.CSV immediately
                self._save_markers_file_internally() 

                console_log(f"\n✅ Successfully converted '{file_name}' and saved to MARKERS.CSV.", function=current_function)
            else:
                error_message = f"No relevant data could be extracted from '{file_name}'. CSV file was not created."
                console_log(f"🚫 {error_message}", function=current_function)

        except FileNotFoundError as e:
            error_message = f"File not found: {e}"
            console_log(f"❌ {error_message}", function=current_function)
        except ET.ParseError as e:
            error_message = f"Error parsing XML (SHW) file: {e}"
            console_log(f"❌ {error_message}", function=current_function)
        except Exception as e:
            error_message = f"An unexpected error occurred during conversion: {e}"
            console_log(f"❌ {error_message}", function=current_function)
        
        finally:
            if error_message:
                debug_log(f"Conversion failed for {file_name}: {error_message}",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                self.app_instance.after(0, lambda: console_log(f"❌ Conversion failed for {file_name}. See Report Converter Log for details.", function=current_function))
            self.app_instance.after(0, self._enable_buttons)


    def _update_markers_display_tab_data(self):
        """
        Function Description:
        This method is called to propagate the current marker data
        from the Report Converter Tab (marker editor) to the Markers Display Tab.
        It finds the MarkersDisplayTab instance and calls its `load_markers_from_file` method.
        This ensures the display tab always reloads from the saved MARKERS.CSV.

        Inputs to this function:
        - None
        """
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__) 
        debug_log(f"[{current_file} - {current_function}] Attempting to tell Markers Display Tab to reload its data from file...",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        if self.app_instance and hasattr(self.app_instance, 'markers_parent_tab') and \
           hasattr(self.app_instance.markers_parent_tab, 'markers_display_tab') and \
           self.app_instance.markers_parent_tab.markers_display_tab is not None:
            try:
                # NEW: Call MarkersDisplayTab's load_markers_from_file() to make it read from disk
                self.app_instance.markers_parent_tab.markers_display_tab.load_markers_from_file()
                console_log("✅ Markers Display Tab signaled to reload data.", function=current_function)
                debug_log(f"[{current_file} - {current_function}] Signaled MarkersDisplayTab to reload its data from file. 🎉",
                            file=current_file,
                            version=current_version,
                            function=current_function)
            except Exception as e:
                console_log(f"❌ Error signaling Markers Display Tab to reload: {e}", function=current_function)
                debug_log(f"[{current_file} - {current_function}] Error signaling MarkersDisplayTab to reload: {e}. Fucking hell, what went wrong now?!",
                            file=current_file,
                            version=current_version,
                            function=current_function)
        else:
            console_log("⚠️ Warning: Markers Display Tab instance not found or accessible in app_instance. Cannot signal reload.", function=current_function)
            debug_log(f"[{current_file} - {current_function}] MarkersDisplayTab instance not found in app_instance. Current app_instance attributes: {dir(self.app_instance)}. This is a goddamn mess!",
                        file=current_file,
                        version=current_version,
                        function=current_function)

    def _on_tab_selected(self, event):
        """
        Callback when this tab is selected. Ensures the marker tree is populated
        if MARKERS.CSV exists in the designated internal data folder.
        """
        current_function = inspect.currentframe().f_code.co_name
        current_file = os.path.basename(__file__) 
        console_log("ReportConverterTab selected. Checking for MARKERS.CSV in internal data folder...", function=current_function)
        debug_log(f"[{current_file} - {current_function}] ReportConverterTab selected. Checking for MARKERS.CSV in internal data folder...",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        markers_file_path = None
        if self.app_instance and hasattr(self.app_instance, 'MARKERS_FILE_PATH'):
            markers_file_path = self.app_instance.MARKERS_FILE_PATH
            debug_log(f"[{current_file} - {current_function}] Attempting to load MARKERS.CSV from configured internal path: {markers_file_path}",
                        file=current_file,
                        version=current_version,
                        function=current_function)
        else:
            console_log("⚠️ Warning: App instance or MARKERS_FILE_PATH not available. Cannot check for MARKERS.CSV.", function=current_function)
            debug_log(f"[{current_file} - {current_function}] App instance or MARKERS_FILE_PATH not available. Cannot check for MARKERS.CSV.",
                        file=current_file,
                        version=current_version,
                        function=current_function)

        if markers_file_path and os.path.exists(markers_file_path):
            debug_log(f"[{current_file} - {current_function}] MARKERS.CSV found at: {markers_file_path}",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            try:
                headers = []
                rows = []
                with open(markers_file_path, mode='r', newline='', encoding='utf-8') as csvfile:
                    reader = csv.DictReader(csvfile)
                    headers = reader.fieldnames
                    for row_data in reader:
                        rows.append(row_data)

                if headers and rows:
                    self.tree_headers = headers
                    self.tree_data = rows
                    self._populate_marker_tree()
                    self.output_csv_path = markers_file_path 
                    console_log(f"✅ Displayed {len(rows)} markers from MARKERS.CSV.", function=current_function)
                else:
                    console_log("ℹ️ Info: The MARKERS.CSV file was found but contains no data.", function=current_function)
                    self.tree_headers = []
                    self.tree_data = []
                    self._populate_marker_tree() 
            except Exception as e:
                console_log(f"❌ Error loading MARKERS.CSV for display: {e}", function=current_function)
                debug_log(f"[{current_file} - {current_function}] Error loading MARKERS.CSV for display: {e}",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                self.tree_headers = []
                self.tree_data = []
                self._populate_marker_tree() 
        else:
            console_log("ℹ️ Info: MARKERS.CSV not found in internal data folder. Table is empty.", function=current_function)
            self.tree_headers = []
            self.tree_data = []
            self._populate_marker_tree()

#####################################
### File: OPEN-AIR 2\workers\Marker_files\utils_file_markers_handling.py
#####################################
# tabs/Markers/utils_markers_file_handling.py
#
# This file contains functions for handling file-related operations, specifically
# for the MARKERS.CSV file. It centralizes the logic for loading, saving, and
# processing marker data.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250814.153000.1

current_version = "20250814.153000.1"
current_version_hash = (20250814 * 153000 * 1)

import os
import inspect
import pandas as pd
import numpy as np

from display.debug_logic import debug_log

def load_and_process_markers(app_instance, console_print_func):
    # [A brief, one-sentence description of the function's purpose.]
    # This is the main orchestrator function that loads the CSV and processes it
    # into the two data structures required by the Showtime tab.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Entering {current_function}. Orchestrating the loading and processing of MARKERS.CSV.",
              file=f"{os.path.basename(__file__)} - {current_version}",
              version=current_version,
              function=current_function)

    df, success, message = load_markers_data(app_instance, console_print_func)
    console_print_func(message)

    if not success or df.empty:
        return {}, {} # Return empty dicts on failure

    # 1. Create the markers_data dictionary (keyed by unique name)
    markers_data_dict = {}
    df['NAME'] = df['NAME'].fillna(pd.Series([f"Unnamed_{i}" for i in range(len(df))]))

    for index, row in df.iterrows():
        unique_name = row['NAME']
        try:
            freq_mhz = float(row.get('FREQ', 0))
        except (ValueError, TypeError):
            freq_mhz = 0
        
        markers_data_dict[unique_name] = {
            'frequency_mhz': freq_mhz,
            'zone': row.get('ZONE', 'Unknown'),
            'group': row.get('GROUP', 'Ungrouped'),
            'device': row.get('DEVICE', ''),
            'peak': row.get('Peak', None)
        }

    # 2. Create the zones dictionary using the helper function
    zones_dict = _group_by_zone_and_group(df)

    debug_log(f"✅ Successfully parsed CSV into {len(markers_data_dict)} devices and {len(zones_dict)} zones.",
              file=f"{os.path.basename(__file__)} - {current_version}",
              version=current_version,
              function=current_function)
              
    return markers_data_dict, zones_dict


def load_markers_data(app_instance, console_print_func):
    # [A brief, one-sentence description of the function's purpose.]
    # Loads marker data from the internal MARKERS.CSV file.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Entering {current_function}. Loading markers data from CSV. Let's see what we've got!",
              file=f"{os.path.basename(__file__)} & {current_version}",
              version=current_version,
              function=current_function)

    markers_data = pd.DataFrame()
    
    if app_instance and hasattr(app_instance, 'MARKERS_FILE_PATH'):
        path = app_instance.MARKERS_FILE_PATH
        debug_log(f"Attempting to load markers from path: {path}",
                  file=f"{os.path.basename(__file__)} & {current_version}",
                  version=current_version,
                  function=current_function)
        if os.path.exists(path):
            try:
                markers_data = pd.read_csv(path)
                return markers_data, True, f"✅ Loaded {len(markers_data)} markers from MARKERS.CSV."
            except pd.errors.EmptyDataError:
                return pd.DataFrame(), False, "⚠️ MARKERS.CSV is empty. No marker data to display."
            except Exception as e:
                return pd.DataFrame(), False, f"❌ Error loading MARKERS.CSV: {e}"
        else:
            return pd.DataFrame(), False, "ℹ️ MARKERS.CSV not found. Please create one."
    
    return pd.DataFrame(), False, "❌ Application instance or file path not available."


def _group_by_zone_and_group(data):
    # [A brief, one-sentence description of the function's purpose.]
    # Groups marker data by zone and then by group.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Entering {current_function}. Grouping marker data by zone and group.",
              file=f"{os.path.basename(__file__)} & {current_version}",
              version=current_version,
              function=current_function)

    if data.empty:
        return {}

    data['GROUP'] = data['GROUP'].fillna('No Group')
    data['ZONE'] = data['ZONE'].fillna('No Zone')

    zones = {}
    for zone, zone_data in data.groupby('ZONE'):
        groups = {group: group_data['NAME'].tolist() for group, group_data in zone_data.groupby('GROUP')}
        
        min_freq = zone_data['FREQ'].min()
        max_freq = zone_data['FREQ'].max()
        if pd.notna(min_freq) and pd.notna(max_freq) and max_freq > min_freq:
            span_hz = (max_freq - min_freq) * 1_000_000 
        else:
            span_hz = 1_000_000 # Default span
        
        groups['span_hz'] = span_hz
        zones[zone] = groups
    
    debug_log(f"✅ Successfully grouped data into {len(zones)} zones.",
              file=f"{os.path.basename(__file__)} & {current_version}",
              version=current_version,
              function=current_function)

    return zones

#####################################
### File: OPEN-AIR 2\workers\Marker_files\utils_marker_report_converter.py
#####################################
# tabs/Markers/report_converter_utils.py
#
# This file contains utility functions for converting various spectrum analyzer
# report formats (HTML, SHW, Soundbase PDF) into a standardized CSV format.
# This version specifically restores the logic from the previously provided
# 'old_report_converter_utils.py' and adapts it to the new logging system.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
# Version 20250815.200000.3 (FIXED: The headers for CSV conversions now include a "Peak" column with a placeholder value to prevent data loss.)

import csv
import subprocess
import sys
import xml.etree.ElementTree as ET
import os
import re
from bs4 import BeautifulSoup
import pdfplumber
import inspect
import numpy as np

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log


def convert_html_report_to_csv(html_content, console_print_func=None):
    """
    Converts the HTML frequency coordination report into a list of dictionaries
    suitable for CSV output, handling multiple zones. This version is based on
    the IAS HTML to CSV.py prototype for accurate extraction.
    All frequencies are converted to MHz for consistency.

    Inputs:
        html_content (str): The full HTML content of the report.
        console_print_func (function, optional): A function to use for printing messages
                                                 to the console. If None, uses standard print.

    Returns:
        tuple: A tuple containing:
               - list: A list of strings representing the CSV headers.
               - list: A list of dictionaries, where each dictionary represents a row
                       in the CSV and keys are column headers.
    """
    _print = console_print_func if console_print_func else print
    current_function = inspect.currentframe().f_code.co_name
    current_file = os.path.basename(__file__) # Get current file name for debug_log

    _print("Starting HTML report conversion...")
    debug_log("Starting HTML report conversion.", file=current_file, function=current_function)

    soup = BeautifulSoup(html_content, 'html.parser')
    
    csv_headers = [
        "ZONE",
        "GROUP",
        "DEVICE",
        "NAME",
        "FREQ",
        "Peak" # NEW: Added Peak header
    ]
    
    data_rows = []

    # Find the main content area within the HTML, based on the IAS prototype.
    main_content_container = None
    
    first_zone_p = soup.find('p', style=lambda value: value and 'font-size: large' in value and 'text-decoration: underline' in value)

    if first_zone_p:
        main_content_container = first_zone_p.find_parent('span')
        _print(f"Found main content container based on first zone paragraph.")
        debug_log(f"Found main content container based on first zone paragraph.", file=current_file, function=current_function)
    
    if not main_content_container:
        main_table = soup.find('table', class_='MainTable')
        if main_table:
            main_table_trs = main_table.find_all('tr')
            if len(main_table_trs) > 1:
                second_tr_td = main_table_trs[1].find('td')
                if second_tr_td:
                    potential_span_wrapper = second_tr_td.find('span')
                    if potential_span_wrapper:
                        main_content_container = potential_span_wrapper
                    else:
                        main_content_container = second_tr_td
                    _print(f"Found main content container based on MainTable structure.")
                    debug_log(f"Found main content container based on MainTable structure.", file=current_file, function=current_function)
    
    if not main_content_container:
        _print("Warning: Could not find the main content container. No data will be extracted.")
        debug_log("Warning: Could not find the main content container. No data will be extracted.", file=current_file, function=current_function)
        return csv_headers, data_rows

    current_zone_type = ""
    # Iterate through the children of the identified main content container
    for element in main_content_container.children:
        if element.name == 'p' and element.get('style') and \
           'font-size: large' in element.get('style') and \
           'text-decoration: underline' in element.get('style'):
            zone_text = element.get_text(strip=True)
            if zone_text.startswith("Zone:"):
                current_zone_type = zone_text.replace("Zone:", "").strip()
                _print(f"Processing Zone: {current_zone_type}")
                debug_log(f"Processing Zone: {current_zone_type}", file=current_file, function=current_function)
        
        elif element.name == 'table' and 'Assignment' in element.get('class', []):
            table = element
            
            device_name_tag = table.find('th')
            current_group_name = device_name_tag.get_text(strip=True) if device_name_tag else ""
            _print(f"  Processing Group: {current_group_name}")
            debug_log(f"Processing Group: {current_group_name}", file=current_file, function=current_function)

            rows_in_table = table.find_all('tr')[1:] # Skip the first row as it contains the <th> (device_name)
            debug_log(f"Found {len(rows_in_table)} rows in current table.", file=current_file, function=current_function)

            for row in rows_in_table:
                data_spans = row.find_all('span')
                
                if data_spans:
                    for data_span in data_spans:
                        cells = data_span.find_all('td')
                        if len(cells) >= 4:
                            band_type = cells[0].get_text(strip=True)
                            
                            channel_frequency_tag = cells[3].find('b')
                            channel_frequency_str = channel_frequency_tag.get_text(strip=True) if channel_frequency_tag else ""

                            channel_name = cells[1].get_text(strip=True)
                            if not channel_name:
                                channel_name = cells[2].get_text(strip=True)
                            
                            # Convert frequency string to MHz
                            freq_mhz = "N/A"
                            try:
                                freq_match = re.search(r'(\d+(\.\d+)?)\s*(kHz|MHz|GHz)', channel_frequency_str, re.IGNORECASE)
                                if freq_match:
                                    value = float(freq_match.group(1))
                                    unit = freq_match.group(3).lower()
                                    if unit == 'mhz':
                                        freq_mhz = value
                                    elif unit == 'ghz':
                                        freq_mhz = value * 1000 # GHz to MHz
                                    elif unit == 'khz':
                                        freq_mhz = value / 1000 # kHz to MHz
                                    debug_log(f"HTML Freq conversion: '{channel_frequency_str}' -> {freq_mhz} MHz", file=current_file, function=current_function)
                                else:
                                    # Fallback if regex doesn't match, assume MHz
                                    freq_mhz = float(channel_frequency_str) # Assume it's already in MHz
                                    _print(f"WARNING (HTML): No unit found for '{channel_frequency_str}'. Assuming MHz.")
                                    debug_log(f"HTML Freq conversion (fallback): '{channel_frequency_str}' -> {freq_mhz} MHz", file=current_file, function=current_function)
                            except ValueError:
                                _print(f"WARNING (HTML): Could not convert frequency '{channel_frequency_str}' to float. Setting to 'Invalid Frequency'.")
                                debug_log(f"HTML Freq conversion error: '{channel_frequency_str}'", file=current_file, function=current_function)
                                freq_mhz = "Invalid Frequency"

                            row_data = {
                                "ZONE": current_zone_type,
                                "GROUP": current_group_name,
                                "DEVICE": band_type,
                                "NAME": channel_name,
                                "FREQ": freq_mhz, # Store in MHz
                                "Peak": np.nan # NEW: Added Peak column
                            }
                            if band_type or channel_frequency_str or channel_name:
                                data_rows.append(row_data)
                                debug_log(f"Added HTML row: {row_data}", file=current_file, function=current_function)
                else:
                    # Process rows that have <td>s directly (e.g., blank rows or specific structures without inner spans)
                    cells = row.find_all('td')
                    if len(cells) >= 4: 
                        band_type = cells[0].get_text(strip=True)
                        channel_frequency_tag = cells[3].find('b')
                        channel_frequency_str = channel_frequency_tag.get_text(strip=True) if channel_frequency_tag else ""
                        
                        channel_name = cells[1].get_text(strip=True)
                        if not channel_name:
                            channel_name = cells[2].get_text(strip=True)

                        # Convert frequency string to MHz
                        freq_mhz = "N/A"
                        try:
                            freq_match = re.search(r'(\d+(?:\.\d+)?)\s*(?:(k|m|g)?hz)?', channel_frequency_str, re.IGNORECASE)
                            if freq_match:
                                value = float(freq_match.group(1))
                                unit_group = freq_match.group(3)
                                if unit_group:
                                    unit = unit_group.lower()
                                    if unit == 'm': # MHz
                                        freq_mhz = value
                                    elif unit == 'g': # GHz
                                        freq_mhz = value * 1000
                                    elif unit == 'k': # kHz
                                        freq_mhz = value / 1000
                                else: # No unit specified, assume MHz
                                    freq_mhz = value
                                debug_log(f"HTML Freq conversion (direct td): '{channel_frequency_str}' -> {freq_mhz} MHz", file=current_file, function=current_function)
                            else:
                                # Fallback if regex doesn't match, assume MHz
                                freq_mhz = float(channel_frequency_str) # Assume it's already in MHz
                                _print(f"WARNING (HTML): No unit found for '{channel_frequency_str}'. Assuming MHz.")
                                debug_log(f"HTML Freq conversion (direct td, fallback): '{channel_frequency_str}' -> {freq_mhz} MHz", file=current_file, function=current_function)
                        except ValueError:
                            _print(f"WARNING (HTML): Could not convert frequency '{channel_frequency_str}' to float. Setting to 'Invalid Frequency'.")
                            debug_log(f"HTML Freq conversion error (direct td): '{channel_frequency_str}'", file=current_file, function=current_function)
                            freq_mhz = "Invalid Frequency"

                        row_data = {
                            "ZONE": current_zone_type,
                            "GROUP": current_group_name,
                            "DEVICE": band_type,
                            "NAME": channel_name,
                            "FREQ": freq_mhz, # Store in MHz
                            "Peak": np.nan # NEW: Added Peak column
                        }
                        if band_type or channel_frequency_str or channel_name:
                            data_rows.append(row_data)
                            debug_log(f"Added HTML row (direct td): {row_data}", file=current_file, function=current_function)
    _print(f"Finished HTML report conversion. Extracted {len(data_rows)} rows.")
    debug_log(f"Finished HTML report conversion. Extracted {len(data_rows)} rows.", file=current_file, function=current_function)
    return csv_headers, data_rows


def generate_csv_from_shw(xml_file_path, console_print_func=None):
    """
    Parses an SHW (XML) file and extracts frequency data, converting it
    into a standardized CSV format. This version is based on the SHOW to CSV.py
    prototype for accurate extraction of ZONE and GROUP.
    All frequencies are converted to MHz for consistency.

    Inputs:
        xml_file_path (str): The full path to the SHW (XML) file.
        console_print_func (function, optional): A function to use for printing messages
                                                 to the console. If None, uses standard print.
    Outputs:
        tuple: A tuple containing:
               - headers (list): A list of strings representing the CSV header row.
               - csv_data (list): A list of dictionaries, where each dictionary
                                  represents a row of data with keys matching the headers.
    Raises:
        FileNotFoundError: If the specified XML file does not exist.
        xml.etree.ElementTree.ParseError: If the XML file is malformed.
        Exception: For other parsing or data extraction errors.
    """
    _print = console_print_func if console_print_func else print
    current_function = inspect.currentframe().f_code.co_name
    current_file = os.path.basename(__file__)

    _print(f"Starting SHW report conversion for '{os.path.basename(xml_file_path)}'...")
    debug_log(f"Starting SHW report conversion for '{os.path.basename(xml_file_path)}'.", file=current_file, function=current_function)

    headers = ["ZONE", "GROUP", "DEVICE", "NAME", "FREQ", "Peak"] # NEW: Added Peak header
    csv_data = []

    try:
        with open(xml_file_path, 'r', encoding='utf-8') as f:
            tree = ET.parse(f)
        root = tree.getroot()
        _print("XML file parsed successfully.")
        debug_log("XML file parsed successfully.", file=current_file, function=current_function)

        # Iterate through 'freq_entry' elements
        for i, freq_entry in enumerate(root.findall('.//freq_entry')):
            if i % 100 == 0: # Print progress every 100 entries
                _print(f"  Processing SHW entry {i}...")
                debug_log(f"Processing SHW entry {i}...", file=current_file, function=current_function)

            # Reverting ZONE and GROUP extraction to match SHOW to CSV.py prototype
            zone_element = freq_entry.find('compat_key/zone')
            zone = zone_element.text if zone_element is not None else "N/A"

            group = freq_entry.get('tag', "N/A") # Extract GROUP from the 'tag' attribute of freq_entry
            
            # Extract DEVICE (manufacturer, model, band)
            manufacturer = freq_entry.find('manufacturer').text if freq_entry.find('manufacturer') is not None else "N/A"
            model = freq_entry.find('model').text if freq_entry.find('model') is not None else "N/A"
            band_element = freq_entry.find('compat_key/band') 
            band = band_element.text if band_element is not None else "N/A"
            device = f"{manufacturer} - {model} - {band}"

            # Extract NAME
            name_element = freq_entry.find('source_name')
            name = name_element.text if name_element is not None else "N/A"

            # Extract FREQ from value. User states SHW files contain markers in KHZ.
            freq_element = freq_entry.find('value')
            freq_mhz = "N/A"
            if freq_element is not None and freq_element.text is not None:
                freq_str = freq_element.text 
                
                debug_log(f"DEBUG (SHW): Processing freq_str: '{freq_str}' for device '{name}'", file=current_file, function=current_function)

                try:
                    # Convert kHz to MHz as per user's clarification
                    freq_mhz = float(freq_str) / 1000.0 
                    debug_log(f"SHW Freq conversion: '{freq_str}' kHz -> {freq_mhz} MHz", file=current_file, function=current_function)
                except ValueError:
                    _print(f"WARNING (SHW): Could not convert SHW frequency value '{freq_str}' to float. Setting to 'Invalid Frequency'.")
                    debug_log(f"SHW Freq conversion error: '{freq_str}'", file=current_file, function=current_function)
                    freq_mhz = "Invalid Frequency"

            csv_data.append({
                "ZONE": zone,
                "GROUP": group,
                "DEVICE": device,
                "NAME": name,
                "FREQ": freq_mhz, # Store in MHz
                "Peak": np.nan # NEW: Added Peak column
            })
        _print(f"Finished SHW report conversion. Extracted {len(csv_data)} rows.")
        debug_log(f"Finished SHW report conversion. Extracted {len(csv_data)} rows.", file=current_file, function=current_function)
        return headers, csv_data

    except FileNotFoundError:
        _print(f"Error: The file '{xml_file_path}' was not found.")
        debug_log(f"Error: The file '{xml_file_path}' was not found.", file=current_file, function=current_function)
        raise FileNotFoundError(f"The file '{xml_file_path}' was not found.")
    except ET.ParseError as e:
        _print(f"Error: Malformed XML (SHW) file '{xml_file_path}': {e}")
        debug_log(f"Error: Malformed XML (SHW) file '{xml_file_path}': {e}", file=current_file, function=current_function)
        raise ET.ParseError(f"Error parsing XML (SHW) file '{xml_file_path}': {e}")
    except Exception as e:
        _print(f"Error during SHW conversion data extraction: {e}")
        debug_log(f"Error during SHW conversion data extraction: {e}", file=current_file, function=current_function)
        raise

def convert_pdf_report_to_csv(pdf_file_path, console_print_func=None):
    """
    Parses a PDF file (Sound Base format) and extracts frequency data, converting it
    into a standardized CSV format. This function maps PDF fields to the MARKERS.CSV
    structure as follows:
    - PDF 'Group' -> CSV 'ZONE'
    - PDF 'Model' -> CSV 'GROUP'
    - PDF 'Name' -> CSV 'NAME'
    - PDF 'Frequency' -> CSV 'FREQ' (in MHz)
    - CSV 'DEVICE' is constructed from PDF 'Model', 'Band', and 'Preset'.

    Inputs:
        pdf_file_path (str): The full path to the PDF file.
        console_print_func (function, optional): A function to use for printing messages
                                                 to the console. If None, uses standard print.
    Outputs:
        tuple: A tuple containing:
               - headers (list): A list of strings representing the CSV header row.
               - csv_data (list): A list of dictionaries, where each dictionary
                                  represents a row of data with keys matching the headers.
    Raises:
        FileNotFoundError: If the specified PDF file does not exist.
        Exception: For other parsing or data extraction errors.
    """
    _print = console_print_func if console_print_func else print
    current_function = inspect.currentframe().f_code.co_name
    current_file = os.path.basename(__file__)

    _print(f"Starting PDF report conversion for '{os.path.basename(pdf_file_path)}'...")
    debug_log(f"Starting PDF report conversion for '{os.path.basename(pdf_file_path)}'.", file=current_file, function=current_function)

    headers = ["ZONE", "GROUP", "DEVICE", "NAME", "FREQ", "Peak"] # NEW: Added Peak header
    csv_data = []

    try:
        with pdfplumber.open(pdf_file_path) as pdf:
            last_known_group = "Uncategorized" # Default group if not found
            _print(f"Opened PDF with {len(pdf.pages)} pages.")
            debug_log(f"Opened PDF with {len(pdf.pages)} pages.", file=current_file, function=current_function)

            for page_num, page in enumerate(pdf.pages):
                _print(f"  Processing Page {page_num + 1}...")
                debug_log(f"Processing Page {page_num + 1}...", file=current_file, function=current_function)
                # Extract text for group headers
                lines = page.extract_text().splitlines()
                lines = [line.strip() for line in lines if line.strip()]

                group_headers = [(i, line) for i, line in enumerate(lines)
                                 if re.match(r".+\(\d+ frequencies\)", line)]

                tables = page.extract_tables()
                debug_log(f"Found {len(tables)} tables on Page {page_num + 1}.", file=current_file, function=current_function)

                group_index = 0
                for table_num, table in enumerate(tables):
                    if group_index < len(group_headers):
                        last_known_group = group_headers[group_index][1]
                        group_index += 1

                    current_zone = last_known_group # PDF Group -> CSV ZONE
                    _print(f"      Processing Table {table_num + 1} for Zone: {current_zone}")
                    debug_log(f"Processing Table {table_num + 1} for Zone: {current_zone}", file=current_file, function=current_function)

                    for row_num, row in enumerate(table):
                        if not row or all(cell is None or cell.strip() == "" for cell in row):
                            continue

                        if "Model" in row[0] and "Frequency" in row[-1]: # Skip header rows
                            debug_log(f"Skipping header row: {row}", file=current_file, function=current_function)
                            continue

                        clean_row = [cell.replace("\n", " ").strip() if cell else "" for cell in row]
                        # Ensure row has at least 6 elements to unpack safely
                        while len(clean_row) < 6:
                            clean_row.append("")

                        model_pdf, band_pdf, name_pdf, preset_pdf, spacing_pdf, frequency_pdf_str = clean_row

                        if model_pdf.strip() == current_zone.strip(): # Skip rows that mistakenly repeat the group name
                            debug_log(f"Skipping duplicate group name row: {row}", file=current_file, function=current_function)
                            continue

                        # Map PDF fields to CSV fields
                        zone_csv = current_zone
                        group_csv = model_pdf # PDF Model -> CSV GROUP

                        # Construct DEVICE from PDF Model, Band, Preset
                        device_csv = f"{model_pdf}"
                        if band_pdf:
                            device_csv += f" - {band_pdf}"
                        if preset_pdf:
                            device_csv += f" - {preset_pdf}"
                        
                        name_csv = name_pdf # PDF Name -> CSV NAME

                        freq_mhz_csv = "N/A"
                        try:
                            # The frequency is already in MHz, so no conversion needed
                            freq_mhz_csv = float(frequency_pdf_str)
                            debug_log(f"PDF Freq conversion: '{frequency_pdf_str}' -> {freq_mhz_csv} MHz", file=current_file, function=current_function)
                        except ValueError:
                            _print(f"WARNING (PDF): Could not convert PDF frequency value '{frequency_pdf_str}' to float (MHz). Setting to 'Invalid Frequency'.")
                            debug_log(f"PDF Freq conversion error: '{frequency_pdf_str}'", file=current_file, function=current_function)
                            freq_mhz_csv = "Invalid Frequency"

                        csv_data.append({
                            "ZONE": zone_csv,
                            "GROUP": group_csv,
                            "DEVICE": device_csv,
                            "NAME": name_csv,
                            "FREQ": freq_mhz_csv,
                            "Peak": np.nan # NEW: Added Peak column
                        })
                        debug_log(f"Added PDF row: {csv_data[-1]}", file=current_file, function=current_function)
        _print(f"Finished PDF report conversion. Extracted {len(csv_data)} rows.")
        debug_log(f"Finished PDF report conversion. Extracted {len(csv_data)} rows.", file=current_file, function=current_function)
        return headers, csv_data

    except FileNotFoundError:
        _print(f"Error: The file '{pdf_file_path}' was not found.")
        debug_log(f"Error: The file '{pdf_file_path}' was not found.", file=current_file, function=current_function)
        raise FileNotFoundError(f"The file '{pdf_file_path}' was not found.")
    except Exception as e:
        _print(f"Error during PDF conversion data extraction: {e}")
        debug_log(f"Error during PDF conversion data extraction: {e}", file=current_file, function=current_function)
        raise


#####################################
### File: OPEN-AIR 2\workers\orchestrator\display_child_orchestrator_tasks.py
#####################################
# display/display_child_orchestrator_tasks.py
#
# This file defines the Orchestrator Tasks tab, a GUI component that displays the
# real-time status of the main application orchestrator and logs check-in events from
# various modules.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250814.113500.1

current_version = "20250814.113500.1"
current_version_hash = (20250814 * 113500 * 1)

import tkinter as tk
from tkinter import ttk
from datetime import datetime
import os
import inspect

from display.debug_logic import debug_log
from display.console_logic import console_log
# REMOVED: Unnecessary import that caused a circular dependency.
# from src.program_style import ProgramStyle

class OrchestratorTasksTab(ttk.Frame):
    def __init__(self, parent, app_instance, *args, **kwargs):
        # Initializes the Orchestrator Tasks tab GUI elements.
        super().__init__(parent, *args, **kwargs)
        self.app_instance = app_instance
        self.parent = parent
        
        self.grid(row=0, column=0, sticky="nsew")
        self.grid_rowconfigure(1, weight=1)
        self.grid_columnconfigure(0, weight=1)

        self._create_widgets()

    def _create_widgets(self):
        # Creates and arranges the widgets within the tab frame.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function_name}", file=f"{__name__}", version=current_version, function=current_function_name)

        try:
            # --- Status Display Frame ---
            status_frame = ttk.Frame(self, style='Dark.TFrame')
            status_frame.grid(row=0, column=0, sticky="ew", padx=10, pady=5)
            status_frame.grid_columnconfigure(1, weight=1)

            ttk.Label(status_frame, text="Orchestrator Status:", style='Header3.TLabel').grid(row=0, column=0, sticky="w")
            
            self.status_var = tk.StringVar(value="STOPPED")
            self.status_label = ttk.Label(status_frame, textvariable=self.status_var, style='Status.Stopped.TLabel')
            self.status_label.grid(row=0, column=1, sticky="w", padx=5)

            # --- Log Table Frame ---
            log_frame = ttk.Frame(self)
            log_frame.grid(row=1, column=0, sticky="nsew", padx=10, pady=(0, 10))
            log_frame.grid_rowconfigure(0, weight=1)
            log_frame.grid_columnconfigure(0, weight=1)

            # --- Treeview for Logging ---
            columns = ("timestamp", "source", "event")
            self.log_tree = ttk.Treeview(log_frame, columns=columns, show="headings", style="Custom.Treeview")
            
            self.log_tree.heading("timestamp", text="Timestamp")
            self.log_tree.heading("source", text="Source Module")
            self.log_tree.heading("event", text="Event")

            self.log_tree.column("timestamp", width=160, anchor='w')
            self.log_tree.column("source", width=250, anchor='w')
            self.log_tree.column("event", width=300, anchor='w')

            # --- Scrollbar ---
            scrollbar = ttk.Scrollbar(log_frame, orient="vertical", command=self.log_tree.yview)
            self.log_tree.configure(yscrollcommand=scrollbar.set)

            self.log_tree.grid(row=0, column=0, sticky="nsew")
            scrollbar.grid(row=0, column=1, sticky="ns")

            console_log("✅ Celebration of success! Orchestrator Tasks tab created.")

        except Exception as e:
            console_log(f"❌ Error in _create_widgets for orchestrator tab: {e}")
            debug_log(f"The orchestrator display tab has imploded! The error be: {e}",
                      file=f"{__name__}", version=current_version, function=current_function_name)

    def log_event(self, source="Unknown", event="Status Checked"):
        # Adds a new entry to the log table.
        try:
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
            values = (timestamp, os.path.basename(source).replace('.py', ''), event)
            
            self.log_tree.insert("", tk.END, values=values)
            self.log_tree.yview_moveto(1)

        except Exception as e:
            print(f"ERROR: Failed to log event to orchestrator tasks tab: {e}")

    def update_status_display(self, is_running, is_paused):
        # Updates the status label based on the orchestrator's state.
        try:
            if is_running and not is_paused:
                self.status_var.set("RUNNING")
                self.status_label.config(style='Status.Running.TLabel')
            elif is_running and is_paused:
                self.status_var.set("PAUSED")
                self.status_label.config(style='Status.Paused.TLabel')
            else:
                self.status_var.set("STOPPED")
                self.status_label.config(style='Status.Stopped.TLabel')
        
        except Exception as e:
            console_log(f"❌ Error in update_status_display for orchestrator tab: {e}")

#####################################
### File: OPEN-AIR 2\workers\orchestrator\orchestrator_gui.py
#####################################
# orchestrator/orchestrator_gui.py
#
# This file defines the GUI for the main application orchestrator,
# providing the user with Start, Stop, and Pause controls.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250814.095000.2
# FIX: Restructured the layout to use a proportional grid for buttons.
# FIX: The button styling now correctly references predefined styles from program_style.py.

current_version = "20250814.095000.2"
current_version_hash = (20250814 * 95000 * 2)

import tkinter as tk
from tkinter import ttk
import inspect
import os

from display.console_logic import console_log
from display.debug_logic import debug_log
# REMOVED incorrect import: from orchestrator.orchestrator_logic import toggle_pause_resume, stop_logic

class OrchestratorGUI(ttk.Frame):
    def __init__(self, parent, app_instance, orchestrator_logic, *args, **kwargs):
        super().__init__(parent, *args, **kwargs)
        self.app_instance = app_instance
        self.orchestrator = orchestrator_logic
        self.grid(row=0, column=0, sticky="ew")
        self._create_widgets()

    def _create_widgets(self):
        # Creates and arranges the widgets for the orchestrator control bar.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function_name}", file=f"{__name__}", version=current_version, function=current_function_name)
        try:
            self.grid_columnconfigure(0, weight=1) # Spacer column to the left
            self.grid_columnconfigure(1, weight=1)
            self.grid_columnconfigure(2, weight=1)
            self.grid_columnconfigure(3, weight=1)
            self.grid_columnconfigure(4, weight=1) # Spacer column to the right
            self.grid_columnconfigure(5, weight=1)
            
            # --- Button Definitions ---
            self.start_button = ttk.Button(self, text="Start", command=self.orchestrator.start_orchestrator, style='Start.TButton')
            self.pause_button = ttk.Button(self, text="Pause", command=self.orchestrator.toggle_pause, style='PauseScan.TButton', state=tk.DISABLED)
            self.stop_button = ttk.Button(self, text="Stop", command=self.orchestrator.stop_orchestrator, style='StopScan.TButton', state=tk.DISABLED)

            # --- Grid Layout ---
            self.start_button.grid(row=0, column=1, padx=(10, 2), pady=10, sticky="ew")
            self.pause_button.grid(row=0, column=2, padx=2, pady=10, sticky="ew")
            self.stop_button.grid(row=0, column=3, padx=(2, 10), pady=10, sticky="ew")

            console_log("✅ Celebration of success! Orchestrator GUI created.")
        except Exception as e:
            console_log(f"❌ Error in _create_widgets for orchestrator GUI: {e}")
            debug_log(f"The GUI has gone rogue! The error be: {e}", file=f"{__name__}", version=current_version, function=current_function_name)

    def update_button_states(self):
        # Updates the enabled/disabled state of the control buttons based on the orchestrator's status.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function_name} with state is_running={self.orchestrator.is_running}, is_paused={self.orchestrator.is_paused}",
                  file=f"{__name__}", version=current_version, function=current_function_name)
        try:
            if self.orchestrator.is_running:
                self.start_button.config(state=tk.DISABLED, style='Disabled.TButton')
                self.pause_button.config(state=tk.NORMAL)
                self.stop_button.config(state=tk.NORMAL, style='StopScan.TButton')
                
                # Use a different style for Resume
                if self.orchestrator.is_paused:
                    self.pause_button.config(text="Resume", style='ResumeScan.Blink.TButton')
                else:
                    self.pause_button.config(text="Pause", style='PauseScan.TButton')

            else:
                self.start_button.config(state=tk.NORMAL, style='StartScan.TButton')
                self.pause_button.config(state=tk.DISABLED, text="Pause", style='Disabled.TButton')
                self.stop_button.config(state=tk.DISABLED, style='Disabled.TButton')

            console_log("✅ Orchestrator button states updated.")
        except Exception as e:
            console_log(f"❌ Error in update_button_states: {e}")
            debug_log(f"The buttons are rebelling! A mutiny! The error be: {e}",
                      file=f"{__name__}", version=current_version, function=current_function_name)

#####################################
### File: OPEN-AIR 2\workers\orchestrator\orchestrator_logic.py
#####################################
# FolderName/orchestrator_logic.py
#
# This file contains the core logic for the application's orchestrator,
# managing the main operational state (running, paused, stopped).
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250814.121000.2

current_version = "20250814.121000.2"
current_version_hash = (20250814 * 121000 * 2)

import inspect
import os
from display.console_logic import console_log
from display.debug_logic import debug_log

class OrchestratorLogic:
    def __init__(self, app_instance, gui):
        self.app_instance = app_instance
        self.gui = gui
        self.is_running = False
        self.is_paused = False

    def get_status(self):
        # A brief, one-sentence description of the function's purpose.
        # Returns the current status of the orchestrator.
        return {
            "is_running": self.is_running,
            "is_paused": self.is_paused
        }

    def start_orchestrator(self):
        # Starts the main application orchestrator.
        if self.is_running:
            console_log("✅ Orchestrator is already running.")
            return

        self.is_running = True
        self.is_paused = False
        self.gui.update_button_states()
        console_log("✅ Orchestrator started. The symphony begins! 🎶")
        
        if self.app_instance.orchestrator_tasks_tab:
            self.app_instance.orchestrator_tasks_tab.update_status_display(self.is_running, self.is_paused)
            self.log_task_event(source_file=__file__, event="Orchestrator Started")

    def stop_orchestrator(self):
        # Stops the main application orchestrator.
        if not self.is_running:
            console_log("✅ Orchestrator is already stopped.")
            return

        self.is_running = False
        self.gui.update_button_states()
        console_log("✅ Orchestrator stopped. The music fades... 🤫")
        
        if self.app_instance.orchestrator_tasks_tab:
            self.app_instance.orchestrator_tasks_tab.update_status_display(self.is_running, self.is_paused)
            self.log_task_event(source_file=__file__, event="Orchestrator Stopped")

    def toggle_pause(self):
        # Toggles the paused state of the orchestrator.
        if not self.is_running:
            console_log("ℹ️ Cannot pause, orchestrator is not running.")
            return

        self.is_paused = not self.is_paused
        self.gui.update_button_states()
        state = "paused" if self.is_paused else "resumed"
        console_log(f"✅ Orchestrator {state}. A brief intermission. ⏸️")

        if self.app_instance.orchestrator_tasks_tab:
            self.app_instance.orchestrator_tasks_tab.update_status_display(self.is_running, self.is_paused)
            self.log_task_event(source_file=__file__, event=f"Orchestrator {state.capitalize()}")

    def log_check_in(self, source_file):
        # Allows other modules to log that they have checked the orchestrator status.
        self.log_task_event(source_file=source_file, event="Checked In")

    def log_task_event(self, source_file, event):
        # [A brief, one-sentence description of the function's purpose.]
        # Logs a specific event from a source module to the orchestrator tasks tab.
        try:
            if self.app_instance.orchestrator_tasks_tab:
                self.app_instance.orchestrator_tasks_tab.log_event(source=source_file, event=event)
        except Exception as e:
            # Avoid a logging loop by printing directly
            print(f"ERROR: Could not log task event from {source_file}: {e}")

#####################################
### File: OPEN-AIR 2\workers\Plotting\TAB_PLOTTING_PARENT.py
#####################################
# Plotting/TAB_PLOTTING_PARENT.py
#
# Version 20250821.222500.1 (Refactored for print statements)

import tkinter as tk
from tkinter import ttk
import inspect

from .tab_plotting_child_Single import PlottingTab
from .tab_plotting_child_average import AveragingTab
from .tab_plotting_child_3D import Plotting3DTab

current_version = "20250821.222500.1"

class TAB_PLOTTING_PARENT(ttk.Frame):
    def __init__(self, parent, app_instance):
        super().__init__(parent)
        self.app_instance = app_instance
        self._create_widgets()

    def _create_widgets(self):
        self.child_notebook = ttk.Notebook(self, style='Plotting.Child.TNotebook')
        self.child_notebook.pack(expand=True, fill="both", padx=5, pady=5)
        self.single_scan_plotting_tab = PlottingTab(self.child_notebook, self.app_instance)
        self.child_notebook.add(self.single_scan_plotting_tab, text="Single Scan Plotting")
        self.averaging_tab = AveragingTab(self.child_notebook, self.app_instance)
        self.child_notebook.add(self.averaging_tab, text="Averaging from Folder")
        self.three_d_plotting_tab = Plotting3DTab(self.child_notebook, self.app_instance)
        self.child_notebook.add(self.three_d_plotting_tab, text="3D Scans Over Time")
        self.child_notebook.bind("<<NotebookTabChanged>>", self._on_child_tab_selected)

    def _on_child_tab_selected(self, event):
        selected_tab_id = self.child_notebook.select()
        if selected_tab_id:
            widget = self.child_notebook.nametowidget(selected_tab_id)
            if hasattr(widget, '_on_tab_selected'):
                widget._on_tab_selected(event)

    def _on_parent_tab_selected(self, event):
        print(f"Plotting Parent tab selected.")
        selected_tab_id = self.child_notebook.select()
        if selected_tab_id:
            widget = self.child_notebook.nametowidget(selected_tab_id)
            if hasattr(widget, '_on_tab_selected'):
                widget._on_tab_selected(event)

#####################################
### File: OPEN-AIR 2\workers\Plotting\tab_plotting_child_3D.py
#####################################
# tabs/Plotting/tab_plotting_child_3D.py
#
# This file defines a Tkinter Frame for generating 3D plots of scans over time.
# It includes functionality for selecting a folder, identifying series of scans,
# and generating the interactive 3D plot.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250801.2250.1 (Refactored debug_print to use debug_log and console_log.)

current_version = "20250801.2250.1" # this variable should always be defined below the header to make the debugging better
current_version_hash = 20250801 * 2250 * 1 # Example hash, adjust as needed

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import os
import pandas as pd
import inspect
import webbrowser # For opening HTML plot in browser
import re # Added for regex in file grouping
import platform # For opening folder cross-platform
import glob # For finding files with specific patterns
from datetime import datetime # Import datetime for timestamping plots
import numpy as np # Added for PSD calculation

# CORRECTED: Import plotting functions and _open_plot_in_browser directly from utils.plotting_utils
from .utils_plotting_scans_over_time import plot_Scans_over_time

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log


class Plotting3DTab(ttk.Frame):
    """
    A Tkinter Frame that provides functionality for generating 3D plots of scans over time.
    """
    def __init__(self, master=None, app_instance=None, console_print_func=None, **kwargs):
        """
        Initializes the Plotting3DTab.

        Inputs:
            master (tk.Widget): The parent widget.
            app_instance (App): The main application instance, used for accessing
                                shared state like collected_scans_dataframes and output directory.
            console_print_func (function): Function to print messages to the GUI console.
            **kwargs: Arbitrary keyword arguments for Tkinter Frame.
        """
        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func if console_print_func else console_log # Use provided func or console_log
        self.last_opened_folder = None # To remember the last opened folder for 3D plotting
        self.grouped_csv_files = {} # Dictionary to store grouped CSV files for 3D plotting
        self.selected_group_prefix = None # Stores the prefix of the currently selected group for 3D plotting

        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        self._create_widgets()
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

    def _create_widgets(self):
        """
        Function Description:
        Creates and arranges all the widgets for the Plotting3DTab.

        Inputs to this function:
            None.

        Process of this function:
            1. Creates the main LabelFrame for "3D Scans Over Time Plotting".
            2. Adds a button to open a folder for 3D plotting.
            3. Creates a LabelFrame to display discovered series of scans with dynamic buttons.
            4. Adds an entry and label for Amplitude Threshold.
            5. Adds a button for generating the 3D plot.
            6. Configures grid weights for responsive layout.

        Outputs of this function:
            None. Populates the tab with GUI elements.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        # --- 3D Scans Over Time Plotting Section ---
        self.plot_3d_frame = ttk.LabelFrame(self, text="3D Scans Over Time Plotting", padding="10")
        self.plot_3d_frame.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")

        # Open Folder for 3D Plotting Button
        self.open_folder_3d_button = ttk.Button(self.plot_3d_frame, text="Open Folder for 3D Plotting", command=self._open_folder_for_3d_plotting)
        self.open_folder_3d_button.grid(row=0, column=0, columnspan=2, padx=5, pady=5, sticky="ew")

        # Discovered Series of Scans Frame for 3D plots
        self.discovered_series_3d_frame = ttk.LabelFrame(self.plot_3d_frame, text="Discovered Series of Scans (for 3D)", padding="10")
        self.discovered_series_3d_frame.grid(row=1, column=0, columnspan=2, padx=5, pady=5, sticky="nsew")
        self.dynamic_3d_buttons_frame = ttk.Frame(self.discovered_series_3d_frame) # This frame will hold dynamically created buttons.
        self.dynamic_3d_buttons_frame.pack(fill="both", expand=True) # Use pack for dynamic buttons within this frame

        # Amplitude Threshold
        amplitude_threshold_frame = ttk.Frame(self.plot_3d_frame)
        amplitude_threshold_frame.grid(row=2, column=0, columnspan=2, padx=5, pady=5, sticky="ew")
        amplitude_threshold_frame.grid_columnconfigure(1, weight=1) # Make entry expand

        ttk.Label(amplitude_threshold_frame, text="Amplitude Threshold (dBm):", style='TLabel').grid(row=0, column=0, padx=5, pady=2, sticky="w")
        self.amplitude_threshold_var = tk.DoubleVar(self, value=-80.0) # Default threshold
        ttk.Entry(amplitude_threshold_frame, textvariable=self.amplitude_threshold_var, style='TEntry').grid(row=0, column=1, padx=5, pady=2, sticky="ew")

        # Generate 3D Plot Button
        self.generate_plot_scans_over_time_button = ttk.Button(self.plot_3d_frame, text="Generate 3D Plot of Scans Over Time", command=self._generate_plot_scans_over_time)
        self.generate_plot_scans_over_time_button.grid(row=3, column=0, columnspan=2, padx=5, pady=5, sticky="ew")
        self.generate_plot_scans_over_time_button.config(state=tk.DISABLED) # Disable until group is selected


        # Configure column weights for resizing
        self.grid_columnconfigure(0, weight=1)
        self.plot_3d_frame.grid_columnconfigure(0, weight=1)
        self.plot_3d_frame.grid_columnconfigure(1, weight=1)
        self.discovered_series_3d_frame.grid_columnconfigure(0, weight=1)
        self.dynamic_3d_buttons_frame.grid_columnconfigure(0, weight=1) # Ensure dynamic buttons expand

        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

    def _open_folder_for_3d_plotting(self):
        """
        Function Description:
        Opens a file dialog to allow the user to select a folder containing CSV files for 3D plotting.
        Upon selection, it calls `_find_and_group_csv_files_3d` and enables relevant buttons.

        Inputs to this function:
            None.

        Process of this function:
            1. Opens a directory selection dialog, defaulting to the last opened folder.
            2. If a folder is selected, stores it as `self.last_opened_folder`.
            3. Calls `_find_and_group_csv_files_3d` to process the CSVs in the selected folder.
            4. Enables the 3D plotting button if groups are found.
            5. If no folder is selected, disables the button.

        Outputs of this function:
            None. Updates GUI state and initiates file grouping.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        folder_path = filedialog.askdirectory(initialdir=self.last_opened_folder)
        debug_log(f"Selected folder_path for 3D plotting: {folder_path}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        if folder_path:
            self.last_opened_folder = folder_path
            self.console_print_func(f"Selected folder for 3D plotting: {folder_path}")
            self._find_and_group_csv_files_3d(folder_path)
            # Enable 3D plotting button if groups are found
            if self.grouped_csv_files: # Only enable if groups were successfully found
                self.generate_plot_scans_over_time_button.config(state=tk.NORMAL)
                debug_log("3D plotting button enabled (folder selected and groups found).",
                            file=__file__,
                            version=current_version,
                            function=current_function)
            else:
                self.generate_plot_scans_over_time_button.config(state=tk.DISABLED)
                debug_log("3D plotting button disabled (no groups found in folder).",
                            file=__file__,
                            version=current_version,
                            function=current_function)
        else:
            self.console_print_func("Folder selection cancelled for 3D plotting.")
            self.generate_plot_scans_over_time_button.config(state=tk.DISABLED)
            debug_log("Folder selection cancelled. 3D plotting button disabled.",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    def _find_and_group_csv_files_3d(self, folder_path):
        """
        Function Description:
        Scans the selected folder for CSV files and groups them based on a common naming prefix
        for 3D plotting. It then creates dynamic buttons for each identified group.

        Inputs to this function:
            folder_path (str): The path to the folder containing CSV files.

        Process of this function:
            1. Lists all CSV files in the given `folder_path`.
            2. If no CSVs are found, clears dynamic buttons and returns.
            3. Iterates through each CSV, attempting to extract a common prefix using regex.
               The regex is designed to be flexible, looking for a pattern before RBW/HOLD/timestamp.
            4. Stores files in `file_groups` dictionary, where keys are prefixes and values are lists of file paths.
            5. Clears any existing dynamic group selection buttons.
            6. Creates a new `ttk.Button` for each identified group, allowing the user to select it.
            7. Configures button styles.

        Outputs of this function:
            None. Populates `self.grouped_csv_files` and updates the GUI with group selection buttons.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function} with folder_path: {folder_path}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        csv_files = [f for f in os.listdir(folder_path) if f.endswith('.csv')]
        debug_log(f"Found CSV files for 3D plotting: {csv_files}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        if not csv_files:
            self.console_print_func("No CSV files found in the selected folder for 3D plotting. FUCK! Where did they go?!")
            self._clear_dynamic_3d_buttons()
            self.grouped_csv_files = {} # Clear groups if no files
            debug_log(f"Exiting {current_function} (no CSVs)",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        file_groups = {}
        for filename in csv_files:
            base_name = os.path.splitext(filename)[0]
            # Updated regex for grouping: be more flexible with the ending part before date/time
            # It tries to capture the main prefix before any RBW/HOLD/timestamp.
            match = re.match(r"([^\d_ -]+(?:[_ -][^\d_ -]+)*?)_RBW\d+K?_HOLD\d+.*", base_name)
            prefix = base_name # Default to full base name if no clear pattern
            if match:
                prefix = match.group(1).strip() # Get the part before RBW/HOLD
                # Refine prefix: remove trailing underscores/hyphens if they were part of the non-digit group
                prefix = re.sub(r"[_ -]+$", "", prefix)
            else:
                # Fallback if the more specific pattern doesn't match (e.g., for INTERMOD.csv or simpler names)
                # Try to split by common delimiters if no complex pattern is found
                if '_' in base_name:
                    prefix = base_name.split('_')[0]
                elif '-' in base_name:
                    prefix = base_name.split('-')[0]
                else:
                    prefix = base_name # Use full name if no common delimiters

            if not prefix: # Ensure prefix is not empty
                prefix = base_name # Fallback to full base name

            if prefix not in file_groups:
                file_groups[prefix] = []
            file_groups[prefix].append(os.path.join(folder_path, filename))
        debug_log(f"Grouped CSV files for 3D plotting: {file_groups}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        self._clear_dynamic_3d_buttons() # Clear any previous buttons

        if not file_groups:
            self.console_print_func("No identifiable groups of CSV files found for 3D plotting. This is a bloody mess!")
            self.grouped_csv_files = {} # Clear groups if no files
            debug_log(f"Exiting {current_function} (no file groups)",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        self.console_print_func(f"Found {len(file_groups)} groups of similar CSV files for 3D plotting. Let's get this show on the road!")

        self.grouped_csv_files = file_groups
        self.selected_group_prefix = None

        row_start = 0
        for i, (prefix, files) in enumerate(file_groups.items()):
            group_text = f"Group '{prefix}' ({len(files)} files)"
            btn = ttk.Button(self.dynamic_3d_buttons_frame, text=group_text,
                             command=lambda p=prefix: self._select_group_for_3d_plotting(p))
            btn.grid(row=row_start + i, column=0, padx=5, pady=2, sticky="ew")
            btn.config(style='Orange.TButton') # Use a distinct style if desired

        try:
            style = ttk.Style()
            style.configure('Orange.TButton', background='orange', foreground='black')
        except Exception as e:
            debug_log(f"Could not apply orange style for 3D plotting buttons: {e}. Damn you, Tkinter styles!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

    def _select_group_for_3d_plotting(self, prefix):
        """
        Function Description:
        Sets the `selected_group_prefix` for 3D plotting and visually highlights the selected group button.

        Inputs to this function:
            prefix (str): The prefix of the selected group of files.

        Process of this function:
            1. Stores the `prefix` in `self.selected_group_prefix`.
            2. Updates the console with the selected group.
            3. Iterates through all dynamic group buttons:
               a. If the button's text matches the selected prefix, sets its relief to "sunken" and applies a "SelectedOrange.TButton" style.
               b. Otherwise, resets its relief to "raised" and applies the default "Orange.TButton" style.
            4. Attempts to configure the "SelectedOrange.TButton" style.

        Outputs of this function:
            None. Updates `self.selected_group_prefix` and GUI button appearance.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function} with prefix: {prefix}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        self.selected_group_prefix = prefix
        self.console_print_func(f"Selected group for 3D plotting: '{prefix}'")
        debug_log(f"Selected group for 3D plotting: '{prefix}'",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        for widget in self.dynamic_3d_buttons_frame.winfo_children():
            if isinstance(widget, ttk.Button):
                if widget.cget("text").startswith(f"Group '{prefix}'"):
                    widget.config(relief="sunken", style='SelectedOrange.TButton')
                    debug_log(f"Highlighted button for group: {prefix}",
                                file=__file__,
                                version=current_version,
                                function=current_function)
                else:
                    widget.config(relief="raised", style='Orange.TButton')
        try:
            style = ttk.Style()
            style.configure('SelectedOrange.TButton', background='darkorange', foreground='white')
        except Exception as e:
            debug_log(f"Could not apply selected orange style for 3D plotting buttons: {e}. This style system is a real pain in the ass!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

    def _clear_dynamic_3d_buttons(self):
        """
        Function Description:
        Destroys all dynamically created group selection buttons for 3D plotting from the GUI.

        Inputs to this function:
            None.

        Process of this function:
            1. Iterates through all child widgets in `self.dynamic_3d_buttons_frame`.
            2. Calls `destroy()` on each widget.

        Outputs of this function:
            None. Clears the dynamic button area in the GUI.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        for widget in self.dynamic_3d_buttons_frame.winfo_children():
            widget.destroy()
        debug_log(f"Cleared dynamic 3D plotting buttons.",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

    def _generate_plot_scans_over_time(self):
        """
        Function Description:
        Generates and opens the 3D Plotly HTML plot for scans over time.
        It utilizes the `plot_Scans_over_time` utility function.

        Inputs to this function:
            None.

        Process of this function:
            1. Checks if `grouped_csv_files` and `selected_group_prefix` are set.
            2. Retrieves the amplitude threshold from the Tkinter variable.
            3. Determines the output folder for the plot.
            4. Calls `plot_Scans_over_time` with the collected parameters.
            5. If the plot is generated successfully, logs success and optionally opens it in a browser.
            6. Logs failure messages to the console.

        Outputs of this function:
            None. Generates an HTML plot file.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        if not hasattr(self, 'grouped_csv_files') or not self.grouped_csv_files:
            self.console_print_func("Warning: No data. Please select a folder and identify CSV file groups for 3D plotting first. What the hell are you trying to plot?")
            debug_log(f"Exiting {current_function} (no grouped_csv_files)",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        if not self.selected_group_prefix:
            self.console_print_func("Warning: No group selected. Please click on one of the group buttons to select files for 3D plotting. Pick one, for crying out loud!")
            debug_log(f"Exiting {current_function} (no selected_group_prefix)",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        amplitude_threshold = self.amplitude_threshold_var.get()
        output_dir = self.app_instance.output_folder_var.get() # Use the main app's output folder

        self.console_print_func(f"Generating 3D plot for group '{self.selected_group_prefix}' with threshold {amplitude_threshold} dBm. This may take some time. Don't go anywhere!")
        debug_log(f"Calling plot_Scans_over_time for group '{self.selected_group_prefix}'",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        try:
            fig, plot_html_path = plot_Scans_over_time(
                self.grouped_csv_files,
                self.selected_group_prefix,
                output_dir,
                amplitude_threshold,
                self.console_print_func
            )

            if fig:
                self.console_print_func(f"✅ 3D plot generated and saved to: {plot_html_path}. BOOM! Nailed it!")
                debug_log(f"3D plot generated and saved to: {plot_html_path}",
                            file=__file__,
                            version=current_version,
                            function=current_function)
                if self.app_instance.open_html_after_complete_var.get():
                    self.console_print_func(f"Opening 3D plot in browser: {plot_html_path}")
                    webbrowser.open_new_tab(plot_html_path)
                    debug_log(f"3D plot opened in browser: {plot_html_path}",
                                file=__file__,
                                version=current_version,
                                function=current_function)
            else:
                self.console_print_func("🚫 3D Plotly figure was not generated. Fucking hell, not again!")
                debug_log("3D Plotly figure not generated.",
                            file=__file__,
                            version=current_version,
                            function=current_function)
        except Exception as e:
            self.console_print_func(f"❌ Error generating 3D plot: {e}. This is a nightmare!")
            debug_log(f"Error generating 3D plot: {e}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    def _on_tab_selected(self, event):
        """
        Function Description:
        Callback for when this tab is selected.
        This can be used to refresh data or update UI elements specific to this tab.

        Inputs to this function:
            event (tkinter.Event): The event object that triggered the tab selection.

        Process of this function:
            1. Logs a debug message indicating the tab selection.
            2. Enables/Disables the "Generate 3D Plot of Scans Over Time" button
               based on whether a folder has been opened and groups of CSV files have been identified.

        Outputs of this function:
            None. Updates the state of various GUI buttons.

        (2025-07-31) Change: Initial implementation for Plotting3DTab.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        debug_log("3D Plotting Tab selected.",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        # Enable/Disable 3D plotting button based on last_opened_folder and grouped_csv_files
        if hasattr(self, 'last_opened_folder') and self.last_opened_folder and \
           hasattr(self, 'grouped_csv_files') and self.grouped_csv_files:
            self.generate_plot_scans_over_time_button.config(state=tk.NORMAL)
            debug_log("3D plotting button enabled (folder and groups exist).",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        else:
            self.generate_plot_scans_over_time_button.config(state=tk.DISABLED)
            debug_log("3D plotting button disabled (no folder or groups).",
                        file=__file__,
                        version=current_version,
                        function=current_function)

        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


#####################################
### File: OPEN-AIR 2\workers\Plotting\tab_plotting_child_Single.py
#####################################
# tabs/Plotting/tab_plotting_child_Single.py
#
# This file defines a Tkinter Frame that provides functionality for plotting single scan data
# and current cycle averaged data. It handles file selection, plotting options,
# and opening generated HTML plots.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250801.2230.1 (Refactored debug_print to use debug_log and console_log.)

current_version = "20250801.2230.1" # this variable should always be defined below the header to make the debugging better
current_version_hash = 20250801 * 2230 * 1 # Example hash, adjust as needed

import tkinter as tk
from tkinter import ttk, filedialog, scrolledtext, messagebox
import os
import pandas as pd
import inspect
import webbrowser # For opening HTML plot in browser
from datetime import datetime # Import datetime for timestamping plots
import numpy as np # Added for PSD calculation in _plot_current_cycle_average

# CORRECTED: Import plotting functions and _open_plot_in_browser directly from utils.utils_plotting
from .utils_plotting import plot_single_scan_data, plot_multi_trace_data, _open_plot_in_browser

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log

# Removed: from process_math.averaging_utils import average_scan
# Removed: from utils.plot_scans_over_time import plot_Scans_over_time


class PlottingTab(ttk.Frame):
    """
    A Tkinter Frame that provides functionality for plotting single scan data and current cycle averages.
    """
    def __init__(self, master=None, app_instance=None, console_print_func=None, **kwargs):
        """
        Initializes the PlottingTab.

        Inputs:
            master (tk.Widget): The parent widget.
            app_instance (App): The main application instance, used for accessing
                                shared state like collected_scans_dataframes and output directory.
            console_print_func (function): Function to print messages to the GUI console.
            **kwargs: Arbitrary keyword arguments for Tkinter Frame.
        """
        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func if console_print_func else console_log # Use provided func or console_log
        self.current_plot_file = None # To store the path of the last generated plot HTML
        # Removed: self.last_opened_folder = None # No longer needed here
        # Removed: self.last_applied_math_folder = None # No longer needed here

        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        self._create_widgets()
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

    def _create_widgets(self):
        """
        Function Description:
        Creates and arranges all the widgets for the PlottingTab.

        Inputs to this function:
            None.

        Process of this function:
            1. Creates the main LabelFrame for "SCAN Plotting Options".
            2. Adds HTML Output Options (checkboxes for creating and opening HTML).
            3. Adds Scan Markers to Plot options (checkboxes for various markers).
            4. Adds buttons for plotting a single scan, plotting current cycle average,
               and opening the last generated plot.
            5. Configures grid weights for responsive layout.

        Outputs of this function:
            None. Populates the tab with GUI elements.

        (2025-07-31) Change: Removed "Plotting Averages from Folder" section.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        # SCAN Plotting Options Frame (for single scan and current cycle average)
        plotting_options_frame = ttk.LabelFrame(self, text="SCAN Plotting Options", padding="10")
        plotting_options_frame.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")

        # Inner frame for 50/50 split
        scan_options_inner_frame = ttk.Frame(plotting_options_frame)
        scan_options_inner_frame.grid(row=0, column=0, padx=5, pady=5, sticky="nsew", columnspan=2)
        scan_options_inner_frame.grid_columnconfigure(0, weight=1)
        scan_options_inner_frame.grid_columnconfigure(1, weight=1)

        # Left 50% - HTML Output Options
        html_output_options_frame = ttk.LabelFrame(scan_options_inner_frame, text="HTML Output Options", padding="10")
        html_output_options_frame.grid(row=0, column=0, padx=5, pady=5, sticky="nsew")
        html_output_options_frame.grid_columnconfigure(0, weight=1)

        # Link to app_instance variables
        ttk.Checkbutton(html_output_options_frame, text="Plot the HTML after every scan", variable=self.app_instance.open_html_after_complete_var).grid(row=0, column=0, padx=5, pady=2, sticky="w")
        ttk.Checkbutton(html_output_options_frame, text="Create HTML", variable=self.app_instance.create_html_report_var,
                        command=self._on_create_html_checkbox_changed).grid(row=1, column=0, padx=5, pady=2, sticky="w")


        # Right 50% - Scan Markers to Plot
        scan_markers_to_plot_frame = ttk.LabelFrame(scan_options_inner_frame, text="Scan Markers to Plot", padding="10")
        scan_markers_to_plot_frame.grid(row=0, column=1, padx=5, pady=5, sticky="nsew")
        scan_markers_to_plot_frame.grid_columnconfigure(0, weight=1)

        # Link to app_instance variables
        ttk.Checkbutton(scan_markers_to_plot_frame, text="Include TV Band Markers", variable=self.app_instance.include_tv_markers_var,
                        command=self._on_scan_marker_checkbox_changed).grid(row=0, column=0, padx=5, pady=2, sticky="w")
        ttk.Checkbutton(scan_markers_to_plot_frame, text="Include Government Band Markers", variable=self.app_instance.include_gov_markers_var,
                        command=self._on_scan_marker_checkbox_changed).grid(row=1, column=0, padx=5, pady=2, sticky="w")
        ttk.Checkbutton(scan_markers_to_plot_frame, text="Include Markers", variable=self.app_instance.include_markers_var,
                        command=self._on_scan_marker_checkbox_changed).grid(row=2, column=0, padx=5, pady=2, sticky="w")
        ttk.Checkbutton(scan_markers_to_plot_frame, text="Include Intermodulations", variable=self.app_instance.include_scan_intermod_markers_var,
                        command=self._on_scan_marker_checkbox_changed).grid(row=3, column=0, padx=5, pady=2, sticky="w")


        # Plotting Buttons below the split frames
        self.plot_button = ttk.Button(plotting_options_frame, text="Plot Single Scan", command=self._plot_single_scan)
        self.plot_button.grid(row=1, column=0, padx=5, pady=5, sticky="ew") # Adjusted row
        # self.plot_button.config(state=tk.DISABLED) # This line is commented out, so it's not disabled here.

        self.plot_average_button = ttk.Button(plotting_options_frame, text="Plot Current Cycle Average (All Traces)", command=self._plot_current_cycle_average)
        self.plot_average_button.grid(row=2, column=0, padx=5, pady=5, sticky="ew") # Adjusted row
        self.plot_average_button.config(state=tk.DISABLED) # Disable until data is available

        self.open_last_plot_button = ttk.Button(plotting_options_frame, text="Open Last Plot", command=self._open_last_plot)
        self.open_last_plot_button.grid(row=3, column=0, padx=5, pady=5, sticky="ew")

        # Configure column weights for resizing
        self.grid_columnconfigure(0, weight=1)
        plotting_options_frame.grid_columnconfigure(0, weight=1)

        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

    # Removed: _on_avg_type_checkbox_changed - moved to tab_plotting_child_Average.py

    def _on_create_html_checkbox_changed(self):
        """
        Function Description:
        Callback function for when the "Create HTML" checkbox is changed.
        It logs the current state of the checkbox to the console.

        Inputs to this function:
            None.

        Process of this function:
            1. Retrieves the boolean state of `self.app_instance.create_html_var`.
            2. Logs the state to the debug log and the GUI console.

        Outputs of this function:
            None. Updates console output.

        (2025-07-31) Change: Maintained in tab_plotting_child_Single.py.
        (2025-08-01) Change: Updated debug_print to debug_log.
        """
        current_function = inspect.currentframe().f_code.co_name
        state = "Enabled" if self.app_instance.create_html_var.get() else "Disabled"
        debug_log(f"Create HTML checkbox changed. State: {state}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        self.console_print_func(f"Create HTML: {state}")


    def _on_scan_marker_checkbox_changed(self):
        """
        Function Description:
        Callback function for when a "Scan Markers to Plot" checkbox is changed.
        It logs the currently selected marker types for single scan plots to the console.

        Inputs to this function:
            None.

        Process of this function:
            1. Retrieves the state of all `include_..._markers_var` Tkinter variables from `app_instance`.
            2. Builds a list of selected marker types.
            3. Logs the selected types to the debug log and the GUI console.

        Outputs of this function:
            None. Updates console output.

        (2025-07-31) Change: Maintained in tab_plotting_child_Single.py.
        (2025-08-01) Change: Updated debug_print to debug_log.
        """
        current_function = inspect.currentframe().f_code.co_name
        selected_markers = []
        if self.app_instance.include_tv_markers_var.get():
            selected_markers.append("TV Band Markers")
        if self.app_instance.include_gov_markers_var.get():
            selected_markers.append("Government Band Markers")
        if self.app_instance.include_markers_var.get():
            selected_markers.append("General Markers")
        if self.app_instance.include_scan_intermod_markers_var.get(): # NEW variable
            selected_markers.append("Intermodulations")

        debug_log(f"SCAN Plotting Options - Selected markers: {selected_markers}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        self.console_print_func(f"SCAN Plotting Options - Markers: {', '.join(selected_markers) if selected_markers else 'None'}")

    # Removed: _on_multi_file_marker_checkbox_changed - moved to tab_plotting_child_Average.py


    def _plot_single_scan(self):
        """
        Function Description:
        Prompts the user to select a single CSV file and then plots its scan data.

        Inputs to this function:
            None.

        Process of this function:
            1. Opens a file dialog to select a CSV file.
            2. If a file is selected, reads it into a Pandas DataFrame.
            3. Determines the output directory and HTML filename for the plot.
            4. Calls `plot_single_scan_data` from `utils.plotting_utils` to generate the plot.
            5. Stores the path of the generated HTML plot in `self.current_plot_file`.
            6. Logs success or failure messages to the console and optionally opens the plot in a browser.

        Outputs of this function:
            None. Generates an HTML plot file and updates `self.current_plot_file`.

        (2025-07-31) Change: Maintained in tab_plotting_child_Single.py.
        (2025-08-01) Change: Updated debug_print to debug_log.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        file_path = filedialog.askopenfilename(
            title="Select a CSV file to plot",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")]
        )
        if not file_path:
            self.console_print_func("File selection cancelled. No single scan plot generated. Damn it!")
            debug_log("File selection cancelled for single plot.",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        try:
            df = pd.read_csv(file_path, header=None, names=['Frequency (Hz)', 'Power (dBm)']) # Ensure column names match plot_logic
            scan_name = os.path.splitext(os.path.basename(file_path))[0]
            self.console_print_func(f"Plotting single scan from: {scan_name}")
            debug_log(f"Plotting single scan for: {scan_name}",
                        file=__file__,
                        version=current_version,
                        function=current_function)

            # Use app_instance.output_folder_var for output directory
            output_dir = self.app_instance.output_folder_var.get()
            if not os.path.exists(output_dir):
                os.makedirs(output_dir)
                debug_log(f"Created output directory: {output_dir}",
                            file=__file__,
                            version=current_version,
                            function=current_function)

            html_filename = os.path.join(output_dir, f"{scan_name.replace(' ', '_')}_single_scan_plot.html")
            debug_log(f"Output HTML filename: {html_filename}",
                        file=__file__,
                        version=current_version,
                        function=current_function)

            fig, plot_html_path_return = plot_single_scan_data(
                df,
                f"Single Scan: {scan_name}",
                include_tv_markers=self.app_instance.include_tv_markers_var.get(),
                include_gov_markers=self.app_instance.include_gov_markers_var.get(),
                include_markers=self.app_instance.include_markers_var.get(), # Pass general markers
                include_intermod_markers=self.app_instance.include_scan_intermod_markers_var.get(), # NEW
                output_html_path=html_filename if self.app_instance.create_html_var.get() else None, # Only create HTML if checkbox is checked
                console_print_func=self.console_print_func,
                scan_data_folder=os.path.dirname(file_path) # Pass the folder of the selected scan
            )

            if fig:
                self.current_plot_file = plot_html_path_return
                if self.app_instance.create_html_var.get():
                    self.console_print_func(f"✅ Single scan plot saved to: {self.current_plot_file}")
                    debug_log(f"Plot saved successfully to: {self.current_plot_file}",
                                file=__file__,
                                version=current_version,
                                function=current_function)
                else:
                    self.console_print_func("✅ Single scan plot data processed (HTML not saved as per setting).")
                    debug_log("Plot data processed, HTML not saved.",
                                file=__file__,
                                version=current_version,
                                function=current_function)

                if self.app_instance.open_html_after_complete_var.get() and self.app_instance.create_html_var.get() and plot_html_path_return:
                    self.console_print_func(f"Opening plot in browser: {self.current_plot_file}")
                    webbrowser.open_new_tab(self.current_plot_file)
                    debug_log(f"Plot opened in browser: {self.current_plot_file}",
                                file=__file__,
                                version=current_version,
                                function=current_function)
                elif self.app_instance.open_html_after_complete_var.get() and not self.app_instance.create_html_var.get():
                    self.console_print_func("HTML plot not opened because 'Create HTML' is unchecked. What a waste of a click!")
                    debug_log("HTML not opened as 'Create HTML' is unchecked.",
                                file=__file__,
                                version=current_version,
                                function=current_function)
            else:
                self.console_print_func("🚫 Plotly figure was not generated for single scan. Fucking useless!")
                debug_log("Plotly figure not generated for single scan.",
                            file=__file__,
                            version=current_version,
                            function=current_function)
        except Exception as e:
            self.console_print_func(f"❌ Error plotting single scan: {e}. This is a goddamn disaster!")
            debug_log(f"Error plotting single scan: {e}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    def _plot_current_cycle_average(self):
        """
        Function Description:
        Generates a plot of the current cycle's collected scan data, applying selected average types.

        Inputs to this function:
            None.

        Process of this function:
            1. Checks if `self.app_instance.collected_scans_dataframes` contains any data.
            2. Determines the output directory for the plot.
            3. Retrieves the currently selected average types from `app_instance` variables.
            4. If no average types are selected, logs a warning and returns.
            5. Aggregates and aligns all collected scan dataframes to a common frequency reference.
            6. Calculates the selected average types (Average, Median, Range, Std Dev, Variance, PSD)
               across the aligned scan data.
            7. Determines the plot title and output HTML filename.
            8. Dynamically sets the y-axis range override based on the selected average types.
            9. Calls `plot_multi_trace_data` from `utils.plotting_utils` to generate the plot.
            10. Stores the path of the generated HTML plot in `self.current_plot_file`.
            11. Logs success or failure messages to the console and optionally opens the plot in a browser.

        Outputs of this function:
            None. Generates an HTML plot file and updates `self.current_plot_file`.

        (2025-07-31) Change: Maintained in tab_plotting_child_Single.py.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        if not self.app_instance.collected_scans_dataframes:
            self.console_print_func("No collected scan dataframes to average. What the hell am I supposed to plot?!")
            debug_log("No collected scan dataframes for current cycle average.",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            debug_log(f"Exiting {current_function} (no data)",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        # Use app_instance.output_folder_var for output directory
        output_dir = self.app_instance.output_folder_var.get()
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
            debug_log(f"Created output directory: {output_dir}",
                        file=__file__,
                        version=current_version,
                        function=current_function)

        # Get selected average types for current cycle plot from app_instance variables
        selected_avg_types = [
            "Average" if self.app_instance.math_average_var.get() else None,
            "Median" if self.app_instance.math_median_var.get() else None,
            "Range" if self.app_instance.math_range_var.get() else None,
            "Standard Deviation" if self.app_instance.math_standard_deviation_var.get() else None,
            "Variance" if self.app_instance.math_variance_var.get() else None,
            "Power Spectral Density (PSD)" if self.app_instance.math_psd_var.get() else None
        ]
        selected_avg_types = [t for t in selected_avg_types if t is not None]

        if not selected_avg_types:
            self.console_print_func("Warning: No average type selected for current cycle plot. Please select at least one type. Come on, pick something!")
            debug_log(f"Exiting {current_function} (no selected_avg_types for current cycle)",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        self.console_print_func("Processing current cycle average plot. This may take a moment depending on the number of scans. Don't touch that dial!")
        debug_log(f"Calling generate_current_cycle_average_csv_and_plot with {len(self.app_instance.collected_scans_dataframes)} dataframes and selected types: {selected_avg_types}.",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        # Aggregate the current cycle scans into a single DataFrame for plotting
        all_frequencies_current_cycle = pd.Series(dtype=float)
        power_levels_current_cycle_list = []
        rbw_values_current_cycle = [] # Collect RBW for PSD calculation

        for df_scan in self.app_instance.collected_scans_dataframes:
            if 'Frequency (Hz)' in df_scan.columns and 'Power (dBm)' in df_scan.columns:
                all_frequencies_current_cycle = pd.concat([all_frequencies_current_cycle, df_scan['Frequency (Hz)']])
                power_levels_current_cycle_list.append(df_scan.set_index('Frequency (Hz)')['Power (dBm)'])
                # Use the app_instance.scan_rbw_hz_var for RBW
                rbw_value = float(self.app_instance.scan_rbw_hz_var.get())
                rbw_values_current_cycle.append(rbw_value)
            else:
                self.console_print_func("Warning: Collected scan missing 'Frequency (Hz)' or 'Power (dBm)'. Skipping for current cycle average. What a mess!")
                debug_log("Collected scan missing freq/power columns.",
                            file=__file__,
                            version=current_version,
                            function=current_function)

        if not power_levels_current_cycle_list:
            self.console_print_func("No valid collected scans to average for current cycle. This is pointless!")
            debug_log("No valid collected scans for current cycle average.",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        # Create a master reference frequency for current cycle
        reference_freq_current_cycle = all_frequencies_current_cycle.sort_values().drop_duplicates().reset_index(drop=True)

        # Reindex and interpolate all power series to the master frequency
        aligned_power_series_current_cycle = []
        for series in power_levels_current_cycle_list:
            aligned_series = series.reindex(reference_freq_current_cycle).interpolate(method='linear', limit_direction='both')
            aligned_power_series_current_cycle.append(aligned_series)

        power_levels_df_current_cycle = pd.concat(aligned_power_series_current_cycle, axis=1)
        power_levels_df_current_cycle.columns = [f"Scan_{i+1}" for i in range(len(aligned_power_series_current_cycle))]

        # Calculate selected average types for current cycle
        aggregated_df_current_cycle = pd.DataFrame({'Frequency (Hz)': reference_freq_current_cycle})

        # Define calculation functions locally or import them if they are in averaging_utils
        # For simplicity, defining them here for now, but ideally they'd be shared.
        def _local_calculate_average(df): return df.mean(axis=1)
        def _local_calculate_median(df): return df.median(axis=1)
        def _local_calculate_range(df): return df.max(axis=1) - df.min(axis=1)
        def _local_calculate_std_dev(df): return df.std(axis=1)
        def _local_calculate_variance(df): return df.var(axis=1)
        def _local_calculate_psd(df, rbw_values_list):
            if rbw_values_list and any(r is not None and r > 0 for r in rbw_values_list):
                # Use the average RBW for the PSD calculation across multiple scans
                avg_rbw = sum([r for r in rbw_values_list if r is not None and r > 0]) / len([r for r in rbw_values_list if r is not None and r > 0])
                linear_power_mW = 10**(df / 10).mean(axis=1) # Average linear power
                return 10 * np.log10(linear_power_mW / avg_rbw)
            else:
                return pd.Series([np.nan]*len(df.index))

        calculation_functions = {
            "Average": _local_calculate_average,
            "Median": _local_calculate_median,
            "Range": _local_calculate_range,
            "Standard Deviation": _local_calculate_std_dev, # Updated key
            "Variance": _local_calculate_variance,
            "Power Spectral Density (PSD)": _local_calculate_psd # Updated key
        }

        for avg_type in selected_avg_types:
            if avg_type in calculation_functions:
                if avg_type == "Power Spectral Density (PSD)": # Updated key
                    # Pass rbw_values_current_cycle to PSD calculation
                    aggregated_df_current_cycle[avg_type] = calculation_functions[avg_type](power_levels_df_current_cycle, rbw_values_current_cycle)
                else:
                    aggregated_df_current_cycle[avg_type] = calculation_functions[avg_type](power_levels_df_current_cycle)
            else:
                self.console_print_func(f"Warning: Unknown average type '{avg_type}' requested for current cycle. Skipping. What the hell is this type?!")

        plot_title_current_cycle = f"Current Cycle Average - {', '.join(selected_avg_types)}"
        html_filename_current_cycle = os.path.join(output_dir, f"CurrentCycleAverage_Plot_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html")

        # Determine y_range_max_override for current cycle plot
        y_range_max_override_val = 0 # Default for power plots
        if any(avg_type in selected_avg_types for avg_type in ["Range", "Standard Deviation", "Variance", "Power Spectral Density (PSD)"]):
            y_range_max_override_val = 30 # Set to 30 for these statistical plots

        fig, plot_html_path_return = plot_multi_trace_data(
            aggregated_df_current_cycle,
            plot_title_current_cycle,
            include_tv_markers=self.app_instance.include_tv_markers_var.get(), # Use app_instance var
            include_gov_markers=self.app_instance.include_gov_markers_var.get(), # Use app_instance var
            include_markers=self.app_instance.include_markers_var.get(), # Use app_instance var
            include_intermod_markers=self.app_instance.include_scan_intermod_markers_var.get(), # NEW
            historical_dfs_with_names=None,
            individual_scan_dfs_with_names=[(df, f"Scan {i+1}") for i, df in enumerate(self.app_instance.collected_scans_dataframes)], # Pass individual scans
            output_html_path=html_filename_current_cycle if self.app_instance.create_html_var.get() else None, # Use app_instance var
            y_range_min_override=None, # Let the plotting function determine min
            y_range_max_override=y_range_max_override_val, # Pass the dynamically set override
            console_print_func=self.console_print_func,
            scan_data_folder=output_dir # Pass the output directory as the scan_data_folder for markers
        )

        if fig:
            self.current_plot_file = plot_html_path_return
            if self.app_instance.create_html_var.get():
                self.console_print_func(f"✅ Current cycle averaged plot saved to: {self.current_plot_file}")
                debug_log(f"Current cycle averaged plot saved to: {self.current_plot_file}",
                            file=__file__,
                            version=current_version,
                            function=current_function)
            else:
                self.console_print_func("✅ Current cycle averaged plot data processed (HTML not saved as per setting).")
                debug_log("Plot data processed, HTML not saved.",
                            file=__file__,
                            version=current_version,
                            function=current_function)

            if self.app_instance.open_html_after_complete_var.get() and self.app_instance.create_html_var.get() and plot_html_path_return:
                _open_plot_in_browser(plot_html_path_return, self.console_print_func)
        else:
            self.console_print_func("🚫 Plotly figure was not generated for current cycle averaged data. Are you even trying?!")
            debug_log("Plotly figure not generated for current cycle averaged data.",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    def _open_last_plot(self):
        """
        Function Description:
        Opens the last generated HTML plot in the default web browser.

        Inputs to this function:
            None.

        Process of this function:
            1. Checks if `self.current_plot_file` is set and the file exists.
            2. If so, opens the file in a new browser tab using `_open_plot_in_browser`.
            3. Otherwise, logs an error message to the console.

        Outputs of this function:
            None. Opens a web browser tab.

        (2025-07-31) Change: Maintained in tab_plotting_child_Single.py.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        if self.current_plot_file and os.path.exists(self.current_plot_file):
            self.console_print_func(f"Opening last plot: {self.current_plot_file}")
            _open_plot_in_browser(self.current_plot_file, self.console_print_func) # Pass console_print_func
            debug_log(f"Opened last plot: {self.current_plot_file}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        else:
            self.console_print_func("Error: No plot available or file not found. Please generate a plot first. What's the point of this button then?!")
            debug_log("No plot available or file not found.",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

    # Removed: _open_folder_for_averaging - moved to tab_plotting_child_Average.py
    # Removed: _find_and_group_csv_files - moved to tab_plotting_child_Average.py
    # Removed: _select_group_for_plotting - moved to tab_plotting_child_Average.py
    # Removed: _clear_dynamic_buttons - moved to tab_plotting_child_Average.py
    # Removed: _generate_csv_selected_series - moved to tab_plotting_child_Average.py
    # Removed: _open_applied_math_folder - moved to tab_plotting_child_Average.py
    # Removed: _generate_multi_average_plot - moved to tab_plotting_child_Average.py
    # Removed: _generate_plot_scans_over_time - moved to tab_plotting_child_Average.py


    def _on_tab_selected(self, event):
        """
        Function Description:
        Callback for when this tab is selected.
        This can be used to refresh data or update UI elements specific to this tab.

        Inputs to this function:
            event (tkinter.Event): The event object that triggered the tab selection.

        Process of this function:
            1. Logs a debug message indicating the tab selection.
            2. Ensures the "Plot Single Scan" button is enabled.
            3. Enables/Disables the "Plot Current Cycle Average" button based on whether
               `collected_scans_dataframes` contains any data.

        Outputs of this function:
            None. Updates the state of relevant GUI buttons.

        (2025-07-31) Change: Updated to reflect removal of folder averaging functionality.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        debug_log("Plotting Tab selected.",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        # The 'Plot Single Scan' button should always be enabled as it opens a file dialog.
        self.plot_button.config(state=tk.NORMAL)
        debug_log("Plot Single Scan button enabled.",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        # Enable/Disable 'Plot Current Cycle Average' button based on collected_scans_dataframes
        if self.app_instance.collected_scans_dataframes:
            self.plot_average_button.config(state=tk.NORMAL)
            debug_log("Plot Current Cycle Average button enabled (data available).",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        else:
            self.plot_average_button.config(state=tk.DISABLED)
            debug_log("Plot Current Cycle Average button disabled (no data available).",
                        file=__file__,
                        version=current_version,
                        function=current_function)

        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


#####################################
### File: OPEN-AIR 2\workers\Plotting\tab_plotting_child_average.py
#####################################
# tabs/Plotting/tab_plotting_child_average.py
#
# This file defines a Tkinter Frame for plotting averaged scan data from folders.
# It handles selecting folders, grouping CSV files, generating averaged CSVs,
# and plotting various statistical analyses (Average, Median, Range, Std Dev, Variance, PSD).
# The 3D plotting functionality has been moved to tab_plotting_child_3D.py.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250801.2225.1 (Refactored debug_print to use debug_log and console_log.)

current_version = "20250801.2225.1" # this variable should always be defined below the header to make the debugging better
current_version_hash = 20250801 * 2225 * 1 # Example hash, adjust as needed

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import os
import pandas as pd
import inspect
import webbrowser # For opening HTML plot in browser
import re # Added for regex in file grouping
import platform # For opening folder cross-platform
import glob # For finding files with specific patterns
from datetime import datetime # Import datetime for timestamping plots
import numpy as np # Added for PSD calculation

# CORRECTED: Import plotting functions and _open_plot_in_browser directly from utils.plotting_utils
from .utils_plotting import plot_multi_trace_data, _open_plot_in_browser

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log

from process_math.averaging_utils import average_scan # NEW import
# Removed: from utils.plot_scans_over_time import plot_Scans_over_time # Moved to tab_plotting_child_3D.py


class AveragingTab(ttk.Frame):
    """
    A Tkinter Frame that provides functionality for plotting averaged scan data from folders.
    """
    def __init__(self, master=None, app_instance=None, console_print_func=None, **kwargs):
        """
        Initializes the AveragingTab.

        Inputs:
            master (tk.Widget): The parent widget.
            app_instance (App): The main application instance, used for accessing
                                shared state like collected_scans_dataframes and output directory.
            console_print_func (function): Function to print messages to the GUI console.
            **kwargs: Arbitrary keyword arguments for Tkinter Frame.
        """
        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func if console_print_func else console_log # Use provided func or console_log
        self.current_plot_file = None # To store the path of the last generated plot HTML
        self.last_opened_folder = None # To remember the last opened folder for averaging
        self.last_applied_math_folder = None # To store the path of the last folder created by applied math
        self.grouped_csv_files = {} # Dictionary to store grouped CSV files
        self.selected_group_prefix = None # Stores the prefix of the currently selected group

        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        self._create_widgets()
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

    def _create_widgets(self):
        """
        Function Description:
        Creates and arranges all the widgets for the AveragingTab.

        Inputs to this function:
            None.

        Process of this function:
            1. Creates the main LabelFrame for "Plotting Averages from Folder".
            2. Adds a button to open a folder for averaging.
            3. Creates a LabelFrame to display discovered series of scans with dynamic buttons.
            4. Creates a frame for "Apply Math" checkboxes (Average, Median, etc.).
            5. Creates a frame for "Markers to Plot" checkboxes specific to averaged plots.
            6. Adds buttons for generating CSVs, opening the applied math folder,
               and generating plots of averages (with/without scans).
            7. Configures grid weights for responsive layout.

        Outputs of this function:
            None. Populates the tab with GUI elements.

        (2025-07-31) Change: Removed "Generate Plot of Scans Over Time" button.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        # --- Plotting Averages from Folder Section ---
        self.averaging_folder_frame = ttk.LabelFrame(self, text="Plotting Averages from Folder", padding="10")
        self.averaging_folder_frame.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")

        # Open Folder to Average Button (Top of this section)
        self.open_folder_button = ttk.Button(self.averaging_folder_frame, text="Open Folder to Average", command=self._open_folder_for_averaging)
        self.open_folder_button.grid(row=0, column=0, columnspan=2, padx=5, pady=5, sticky="ew")

        # Discovered Series of Scans Frame
        self.discovered_series_frame = ttk.LabelFrame(self.averaging_folder_frame, text="Discovered Series of Scans", padding="10")
        self.discovered_series_frame.grid(row=1, column=0, columnspan=2, padx=5, pady=5, sticky="nsew")
        self.dynamic_avg_buttons_frame = ttk.Frame(self.discovered_series_frame) # This frame will hold dynamically created buttons.
        self.dynamic_avg_buttons_frame.pack(fill="both", expand=True) # Use pack for dynamic buttons within this frame

        # Math and Markers Container Frame (for 50/50 split)
        math_and_markers_frame = ttk.Frame(self.averaging_folder_frame)
        math_and_markers_frame.grid(row=2, column=0, columnspan=2, padx=5, pady=5, sticky="nsew")
        math_and_markers_frame.grid_columnconfigure(0, weight=1) # Make columns expandable
        math_and_markers_frame.grid_columnconfigure(1, weight=1)

        # Apply Math Frame
        apply_math_frame = ttk.LabelFrame(math_and_markers_frame, text="Apply Math", padding="10")
        apply_math_frame.grid(row=0, column=0, padx=5, pady=5, sticky="nsew")
        apply_math_frame.grid_columnconfigure(0, weight=1) # Make column expandable

        # Link to app_instance variables
        self.avg_type_vars = {
            "Average": self.app_instance.math_average_var,
            "Median": self.app_instance.math_median_var,
            "Range": self.app_instance.math_range_var,
            "Standard Deviation": self.app_instance.math_standard_deviation_var,
            "Variance": self.app_instance.math_variance_var,
            "Power Spectral Density (PSD)": self.app_instance.math_psd_var
        }

        # Tooltip definitions (example, you'd integrate a proper tooltip class)
        tooltip_texts = {
            "Average": "Calculates the arithmetic mean of power levels across all scans.",
            "Median": "Calculates the median (middle value) of power levels across all scans.",
            "Range": "Calculates the difference between the maximum and minimum power levels for each frequency point.",
            "Standard Deviation": "Measures the dispersion of power levels around the mean for each frequency point.",
            "Variance": "Measures the squared deviation from the mean, indicating the spread of power levels.",
            "Power Spectral Density (PSD)": "Normalizes power to a 1 Hz bandwidth, useful for comparing noise floors."
        }

        for i, (text, var) in enumerate(self.avg_type_vars.items()):
            chk = ttk.Checkbutton(apply_math_frame, text=text, variable=var,
                                  command=self._on_avg_type_checkbox_changed)
            chk.grid(row=i, column=0, padx=5, pady=2, sticky="w")

            # --- Tooltip Integration Suggestion ---
            # To add tooltips, you would typically use a custom Tooltip class
            # or bind to <Enter> and <Leave> events to show/hide a Label.
            # Example (conceptual, requires Tooltip class definition):
            # Tooltip(chk, text=tooltip_texts.get(text, "No description available."))
            # ------------------------------------

        # Markers to Plot Frame (Includes TV, Government, General, and Intermodulations)
        markers_to_plot_frame = ttk.LabelFrame(math_and_markers_frame, text="Markers to Plot", padding="10")
        markers_to_plot_frame.grid(row=0, column=1, padx=5, pady=5, sticky="nsew")
        markers_to_plot_frame.grid_columnconfigure(0, weight=1) # Make column expandable

        # Link to app_instance variables for average markers
        ttk.Checkbutton(markers_to_plot_frame, text="Include TV Band Markers", variable=self.app_instance.include_tv_markers_var,
                        command=self._on_multi_file_marker_checkbox_changed).grid(row=0, column=0, padx=5, pady=2, sticky="w")
        ttk.Checkbutton(markers_to_plot_frame, text="Include Government Band Markers", variable=self.app_instance.include_gov_markers_var,
                        command=self._on_multi_file_marker_checkbox_changed).grid(row=1, column=0, padx=5, pady=2, sticky="w")
        ttk.Checkbutton(markers_to_plot_frame, text="Include Markers", variable=self.app_instance.include_markers_var,
                        command=self._on_multi_file_marker_checkbox_changed).grid(row=2, column=0, padx=5, pady=2, sticky="w")
        ttk.Checkbutton(markers_to_plot_frame, text="Include Intermodulations", variable=self.app_instance.include_scan_intermod_markers_var,
                        command=self._on_multi_file_marker_checkbox_changed).grid(row=3, column=0, padx=5, pady=2, sticky="w")


        # Make Averages Frame
        make_averages_frame = ttk.LabelFrame(self.averaging_folder_frame, text="Make Averages", padding="10")
        make_averages_frame.grid(row=3, column=0, columnspan=2, padx=5, pady=5, sticky="nsew")
        make_averages_frame.grid_columnconfigure(0, weight=1) # Make column expandable

        self.generate_csv_button = ttk.Button(make_averages_frame, text="Generate CSV of Selected Series of Scan", command=self._generate_csv_selected_series)
        self.generate_csv_button.grid(row=0, column=0, padx=5, pady=5, sticky="ew")
        self.generate_csv_button.config(state=tk.DISABLED) # Disable until group is selected

        self.open_applied_math_folder_button = ttk.Button(make_averages_frame, text="Open Folder of Applied Math", command=self._open_applied_math_folder)
        self.open_applied_math_folder_button.grid(row=1, column=0, padx=5, pady=5, sticky="ew")
        self.open_applied_math_folder_button.config(state=tk.DISABLED) # Disable until a folder is created

        self.generate_plot_averages_button = ttk.Button(make_averages_frame, text="Generate Plot of Averages", command=lambda: self._generate_multi_average_plot(include_scans=False))
        self.generate_plot_averages_button.grid(row=2, column=0, padx=5, pady=5, sticky="ew")
        self.generate_plot_averages_button.config(state=tk.DISABLED) # Disable until group is selected

        self.generate_plot_averages_with_scan_button = ttk.Button(make_averages_frame, text="Generate Plot of Averages with Scan", command=lambda: self._generate_multi_average_plot(include_scans=True))
        self.generate_plot_averages_with_scan_button.grid(row=3, column=0, padx=5, pady=5, sticky="ew")
        self.generate_plot_averages_with_scan_button.config(state=tk.DISABLED) # Disable until group is selected

        # Removed: self.generate_plot_scans_over_time_button = ttk.Button(make_averages_frame, text="Generate Plot of Scans Over Time", command=self._generate_plot_scans_over_time)
        # Removed: self.generate_plot_scans_over_time_button.grid(row=4, column=0, padx=5, pady=5, sticky="ew")
        # Removed: self.generate_plot_scans_over_time_button.config(state=tk.DISABLED) # Disable until group is selected


        # Configure column weights for resizing
        self.grid_columnconfigure(0, weight=1)
        self.averaging_folder_frame.grid_columnconfigure(0, weight=1)
        self.averaging_folder_frame.grid_columnconfigure(1, weight=1) # For the two columns inside
        self.discovered_series_frame.grid_columnconfigure(0, weight=1)
        self.dynamic_avg_buttons_frame.grid_columnconfigure(0, weight=1) # Ensure dynamic buttons expand
        make_averages_frame.grid_columnconfigure(0, weight=1)


        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

    def _on_avg_type_checkbox_changed(self):
        """
        Function Description:
        Callback function for when an "Apply Math" checkbox is changed.
        It logs the currently selected average types to the console.

        Inputs to this function:
            None.

        Process of this function:
            1. Retrieves the state of all "math_average_var" Tkinter variables from app_instance.
            2. Filters out unselected types.
            3. Logs the selected types to the debug log and the GUI console.

        Outputs of this function:
            None. Updates console output.

        (2025-07-31) Change: Moved from tab_plotting_child_Single.py.
        (2025-08-01) Change: Updated debug_print to debug_log.
        """
        current_function = inspect.currentframe().f_code.co_name
        # Now directly use app_instance variables as they are linked
        selected_types = [
            "Average" if self.app_instance.math_average_var.get() else None,
            "Median" if self.app_instance.math_median_var.get() else None,
            "Range" if self.app_instance.math_range_var.get() else None,
            "Standard Deviation" if self.app_instance.math_standard_deviation_var.get() else None,
            "Variance" if self.app_instance.math_variance_var.get() else None,
            "Power Spectral Density (PSD)" if self.app_instance.math_psd_var.get() else None
        ]
        selected_types = [t for t in selected_types if t is not None]
        debug_log(f"Checkbox changed. Currently selected average types: {selected_types}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        self.console_print_func(f"Selected average types: {', '.join(selected_types) if selected_types else 'None'}")

    def _on_multi_file_marker_checkbox_changed(self):
        """
        Function Description:
        Callback function for when a "Markers to Plot" checkbox (for multi-file plots) is changed.
        It logs the currently selected marker types to the console.

        Inputs to this function:
            None.

        Process of this function:
            1. Retrieves the state of all "avg_include_..." Tkinter variables from app_instance.
            2. Builds a list of selected marker types.
            3. Logs the selected types to the debug log and the GUI console.

        Outputs of this function:
            None. Updates console output.

        (2025-07-31) Change: Moved from tab_plotting_child_Single.py.
        (2025-08-01) Change: Updated debug_print to debug_log.
        """
        current_function = inspect.currentframe().f_code.co_name
        selected_markers = []
        if self.app_instance.avg_include_tv_markers_var.get(): # NEW variable
            selected_markers.append("TV Band Markers")
        if self.app_instance.avg_include_gov_markers_var.get(): # NEW variable
            selected_markers.append("Government Band Markers")
        if self.app_instance.avg_include_markers_var.get(): # NEW variable
            selected_markers.append("General Markers")
        if self.app_instance.avg_include_intermod_markers_var.get(): # NEW variable
            selected_markers.append("Intermodulations")

        debug_log(f"Multi-File Plotting - Selected markers: {selected_markers}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        self.console_print_func(f"Multi-File Plotting - Markers: {', '.join(selected_markers) if selected_markers else 'None'}")

    def _open_folder_for_averaging(self):
        """
        Function Description:
        Opens a file dialog to allow the user to select a folder containing CSV files for averaging.
        Upon selection, it calls `_find_and_group_csv_files` and enables relevant buttons.

        Inputs to this function:
            None.

        Process of this function:
            1. Opens a directory selection dialog, defaulting to the last opened folder.
            2. If a folder is selected, stores it as `self.last_opened_folder`.
            3. Calls `_find_and_group_csv_files` to process the CSVs in the selected folder.
            4. Enables the CSV generation and plotting buttons.
            5. If no folder is selected, disables the buttons.

        Outputs of this function:
            None. Updates GUI state and initiates file grouping.

        (2025-07-31) Change: Moved from tab_plotting_child_Single.py.
        (2025-08-01) Change: Updated debug_print to debug_log.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        folder_path = filedialog.askdirectory(initialdir=self.last_opened_folder)
        debug_log(f"Selected folder_path: {folder_path}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        if folder_path:
            self.last_opened_folder = folder_path
            self.console_print_func(f"Selected folder for averaging: {folder_path}")
            self._find_and_group_csv_files(folder_path)
            # Enable relevant buttons after a folder is selected and groups are found
            self.generate_csv_button.config(state=tk.NORMAL)
            self.generate_plot_averages_button.config(state=tk.NORMAL)
            self.generate_plot_averages_with_scan_button.config(state=tk.NORMAL)
            # Removed: self.generate_plot_scans_over_time_button.config(state=tk.NORMAL)
            debug_log("Averaging buttons enabled (folder selected).",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        else:
            self.console_print_func("Folder selection cancelled.")
            # Disable buttons if folder selection is cancelled
            self.generate_csv_button.config(state=tk.DISABLED)
            self.generate_plot_averages_button.config(state=tk.DISABLED)
            self.generate_plot_averages_with_scan_button.config(state=tk.DISABLED)
            # Removed: self.generate_plot_scans_over_time_button.config(state=tk.DISABLED)
            debug_log("Folder selection cancelled. Averaging buttons disabled.",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    def _find_and_group_csv_files(self, folder_path):
        """
        Function Description:
        Scans the selected folder for CSV files and groups them based on a common naming prefix.
        It then creates dynamic buttons for each identified group.

        Inputs to this function:
            folder_path (str): The path to the folder containing CSV files.

        Process of this function:
            1. Lists all CSV files in the given `folder_path`.
            2. If no CSVs are found, clears dynamic buttons and returns.
            3. Iterates through each CSV, attempting to extract a common prefix using regex.
               The regex is designed to be flexible, looking for a pattern before RBW/HOLD/timestamp.
            4. Stores files in `file_groups` dictionary, where keys are prefixes and values are lists of file paths.
            5. Clears any existing dynamic group selection buttons.
            6. Creates a new `ttk.Button` for each identified group, allowing the user to select it.
            7. Configures button styles.

        Outputs of this function:
            None. Populates `self.grouped_csv_files` and updates the GUI with group selection buttons.

        (2025-07-31) Change: Moved from tab_plotting_child_Single.py.
        (2025-08-01) Change: Updated debug_print to debug_log.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function} with folder_path: {folder_path}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        csv_files = [f for f in os.listdir(folder_path) if f.endswith('.csv')]
        debug_log(f"Found CSV files: {csv_files}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        if not csv_files:
            self.console_print_func("No CSV files found in the selected folder. FUCK! Where did they go?!")
            self._clear_dynamic_buttons()
            debug_log(f"Exiting {current_function} (no CSVs)",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        file_groups = {}
        for filename in csv_files:
            base_name = os.path.splitext(filename)[0]
            # Updated regex for grouping: be more flexible with the ending part before date/time
            # It tries to capture the main prefix before any RBW/HOLD/Offset/timestamp.
            match = re.match(r"([^\d_ -]+(?:[_ -][^\d_ -]+)*?)_RBW\d+K?_HOLD\d+.*", base_name)
            prefix = base_name # Default to full base name if no clear pattern
            if match:
                prefix = match.group(1).strip() # Get the part before RBW/HOLD
                # Refine prefix: remove trailing underscores/hyphens if they were part of the non-digit group
                prefix = re.sub(r"[_ -]+$", "", prefix)
            else:
                # Fallback if the more specific pattern doesn't match (e.g., for INTERMOD.csv or simpler names)
                # Try to split by common delimiters if no complex pattern is found
                if '_' in base_name:
                    prefix = base_name.split('_')[0]
                elif '-' in base_name:
                    prefix = base_name.split('-')[0]
                else:
                    prefix = base_name # Use full name if no common delimiters

            if not prefix: # Ensure prefix is not empty
                prefix = base_name # Fallback to full base name

            if prefix not in file_groups:
                file_groups[prefix] = []
            file_groups[prefix].append(os.path.join(folder_path, filename))
        debug_log(f"Grouped CSV files: {file_groups}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        self._clear_dynamic_buttons() # Clear any previous buttons

        if not file_groups:
            self.console_print_func("No identifiable groups of CSV files found. This is a bloody mess!")
            debug_log(f"Exiting {current_function} (no file groups)",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        self.console_print_func(f"Found {len(file_groups)} groups of similar CSV files. Let's get this show on the road!")

        self.grouped_csv_files = file_groups
        self.selected_group_prefix = None

        row_start = 0
        for i, (prefix, files) in enumerate(file_groups.items()):
            group_text = f"Group '{prefix}' ({len(files)} files)"
            btn = ttk.Button(self.dynamic_avg_buttons_frame, text=group_text,
                             command=lambda p=prefix: self._select_group_for_plotting(p))
            btn.grid(row=row_start + i, column=0, padx=5, pady=2, sticky="ew")
            btn.config(style='Orange.TButton')

        try:
            style = ttk.Style()
            style.configure('Orange.TButton', background='orange', foreground='black')
        except Exception as e:
            debug_log(f"Could not apply orange style: {e}. Damn you, Tkinter styles!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    def _select_group_for_plotting(self, prefix):
        """
        Function Description:
        Sets the `selected_group_prefix` and visually highlights the selected group button.

        Inputs to this function:
            prefix (str): The prefix of the selected group of files.

        Process of this function:
            1. Stores the `prefix` in `self.selected_group_prefix`.
            2. Updates the console with the selected group.
            3. Iterates through all dynamic group buttons:
               a. If the button's text matches the selected prefix, sets its relief to "sunken" and applies a "SelectedOrange.TButton" style.
               b. Otherwise, resets its relief to "raised" and applies the default "Orange.TButton" style.
            4. Attempts to configure the "SelectedOrange.TButton" style.

        Outputs of this function:
            None. Updates `self.selected_group_prefix` and GUI button appearance.

        (2025-07-31) Change: Moved from tab_plotting_child_Single.py.
        (2025-08-01) Change: Updated debug_print to debug_log.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function} with prefix: {prefix}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        self.selected_group_prefix = prefix
        self.console_print_func(f"Selected group for plotting: '{prefix}'")
        debug_log(f"Selected group for plotting: '{prefix}'",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        for widget in self.dynamic_avg_buttons_frame.winfo_children():
            if isinstance(widget, ttk.Button):
                if widget.cget("text").startswith(f"Group '{prefix}'"):
                    widget.config(relief="sunken", style='SelectedOrange.TButton')
                    debug_log(f"Highlighted button for group: {prefix}",
                                file=__file__,
                                version=current_version,
                                function=current_function)
                else:
                    widget.config(relief="raised", style='Orange.TButton')
        try:
            style = ttk.Style()
            style.configure('SelectedOrange.TButton', background='darkorange', foreground='white')
        except Exception as e:
            debug_log(f"Could not apply selected orange style: {e}. This style system is a real pain in the ass!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    def _clear_dynamic_buttons(self):
        """
        Function Description:
        Destroys all dynamically created group selection buttons from the GUI.

        Inputs to this function:
            None.

        Process of this function:
            1. Iterates through all child widgets in `self.dynamic_avg_buttons_frame`.
            2. Calls `destroy()` on each widget.

        Outputs of this function:
            None. Clears the dynamic button area in the GUI.

        (2025-07-31) Change: Moved from tab_plotting_child_Single.py.
        (2025-08-01) Change: Updated debug_print to debug_log.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        for widget in self.dynamic_avg_buttons_frame.winfo_children():
            widget.destroy()
        debug_log(f"Cleared dynamic buttons.",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    def _generate_csv_selected_series(self):
        """
        Function Description:
        Generates CSV files containing the selected average types for the currently selected group of scans.
        It utilizes the `average_scan` utility function.

        Inputs to this function:
            None.

        Process of this function:
            1. Checks if `grouped_csv_files` and `selected_group_prefix` are set. If not, logs a warning and returns.
            2. Retrieves the list of files to average for the selected group.
            3. Retrieves the currently selected average types from `app_instance` variables.
            4. If no average types are selected, logs a warning and returns.
            5. Calls the `average_scan` function with the collected parameters.
            6. If CSV generation is successful, stores the `output_folder_path` in `self.last_applied_math_folder`
               and enables the "Open Folder of Applied Math" button. Otherwise, disables it.

        Outputs of this function:
            None. Creates CSV files and updates GUI button state.

        (2025-07-31) Change: Moved from tab_plotting_child_Single.py.
        (2025-08-01) Change: Updated debug_print to debug_log.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        if not hasattr(self, 'grouped_csv_files') or not self.grouped_csv_files:
            self.console_print_func("Warning: No data. Please select a folder and identify CSV file groups first. What the hell are you trying to average?")
            debug_log(f"Exiting {current_function} (no grouped_csv_files)",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        if not self.selected_group_prefix:
            self.console_print_func("Warning: No group selected. Please click on one of the group buttons to select files for averaging. Pick one, for crying out loud!")
            debug_log(f"Exiting {current_function} (no selected_group_prefix)",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        files_to_average = self.grouped_csv_files[self.selected_group_prefix]
        debug_log(f"Files to average for selected group '{self.selected_group_prefix}': {files_to_average}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        if not files_to_average:
            self.console_print_func("Error: No files found for the selected group. This is utterly useless!")
            debug_log(f"Exiting {current_function} (files_to_average is empty)",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        # Get selected average types from app_instance variables
        selected_avg_types = [
            "Average" if self.app_instance.math_average_var.get() else None,
            "Median" if self.app_instance.math_median_var.get() else None,
            "Range" if self.app_instance.math_range_var.get() else None,
            "Standard Deviation" if self.app_instance.math_standard_deviation_var.get() else None,
            "Variance" if self.app_instance.math_variance_var.get() else None,
            "Power Spectral Density (PSD)" if self.app_instance.math_psd_var.get() else None
        ]
        selected_avg_types = [t for t in selected_avg_types if t is not None]

        debug_log(f"Selected average types BEFORE check: {selected_avg_types}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        if not selected_avg_types:
            self.console_print_func("Warning: No average type selected. Please select at least one type of average to generate CSVs (e.g., Average, Median). Are you even trying?!")
            debug_log(f"Exiting {current_function} (no selected_avg_types)",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        self.console_print_func(f"Generating CSVs for selected series. This may take some time depending on the number and size of scans. Don't go anywhere!")

        output_dir_base = self.last_opened_folder # Use the folder where files were opened as base for new subfolder

        # Call the new average_scan function
        aggregated_df, output_folder_path = average_scan(
            file_paths=files_to_average,
            selected_avg_types=selected_avg_types,
            plot_title_prefix=self.selected_group_prefix,
            output_html_path_base=output_dir_base,
            console_print_func=self.console_print_func
        )

        if output_folder_path:
            self.last_applied_math_folder = output_folder_path
            self.console_print_func(f"CSV files generated in: {output_folder_path}")
            self.open_applied_math_folder_button.config(state=tk.NORMAL) # Enable the button
            self.console_print_func("🎉 CSV generation complete! Now that's what I call progress! 🎉")
        else:
            self.console_print_func("🚫 CSV generation failed. FML, this is frustrating!")
            self.open_applied_math_folder_button.config(state=tk.DISABLED)
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    def _open_applied_math_folder(self):
        """
        Function Description:
        Opens the folder where the applied math (averaged CSVs and plots) were saved.
        It uses platform-specific commands to open the folder in the file explorer.

        Inputs to this function:
            None.

        Process of this function:
            1. Checks if `self.last_applied_math_folder` is set and exists.
            2. If so, attempts to open the folder using `os.startfile` (Windows),
               `subprocess.Popen(["open", ...])` (macOS), or `subprocess.Popen(["xdg-open", ...])` (Linux).
            3. If an error occurs, logs it to the console.
            4. If no folder is available, logs a message to the console.

        Outputs of this function:
            None. Opens a file explorer window.

        (2025-07-31) Change: Moved from tab_plotting_child_Single.py.
        (2025-08-01) Change: Updated debug_print to debug_log.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        if self.last_applied_math_folder and os.path.exists(self.last_applied_math_folder):
            self.console_print_func(f"Opening folder: {self.last_applied_math_folder}")
            try:
                if platform.system() == "Windows":
                    os.startfile(self.last_applied_math_folder)
                elif platform.system() == "Darwin": # macOS
                    import subprocess
                    subprocess.Popen(["open", self.last_applied_math_folder])
                else: # Linux and other Unix-like systems
                    import subprocess
                    subprocess.Popen(["xdg-open", self.last_applied_math_folder])
            except Exception as e:
                self.console_print_func(f"❌ Error opening folder: {e}. Are you kidding me?!")
                debug_log(f"Error opening folder {self.last_applied_math_folder}: {e}",
                            file=__file__,
                            version=current_version,
                            function=current_function)
        else:
            self.console_print_func("No folder of applied math available. Please generate CSVs first. What did you expect, magic?")
            debug_log("No applied math folder to open.",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    def _generate_multi_average_plot(self, include_scans=False):
        """
        Function Description:
        Generates a plot of selected averages from the 'COMPLETE_MATH' CSV,
        optionally overlaying individual scan data.

        Inputs to this function:
            include_scans (bool): If True, individual scan data will be overlaid on the plot.

        Process of this function:
            1. Checks for the existence of `self.last_applied_math_folder` and `self.selected_group_prefix`.
            2. Constructs a path to find the `COMPLETE_MATH` CSV file within the applied math folder.
            3. Loads the `COMPLETE_MATH` CSV into a Pandas DataFrame.
            4. Filters the DataFrame to include only the selected average types for plotting.
            5. If `include_scans` is True, loads individual scan CSVs from the original folder
               and prepares them for overlay.
            6. Determines the plot title and output HTML filename.
            7. Dynamically sets the y-axis range override based on the selected average types.
            8. Calls `plot_multi_trace_data` from `utils.plotting_utils` to generate the plot.
            9. Stores the path of the generated HTML plot in `self.current_plot_file`.
            10. Logs success or failure messages to the console.

        Outputs of this function:
            None. Generates an HTML plot file and updates `self.current_plot_file`.

        (2025-07-31) Change: Moved from tab_plotting_child_Single.py.
        (2025-08-01) Change: Updated debug_print to debug_log.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function} with include_scans={include_scans}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        if not self.last_applied_math_folder or not os.path.exists(self.last_applied_math_folder):
            self.console_print_func("Error: No 'Applied Math' folder found. Please generate CSVs first. What the hell are you trying to plot?")
            debug_log("No 'Applied Math' folder found.",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        if not self.selected_group_prefix:
            self.console_print_func("Warning: No group selected. Please click on one of the group buttons to select files for averaging. Pick a damn group!")
            debug_log(f"Exiting {current_function} (no selected_group_prefix)",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        self.console_print_func(f"Generating plot for selected series. This may take some time depending on the number and size of scans. Patience, my friend, patience!")

        # Construct the path to the COMPLETE_MATH CSV
        complete_math_csv_pattern = os.path.join(self.last_applied_math_folder, f"COMPLETE_MATH_{self.selected_group_prefix}_MultiFileAverage_*.csv")
        complete_math_csv_files = glob.glob(complete_math_csv_pattern)

        if not complete_math_csv_files:
            self.console_print_func(f"Error: No COMPLETE_MATH CSV found in '{self.last_applied_math_folder}' for group '{self.selected_group_prefix}'. This is a nightmare!")
            debug_log(f"No COMPLETE_MATH CSV found for group '{self.selected_group_prefix}'.",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        # Take the most recent COMPLETE_MATH CSV if multiple exist
        complete_math_csv_path = max(complete_math_csv_files, key=os.path.getctime)
        self.console_print_func(f"Loaded COMPLETE_MATH CSV from: {complete_math_csv_path}")
        debug_log(f"Loaded COMPLETE_MATH CSV from: {complete_math_csv_path}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        try:
            # Read the COMPLETE_MATH CSV. Assuming the first column is Frequency (Hz) and others are data.
            # Use header=True to correctly read the column names (Average, Median, etc.)
            aggregated_df = pd.read_csv(complete_math_csv_path)
            debug_log(f"Loaded aggregated_df columns: {aggregated_df.columns.tolist()}",
                        file=__file__,
                        version=current_version,
                        function=current_function)

            # Filter aggregated_df to include only selected average types for plotting
            selected_avg_types = [
                "Average" if self.app_instance.math_average_var.get() else None,
                "Median" if self.app_instance.math_median_var.get() else None,
                "Range" if self.app_instance.math_range_var.get() else None,
                "Standard Deviation" if self.app_instance.math_standard_deviation_var.get() else None,
                "Variance" if self.app_instance.math_variance_var.get() else None,
                "Power Spectral Density (PSD)" if self.app_instance.math_psd_var.get() else None
            ]
            selected_avg_types = [t for t in selected_avg_types if t is not None]

            # Map the full names back to the column names in the CSV if they are different
            # (e.g., "Standard Deviation" -> "Std Dev")
            column_name_map = {
                "Average": "Average",
                "Median": "Median",
                "Range": "Range",
                "Standard Deviation": "Std Dev",
                "Variance": "Variance",
                "Power Spectral Density (PSD)": "PSD (dBm/Hz)"
            }
            plot_columns = ['Frequency (Hz)'] + [column_name_map[t] for t in selected_avg_types if column_name_map[t] in aggregated_df.columns]

            if not plot_columns or len(plot_columns) < 2: # Need at least Frequency and one data column
                self.console_print_func("Error: No selected average types found in the loaded COMPLETE_MATH CSV for plotting. This is a goddamn travesty!")
                debug_log("No selected average types found in COMPLETE_MATH CSV.",
                            file=__file__,
                            version=current_version,
                            function=current_function)
                return

            aggregated_df_for_plot = aggregated_df[plot_columns].copy()
            debug_log(f"DataFrame for plotting (selected averages) columns: {aggregated_df_for_plot.columns.tolist()}",
                        file=__file__,
                        version=current_version,
                        function=current_function)

            individual_scan_dfs_for_overlay = []
            if include_scans:
                self.console_print_func("Loading individual scans for overlay... This better work!")
                files_to_overlay = self.grouped_csv_files[self.selected_group_prefix]
                for f_path in files_to_overlay:
                    try:
                        scan_df = pd.read_csv(f_path, header=None, names=['Frequency (Hz)', 'Power (dBm)'])
                        scan_name = os.path.splitext(os.path.basename(f_path))[0]
                        individual_scan_dfs_for_overlay.append((scan_df, scan_name))
                        debug_log(f"Loaded individual scan for overlay: {scan_name}",
                                    file=__file__,
                                    version=current_version,
                                    function=current_function)
                    except Exception as e:
                        self.console_print_func(f"Warning: Could not load individual scan {os.path.basename(f_path)} for overlay: {e}. What a pain!")
                        debug_log(f"Could not load individual scan {os.path.basename(f_path)}: {e}",
                                    file=__file__,
                                    version=current_version,
                                    function=current_function)

            # Define historical_dfs_with_names as None before the debug print
            historical_dfs_with_names = None

            plot_title_suffix = ", ".join(selected_avg_types)
            plot_title = f"{self.selected_group_prefix} - {plot_title_suffix} (Multi-File Average)"
            if include_scans:
                plot_title += " with Individual Scans"

            # Determine y_range_max_override based on selected average types
            y_range_max_override_val = 0 # Default for power plots
            # Check if any of the statistical measures are selected
            if any(avg_type in selected_avg_types for avg_type in ["Range", "Standard Deviation", "Variance", "Power Spectral Density (PSD)"]):
                y_range_max_override_val = 30 # Set to 30 for these statistical plots

            # --- DEEPER DEBUGGING FOR plot_multi_trace_data CALL ---
            debug_log(f"DEBUG: Calling plot_multi_trace_data with the following arguments:",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            debug_log(f"  aggregated_df_for_plot (shape): {aggregated_df_for_plot.shape}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            debug_log(f"  plot_title: {plot_title}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            debug_log(f"  include_tv_markers: {self.app_instance.avg_include_tv_markers_var.get()}",
                        file=__file__,
                        version=current_version,
                        function=current_function) # Use app_instance var
            debug_log(f"  include_gov_markers: {self.app_instance.avg_include_gov_markers_var.get()}",
                        file=__file__,
                        version=current_version,
                        function=current_function) # Use app_instance var
            debug_log(f"  include_markers: {self.app_instance.avg_include_markers_var.get()}",
                        file=__file__,
                        version=current_version,
                        function=current_function) # Use app_instance var
            debug_log(f"  include_intermod_markers: {self.app_instance.avg_include_intermod_markers_var.get()}",
                        file=__file__,
                        version=current_version,
                        function=current_function) # NEW
            debug_log(f"  historical_dfs_with_names: {historical_dfs_with_names is not None}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            debug_log(f"  individual_scan_dfs_with_names (count): {len(individual_scan_dfs_for_overlay) if individual_scan_dfs_for_overlay else 0}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            debug_log(f"  output_html_path: {os.path.join(self.last_applied_math_folder, f'{self.selected_group_prefix}_MultiFileAverage_Plot_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html')}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            debug_log(f"  y_range_max_override: {y_range_max_override_val}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            debug_log(f"  scan_data_folder: {self.last_opened_folder}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            # --- END DEEPER DEBUGGING ---

            fig, plot_html_path_return = plot_multi_trace_data(
                aggregated_df_for_plot, # Pass the filtered DataFrame
                plot_title,
                include_tv_markers=self.app_instance.avg_include_tv_markers_var.get(), # Use app_instance var
                include_gov_markers=self.app_instance.avg_include_gov_markers_var.get(), # Use app_instance var
                include_markers=self.app_instance.avg_include_markers_var.get(), # Use app_instance var
                include_intermod_markers=self.app_instance.avg_include_intermod_markers_var.get(), # NEW
                historical_dfs_with_names=None, # No historical overlays for this multi-file average from external folder
                individual_scan_dfs_with_names=individual_scan_dfs_for_overlay if include_scans else None,
                output_html_path=os.path.join(self.last_applied_math_folder, f"{self.selected_group_prefix}_MultiFileAverage_Plot_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html"),
                y_range_min_override=None, # Let the plotting function determine min
                y_range_max_override=y_range_max_override_val, # Pass the dynamically set override
                console_print_func=self.console_print_func,
                # CORRECTED: Pass the original folder where scans were opened for MARKERS.CSV
                scan_data_folder=self.last_opened_folder
            )

            if fig:
                self.current_plot_file = plot_html_path_return
                if self.app_instance.create_html_var.get():
                    self.console_print_func(f"✅ Multi-file averaged plot saved to: {self.current_plot_file}. BOOM! Nailed it!")
                    debug_log(f"Multi-file averaged plot saved to: {self.current_plot_file}",
                                file=__file__,
                                version=current_version,
                                function=current_function)
                else:
                    self.console_print_func("✅ Multi-file averaged plot data processed (HTML not saved as per setting).")
                    debug_log("Plot data processed, HTML not saved.",
                                file=__file__,
                                version=current_version,
                                function=current_function)

                if self.app_instance.open_html_after_complete_var.get() and self.app_instance.create_html_var.get() and plot_html_path_return:
                    _open_plot_in_browser(plot_html_path_return, self.console_print_func)
            else:
                self.console_print_func("🚫 Plotly figure was not generated for multi-file averaged data. Fucking hell, not again!")
                debug_log("Plotly figure not generated for multi-file averaged data.",
                            file=__file__,
                            version=current_version,
                            function=current_function)

        except Exception as e:
            self.console_print_func(f"❌ Error generating plot: {e}. This is a nightmare!")
            debug_log(f"Error generating plot: {e}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    # Removed: _generate_plot_scans_over_time - Moved to tab_plotting_child_3D.py


    def _on_tab_selected(self, event):
        """
        Function Description:
        Callback for when this tab is selected.
        This can be used to refresh data or update UI elements specific to this tab.

        Inputs to this function:
            event (tkinter.Event): The event object that triggered the tab selection.

        Process of this function:
            1. Logs a debug message indicating the tab selection.
            2. Enables/Disables multi-file averaging buttons based on whether a folder has been opened
               and groups of CSV files have been identified.
            3. Enables/Disables the "Open Applied Math Folder" button based on whether a folder
               for applied math exists.

        Outputs of this function:
            None. Updates the state of various GUI buttons.

        (2025-07-31) Change: Moved from tab_plotting_child_Single.py and adapted for AveragingTab. Removed 3D plot button state management.
        (2025-08-01) Change: Updated debug_print to debug_log.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Entering {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        debug_log("Averaging Tab selected.",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        # Enable/Disable multi-file averaging buttons based on last_opened_folder and grouped_csv_files
        if hasattr(self, 'last_opened_folder') and self.last_opened_folder and \
           hasattr(self, 'grouped_csv_files') and self.grouped_csv_files:
            self.generate_csv_button.config(state=tk.NORMAL)
            self.generate_plot_averages_button.config(state=tk.NORMAL)
            self.generate_plot_averages_with_scan_button.config(state=tk.NORMAL)
            # Removed: self.generate_plot_scans_over_time_button.config(state=tk.NORMAL)
            debug_log("Multi-file averaging buttons enabled (folder and groups exist).",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        else:
            self.generate_csv_button.config(state=tk.DISABLED)
            self.generate_plot_averages_button.config(state=tk.DISABLED)
            self.generate_plot_averages_with_scan_button.config(state=tk.DISABLED)
            # Removed: self.generate_plot_scans_over_time_button.config(state=tk.DISABLED)
            debug_log("Multi-file averaging buttons disabled (no folder or groups).",
                        file=__file__,
                        version=current_version,
                        function=current_function)

        # Enable/Disable "Open Applied Math Folder" button
        if self.last_applied_math_folder and os.path.exists(self.last_applied_math_folder):
            self.open_applied_math_folder_button.config(state=tk.NORMAL)
            debug_log("Open Applied Math Folder button enabled.",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        else:
            self.open_applied_math_folder_button.config(state=tk.DISABLED)
            debug_log("Open Applied Math Folder button disabled.",
                        file=__file__,
                        version=current_version,
                        function=current_function)

        debug_log(f"Exiting {current_function}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


#####################################
### File: OPEN-AIR 2\workers\Plotting\utils_plotting.py
#####################################
# utils/utils_plotting.py
#
# This module provides functions for generating interactive plots of spectrum analyzer data
# using Plotly. It supports plotting single scan traces, as well as aggregated data
# (average, median, range, standard deviation, variance, PSD) with historical overlays.
# It also includes functionalities for adding frequency band markers (TV, Government)
# and saving plots to HTML files.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250810.140800.1 (FIXED: Removed top-level import of frequency_bands.py constants to resolve startup error. The constants will now be passed to the functions that need them.)

current_version = "20250810.140800.1" # this variable should always be defined below the header to make the debugging better
current_version_hash = 20250810 * 140800 * 1 # Example hash, adjust as needed

import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import webbrowser
import os
import re # Added import for regular expressions
import csv # New: Import csv for MARKERS.CSV
import inspect # Import inspect for debug_log

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log

# The `frequency_bands` constants are now passed to the functions that need them.
# The previous `try...except` block has been removed, resolving the startup error.

def _open_plot_in_browser(html_file_path, console_print_func):
    """
    Function Description:
    Opens the generated HTML plot in the default web browser.

    Inputs to this function:
        html_file_path (str): The full path to the HTML plot file.
        console_print_func (function): Function to print messages to the GUI console.

    Process of this function:
        1. Checks if the HTML file exists.
        2. If it exists, uses `webbrowser.open_new_tab` to open it.
        3. Logs success or failure to the console and debug log.

    Outputs of this function:
        None. Opens a web browser tab.

    (2025-07-31) Change: Moved from main_app.py to utils_plotting.py.
    (2025-08-01) Change: Updated debug_print to debug_log.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Attempting to open plot in browser: {html_file_path}",
                file=__file__,
                version=current_version,
                function=current_function)
    if os.path.exists(html_file_path):
        try:
            webbrowser.open_new_tab(html_file_path)
            console_print_func(f"✅ Plot opened in browser: {os.path.basename(html_file_path)}")
            debug_log(f"Plot opened successfully: {html_file_path}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        except Exception as e:
            console_print_func(f"❌ Error opening plot in browser: {e}. This is a goddamn mess!")
            debug_log(f"Error opening plot {html_file_path} in browser: {e}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
    else:
        console_print_func(f"❌ Error: Plot file not found at {html_file_path}. What the hell?!")
        debug_log(f"Plot file not found: {html_file_path}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


def _add_band_markers(fig, markers_dict, line_color, line_dash, band_name_suffix, MHZ_TO_HZ, console_print_func):
    """
    Function Description:
    Adds rectangular shape annotations to a Plotly figure to represent frequency bands.

    Inputs to this function:
        fig (go.Figure): The Plotly figure object to which markers will be added.
        markers_dict (dict): A dictionary where keys are band names (str) and values are
                             lists of [min_freq_MHz, max_freq_MHz].
        line_color (str): The color for the band outlines (e.g., 'rgba(255, 0, 0, 0.5)').
        line_dash (str): The dash style for the band outlines (e.g., 'dot', 'dash').
        band_name_suffix (str): A suffix to add to the band names for legend clarity (e.g., " (TV)").
        MHZ_TO_HZ (float): The conversion factor from MHz to Hz.
        console_print_func (function): Function to print messages to the GUI console.

    Outputs of this function:
        Modifies the `fig` object by adding shapes.

    (2025-07-31) Change: Moved from main_app.py to utils_plotting.py.
    (2025-08-01) Change: Updated debug_print to debug_log.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Adding band markers with suffix '{band_name_suffix}'...",
                file=__file__,
                version=current_version,
                function=current_function)
    for band_name, freq_range_mhz in markers_dict.items():
        min_freq_hz = freq_range_mhz[0] * MHZ_TO_HZ
        max_freq_hz = freq_range_mhz[1] * MHZ_TO_HZ
        fig.add_shape(
            type="rect",
            xref="x", yref="paper",
            x0=min_freq_hz, y0=0, x1=max_freq_hz, y1=1,
            line=dict(color=line_color, width=1, dash=line_dash),
            fillcolor=line_color.replace('0.5', '0.1'), # Lighter fill
            layer="below",
            name=f"{band_name}{band_name_suffix}",
            # Add a legend group to show these as distinct items in the legend
            # but still allow toggling them together if desired by Plotly's default behavior
            legendgroup=f"{band_name_suffix.strip()}_bands",
            showlegend=True # Ensure they appear in the legend
        )
        # Add a dummy trace for the legend entry if the shape's name doesn't show up correctly
        fig.add_trace(go.Scatter(
            x=[None], y=[None],
            mode='lines',
            line=dict(color=line_color, width=1, dash=line_dash),
            name=f"{band_name}{band_name_suffix}",
            legendgroup=f"{band_name_suffix.strip()}_bands",
            showlegend=True
        ))
        debug_log(f"Added band marker: {band_name}{band_name_suffix} ({min_freq_hz/MHZ_TO_HZ:.2f}-{max_freq_hz/MHZ_TO_HZ:.2f} MHz)",
                    file=__file__,
                    version=current_version,
                    function=current_function)
    debug_log(f"Finished adding band markers with suffix '{band_name_suffix}'.",
                file=__file__,
                version=current_version,
                function=current_function)


def _add_markers_from_csv(fig, markers_csv_path, MHZ_TO_HZ, console_print_func):
    """
    Function Description:
    Reads markers from a specified CSV file and adds vertical line annotations to a Plotly figure.
    The CSV is expected to have 'FREQ' and 'NAME' columns.

    Inputs to this function:
        fig (go.Figure): The Plotly figure object to which markers will be added.
        markers_csv_path (str): The path to the CSV file containing marker data.
        MHZ_TO_HZ (float): The conversion factor from MHz to Hz.
        console_print_func (function): Function to print messages to the GUI console.

    Outputs of this function:
        Modifies the `fig` object by adding vertical lines and text annotations.

    (2025-07-31) Change: Moved from main_app.py to utils_plotting.py.
    (2025-08-01) Change: Updated debug_print to debug_log.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Attempting to add markers from CSV: {markers_csv_path}",
                file=__file__,
                version=current_version,
                function=current_function)
    if not os.path.exists(markers_csv_path):
        console_print_func(f"⚠️ Warning: Markers CSV file not found at {markers_csv_path}. Cannot add markers. What the hell?!")
        debug_log(f"Markers CSV not found: {markers_csv_path}. Fucking useless!",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        return

    try:
        df_markers = pd.read_csv(markers_csv_path)
        if 'FREQ' not in df_markers.columns or 'NAME' not in df_markers.columns:
            console_print_func(f"❌ Error: Markers CSV '{markers_csv_path}' must contain 'FREQ' and 'NAME' columns. This is a goddamn mess!")
            debug_log(f"Markers CSV '{markers_csv_path}' missing required columns.",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        for index, row in df_markers.iterrows():
            freq_hz = row['FREQ']
            marker_name = row['NAME']
            fig.add_vline(x=freq_hz, line_width=1, line_dash="dash", line_color="purple",
                          annotation_text=marker_name, annotation_position="top right")
            debug_log(f"Added marker from CSV: {marker_name} at {freq_hz/MHZ_TO_HZ:.3f} MHz",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        console_print_func(f"✅ Added markers from {os.path.basename(markers_csv_path)}.")
    except Exception as e:
        console_print_func(f"❌ Error reading or adding markers from CSV {os.path.basename(markers_csv_path)}: {e}. This CSV is a stubborn bastard!")
        debug_log(f"Error reading or adding markers from CSV {markers_csv_path}: {e}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


def _add_intermodulation_markers(fig, intermod_csv_path, MHZ_TO_HZ, console_print_func):
    """
    Function Description:
    Reads intermodulation product frequencies from a specified CSV file and adds
    vertical line annotations to a Plotly figure. The CSV is expected to have
    a 'Frequency_MHz' column.

    Inputs to this function:
        fig (go.Figure): The Plotly figure object to which markers will be added.
        intermod_csv_path (str): The path to the CSV file containing intermodulation data.
        MHZ_TO_HZ (float): The conversion factor from MHz to Hz.
        console_print_func (function): Function to print messages to the GUI console.

    Outputs of this function:
        Modifies the `fig` object by adding vertical lines and text annotations.

    (2025-08-01) Change: New function to add intermodulation markers.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Attempting to add intermodulation markers from CSV: {intermod_csv_path}",
                file=__file__,
                version=current_version,
                function=current_function)
    if not os.path.exists(intermod_csv_path):
        console_print_func(f"⚠️ Warning: Intermodulation CSV file not found at {intermod_csv_path}. Cannot add IMD markers. What the hell?!")
        debug_log(f"Intermodulation CSV not found: {intermod_csv_path}. Fucking useless!",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        return

    try:
        df_intermod = pd.read_csv(intermod_csv_path)
        if 'Frequency_MHz' not in df_intermod.columns:
            console_print_func(f"❌ Error: Intermodulation CSV '{intermod_csv_path}' must contain 'Frequency_MHz' column. This is a goddamn mess!")
            debug_log(f"Intermodulation CSV '{intermod_csv_path}' missing required 'Frequency_MHz' column.",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        for index, row in df_intermod.iterrows():
            freq_mhz = row['Frequency_MHz']
            freq_hz = freq_mhz * MHZ_TO_HZ
            # Create a descriptive name for the IMD marker
            imd_name = f"IMD {row.get('Order', '')} ({row.get('Type', '')}) from {row.get('Parent_Freq1', 'N/A')} & {row.get('Parent_Freq2', 'N/A')} MHz"
            fig.add_vline(x=freq_hz, line_width=1, line_dash="solid", line_color="red",
                          annotation_text=f"IMD {freq_mhz:.3f} MHz", annotation_position="bottom right")
            debug_log(f"Added intermodulation marker: {imd_name} at {freq_mhz:.3f} MHz",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        console_print_func(f"✅ Added intermodulation markers from {os.path.basename(intermod_csv_path)}.")
    except Exception as e:
        console_print_func(f"❌ Error reading or adding intermodulation markers from CSV {os.path.basename(intermod_csv_path)}: {e}. This IMD CSV is a stubborn bastard!")
        debug_log(f"Error reading or adding intermodulation markers from CSV {intermod_csv_path}: {e}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


def _create_spectrum_plot(data_traces, plot_title, include_tv_markers, include_gov_markers,
                          include_markers, include_intermod_markers, output_html_path,
                          y_range_min_override, y_range_max_override, console_print_func,
                          scan_data_folder, MHZ_TO_HZ, TV_BAND_MARKERS_MHZ, GOVERNMENT_BAND_MARKERS_MHZ,
                          DEFAULT_MARKERS_FILE, DEFAULT_INTERMOD_FILE):
    """
    Function Description:
    Generates a Plotly HTML interactive plot for spectrum analyzer data.
    This is a core plotting function that can handle multiple traces (e.g., current, historical, averages).
    It includes options for adding TV, Government, and custom markers.

    Inputs to this function:
        data_traces (list of dict): A list where each dict represents a trace to plot, e.g.:
                                    `{'df': DataFrame, 'name': 'Trace Name', 'color': 'blue', 'width': 2, 'dash': 'solid', 'show_legend': True, 'y_column_name': 'Power (dBm)'}`
        plot_title (str): The title of the plot.
        include_tv_markers (bool): If True, TV band markers are added.
        include_gov_markers (bool): If True, Government band markers are added.
        include_markers (bool): If True, custom markers from MARKERS.csv are added.
        include_intermod_markers (bool): If True, intermodulation markers from INTERMOD.csv are added.
        output_html_path (str or None): If a string, saves the plot to this HTML file. If None, does not save.
        y_range_min_override (float or None): Optional minimum Y-axis value.
        y_range_max_override (float or None): Optional maximum Y-axis value.
        console_print_func (function): Function to print messages to the GUI console.
        scan_data_folder (str): The folder where scan data (and potentially MARKERS.csv/INTERMOD.csv) resides.
        MHZ_TO_HZ (float): The conversion factor from MHz to Hz.
        TV_BAND_MARKERS_MHZ (dict): Dictionary of TV band markers.
        GOVERNMENT_BAND_MARKERS_MHZ (dict): Dictionary of Government band markers.
        DEFAULT_MARKERS_FILE (str): Default filename for markers CSV.
        DEFAULT_INTERMOD_FILE (str): Default filename for intermodulation CSV.

    Process of this function:
        1. Initializes an empty Plotly figure.
        2. Adds each trace from `data_traces` to the figure.
        3. Configures the layout (title, axes labels, hover mode).
        4. Conditionally adds TV, Government, custom, and intermodulation band markers.
        5. Sets Y-axis range if overrides are provided.
        6. If `output_html_path` is provided, saves the figure to an HTML file.
        7. Logs debug information throughout the process.

    Outputs of this function:
        tuple: (go.Figure, str or None) - The Plotly figure object and the path to the saved HTML file (or None).

    (2025-07-31) Change: Consolidated plotting logic from plot_single_scan_data and plot_multi_trace_data.
    (2025-07-31) Change: Added y_range_min_override and y_range_max_override parameters.
    (2025-08-01) Change: Added include_intermod_markers parameter and call to _add_intermodulation_markers.
    (2025-08-01) Change: Updated debug_print to debug_log.
    (2025-08-10) Change: Updated function signature to accept constants as arguments.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Creating spectrum plot: '{plot_title}'",
                file=__file__,
                version=current_version,
                function=current_function)

    fig = go.Figure()

    for trace_data in data_traces:
        df = trace_data['df']
        name = trace_data['name']
        color = trace_data['color']
        width = trace_data['width']
        dash = trace_data['dash']
        show_legend = trace_data['show_legend']
        y_column_name = trace_data['y_column_name'] # Use this to select the Y-axis column

        if df.empty or 'Frequency (Hz)' not in df.columns or y_column_name not in df.columns:
            debug_log(f"Skipping trace '{name}': Invalid DataFrame or missing columns. What a bummer!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            continue

        fig.add_trace(go.Scatter(
            x=df['Frequency (Hz)'],
            y=df[y_column_name],
            mode='lines',
            name=name,
            line=dict(color=color, width=width, dash=dash),
            showlegend=show_legend
        ))
        debug_log(f"Added trace: '{name}' with Y-column '{y_column_name}'",
                    file=__file__,
                    version=current_version,
                    function=current_function)

    fig.update_layout(
        title={
            'text': plot_title,
            'y':0.9,
            'x':0.5,
            'xanchor': 'center',
            'yanchor': 'top'
        },
        xaxis_title="Frequency (Hz)",
        yaxis_title="Power (dBm)", # Default Y-axis title
        hovermode="x unified",
        template="plotly_dark",
        margin=dict(l=50, r=50, t=80, b=50),
        height=700,
        width=1000,
        legend=dict(
            orientation="h",
            yanchor="bottom",
            y=1.02,
            xanchor="right",
            x=1
        )
    )
    debug_log("Plot layout updated.",
                file=__file__,
                version=current_version,
                function=current_function)

    # Conditionally add markers
    if include_tv_markers:
        _add_band_markers(fig, TV_BAND_MARKERS_MHZ, 'rgba(0, 255, 0, 0.5)', 'dot', ' (TV)', MHZ_TO_HZ, console_print_func)
    if include_gov_markers:
        _add_band_markers(fig, GOVERNMENT_BAND_MARKERS_MHZ, 'rgba(255, 165, 0, 0.5)', 'dash', ' (Gov)', MHZ_TO_HZ, console_print_func)
    if include_markers and scan_data_folder:
        markers_csv_path = os.path.join(scan_data_folder, DEFAULT_MARKERS_FILE)
        _add_markers_from_csv(fig, markers_csv_path, MHZ_TO_HZ, console_print_func)
    if include_intermod_markers and scan_data_folder:
        intermod_csv_path = os.path.join(scan_data_folder, DEFAULT_INTERMOD_FILE)
        _add_intermodulation_markers(fig, intermod_csv_path, MHZ_TO_HZ, console_print_func)


    # Apply Y-axis range override if provided
    if y_range_min_override is not None and y_range_max_override is not None:
        fig.update_yaxes(range=[y_range_min_override, y_range_max_override])
        debug_log(f"Y-axis range overridden to: [{y_range_min_override}, {y_range_max_override}]",
                    file=__file__,
                    version=current_version,
                    function=current_function)
    elif y_range_max_override is not None: # Only max override
        fig.update_yaxes(range=[fig.layout.yaxis.range[0], y_range_max_override])
        debug_log(f"Y-axis max range overridden to: {y_range_max_override}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
    elif y_range_min_override is not None: # Only min override
        fig.update_yaxes(range=[y_range_min_override, fig.layout.yaxis.range[1]])
        debug_log(f"Y-axis min range overridden to: {y_range_min_override}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    plot_html_path_return = None
    if output_html_path:
        output_dir = os.path.dirname(output_html_path)
        if output_dir and not os.path.exists(output_dir):
            os.makedirs(output_dir)
            debug_log(f"Created output directory for plot: {output_html_path}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        debug_log(f"Saving plot to: {output_html_path}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        fig.write_html(output_html_path, auto_open=False)
        plot_html_path_return = output_html_path
        debug_log(f"Plot saved to: {output_html_path}. Fucking brilliant!",
                    file=__file__,
                    version=current_version,
                    function=current_function)
    else:
        debug_log("Output HTML path not provided, skipping saving plot to file. What a waste!",
                    file=__file__,
                    version=current_version,
                    function=current_function)

    debug_log(f"Exiting {current_function}",
                file=__file__,
                version=current_version,
                function=current_function)
    return fig, plot_html_path_return


def plot_single_scan_data(df_scan, plot_title, include_tv_markers, include_gov_markers,
                          include_markers, include_intermod_markers, output_html_path, console_print_func,
                          scan_data_folder, MHZ_TO_HZ, TV_BAND_MARKERS_MHZ, GOVERNMENT_BAND_MARKERS_MHZ,
                          DEFAULT_MARKERS_FILE, DEFAULT_INTERMOD_FILE):
    """
    Function Description:
    Plots a single spectrum analyzer scan. This is a wrapper around `_create_spectrum_plot`.

    Inputs to this function:
        df_scan (pd.DataFrame): DataFrame containing 'Frequency (Hz)' and 'Power (dBm)'.
        plot_title (str): The title for the plot.
        include_tv_markers (bool): If True, TV band markers are added.
        include_gov_markers (bool): If True, Government band markers are added.
        include_markers (bool): If True, custom markers from MARKERS.csv are added.
        include_intermod_markers (bool): If True, intermodulation markers from INTERMOD.csv are added.
        output_html_path (str or None): If a string, saves the plot to this HTML file. If None, does not save.
        console_print_func (function): Function to print messages to the GUI console.
        scan_data_folder (str): The folder where scan data (and potentially MARKERS.csv/INTERMOD.csv) resides.
        MHZ_TO_HZ (float): The conversion factor from MHz to Hz.
        TV_BAND_MARKERS_MHZ (dict): Dictionary of TV band markers.
        GOVERNMENT_BAND_MARKERS_MHZ (dict): Dictionary of Government band markers.
        DEFAULT_MARKERS_FILE (str): Default filename for markers CSV.
        DEFAULT_INTERMOD_FILE (str): Default filename for intermodulation CSV.

    Outputs of this function:
        tuple: (go.Figure, str or None) - The Plotly figure object and the path to the saved HTML file (or None).

    (2025-07-31) Change: Simplified to be a wrapper for _create_spectrum_plot.
    (2025-08-01) Change: Added include_intermod_markers parameter.
    (2025-08-01) Change: Updated debug_print to debug_log.
    (2025-08-10) Change: Updated function signature to accept constants as arguments.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Plotting single scan data for '{plot_title}'...",
                file=__file__,
                version=current_version,
                function=current_function)

    data_traces = [{
        'df': df_scan,
        'name': 'Current Scan',
        'color': 'blue',
        'width': 2,
        'dash': 'solid',
        'show_legend': True,
        'y_column_name': 'Power (dBm)'
    }]

    fig, html_path = _create_spectrum_plot(
        data_traces,
        plot_title,
        include_tv_markers,
        include_gov_markers,
        include_markers,
        include_intermod_markers, # Pass the new parameter
        output_html_path,
        y_range_min_override=None,
        y_range_max_override=None,
        console_print_func=console_print_func,
        scan_data_folder=scan_data_folder,
        MHZ_TO_HZ=MHZ_TO_HZ,
        TV_BAND_MARKERS_MHZ=TV_BAND_MARKERS_MHZ,
        GOVERNMENT_BAND_MARKERS_MHZ=GOVERNMENT_BAND_MARKERS_MHZ,
        DEFAULT_MARKERS_FILE=DEFAULT_MARKERS_FILE,
        DEFAULT_INTERMOD_FILE=DEFAULT_INTERMOD_FILE
    )
    debug_log(f"Finished plotting single scan data for '{plot_title}'.",
                file=__file__,
                version=current_version,
                function=current_function)
    return fig, html_path


def plot_multi_trace_data(df_aggregated, plot_title, include_tv_markers, include_gov_markers,
                          include_markers, include_intermod_markers, historical_dfs_with_names,
                          individual_scan_dfs_with_names, output_html_path,
                          y_range_min_override, y_range_max_override, console_print_func,
                          scan_data_folder, MHZ_TO_HZ, TV_BAND_MARKERS_MHZ, GOVERNMENT_BAND_MARKERS_MHZ,
                          DEFAULT_MARKERS_FILE, DEFAULT_INTERMOD_FILE):
    """
    Function Description:
    Plots multiple traces on a single Plotly graph, including an aggregated trace (e.g., average)
    and optional historical or individual scan overlays. This is a wrapper around `_create_spectrum_plot`.

    Inputs to this function:
        df_aggregated (pd.DataFrame): DataFrame for the main aggregated trace (e.g., current average).
                                      Expected to have 'Frequency (Hz)' and other calculated columns.
        plot_title (str): The title for the plot.
        include_tv_markers (bool): If True, TV band markers are added.
        include_gov_markers (bool): If True, Government band markers are added.
        include_markers (bool): If True, custom markers from MARKERS.csv are added.
        include_intermod_markers (bool): If True, intermodulation markers from INTERMOD.csv are added.
        historical_dfs_with_names (list of tuples or None): List of (DataFrame, name) for historical overlays.
                                                            Each DataFrame should have 'Frequency (Hz)' and 'Power (dBm)'.
        individual_scan_dfs_with_names (list of tuples or None): List of (DataFrame, name) for individual scan overlays.
                                                                  Each DataFrame should have 'Frequency (Hz)' and 'Power (dBm)'.
        output_html_path (str or None): If a string, saves the plot to this HTML file. If None, does not save.
        y_range_min_override (float or None): Optional minimum Y-axis value.
        y_range_max_override (float or None): Optional maximum Y-axis value.
        console_print_func (function): Function to print messages to the GUI console.
        scan_data_folder (str): The folder where scan data (and potentially MARKERS.csv/INTERMOD.csv) resides.
        MHZ_TO_HZ (float): The conversion factor from MHz to Hz.
        TV_BAND_MARKERS_MHZ (dict): Dictionary of TV band markers.
        GOVERNMENT_BAND_MARKERS_MHZ (dict): Dictionary of Government band markers.
        DEFAULT_MARKERS_FILE (str): Default filename for markers CSV.
        DEFAULT_INTERMOD_FILE (str): Default filename for intermodulation CSV.

    Outputs of this function:
        tuple: (go.Figure, str or None) - The Plotly figure object and the path to the saved HTML file (or None).

    (2025-07-31) Change: Consolidated plotting logic into _create_spectrum_plot.
    (2025-07-31) Change: Added y_range_min_override and y_range_max_override parameters.
    (2025-08-01) Change: Added include_intermod_markers parameter.
    (2025-08-01) Change: Updated debug_print to debug_log.
    (2025-08-10) Change: Updated function signature to accept constants as arguments.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Plotting multi-trace data for '{plot_title}'...",
                file=__file__,
                version=current_version,
                function=current_function)

    data_traces = []

    # Add the main aggregated trace (e.g., Average, Median, etc.)
    # The y_column_name for the main aggregated trace will be the first data column after Frequency (Hz)
    # This assumes df_aggregated columns are ['Frequency (Hz)', 'Average', 'Median', ...]
    if not df_aggregated.empty and 'Frequency (Hz)' in df_aggregated.columns and len(df_aggregated.columns) > 1:
        # Get all columns except 'Frequency (Hz)' as y-axis columns
        y_cols = [col for col in df_aggregated.columns if col != 'Frequency (Hz)']
        for y_col in y_cols:
            data_traces.append({
                'df': df_aggregated,
                'name': y_col, # Use the column name as the trace name
                'color': px.colors.qualitative.Plotly[y_cols.index(y_col) % len(px.colors.qualitative.Plotly)], # Cycle through colors
                'width': 3,
                'dash': 'solid',
                'show_legend': True,
                'y_column_name': y_col # Specify the column to use for Y-axis
            })
        debug_log(f"Added aggregated trace(s) from columns: {y_cols}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
    else:
        debug_log("Aggregated DataFrame is empty or invalid. Skipping aggregated trace. Fucking useless!",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    # Add historical overlays if provided
    if historical_dfs_with_names:
        debug_log(f"Adding {len(historical_dfs_with_names)} historical overlays.",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        for i, (df_hist, name) in enumerate(historical_dfs_with_names):
            if not df_hist.empty and 'Frequency (Hz)' in df_hist.columns and 'Power (dBm)' in df_hist.columns:
                data_traces.append({
                    'df': df_hist,
                    'name': f'{name} (Historical)',
                    'color': f'rgba(100, 100, 100, {max(0, 0.8 - i * 0.1)})', # Faded gray for historical
                    'width': 1,
                    'dash': 'dot',
                    'show_legend': True,
                    'y_column_name': 'Power (dBm)' # Historical scans will have 'Power (dBm)'
                })
            else:
                debug_log(f"Skipping historical DF '{name}': Invalid DataFrame. What a pain!",
                            file=__file__,
                            version=current_version,
                            function=current_function)

    # Add individual scan overlays if provided
    if individual_scan_dfs_with_names:
        debug_log(f"Adding {len(individual_scan_dfs_with_names)} individual scan overlays.",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        for i, (df_scan_plot, name) in enumerate(individual_scan_dfs_with_names):
            debug_log(f"Preparing individual scan overlay: {name}",
                        file=__file__,
                        version=current_version,
                        function=current_function)

            if not df_scan_plot.empty and 'Frequency (Hz)' in df_scan_plot.columns and 'Power (dBm)' in df_scan_plot.columns:
                data_traces.append({
                    'df': df_scan_plot,
                    'name': f'{name} (Scan)',
                    'color': f'rgba(0, 200, 255, {max(0, 0.5 - i * 0.05)})', # Clamped alpha value
                    'width': 1,
                    'dash': 'dot',
                    'show_legend': True,
                    'y_column_name': 'Power (dBm)' # Individual scans will have 'Power (dBm)'
                })
            else:
                debug_log(f"Skipping individual scan DF '{name}': Invalid DataFrame. Fucking useless!",
                            file=__file__,
                            version=current_version,
                            function=current_function)

    if not data_traces:
        console_print_func("No valid data to plot in multi-trace function. This is a goddamn mess!")
        debug_log("No valid data traces prepared for multi-trace plot.",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        return None, None

    return _create_spectrum_plot(
        data_traces,
        plot_title,
        include_tv_markers,
        include_gov_markers,
        include_markers,
        include_intermod_markers, # Pass the new parameter
        output_html_path,
        y_range_min_override,
        y_range_max_override,
        console_print_func,
        scan_data_folder,
        MHZ_TO_HZ=MHZ_TO_HZ,
        TV_BAND_MARKERS_MHZ=TV_BAND_MARKERS_MHZ,
        GOVERNMENT_BAND_MARKERS_MHZ=GOVERNMENT_BAND_MARKERS_MHZ,
        DEFAULT_MARKERS_FILE=DEFAULT_MARKERS_FILE,
        DEFAULT_INTERMOD_FILE=DEFAULT_INTERMOD_FILE
    )


#####################################
### File: OPEN-AIR 2\workers\Plotting\utils_plotting_scans_over_time.py
#####################################
# utils/utils_plotting_scans_over_time.py
#
# This module provides a function for generating an interactive 3D Plotly plot
# of spectrum analyzer scan data over time. It visualizes frequency, amplitude,
# and the time of each scan, with amplitude color-coded based on user-defined
# thresholds.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250801.2245.1 (Refactored debug_print to use debug_log and console_log.)

current_version = "20250801.2245.1" # this variable should always be defined below the header to make the debugging better
current_version_hash = 20250801 * 2245 * 1 # Example hash, adjust as needed

import pandas as pd
import plotly.graph_objects as go
import plotly.colors as pcolors # For color scales
import webbrowser
import os
import re
import inspect
from datetime import datetime

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log

# Import constants from frequency_bands.py - CORRECTED PATH
try:
    from ref.ref_frequency_bands import MHZ_TO_HZ
except ImportError:
    debug_log("Error: frequency_bands.py not found in 'ref' or current directory. Using default MHZ_TO_HZ. This is a goddamn mess!",
                file=__file__,
                version=current_version,
                function=inspect.currentframe().f_code.co_name)
    MHZ_TO_HZ = 1_000_000 # Default fallback


def plot_Scans_over_time(grouped_csv_files, selected_group_prefix, output_folder,
                         amplitude_threshold_dbm, console_print_func):
    """
    Function Description:
    Generates an interactive 3D Plotly plot of spectrum analyzer scan data over time.
    It visualizes frequency, amplitude, and the time of each scan, with amplitude
    color-coded based on a user-defined threshold.

    Inputs to this function:
        grouped_csv_files (dict): A dictionary where keys are group prefixes (str) and values are
                                  lists of full file paths to CSV scan data.
        selected_group_prefix (str): The prefix of the group to be plotted.
        output_folder (str): The directory where the HTML plot file will be saved.
        amplitude_threshold_dbm (float): The amplitude threshold (in dBm) for color-coding.
        console_print_func (function): Function to print messages to the GUI console.

    Process of this function:
        1. Checks if the selected group exists and contains files.
        2. Initializes lists to store frequency, power, and time data.
        3. Iterates through each CSV file in the selected group:
           a. Reads the CSV into a Pandas DataFrame, assuming 'Frequency (Hz)' and 'Power (dBm)' columns.
           b. Extracts frequency, power, and a timestamp for each scan.
           c. Appends the data to the respective lists.
        4. Creates a Pandas DataFrame from the collected data (Frequency, Power, Time).
        5. Creates a 3D scatter plot using `plotly.graph_objects.Scatter3d`.
           - X-axis: Frequency (Hz)
           - Y-axis: Time (numerical representation for plotting)
           - Z-axis: Power (dBm)
           - Color: Based on `Power (dBm)` relative to `amplitude_threshold_dbm`.
        6. Configures the 3D plot layout (title, axis labels, camera settings).
        7. Saves the figure to an HTML file in the specified `output_folder`.
        8. Logs progress and errors to the console and debug log.

    Outputs of this function:
        tuple: (go.Figure, str or None) - The Plotly figure object and the path to the saved HTML file (or None).

    (2025-07-31) Change: Initial implementation for 3D plotting.
    (2025-08-01) Change: Updated debug_print to debug_log.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Entering {current_function} for group '{selected_group_prefix}' with threshold {amplitude_threshold_dbm} dBm.",
                file=__file__,
                version=current_version,
                function=current_function)

    files_to_plot = grouped_csv_files.get(selected_group_prefix)
    if not files_to_plot:
        console_print_func(f"Error: No files found for group '{selected_group_prefix}'. What the hell am I supposed to plot?!")
        debug_log(f"No files found for group '{selected_group_prefix}'. Fucking useless!",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        return None, None

    all_frequencies = []
    all_powers = []
    all_times = []
    time_labels = [] # To store human-readable time labels for hover text

    # Sort files by creation time to ensure correct time progression
    files_to_plot.sort(key=os.path.getctime)

    start_time = None

    for file_path in files_to_plot:
        try:
            df = pd.read_csv(file_path, header=None, names=['Frequency (Hz)', 'Power (dBm)'])
            # Extract timestamp from filename or file modification time
            # Assuming filename format like "PREFIX_YYYYMMDD_HHMMSS.csv" or similar
            filename = os.path.basename(file_path)
            match = re.search(r'(\d{8}_\d{6})', filename)
            if match:
                timestamp_str = match.group(1)
                scan_datetime = datetime.strptime(timestamp_str, '%Y%m%d_%H%M%S')
            else:
                # Fallback to file modification time if no timestamp in filename
                scan_datetime = datetime.fromtimestamp(os.path.getmtime(file_path))
                debug_log(f"No timestamp in filename for {filename}. Using file modification time. This is a bit of a mess!",
                            file=__file__,
                            version=current_version,
                            function=current_function)

            if start_time is None:
                start_time = scan_datetime

            # Calculate time difference in seconds from the first scan
            time_diff_seconds = (scan_datetime - start_time).total_seconds()

            all_frequencies.extend(df['Frequency (Hz)'].tolist())
            all_powers.extend(df['Power (dBm)'].tolist())
            all_times.extend([time_diff_seconds] * len(df))
            time_labels.extend([scan_datetime.strftime('%Y-%m-%d %H:%M:%S')] * len(df))

            debug_log(f"Processed file: {filename}, Scan Time: {scan_datetime.strftime('%H:%M:%S')}, Time Offset: {time_diff_seconds:.2f}s",
                        file=__file__,
                        version=current_version,
                        function=current_function)

        except Exception as e:
            console_print_func(f"❌ Error processing file {os.path.basename(file_path)} for 3D plot: {e}. This file is a stubborn bastard!")
            debug_log(f"Error processing {file_path} for 3D plot: {e}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            continue

    if not all_frequencies:
        console_print_func("No valid scan data found to create 3D plot. This is utterly useless!")
        debug_log("No valid scan data for 3D plot.",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        return None, None

    df_3d = pd.DataFrame({
        'Frequency (Hz)': all_frequencies,
        'Power (dBm)': all_powers,
        'Time (s)': all_times,
        'Time Label': time_labels
    })

    # Create a color scale based on the amplitude threshold
    colorscale = [
        [0, 'blue'], # Below threshold
        [max(0.0, (amplitude_threshold_dbm + 100) / 100), 'green'], # Around threshold (adjust 100 based on expected power range)
        [max(0.0, (amplitude_threshold_dbm + 50) / 100), 'yellow'],
        [max(0.0, (amplitude_threshold_dbm + 20) / 100), 'orange'],
        [1, 'red'] # Above threshold
    ]
    # Normalize the threshold to 0-1 range for colorscale mapping. Assuming power range -100 to 0 dBm
    # This might need adjustment based on typical power ranges.
    normalized_threshold = (amplitude_threshold_dbm + 100) / 100.0
    colorscale = [
        [0, 'blue'],
        [max(0.0, normalized_threshold - 0.05), 'green'], # Slightly below threshold
        [normalized_threshold, 'yellow'], # At threshold
        [min(1.0, normalized_threshold + 0.05), 'red'], # Slightly above threshold
        [1, 'darkred'] # Significantly above threshold
    ]
    # Ensure the colorscale points are ordered correctly
    colorscale.sort(key=lambda x: x[0])
    debug_log(f"Generated colorscale: {colorscale}",
                file=__file__,
                version=current_version,
                function=current_function)


    # Create the 3D scatter plot
    fig = go.Figure(data=[go.Scatter3d(
        x=df_3d['Frequency (Hz)'],
        y=df_3d['Time (s)'],
        z=df_3d['Power (dBm)'],
        mode='markers',
        marker=dict(
            size=3,
            color=df_3d['Power (dBm)'], # Color by power
            colorscale=colorscale, # Apply custom colorscale
            colorbar=dict(title='Power (dBm)'),
            cmin=-100, # Adjust based on expected min power
            cmax=0 # Adjust based on expected max power
        ),
        hoverinfo='text',
        hovertext=[
            f"Freq: {f/MHZ_TO_HZ:.3f} MHz<br>Power: {p:.2f} dBm<br>Time: {t_label}"
            for f, p, t_label in zip(df_3d['Frequency (Hz)'], df_3d['Power (dBm)'], df_3d['Time Label'])
        ]
    )])
    debug_log("Plotly 3D Scatter3d trace created.",
                file=__file__,
                version=current_version,
                function=current_function)

    # Update layout
    fig.update_layout(
        title={
            'text': f"3D Scans Over Time: {selected_group_prefix} (Threshold: {amplitude_threshold_dbm} dBm)",
            'y':0.9,
            'x':0.5,
            'xanchor': 'center',
            'yanchor': 'top'
        },
        scene=dict(
            xaxis_title='Frequency (Hz)',
            yaxis_title='Time (seconds from start)',
            zaxis_title='Power (dBm)',
            xaxis=dict(
                type='linear', # Can also be 'log' if frequencies span wide range
                tickformat=".3s", # Format ticks nicely
                tickangle=-45,
                nticks=10,
                backgroundcolor="#2d2d2d", # Dark background for axes
                gridcolor="#444444",
                zerolinecolor="#666666"
            ),
            yaxis=dict(
                type='linear',
                backgroundcolor="#2d2d2d",
                gridcolor="#444444",
                zerolinecolor="#666666"
            ),
            zaxis=dict(
                type='linear',
                backgroundcolor="#2d2d2d",
                gridcolor="#444444",
                zerolinecolor="#666666"
            ),
            camera=dict(
                eye=dict(x=1.5, y=1.5, z=1.5) # Initial camera position
            )
        ),
        paper_bgcolor="#222222", # Dark background for the plot area
        plot_bgcolor="#222222", # Dark background for the plot itself
        font=dict(color="#cccccc"), # Font color for titles, labels, etc.
        # Removed the legend dictionary entirely to turn off the legend
        margin=dict(l=50, r=50, t=80, b=50),
        height=None,
        width=None,
        autosize=True,
        showlegend=False # Explicitly set showlegend to False to turn off the legend
    )
    debug_log("Plotly 3D layout updated.",
                file=__file__,
                version=current_version,
                function=current_function)

    output_html_path = os.path.join(output_folder, f"{selected_group_prefix}_3D_Scans_Over_Time_{datetime.now().strftime('%Y%m%d_%H%M%S')}.html")

    if output_html_path:
        output_dir = os.path.dirname(output_html_path)
        if output_dir and not os.path.exists(output_dir):
            os.makedirs(output_dir)
            debug_log(f"Created directory for plot: {output_html_path}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        debug_log(f"Saving 3D plot to: {output_html_path}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        fig.write_html(output_html_path, auto_open=False)
        console_print_func(f"✅ 3D plot saved to: {output_html_path}. Fucking brilliant!")
        debug_log(f"✅ 3D plot saved to: {output_html_path}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
    else:
        debug_log("Output HTML path not provided, skipping saving 3D plot to file. What a waste!",
                    file=__file__,
                    version=current_version,
                    function=current_function)

    debug_log(f"Exiting {current_function}",
                file=__file__,
                version=current_version,
                function=current_function)
    return fig, output_html_path


#####################################
### File: OPEN-AIR 2\workers\Presets\TAB_PRESETS_PARENT.py
#####################################
# Presets/TAB_PRESETS_PARENT.py
#
# Version 20250821.222500.1 (Refactored for print statements)

import tkinter as tk
from tkinter import ttk
import inspect
import os

from .tab_presets_child_local import LocalPresetsTab
from .tab_presets_child_device import DevicePresetsTab
from .tab_presets_child_preset_editor import PresetEditorTab

current_version = "20250821.222500.1"

class TAB_PRESETS_PARENT(ttk.Frame):
    def __init__(self, parent, app_instance):
        super().__init__(parent)
        self.app_instance = app_instance
        self._create_widgets()

    def _create_widgets(self):
        self.child_notebook = ttk.Notebook(self, style='Presets.Child.TNotebook')
        self.child_notebook.pack(expand=True, fill="both", padx=5, pady=5)
        self.local_presets_tab = LocalPresetsTab(self.child_notebook, self.app_instance)
        self.device_presets_tab = DevicePresetsTab(self.child_notebook, self.app_instance)
        self.preset_editor_tab = PresetEditorTab(self.child_notebook, self.app_instance)
        self.child_notebook.add(self.local_presets_tab, text="Local Presets")
        self.child_notebook.add(self.device_presets_tab, text="Device Presets")
        self.child_notebook.add(self.preset_editor_tab, text="Preset Editor")
        self.child_notebook.bind("<<NotebookTabChanged>>", self._on_child_tab_selected)

    def _on_child_tab_selected(self, event):
        print(f"Presets child tab selected.")
        selected_tab_id = self.child_notebook.select()
        if selected_tab_id:
            widget = self.child_notebook.nametowidget(selected_tab_id)
            if hasattr(widget, '_on_tab_selected'):
                widget._on_tab_selected(event)

    def _on_parent_tab_selected(self, event):
        print(f"Presets Parent tab selected.")
        selected_tab_id = self.child_notebook.select()
        if selected_tab_id:
            widget = self.child_notebook.nametowidget(selected_tab_id)
            if hasattr(widget, '_on_tab_selected'):
                widget._on_tab_selected(event)

#####################################
### File: OPEN-AIR 2\workers\Presets\tab_presets_child_device.py
#####################################
# tabs/Presets/tab_presets_child_device.py
#
# This file defines the DevicePresetsTab, a Tkinter Frame that provides
# functionality for managing instrument-defined presets. It allows querying
# presets from the connected instrument and loading selected presets.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.173331.1
# UPDATED: Refactored logic to break circular dependencies by moving the core load preset logic 
#          to `utils_preset_query_and_load.py` and importing push_preset_logic lazily.

import tkinter as tk
from tkinter import ttk, filedialog, simpledialog
import inspect
import os
import csv
from datetime import datetime

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log
from src.program_style import COLOR_PALETTE

# Import functions from preset utility modules
from Presets.utils_preset_csv_process import load_user_presets_from_csv, overwrite_user_presets_csv
from Presets.utils_preset_query_and_load import query_device_presets_logic, load_selected_preset_logic
from Instrument.connection.instrument_logic import query_current_settings_logic

# --- Versioning ---
w = 20250821
x_str = '173331'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = f"{os.path.basename(__file__)}"


class DevicePresetsTab(ttk.Frame):
    def __init__(self, parent, app_instance, console_print_func, style_obj, *args, **kwargs):
        super().__init__(parent, *args, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func
        self.style_obj = style_obj
        self.cached_user_presets = {}

        self.create_widgets()
        self.setup_layout()
        self.bind_events()

        is_connected = self.app_instance.inst is not None
        instrument_model = self.app_instance.connected_instrument_model.get() if hasattr(self.app_instance, 'connected_instrument_model') else ""
        self._on_connection_status_changed(is_connected, instrument_model)

        debug_log(f"DevicePresetsTab initialized. Version: {current_version}",
                    file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)

    def create_widgets(self):
        self.device_presets_frame = ttk.LabelFrame(self, text="Device Presets", style='Custom.TLabelframe')
        self.device_presets_frame.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")

        self.query_device_presets_button = ttk.Button(self.device_presets_frame,
                                                    text="Query Device Presets",
                                                    command=self._query_and_populate_device_presets,
                                                    style='TButton')
        self.query_device_presets_button.grid(row=0, column=0, padx=5, pady=5, sticky="ew")
        self.query_device_presets_button.config(state=tk.DISABLED)

        self.device_preset_listbox_label = ttk.Label(self.device_presets_frame, text="Available Device Presets:")
        self.device_preset_listbox_label.grid(row=1, column=0, padx=5, pady=2, sticky="w")

        self.device_preset_listbox_frame = ttk.Frame(self.device_presets_frame, style='TFrame')
        self.device_preset_listbox_frame.grid(row=2, column=0, padx=5, pady=5, sticky="nsew")

        self.device_preset_listbox = tk.Listbox(self.device_preset_listbox_frame, height=10, width=50,
                                                selectmode=tk.SINGLE, exportselection=False,
                                                bg=COLOR_PALETTE.get('input_bg'),
                                                fg=COLOR_PALETTE.get('input_fg'),
                                                selectbackground=COLOR_PALETTE.get('select_bg'),
                                                selectforeground=COLOR_PALETTE.get('select_fg'))
        self.device_preset_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        self.device_preset_scrollbar = ttk.Scrollbar(self.device_preset_listbox_frame, orient="vertical", command=self.device_preset_listbox.yview)
        self.device_preset_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.device_preset_listbox.config(yscrollcommand=self.device_preset_scrollbar.set)

        self.load_device_preset_button = ttk.Button(self.device_presets_frame,
                                                    text="Load Selected Device Preset",
                                                    command=self._load_selected_device_preset,
                                                    style='TButton')
        self.load_device_preset_button.grid(row=3, column=0, padx=5, pady=5, sticky="ew")
        self.load_device_preset_button.config(state=tk.DISABLED)

        self.save_current_frame = ttk.LabelFrame(self, text="Save Current Instrument Settings as User Preset", style='Custom.TLabelframe')
        self.save_current_frame.grid(row=4, column=0, padx=10, pady=10, sticky="ew")

        self.filename_label = ttk.Label(self.save_current_frame, text="Filename (e.g., MY_PRESET.STA):")
        self.filename_label.grid(row=0, column=0, padx=5, pady=2, sticky="w")
        self.filename_entry = ttk.Entry(self.save_current_frame, style='TEntry')
        self.filename_entry.grid(row=0, column=1, padx=5, pady=2, sticky="ew")

        self.nickname_label = ttk.Label(self.save_current_frame, text="Nickname (optional):")
        self.nickname_label.grid(row=1, column=0, padx=5, pady=2, sticky="w")
        self.nickname_entry = ttk.Entry(self.save_current_frame, style='TEntry')
        self.nickname_entry.grid(row=1, column=1, padx=5, pady=2, sticky="ew")

        self.save_current_button = ttk.Button(self.save_current_frame,
                                            text="Save Current Settings to PRESETS.CSV",
                                            command=self.save_current_settings_as_user_preset,
                                            style='TButton')
        self.save_current_button.grid(row=2, column=0, columnspan=2, padx=5, pady=5, sticky="ew")
        self.save_current_button.config(state=tk.DISABLED)

    def setup_layout(self):
        self.grid_rowconfigure(0, weight=1)
        self.grid_columnconfigure(0, weight=1)
        self.device_presets_frame.grid_columnconfigure(0, weight=1)
        self.device_preset_listbox_frame.grid_columnconfigure(0, weight=1)
        self.save_current_frame.grid_columnconfigure(1, weight=1)

    def bind_events(self):
        self.device_preset_listbox.bind("<<ListboxSelect>>", self._on_device_preset_select)
        self.app_instance.bind("<<ConnectionStatusChanged>>", self._handle_connection_status_change_event)

    def _handle_connection_status_change_event(self, event=None):
        is_connected = self.app_instance.inst is not None
        instrument_model = self.app_instance.connected_instrument_model.get() if hasattr(self.app_instance, 'connected_instrument_model') else ""
        self._on_connection_status_changed(is_connected, instrument_model)

    def _on_connection_status_changed(self, is_connected, instrument_model):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Connection status changed event received in DevicePresetsTab: Connected={is_connected}, Model={instrument_model}. Updating UI state.",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        if is_connected and "N9342CN" in instrument_model:
            self.query_device_presets_button.config(state=tk.NORMAL)
            self.load_device_preset_button.config(state=tk.NORMAL)
            self.save_current_button.config(state=tk.NORMAL)
            if not self.device_preset_listbox.get(0, tk.END):
                self._query_and_populate_device_presets()
        else:
            self.query_device_presets_button.config(state=tk.DISABLED)
            self.load_device_preset_button.config(state=tk.DISABLED)
            self.save_current_button.config(state=tk.DISABLED)
            self._populate_device_preset_listboxes([])
            self.console_print_func("⚠️ Query Device Presets button disabled (not connected or not N9342CN).")

    def _query_and_populate_device_presets(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Querying device presets. Getting the list of presets from the instrument. Version: {current_version}",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        if self.app_instance.inst:
            presets = query_device_presets_logic(self.app_instance, self.console_print_func)
            self._populate_device_preset_listboxes(presets)
            if presets:
                self.console_print_func(f"✅ Found {len(presets)} device presets.")
            else:
                self.console_print_func("ℹ️ No device presets found or instrument does not support preset querying.")
        else:
            self.console_print_func("❌ Instrument not connected. Cannot query device presets.")
            debug_log("Instrument not connected. Cannot query device presets. What a mess!",
                        file=current_file,
                        version=current_version,
                        function=current_function)

    def _populate_device_preset_listboxes(self, presets):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Populating device preset listbox with {len(presets)} entries. Filling up the display!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        self.device_preset_listbox.delete(0, tk.END)
        for preset in presets:
            self.device_preset_listbox.insert(tk.END, preset)
        debug_log("Device preset listbox populated.",
                    file=current_file,
                    version=current_version,
                    function=current_function)

    def _on_device_preset_select(self, event):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Device preset selected event triggered. Let's see what's chosen! Version: {current_version}",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        if self.device_preset_listbox.curselection():
            self.load_device_preset_button.config(state=tk.NORMAL)
        else:
            self.load_device_preset_button.config(state=tk.DISABLED)
        debug_log("Device preset selection handled.",
                    file=current_file,
                    version=current_version,
                    function=current_function)

    def _load_selected_device_preset(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Loading selected device preset. Applying the magic! Version: {current_version}",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        selected_index = self.device_preset_listbox.curselection()
        if selected_index:
            selected_preset_name = self.device_preset_listbox.get(selected_index[0])
            self.console_print_func(f"Attempting to load device preset: {selected_preset_name}...")
            # Use the new centralized logic function
            success = load_selected_preset_logic(
                app_instance=self.app_instance,
                selected_preset_name=selected_preset_name,
                console_print_func=self.console_print_func,
                is_device_preset=True
            )
            if success:
                self.console_print_func(f"✅ Successfully loaded device preset: {selected_preset_name}.")
                debug_log(f"Device preset '{selected_preset_name}' loaded successfully. Good job!",
                            file=current_file,
                            version=current_version,
                            function=current_function)
            else:
                self.console_print_func(f"❌ Failed to load device preset: {selected_preset_name}. Something went wrong!")
                debug_log(f"Failed to load device preset '{selected_preset_name}'. This is a disaster!",
                            file=current_file,
                            version=current_version,
                            function=current_function)
        else:
            self.console_print_func("⚠️ No device preset selected to load. Pick one!")
            debug_log("No device preset selected to load.",
                        file=current_file,
                        version=current_version,
                        function=current_function)

    def save_current_settings_as_user_preset(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Saving current settings as user preset. Getting all the goodies! Version: {current_version}",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        filename = self.filename_entry.get().strip()
        nickname = self.nickname_entry.get().strip()

        if not filename:
            self.console_print_func("❌ Filename cannot be empty. Please enter a filename.")
            debug_log("Filename for new preset was empty. User needs to provide one.",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return

        if not filename.endswith(".STA"):
            filename += ".STA"
        
        # LAZY IMPORT: Imports moved here to break circular dependency
        from Presets.utils_push_preset import push_preset_logic

        current_settings = query_current_settings_logic(self.app_instance, self.console_print_func)
        if not current_settings:
            self.console_print_func("❌ Could not retrieve current instrument settings to save.")
            debug_log("Failed to retrieve current instrument settings. Cannot save preset.",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return

        new_preset = {
            'Filename': filename,
            'NickName': nickname,
            'Center': str(current_settings.get('center_freq_hz', 0.0)),
            'Span': str(current_settings.get('span_freq_hz', 0.0)),
            'RBW': str(current_settings.get('rbw_hz', 0.0)),
            'VBW': str(current_settings.get('vbw_hz', '')),
            'RefLevel': str(current_settings.get('ref_level_dbm', '')),
            'Attenuation': str(current_settings.get('attenuation_db', '')),
            'MaxHold': current_settings.get('max_hold_enabled', 'OFF'),
            'HighSens': current_settings.get('high_sensitivity_enabled', 'OFF'),
            'PreAmp': current_settings.get('preamp_enabled', 'OFF'),
            'Trace1Mode': current_settings.get('trace1_mode', ''),
            'Trace2Mode': current_settings.get('trace2_mode', ''),
            'Trace3Mode': current_settings.get('trace3_mode', ''),
            'Trace4Mode': current_settings.get('trace4_mode', ''),
            'Marker1Max': str(current_settings.get('marker1_max', '')),
            'Marker2Max': str(current_settings.get('marker2_max', '')),
            'Marker3Max': str(current_settings.get('marker3_max', '')),
            'Marker4Max': str(current_settings.get('marker4_max', '')),
            'Marker5Max': str(current_settings.get('marker5_max', '')),
            'Marker6Max': str(current_settings.get('marker6_max', ''))
        }

        all_presets = load_user_presets_from_csv(self.app_instance.CONFIG_FILE_PATH, self.console_print_func)

        existing_index = -1
        for i, preset in enumerate(all_presets):
            if preset.get('Filename') == filename:
                existing_index = i
                break

        if existing_index != -1:
            if tk.messagebox.askyesno("Overwrite Preset",
                                    f"A preset with filename '{filename}' already exists. Do you want to overwrite it?",
                                    parent=self):
                all_presets[existing_index] = new_preset
                self.console_print_func(f"ℹ️ Overwriting existing preset: {filename}.")
                debug_log(f"User confirmed overwrite for preset: {filename}",
                            file=current_file,
                            version=current_version,
                            function=current_function)
            else:
                self.console_print_func("ℹ️ Preset save cancelled by user.")
                debug_log("User cancelled preset overwrite.",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return
        else:
            all_presets.append(new_preset)
            self.console_print_func(f"ℹ️ Adding new preset: {filename}.")
            debug_log(f"Adding new preset: {filename}",
                        file=current_file,
                        version=current_version,
                        function=current_function)

        if overwrite_user_presets_csv(self.app_instance.CONFIG_FILE_PATH, all_presets, self.console_print_func):
            self.console_print_func(f"✅ Preset '{filename}' saved successfully to PRESETS.CSV!")
            debug_log(f"Preset '{filename}' saved to CSV. All good!",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            self.filename_entry.delete(0, tk.END)
            self.nickname_entry.delete(0, tk.END)
        else:
            self.console_print_func(f"❌ Failed to save preset '{filename}'. Check console for errors.")
            debug_log(f"Failed to save preset '{filename}'. This is a nightmare!",
                        file=current_file,
                        version=current_version,
                        function=current_function)

    def __load_selected_preset_logic(self, selected_preset_name, is_device_preset=True, preset_data_dict=None):
        return load_selected_preset_logic(self.app_instance, selected_preset_name, self.console_print_func, is_device_preset, preset_data_dict)

#####################################
### File: OPEN-AIR 2\workers\Presets\tab_presets_child_local.py
#####################################
# tabs/Presets/tab_presets_child_local.py
#
# This file defines the LocalPresetsTab, a Tkinter Frame that provides
# functionality for displaying and loading user-defined presets stored
# locally in a CSV file. It does NOT include direct editing capabilities;
# editing is handled in the separate PresetEditorTab.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.173331.1
# UPDATED: Refactored logic to break circular dependencies by using a shared load preset logic
#          file and importing push_preset_logic lazily.

import tkinter as tk
from tkinter import ttk
import inspect
import os

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log

# Import functions from preset utility modules
from Presets.utils_preset_csv_process import load_user_presets_from_csv
from src.program_style import COLOR_PALETTE
from settings_and_config.config_manager_save import save_program_config 
from ref.ref_file_paths import CONFIG_FILE_PATH, PRESETS_FILE_PATH
from Presets.utils_preset_query_and_load import load_selected_preset_logic

# --- Versioning ---
w = 20250821
x_str = '173331'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = f"{os.path.basename(__file__)}"


class LocalPresetsTab(ttk.Frame):
    """
    A Tkinter Frame for displaying and loading user-defined local presets.
    It lists presets from PRESETS.CSV as a grid of buttons and allows the user
    to load them, which updates the main application's instrument settings
    and pushes them to the connected instrument.
    """

    def __init__(self, master=None, app_instance=None, console_print_func=None, style_obj=None, **kwargs):
        filtered_kwargs = {k: v for k, v in kwargs.items() if k != 'style_obj'}
        super().__init__(master, **filtered_kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func
        self.style_obj = style_obj

        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Initializing LocalPresetsTab. Version: {current_version}. Setting up local preset display! 💾", file=current_file,
                    version=current_version,
                    function=current_function)

        self.user_presets_data = []
        self.last_clicked_button = None
        
        self.selected_preset_nickname_var = tk.StringVar(self, value="N/A")
        self.selected_preset_start_var = tk.StringVar(self, value="N/A")
        self.selected_preset_stop_var = tk.StringVar(self, value="N/A")
        self.selected_preset_center_var = tk.StringVar(self, value="N/A")
        self.selected_preset_span_var = tk.StringVar(self, value="N/A")
        self.selected_preset_rbw_var = tk.StringVar(self, value="N/A")
        self.selected_preset_vbw_var = tk.StringVar(self, value="N/A")
        self.selected_preset_reflevel_var = tk.StringVar(self, value="N/A")
        self.selected_preset_attenuation_var = tk.StringVar(self, value="N/A")
        self.selected_preset_maxhold_var = tk.StringVar(self, value="N/A")
        self.selected_preset_highsens_var = tk.StringVar(self, value="N/A")
        self.selected_preset_preamp_var = tk.StringVar(self, value="N/A")
        self.selected_preset_trace1_var = tk.StringVar(self, value="N/A")
        self.selected_preset_trace2_var = tk.StringVar(self, value="N/A")
        self.selected_preset_trace3_var = tk.StringVar(self, value="N/A")
        self.selected_preset_trace4_var = tk.StringVar(self, value="N/A")
        self.selected_preset_marker1_var = tk.StringVar(self, value="N/A")
        self.selected_preset_marker2_var = tk.StringVar(self, value="N/A")
        self.selected_preset_marker3_var = tk.StringVar(self, value="N/A")
        self.selected_preset_marker4_var = tk.StringVar(self, value="N/A")
        self.selected_preset_marker5_var = tk.StringVar(self, value="N/A")
        self.selected_preset_marker6_var = tk.StringVar(self, value="N/A")
        
        self.display_variables_map = {
            'NickName': self.selected_preset_nickname_var,
            'Start': self.selected_preset_start_var,
            'Stop': self.selected_preset_stop_var,
            'Center': self.selected_preset_center_var,
            'Span': self.selected_preset_span_var,
            'RBW': self.selected_preset_rbw_var,
            'VBW': self.selected_preset_vbw_var,
            'RefLevel': self.selected_preset_reflevel_var,
            'Attenuation': self.selected_preset_attenuation_var,
            'MaxHold': self.selected_preset_maxhold_var,
            'HighSens': self.selected_preset_highsens_var,
            'PreAmp': self.selected_preset_preamp_var,
            'Trace1Mode': self.selected_preset_trace1_var,
            'Trace2Mode': self.selected_preset_trace2_var,
            'Trace3Mode': self.selected_preset_trace3_var,
            'Trace4Mode': self.selected_preset_trace4_var,
            'Marker1Max': self.selected_preset_marker1_var,
            'Marker2Max': self.selected_preset_marker2_var,
            'Marker3Max': self.selected_preset_marker3_var,
            'Marker4Max': self.selected_preset_marker4_var,
            'Marker5Max': self.selected_preset_marker5_var,
            'Marker6Max': self.selected_preset_marker6_var,
        }

        self._create_widgets()
        self.populate_local_presets_list()

        debug_log(f"LocalPresetsTab initialized. Version: {current_version}. Local presets ready! ✅", file=current_file,
                    version=current_version,
                    function=current_function)

    def _create_widgets(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log("Creating LocalPresetsTab widgets...", file=current_file,
                    version=current_version,
                    function=current_function)

        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(0, weight=1)
        self.grid_rowconfigure(1, weight=0)

        self.canvas = tk.Canvas(self, bg=COLOR_PALETTE.get('background'), highlightthickness=0)
        self.scrollbar = ttk.Scrollbar(self, orient="vertical", command=self.canvas.yview)
        self.scrollable_frame = ttk.Frame(self.canvas, style='Dark.TFrame')

        self.scrollable_frame.bind(
            "<Configure>",
            lambda e: self.canvas.configure(
                scrollregion=self.canvas.bbox("all")
            )
        )

        self.canvas_window = self.canvas.create_window((0, 0), window=self.scrollable_frame, anchor="nw")

        self.canvas.configure(yscrollcommand=self.scrollbar.set)

        self.canvas.grid(row=0, column=0, sticky="nsew")
        self.scrollbar.grid(row=0, column=1, sticky="ns")

        self.canvas.bind('<Enter>', lambda e: self.canvas.bind_all("<MouseWheel>", self._on_mousewheel))
        self.canvas.bind('<Leave>', lambda e: self.canvas.unbind_all("<MouseWheel>"))

        self.max_cols = 5
        for i in range(self.max_cols):
            self.scrollable_frame.grid_columnconfigure(i, weight=1)

        selected_preset_box = ttk.LabelFrame(self, text="Selected Preset Details", style='Dark.TLabelframe')
        selected_preset_box.grid(row=1, column=0, padx=10, pady=10, sticky="ew")
        
        details_grid_frame = ttk.Frame(selected_preset_box)
        details_grid_frame.pack(fill="both", expand=True, padx=5, pady=5)
        details_grid_frame.grid_columnconfigure(1, weight=1)

        details_grid_frame.grid_columnconfigure(0, weight=1)
        details_grid_frame.grid_columnconfigure(1, weight=1)
        details_grid_frame.grid_columnconfigure(2, weight=1)
        details_grid_frame.grid_columnconfigure(3, weight=1)

        row_idx = 0
        ttk.Label(details_grid_frame, text="Nickname:", style='TLabel').grid(row=row_idx, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_nickname_var, style='Dark.TLabel.Value').grid(row=row_idx, column=1, padx=5, pady=2, sticky="ew", columnspan=3)

        row_idx += 1
        ttk.Separator(details_grid_frame, orient=tk.HORIZONTAL).grid(row=row_idx, column=0, columnspan=4, sticky="ew", pady=5)
        row_idx += 1
        ttk.Label(details_grid_frame, text="Frequency Settings", style='Dark.TLabel.Value').grid(row=row_idx, column=0, columnspan=4, sticky="ew")

        row_idx += 1
        ttk.Label(details_grid_frame, text="Start (MHz):", style='TLabel').grid(row=row_idx, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_start_var, style='Dark.TLabel.Value').grid(row=row_idx, column=1, padx=5, pady=2, sticky="ew")
        ttk.Label(details_grid_frame, text="Stop (MHz):", style='TLabel').grid(row=row_idx, column=2, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_stop_var, style='Dark.TLabel.Value').grid(row=row_idx, column=3, padx=5, pady=2, sticky="ew")
        
        row_idx += 1
        ttk.Label(details_grid_frame, text="Center (MHz):", style='TLabel').grid(row=row_idx, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_center_var, style='Dark.TLabel.Value').grid(row=row_idx, column=1, padx=5, pady=2, sticky="ew")
        ttk.Label(details_grid_frame, text="Span (MHz):", style='TLabel').grid(row=row_idx, column=2, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_span_var, style='Dark.TLabel.Value').grid(row=row_idx, column=3, padx=5, pady=2, sticky="ew")
        
        row_idx += 1
        ttk.Separator(details_grid_frame, orient=tk.HORIZONTAL).grid(row=row_idx, column=0, columnspan=4, sticky="ew", pady=5)
        row_idx += 1
        ttk.Label(details_grid_frame, text="Bandwidth Settings", style='Dark.TLabel.Value').grid(row=row_idx, column=0, columnspan=4, sticky="ew")

        row_idx += 1
        ttk.Label(details_grid_frame, text="RBW (Hz):", style='TLabel').grid(row=row_idx, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_rbw_var, style='Dark.TLabel.Value').grid(row=row_idx, column=1, padx=5, pady=2, sticky="ew")
        ttk.Label(details_grid_frame, text="VBW (Hz):", style='TLabel').grid(row=row_idx, column=2, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_vbw_var, style='Dark.TLabel.Value').grid(row=row_idx, column=3, padx=5, pady=2, sticky="ew")

        row_idx += 1
        ttk.Separator(details_grid_frame, orient=tk.HORIZONTAL).grid(row=row_idx, column=0, columnspan=4, sticky="ew", pady=5)
        row_idx += 1
        ttk.Label(details_grid_frame, text="Amplitude Settings", style='Dark.TLabel.Value').grid(row=row_idx, column=0, columnspan=4, sticky="ew")

        row_idx += 1
        ttk.Label(details_grid_frame, text="Ref Level:", style='TLabel').grid(row=row_idx, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_reflevel_var, style='Dark.TLabel.Value').grid(row=row_idx, column=1, padx=5, pady=2, sticky="ew")
        ttk.Label(details_grid_frame, text="Attenuation:", style='TLabel').grid(row=row_idx, column=2, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_attenuation_var, style='Dark.TLabel.Value').grid(row=row_idx, column=3, padx=5, pady=2, sticky="ew")

        row_idx += 1
        ttk.Label(details_grid_frame, text="Max Hold:", style='TLabel').grid(row=row_idx, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_maxhold_var, style='Dark.TLabel.Value').grid(row=row_idx, column=1, padx=5, pady=2, sticky="ew")
        ttk.Label(details_grid_frame, text="High Sens.:", style='TLabel').grid(row=row_idx, column=2, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_highsens_var, style='Dark.TLabel.Value').grid(row=row_idx, column=3, padx=5, pady=2, sticky="ew")
        
        row_idx += 1
        ttk.Label(details_grid_frame, text="PreAmp:", style='TLabel').grid(row=row_idx, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_preamp_var, style='Dark.TLabel.Value').grid(row=row_idx, column=1, padx=5, pady=2, sticky="ew")
        
        row_idx += 1
        ttk.Separator(details_grid_frame, orient=tk.HORIZONTAL).grid(row=row_idx, column=0, columnspan=4, sticky="ew", pady=5)
        row_idx += 1
        ttk.Label(details_grid_frame, text="Trace Modes", style='Dark.TLabel.Value').grid(row=row_idx, column=0, columnspan=4, sticky="ew")
        
        row_idx += 1
        ttk.Label(details_grid_frame, text="T1 Mode:", style='TLabel').grid(row=row_idx, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_trace1_var, style='Dark.TLabel.Value').grid(row=row_idx, column=1, padx=5, pady=2, sticky="ew")
        ttk.Label(details_grid_frame, text="T2 Mode:", style='TLabel').grid(row=row_idx, column=2, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_trace2_var, style='Dark.TLabel.Value').grid(row=row_idx, column=3, padx=5, pady=2, sticky="ew")
        
        row_idx += 1
        ttk.Label(details_grid_frame, text="T3 Mode:", style='TLabel').grid(row=row_idx, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_trace3_var, style='Dark.TLabel.Value').grid(row=row_idx, column=1, padx=5, pady=2, sticky="ew")
        ttk.Label(details_grid_frame, text="T4 Mode:", style='TLabel').grid(row=row_idx, column=2, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_trace4_var, style='Dark.TLabel.Value').grid(row=row_idx, column=3, padx=5, pady=2, sticky="ew")

        row_idx += 1
        ttk.Separator(details_grid_frame, orient=tk.HORIZONTAL).grid(row=row_idx, column=0, columnspan=4, sticky="ew", pady=5)
        row_idx += 1
        ttk.Label(details_grid_frame, text="Marker Settings", style='Dark.TLabel.Value').grid(row=row_idx, column=0, columnspan=4, sticky="ew")
        
        row_idx += 1
        ttk.Label(details_grid_frame, text="M1 Max:", style='TLabel').grid(row=row_idx, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_marker1_var, style='Dark.TLabel.Value').grid(row=row_idx, column=1, padx=5, pady=2, sticky="ew")
        ttk.Label(details_grid_frame, text="M2 Max:", style='TLabel').grid(row=row_idx, column=2, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_marker2_var, style='Dark.TLabel.Value').grid(row=row_idx, column=3, padx=5, pady=2, sticky="ew")

        row_idx += 1
        ttk.Label(details_grid_frame, text="M3 Max:", style='TLabel').grid(row=row_idx, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_marker3_var, style='Dark.TLabel.Value').grid(row=row_idx, column=1, padx=5, pady=2, sticky="ew")
        ttk.Label(details_grid_frame, text="M4 Max:", style='TLabel').grid(row=row_idx, column=2, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_marker4_var, style='Dark.TLabel.Value').grid(row=row_idx, column=3, padx=5, pady=2, sticky="ew")

        row_idx += 1
        ttk.Label(details_grid_frame, text="M5 Max:", style='TLabel').grid(row=row_idx, column=0, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_marker5_var, style='Dark.TLabel.Value').grid(row=row_idx, column=1, padx=5, pady=2, sticky="ew")
        ttk.Label(details_grid_frame, text="M6 Max:", style='TLabel').grid(row=row_idx, column=2, padx=5, pady=2, sticky="w")
        ttk.Label(details_grid_frame, textvariable=self.selected_preset_marker6_var, style='Dark.TLabel.Value').grid(row=row_idx, column=3, padx=5, pady=2, sticky="ew")

        debug_log("LocalPresetsTab widgets created. Scrollable button container and details box ready! 🖼️", file=current_file,
                    version=current_version,
                    function=current_function)

    def _on_mousewheel(self, event):
        self.canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        debug_log(f"Mouse wheel scrolled by {event.delta} units. Adjusting canvas view.", file=current_file,
                    version=current_version,
                    function=inspect.currentframe().f_code.co_name)

    def populate_local_presets_list(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log("Populating local presets buttons...", file=current_file,
                    version=current_version,
                    function=current_function)

        for widget in self.scrollable_frame.winfo_children():
            widget.destroy()
        
        self.last_clicked_button = None
        for var in self.display_variables_map.values():
            var.set("N/A")

        self.user_presets_data = load_user_presets_from_csv(PRESETS_FILE_PATH, self.console_print_func)

        if not self.user_presets_data:
            ttk.Label(self.scrollable_frame, text="No local presets found.", style='TLabel').grid(row=0, column=0, columnspan=self.max_cols, padx=10, pady=10)
            self.console_print_func("ℹ️ No local presets found in PRESETS.CSV.")
            debug_log("No local presets found. 🤷‍♂️", file=current_file,
                        version=current_version,
                        function=current_function)
            return

        row_idx = 0
        col_idx = 0
        
        for preset in self.user_presets_data:
            nickname = preset.get('NickName', preset.get('Filename', 'Unnamed Preset'))
            
            start_freq_mhz_display = "N/A"
            stop_freq_mhz_display = "N/A"
            try:
                if preset.get('Start', '').strip():
                    start_freq_mhz_display = f"{float(preset.get('Start')):.3f}"
                if preset.get('Stop', '').strip():
                    stop_freq_mhz_display = f"{float(preset.get('Stop')):.3f}"
            except ValueError:
                debug_log(f"Warning: Could not convert Start/Stop for button text for preset '{nickname}'. What a mess!", file=current_file,
                            version=current_version,
                            function=current_function)

            button_text = f"{nickname}\nStart: {start_freq_mhz_display} MHz\nStop: {stop_freq_mhz_display} MHz"

            preset_button = ttk.Button(self.scrollable_frame,
                                       text=button_text,
                                       command=lambda p=preset, b=None: self._on_preset_button_click(p, b),
                                       style='LocalPreset.TButton')
            
            preset_button.configure(command=lambda p=preset, b=preset_button: self._on_preset_button_click(p, b))

            preset_button.grid(row=row_idx, column=col_idx, padx=5, pady=5, sticky="nsew")

            col_idx += 1
            if col_idx >= self.max_cols:
                col_idx = 0
                row_idx += 1
        
        self.canvas.update_idletasks()
        self.canvas.config(scrollregion=self.canvas.bbox("all"))

        self.console_print_func(f"✅ Displayed {len(self.user_presets_data)} local presets as buttons.")
        debug_log(f"Local presets buttons populated with {len(self.user_presets_data)} entries. Looking good! 👍", file=current_file,
                    version=current_version,
                    function=current_function)

    def _on_preset_button_click(self, preset_data, clicked_button):
        current_function = inspect.currentframe().f_code.co_name
        display_name = preset_data.get('NickName', preset_data.get('Filename', 'Unnamed Preset'))
        self.console_print_func(f"Attempting to load and apply preset: {display_name}...")
        debug_log(f"Preset button clicked for: {display_name}. Applying settings to GUI and instrument. 🖱️", file=current_file,
                    version=current_version,
                    function=current_function)

        if self.last_clicked_button and self.last_clicked_button != clicked_button:
            self.last_clicked_button.config(style='LocalPreset.TButton')
            debug_log(f"Reset style of previous button: {self.last_clicked_button.cget('text').splitlines()[0]}", file=current_file,
                        version=current_version,
                        function=current_function)

        clicked_button.config(style='SelectedPreset.Orange.TButton')
        self.last_clicked_button = clicked_button
        debug_log(f"Set style of current button to orange: {display_name}", file=current_file,
                    version=current_version,
                    function=current_function)

        self.app_instance.defer_config_save = True
        debug_log("Config saving deferred. GUI updates won't trigger saves yet. 🛑", file=current_file,
                    version=current_version,
                    function=current_function)

        success_push_to_instrument = False
        if not self.app_instance.inst:
            self.console_print_func("⚠️ Instrument not connected. Settings will be applied to GUI only.")
            debug_log("Instrument not connected. Skipping SCPI commands. GUI only update. 🖥️", file=current_file,
                        version=current_version,
                        function=current_function)
            self._update_gui_from_preset_data(preset_data)
        else:
            self._update_gui_from_preset_data(preset_data)
            debug_log(f"Instrument is connected ({self.app_instance.inst}). Attempting to push preset to device. ⚡", file=current_file,
                        version=current_version,
                        function=current_function)
            
            # LAZY IMPORT: Imports moved here to break circular dependency
            from Presets.utils_push_preset import push_preset_logic
            
            success_push_to_instrument = push_preset_logic(self.app_instance, self.console_print_func, preset_data)
        
        if success_push_to_instrument:
            self.console_print_func(f"✅ Preset '{display_name}' applied to instrument and GUI. Fantastic!")
            debug_log(f"Preset '{display_name}' applied to instrument and GUI successfully. 🎉", file=current_file,
                        version=current_version,
                        function=current_function)
        elif self.app_instance.inst:
             self.console_print_func(f"❌ Failed to apply preset '{display_name}' to instrument. GUI updated only.")
             debug_log(f"Failed to apply preset '{display_name}' to instrument. GUI updated only. 🤦‍♂️", file=current_file,
                         version=current_version,
                         function=current_function)

        try:
            if hasattr(self.app_instance, 'instrument_parent_tab') and \
               hasattr(self.app_instance.instrument_parent_tab, 'settings_tab') and \
               hasattr(self.app_instance.instrument_parent_tab.settings_tab, 'refresh_all_child_tabs'):
                self.app_instance.instrument_parent_tab.settings_tab.refresh_all_child_tabs()
        finally:
            self.app_instance.defer_config_save = False
            debug_log("Config saving re-enabled. Triggering final save. ✅", file=current_file,
                        version=current_version,
                        function=current_function)
            
            try:
                save_program_config (self.app_instance.program_config, self.console_print_func, self.app_instance)
            except Exception as e:
                debug_log(f"CRITICAL ERROR: Could not save config after preset load: {e}. Config not saved!", file=current_file,
                            version=current_version,
                            function=current_function)
                self.console_print_func("❌ CRITICAL ERROR: Application config could not be saved! See debug log.")

    def _update_gui_from_preset_data(self, preset_data):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Updating GUI from preset data: {preset_data.get('NickName', 'Unnamed')}. 🔄", file=current_file,
                    version=current_version,
                    function=current_function)

        self.selected_preset_nickname_var.set(preset_data.get('NickName', 'N/A'))
        
        for var in self.display_variables_map.values():
            var.set("N/A")

        def set_display_var(tk_var, key, format_str="{}", conversion_func=str, default_val="N/A"):
            value_str = preset_data.get(key, '').strip()
            if not value_str:
                tk_var.set(default_val)
                debug_log(f"Preset '{key}' is empty for display. Setting display to '{default_val}'.", file=current_file,
                            version=current_version,
                            function=current_function)
                return

            try:
                converted_value = conversion_func(value_str)
                tk_var.set(format_str.format(converted_value))
                debug_log(f"Preset '{key}' value '{value_str}' converted to '{converted_value}' and displayed as '{tk_var.get()}'.", file=current_file,
                            version=current_version,
                            function=current_function)
            except ValueError as e:
                tk_var.set("Invalid Value")
                debug_log(f"Error converting preset '{key}' value '{value_str}' to {conversion_func.__name__}: {e}. Displaying 'Invalid Value'. 💥", file=current_file,
                            version=current_version,
                            function=current_function)
            except Exception as e:
                tk_var.set("Error")
                debug_log(f"Unexpected error processing preset '{key}' value '{value_str}': {e}. Displaying 'Error'. 🤯", file=current_file,
                            version=current_version,
                            function=current_function)

        set_display_var(self.selected_preset_start_var, 'Start', "{:.3f}", float)
        set_display_var(self.selected_preset_stop_var, 'Stop', "{:.3f}", float)
        set_display_var(self.selected_preset_center_var, 'Center', "{:.3f}", float)
        set_display_var(self.selected_preset_span_var, 'Span', "{:.3f}", float)
        set_display_var(self.selected_preset_rbw_var, 'RBW', "{:.0f}", float)
        set_display_var(self.selected_preset_vbw_var, 'VBW', "{:.0f}", float)
        set_display_var(self.selected_preset_reflevel_var, 'RefLevel', "{:.1f}", float)
        set_display_var(self.selected_preset_attenuation_var, 'Attenuation', "{:.0f}", float)
        set_display_var(self.selected_preset_maxhold_var, 'MaxHold')
        set_display_var(self.selected_preset_highsens_var, 'HighSens')
        set_display_var(self.selected_preset_preamp_var, 'PreAmp')
        set_display_var(self.selected_preset_trace1_var, 'Trace1Mode')
        set_display_var(self.selected_preset_trace2_var, 'Trace2Mode')
        set_display_var(self.selected_preset_trace3_var, 'Trace3Mode')
        set_display_var(self.selected_preset_trace4_var, 'Trace4Mode')
        set_display_var(self.selected_preset_marker1_var, 'Marker1Max')
        set_display_var(self.selected_preset_marker2_var, 'Marker2Max')
        set_display_var(self.selected_preset_marker3_var, 'Marker3Max')
        set_display_var(self.selected_preset_marker4_var, 'Marker4Max')
        set_display_var(self.selected_preset_marker5_var, 'Marker5Max')
        set_display_var(self.selected_preset_marker6_var, 'Marker6Max')

        def get_and_set_app_var(preset_key, app_attr_name, conversion_func=str, scale_factor=1.0):
            value_str = preset_data.get(preset_key, '').strip()
            app_tk_var = getattr(self.app_instance, app_attr_name, None)

            if app_tk_var is None:
                debug_log(f"WARNING: app_instance does not have attribute '{app_attr_name}'. Cannot update. ⚠️", file=current_file,
                            version=current_version,
                            function=current_function)
                return
            
            if not value_str:
                debug_log(f"Preset '{preset_key}' is empty. Skipping update for app_instance.{app_attr_name}. 🤷‍♀️", file=current_file,
                            version=current_version,
                            function=current_function)
                return

            try:
                converted_value = conversion_func(value_str) * scale_factor
                app_tk_var.set(converted_value)
                debug_log(f"App var '{app_attr_name}' (from '{preset_key}') updated to '{converted_value}'.", file=current_file,
                            version=current_version,
                            function=current_function)
            except ValueError as e:
                debug_log(f"Error converting preset '{preset_key}' value '{value_str}' to {conversion_func.__name__}: {e}. Skipping update. 💥", file=current_file,
                            version=current_version,
                            function=current_function)
            except Exception as e:
                debug_log(f"Unexpected error processing preset '{preset_key}' value '{value_str}': {e}. Skipping update. 🤯", file=current_file,
                            version=current_version,
                            function=current_function)

        get_and_set_app_var('Center', 'center_freq_mhz_var', float, self.app_instance.MHZ_TO_HZ)
        get_and_set_app_var('Span', 'span_freq_mhz_var', float, self.app_instance.MHZ_TO_HZ)
        get_and_set_app_var('RBW', 'rbw_hz_var', float)
        get_and_set_app_var('VBW', 'vbw_hz_var', float)
        get_and_set_app_var('RefLevel', 'reference_level_dbm_var', float)
        get_and_set_app_var('Attenuation', 'attenuation_db_var', int)
        get_and_set_app_var('FreqShift', 'freq_shift_hz_var', float)

        def get_and_set_bool_app_var(preset_key, app_attr_name):
            value_str = preset_data.get(preset_key, '').strip().upper()
            app_tk_var = getattr(self.app_instance, app_attr_name, None)

            if app_tk_var is None:
                debug_log(f"WARNING: app_instance does not have attribute '{app_attr_name}'. Cannot update. ⚠️", file=current_file,
                            version=current_version,
                            function=current_function)
                return

            if value_str in ['ON', 'TRUE', 'WRITE']:
                app_tk_var.set(True)
            elif value_str in ['OFF', 'FALSE', '']:
                app_tk_var.set(False)
            else:
                debug_log(f"Warning: Unexpected boolean value for '{preset_key}': '{value_str}'. Not updating app_instance.{app_attr_name}. ⚠️", file=current_file,
                            version=current_version,
                            function=current_function)

        get_and_set_bool_app_var('MaxHold', 'maxhold_enabled_var')
        get_and_set_bool_app_var('HighSens', 'high_sensitivity_var')
        get_and_set_bool_app_var('PreAmp', 'preamp_on_var')

        get_and_set_app_var('Trace1Mode', 'trace1_mode_var')
        get_and_set_app_var('Trace2Mode', 'trace2_mode_var')
        get_and_set_app_var('Trace3Mode', 'trace3_mode_var')
        get_and_set_app_var('Trace4Mode', 'trace4_mode_var')

        get_and_set_bool_app_var('Marker1Max', 'marker1_calculate_max_var')
        get_and_set_bool_app_var('Marker2Max', 'marker2_calculate_max_var')
        get_and_set_bool_app_var('Marker3Max', 'marker3_calculate_max_var')
        get_and_set_bool_app_var('Marker4Max', 'marker4_calculate_max_var')
        get_and_set_bool_app_var('Marker5Max', 'marker5_calculate_max_var')
        get_and_set_bool_app_var('Marker6Max', 'marker6_calculate_max_var')


        self.app_instance.last_selected_preset_name_var.set(preset_data.get('NickName', preset_data.get('Filename', '')))
        
        set_display_var(self.app_instance.last_loaded_preset_center_freq_mhz_var, 'Center', "{:.3f}", float)
        set_display_var(self.app_instance.last_loaded_preset_span_mhz_var, 'Span', "{:.3f}", float)
        set_display_var(self.app_instance.last_loaded_preset_rbw_hz_var, 'RBW', "{:.0f}", float)


        self.console_print_func(f"✅ GUI settings updated from local preset '{preset_data.get('NickName', 'Unnamed')}'.")
        debug_log("GUI settings updated from local preset. Done! ✅", file=current_file,
                    version=current_version,
                    function=current_function)

    def _on_tab_selected(self, event):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Local Presets tab selected. Refreshing buttons instantly. ✅", file=current_file,
                    version=current_version,
                    function=current_function)
        self.populate_local_presets_list()
        debug_log(f"Local Presets tab refreshed after selection. 👍", file=current_file,
                    version=current_version,
                    function=current_function)

#####################################
### File: OPEN-AIR 2\workers\Presets\tab_presets_child_preset_editor.py
#####################################
# tabs/Presets/tab_presets_child_preset_editor.py
#
# This file defines the PresetEditorTab, a Tkinter Frame that provides
# comprehensive functionality for managing user-defined presets stored locally
# in a CSV file. It allows displaying, editing (cell-by-cell), saving, importing,
# exporting, and adding new presets (including current instrument settings).
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250814.162500.1 (REBUILT: Refactored the GUI to use the new PresetEditorLogic class, decoupling presentation from data management.)

current_version = "20250814.162500.1"
current_version_hash = 20250814 * 162500 * 1

import tkinter as tk
from tkinter import ttk, filedialog, simpledialog
import inspect
import os
from datetime import datetime
import pandas as pd
import numpy as np

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log

# Import the new utility file
from .utils_presets_editor import PresetEditorLogic

from Instrument.connection.instrument_logic import query_current_settings_logic
from src.program_style import COLOR_PALETTE


class PresetEditorTab(ttk.Frame):
    """
    A Tkinter Frame that provides comprehensive functionality for managing
    user-defined presets stored locally in a CSV file. It allows displaying,
    editing (cell-by-cell), saving, importing, exporting, and adding new presets
    (including current instrument settings).
    """
    def __init__(self, master=None, app_instance=None, console_print_func=None, style_obj=None, **kwargs):
        filtered_kwargs = {k: v for k, v in kwargs.items() if k != 'style_obj'}
        super().__init__(master, **filtered_kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func if console_print_func else console_log
        self.style_obj = style_obj

        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Initializing PresetEditorTab. Version: {current_version}. Get ready to edit presets!",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)

        self.columns = [
            'Filename', 'NickName', 'Start (MHz)', 'Stop (MHz)', 'Center (MHz)', 'Span (MHz)', 'RBW (Hz)', 'VBW (Hz)',
            'RefLevel (dBm)', 'Attenuation (dB)', 'MaxHold', 'HighSens', 'PreAmp',
            'Trace1Mode', 'Trace2Mode', 'Trace3Mode', 'Trace4Mode',
            'Marker1Max', 'Marker2Max', 'Marker3Max', 'Marker4Max',
            'Marker5Max', 'Marker6Max'
        ]
        self.column_widths = {'Filename': 120, 'NickName': 120, 'Start (MHz)': 100, 'Stop (MHz)': 100, 'Center (MHz)': 100, 'Span (MHz)': 100, 'RBW (Hz)': 80, 'VBW (Hz)': 80,
            'RefLevel (dBm)': 80, 'Attenuation (dB)': 90, 'MaxHold': 80, 'HighSens': 80, 'PreAmp': 80,
            'Trace1Mode': 90, 'Trace2Mode': 90, 'Trace3Mode': 90, 'Trace4Mode': 90,
            'Marker1Max': 90, 'Marker2Max': 90, 'Marker3Max': 90, 'Marker4Max': 90,
            'Marker5Max': 90, 'Marker6Max': 90
        }

        # NEW: Instantiate the logic class
        self.logic = PresetEditorLogic(self.app_instance, self.console_print_func, self.columns)
        self.logic.load_presets()

        self.current_edit_cell = None
        self.is_editing_cell = False

        self._create_widgets()
        self.populate_presets_table()
        
        # Removed the problematic binding to <FocusIn>
        # self.app_instance.bind("<FocusIn>", self._on_window_focus_in)

        debug_log(f"PresetEditorTab initialized. Version: {current_version}. Preset editor is live!",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)

    def _on_window_focus_in(self, event):
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Main window gained focus. Refreshing presets. 🔄", file=f"{os.path.basename(__file__)}",
                    version=current_version,
                    function=current_function)
        if self.master.winfo_exists() and self.master.select() == str(self):
            self.logic.load_presets()
            self.populate_presets_table()

    def _create_widgets(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log("Creating PresetEditorTab widgets...",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)

        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(0, weight=0)
        self.grid_rowconfigure(1, weight=0)
        self.grid_rowconfigure(2, weight=1)
        self.grid_rowconfigure(3, weight=0)
        self.grid_rowconfigure(4, weight=0)

        top_button_frame = ttk.Frame(self, style='Dark.TFrame')
        top_button_frame.grid(row=0, column=0, columnspan=2, sticky="ew", padx=10, pady=5)
        top_button_frame.grid_columnconfigure(0, weight=1)
        top_button_frame.grid_columnconfigure(1, weight=1)
        top_button_frame.grid_columnconfigure(2, weight=1)

        add_current_button = ttk.Button(top_button_frame, text="Add Current Settings", command=self._add_current_settings, style='Green.TButton')
        add_current_button.grid(row=0, column=0, padx=5, pady=5, sticky="ew")

        add_empty_row_button = ttk.Button(top_button_frame, text="Add New Empty Row", command=self._add_new_empty_row, style='Blue.TButton')
        add_empty_row_button.grid(row=0, column=1, padx=5, pady=5, sticky="ew")

        delete_button = ttk.Button(top_button_frame, text="Delete Selected", command=self._delete_selected_preset, style='Red.TButton')
        delete_button.grid(row=0, column=2, padx=5, pady=5, sticky="ew")

        move_button_frame = ttk.Frame(self, style='Dark.TFrame')
        move_button_frame.grid(row=1, column=0, columnspan=2, sticky="ew", padx=10, pady=5)
        move_button_frame.grid_columnconfigure(0, weight=1)
        move_button_frame.grid_columnconfigure(1, weight=1)

        move_up_button = ttk.Button(move_button_frame, text="Move Preset UP (CTRL+UP)", command=self._move_preset_up, style='Orange.TButton')
        move_up_button.grid(row=0, column=0, padx=5, pady=5, sticky="ew")

        move_down_button = ttk.Button(move_button_frame, text="Move Preset DOWN (CTRL+DOWN)", command=self._move_preset_down, style='Orange.TButton')
        move_down_button.grid(row=0, column=1, padx=5, pady=5, sticky="ew")

        self.presets_tree = ttk.Treeview(self, columns=self.columns, show='headings', style='Treeview')
        self.presets_tree.grid(row=2, column=0, sticky="nsew", padx=10, pady=10)

        for col in self.columns:
            self.presets_tree.heading(col, text=col, anchor=tk.W)
            self.presets_tree.column(col, width=self.column_widths.get(col, 100), anchor=tk.W, stretch=tk.NO)

        vsb = ttk.Scrollbar(self, orient="vertical", command=self.presets_tree.yview)
        vsb.grid(row=2, column=1, sticky='ns')
        self.presets_tree.configure(yscrollcommand=vsb.set)

        hsb = ttk.Scrollbar(self, orient="horizontal", command=self.presets_tree.xview)
        hsb.grid(row=3, column=0, sticky='ew')
        self.presets_tree.configure(xscrollcommand=hsb.set)

        self.presets_tree.bind("<Double-1>", self._on_double_click)
        self.presets_tree.bind("<<TreeviewSelect>>", self._on_tree_select)
        self.presets_tree.bind("<Control-Up>", lambda event: self._move_preset_up())
        self.presets_tree.bind("<Control-Down>", lambda event: self._move_preset_down())

        file_ops_button_frame = ttk.Frame(self, style='Dark.TFrame')
        file_ops_button_frame.grid(row=4, column=0, columnspan=2, pady=10, padx=10, sticky="ew")
        file_ops_button_frame.grid_columnconfigure(0, weight=1)
        file_ops_button_frame.grid_columnconfigure(1, weight=1)
        file_ops_button_frame.grid_columnconfigure(2, weight=1)

        import_button = ttk.Button(file_ops_button_frame, text="Import Presets", command=self._import_presets, style='Orange.TButton')
        import_button.grid(row=0, column=0, padx=5, pady=5, sticky="ew")

        export_button = ttk.Button(file_ops_button_frame, text="Export Presets", command=self._export_presets, style='Purple.TButton')
        export_button.grid(row=0, column=1, padx=5, pady=5, sticky="ew")

        debug_log("PresetEditorTab widgets created. Treeview and buttons are ready for action!",
                    file=f"{os.path.basename(__file__)}",
                    version=current_version,
                    function=current_function)

    def populate_presets_table(self):
        current_function = inspect.currentframe().f_code.co_name
        debug_log("Populating local presets table from internal data...",
                    file=f"{os.path.basename(__file__)}",
                    version=current_version,
                    function=current_function)

        for item in self.presets_tree.get_children():
            self.presets_tree.delete(item)

        if not self.logic.presets_data:
            self.console_print_func("ℹ️ No user presets in memory to display in editor.")
            return

        for preset in self.logic.presets_data:
            row_values = []
            for col_key in self.columns:
                clean_col_key = col_key.split(' ')[0]
                value = preset.get(clean_col_key, '')
                
                if isinstance(value, float) and np.isnan(value):
                    value = ''
                
                row_values.append(value)
            
            self.presets_tree.insert('', 'end', values=row_values)
        
        self.console_print_func(f"✅ Displayed {len(self.logic.presets_data)} user presets in the editor.")
        debug_log(f"Local presets table populated with {len(self.logic.presets_data)} entries from internal data.",
                    file=f"{os.path.basename(__file__)}",
                    version=current_version,
                    function=current_function)

    def _add_current_settings(self):
        if self.logic.add_current_settings():
            self.populate_presets_table()
            self.logic.save_presets()

    def _add_new_empty_row(self):
        if self.logic.add_new_empty_row():
            self.populate_presets_table()
            self.logic.save_presets()

    def _save_presets_to_csv(self):
        if self.logic.save_presets():
            self.console_print_func(f"✅ Presets saved successfully to: {self.app_instance.PRESETS_FILE_PATH}")

    def _import_presets(self):
        file_path = filedialog.askopenfilename(
            parent=self.app_instance,
            title="Select CSV file to import",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")]
        )
        if file_path and self.logic.import_presets(file_path):
            self.populate_presets_table()
            self.logic.save_presets()

    def _export_presets(self):
        file_path = filedialog.asksaveasfilename(
            parent=self.app_instance,
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
            initialfile=f"exported_presets_{datetime.now().strftime('%Y%m%d_%H%M')}.csv"
        )
        if file_path:
            self.logic.export_presets(file_path)

    def _delete_selected_preset(self):
        selected_items = self.presets_tree.selection()
        if not selected_items:
            self.console_print_func("⚠️ No preset selected for deletion. Pick one, genius!")
            return

        filenames_to_delete = [self.presets_tree.item(item, 'values')[0] for item in selected_items]
        if self.logic.delete_presets(filenames_to_delete):
            self.populate_presets_table()
            self.logic.save_presets()

    def _on_double_click(self, event):
        region = self.presets_tree.identify("region", event.x, event.y)
        if region == "cell":
            col = self.presets_tree.identify_column(event.x)
            item = self.presets_tree.identify_row(event.y)
            if item and self.columns[int(col[1:]) - 1] != 'Filename':
                col_index = int(col[1:]) - 1
                self._start_edit(item, col_index)

    def _start_edit(self, item_id, col_index):
        if hasattr(self, 'edit_entry') and self.edit_entry.winfo_exists():
            self._end_edit()

        x, y, width, height = self.presets_tree.bbox(item_id, f"#{col_index + 1}")
        current_values_in_tree = self.presets_tree.item(item_id, "values")
        current_value = current_values_in_tree[col_index]
        filename_of_edited_row = current_values_in_tree[0]

        self.edit_entry = ttk.Entry(self.presets_tree, style='TEntry')
        self.edit_entry.place(x=x, y=y, width=width, height=height, anchor="nw")
        self.edit_entry.insert(0, current_value)
        self.edit_entry.focus_set()

        self.current_edit_cell = (item_id, col_index, filename_of_edited_row)
        self.is_editing_cell = True

        self.edit_entry.bind("<FocusOut>", self._end_edit)
        self.edit_entry.bind("<Return>", self._on_edit_return)
        self.edit_entry.bind("<Escape>", self._on_edit_escape)

    def _on_edit_return(self, event):
        self._end_edit()
        return "break"

    def _on_edit_escape(self, event):
        if hasattr(self, 'edit_entry') and self.edit_entry.winfo_exists():
            self.edit_entry.destroy()
            self.current_edit_cell = None
            self.is_editing_cell = False
        return "break"

    def _end_edit(self, event=None):
        if not hasattr(self, 'edit_entry') or not self.edit_entry.winfo_exists():
            return

        if self.current_edit_cell:
            item_id_from_edit, col_index, filename_of_edited_row = self.current_edit_cell
            new_value = self.edit_entry.get()
            original_col_name = self.columns[col_index].split(' ')[0]
            
            if self.logic.update_preset_value(filename_of_edited_row, original_col_name, new_value):
                self.logic.save_presets()
            
            self.populate_presets_table()
            self.current_edit_cell = None

        self.edit_entry.destroy()
        self.is_editing_cell = False

    def _on_tab_selected(self, event):
        if self.logic.has_unsaved_changes:
            self.logic.save_presets()
        self.logic.load_presets()
        self.populate_presets_table()
        
    def _on_tree_select(self, event):
        pass

    def _move_preset_up(self):
        selected_items = self.presets_tree.selection()
        if not selected_items:
            self.console_print_func("⚠️ No preset selected to move up. Select one, genius!")
            return
        
        filenames_to_move = [self.presets_tree.item(item, 'values')[0] for item in selected_items]
        
        for filename in filenames_to_move:
            self.logic.move_preset_up(filename)
        
        self.populate_presets_table()
        self.presets_tree.selection_set(self.presets_tree.get_children()[:len(filenames_to_move)])
        self.logic.save_presets()

    def _move_preset_down(self):
        selected_items = self.presets_tree.selection()
        if not selected_items:
            self.console_print_func("⚠️ No preset selected to move down. Select one, buddy!")
            return
            
        filenames_to_move = [self.presets_tree.item(item, 'values')[0] for item in selected_items]
        
        for filename in reversed(filenames_to_move):
            self.logic.move_preset_down(filename)

        self.populate_presets_table()
        self.presets_tree.selection_set(self.presets_tree.get_children()[-len(filenames_to_move):])
        self.logic.save_presets()



#####################################
### File: OPEN-AIR 2\workers\Presets\utils_preset_csv_process.py
#####################################
# tabs/Presets/utils_preset_process.py
#
# This file provides utility functions for loading, saving, and managing
# user-defined presets stored in a CSV file. It handles the file path resolution
# and the actual reading/writing operations.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250814.161800.1 (FIXED: The loading and saving functions were updated to correctly handle the new 'Start' and 'Stop' columns and gracefully manage potential header mismatches by using pandas for robust file operations.)

current_version = "20250814.161800.1"
current_version_hash = 20250814 * 161800 * 1

import os
import csv
import inspect
import pandas as pd # For robust CSV reading/writing
import numpy as np # For handling NaN values

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log

current_version = "20250814.161800.1"
current_version_hash = 20250814 * 161800 * 1

def get_presets_csv_path(config_file_path, console_print_func=None):
    """
    Determines the full path to the PRESETS.CSV file.
    It assumes PRESETS.CSV is in the same directory as the config file,
    or in a 'DATA' subdirectory if the config file is one level up.

    Inputs:
        config_file_path (str): The full path to the application's config.ini file.
        console_print_func (function, optional): A function to use for printing messages
                                                 to the console. If None, uses standard print.
    Returns:
        str: The full path to the PRESETS.CSV file.
    """
    _print = console_print_func if console_print_func else print
    current_function = inspect.currentframe().f_code.co_name
    
    # Get the directory containing the config file
    config_dir = os.path.dirname(config_file_path)
    
    # Check if config_dir itself ends with 'DATA'
    if os.path.basename(config_dir).upper() == 'DATA':
        # If config_file_path is already within the DATA folder, use that folder directly
        presets_csv_path = os.path.join(config_dir, "PRESETS.CSV")
    else:
        # Otherwise, assume DATA is a sibling directory to config_dir
        # This might need adjustment based on your exact project structure.
        # For now, let's assume config_file_path is like ".../OPEN-AIR/config.ini"
        # and DATA is ".../OPEN-AIR/DATA/"
        app_root_dir = os.path.dirname(config_dir)
        data_folder = os.path.join(app_root_dir, "DATA")
        presets_csv_path = os.path.join(data_folder, "PRESETS.CSV")

    debug_log(f"Determined presets CSV path: {presets_csv_path}.",
                file=f"{os.path.basename(__file__)} - {current_version}",
                version=current_version,
                function=current_function)
    return presets_csv_path

def load_user_presets_from_csv(config_file_path, console_print_func=None):
    """
    Loads user-defined presets from the PRESETS.CSV file.
    If the file does not exist, it creates an empty one with headers.

    Inputs:
        config_file_path (str): The full path to the application's config.ini file.
        console_print_func (function, optional): A function to use for printing messages
                                                 to the console. If None, uses standard print.
    Returns:
        list: A list of dictionaries, where each dictionary represents a preset.
              Returns an empty list if the file is empty or cannot be read.
    """
    _print = console_print_func if console_print_func else print
    current_function = inspect.currentframe().f_code.co_name
    presets_csv_path = get_presets_csv_path(config_file_path, _print)
    
    # Define the expected headers for the PRESETS.CSV file
    # This list must match the columns expected by PresetEditorTab
    expected_headers = [
        'Filename', 'NickName', 'Start', 'Stop', 'Center', 'Span', 'RBW', 'VBW',
        'RefLevel', 'Attenuation', 'MaxHold', 'HighSens', 'PreAmp',
        'Trace1Mode', 'Trace2Mode', 'Trace3Mode', 'Trace4Mode',
        'Marker1Max', 'Marker2Max', 'Marker3Max', 'Marker4Max',
        'Marker5Max', 'Marker6Max'
    ]

    if not os.path.exists(presets_csv_path):
        _print(f"ℹ️ PRESETS.CSV not found at '{presets_csv_path}'. Creating a new empty file with headers.")
        debug_log(f"PRESETS.CSV not found. Creating new file.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        try:
            # Ensure the DATA directory exists
            os.makedirs(os.path.dirname(presets_csv_path), exist_ok=True)
            with open(presets_csv_path, 'w', newline='', encoding='utf-8') as csvfile:
                writer = csv.DictWriter(csvfile, fieldnames=expected_headers)
                writer.writeheader()
            _print("✅ New PRESETS.CSV created with headers.")
            debug_log("New PRESETS.CSV created with headers.",
                        file=f"{os.path.basename(__file__)} - {current_version}",
                        version=current_version,
                        function=current_function)
            return [] # Return empty list as the file is new and empty
        except Exception as e:
            _print(f"❌ Error creating PRESETS.CSV: {e}. Cannot load presets.")
            debug_log(f"Error creating PRESETS.CSV: {e}.",
                        file=f"{os.path.basename(__file__)} - {current_version}",
                        version=current_version,
                        function=current_function)
            return []
    
    # Use a try/except block to handle file reading errors gracefully.
    try:
        _print(f"💬 Loading user presets from existing file: {os.path.basename(presets_csv_path)}. Let's get this data!")
        debug_log(f"Loading user presets from existing file: {presets_csv_path}.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        # Use pandas for more robust CSV reading, handling potential missing columns
        df = pd.read_csv(presets_csv_path, dtype=str, keep_default_na=False) # Read all as string, keep empty strings as empty
        
        # Ensure all expected headers are present, add missing ones with empty string values
        for header in expected_headers:
            if header not in df.columns:
                df[header] = ''

        # Reorder columns to match expected_headers
        df = df[expected_headers]

        presets = df.to_dict(orient='records')

        # Convert NaN values to empty strings after reading with pandas
        for preset in presets:
            for key, value in preset.items():
                if pd.isna(value):
                    preset[key] = ''
                # Ensure all values are strings for consistency
                elif not isinstance(value, str):
                    preset[key] = str(value)

        _print(f"✅ Loaded {len(presets)} user presets from {os.path.basename(presets_csv_path)}.")
        debug_log(f"Loaded {len(presets)} user presets.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        return presets
    except pd.errors.EmptyDataError:
        _print(f"ℹ️ PRESETS.CSV at '{presets_csv_path}' is empty. Returning no presets.")
        debug_log(f"PRESETS.CSV is empty.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        # Re-create with headers if it was truly empty (not just header-only)
        try:
            with open(presets_csv_path, 'w', newline='', encoding='utf-8') as csvfile:
                writer = csv.DictWriter(csvfile, fieldnames=expected_headers)
                writer.writeheader()
            _print("✅ Empty PRESETS.CSV re-initialized with headers.")
            debug_log("Empty PRESETS.CSV re-initialized with headers.",
                        file=f"{os.path.basename(__file__)} - {current_version}",
                        version=current_version,
                        function=current_function)
        except Exception as e:
            _print(f"❌ Error re-initializing empty PRESETS.CSV: {e}.")
            debug_log(f"Error re-initializing empty PRESETS.CSV: {e}.",
                        file=f"{os.path.basename(__file__)} - {current_version}",
                        version=current_version,
                        function=current_function)
        return []
    except Exception as e:
        _print(f"❌ Error loading presets from {os.path.basename(presets_csv_path)}: {e}. Returning no presets.")
        debug_log(f"Error loading presets: {e}. What the hell?!",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        return []

def overwrite_user_presets_csv(config_file_path, presets_data, console_print_func=None, fieldnames=None):
    """
    Overwrites the PRESETS.CSV file with the provided presets data.
    Ensures all dictionary keys match the fieldnames for csv.DictWriter.

    Inputs:
        config_file_path (str): The full path to the application's config.ini file.
        presets_data (list): A list of dictionaries, where each dictionary represents a preset.
        console_print_func (function, optional): A function to use for printing messages
                                                 to the console. If None, uses standard print.
        fieldnames (list, optional): A list of strings representing the CSV header order.
                                     If None, it will be derived from the keys of the first preset,
                                     or a default set if presets_data is empty.
    Returns:
        bool: True if save was successful, False otherwise.
    """
    _print = console_print_func if console_print_func else print
    current_function = inspect.currentframe().f_code.co_name
    presets_csv_path = get_presets_csv_path(config_file_path, _print)

    try:
        # Determine fieldnames if not provided
        if fieldnames is None:
            if presets_data:
                # Use keys from the first preset as fieldnames
                fieldnames = list(presets_data[0].keys())
                debug_log(f"Derived fieldnames from first preset: {fieldnames}",
                            file=f"{os.path.basename(__file__)} - {current_version}",
                            version=current_version,
                            function=current_function)
            else:
                # If presets_data is empty and no fieldnames provided, use a default set
                fieldnames = [
                    'Filename', 'NickName', 'Start', 'Stop', 'Center', 'Span', 'RBW', 'VBW',
                    'RefLevel', 'Attenuation', 'MaxHold', 'HighSens', 'PreAmp',
                    'Trace1Mode', 'Trace2Mode', 'Trace3Mode', 'Trace4Mode',
                    'Marker1Max', 'Marker2Max', 'Marker3Max', 'Marker4Max',
                    'Marker5Max', 'Marker6Max'
                ]
                debug_log(f"Using default fieldnames as presets_data is empty: {fieldnames}",
                            file=f"{os.path.basename(__file__)} - {current_version}",
                            version=current_version,
                            function=current_function)

        # Ensure all dictionaries in presets_data have all keys defined in fieldnames
        # and convert values to strings, handling NaN
        cleaned_presets_data = []
        for preset in presets_data:
            cleaned_preset = {}
            for field in fieldnames:
                value = preset.get(field, '') # Get value, default to empty string if key is missing
                if pd.isna(value):
                    cleaned_preset[field] = '' # Replace NaN with empty string
                elif isinstance(value, (float, np.float64)) and value.is_integer():
                    cleaned_preset[field] = str(int(value))
                else:
                    cleaned_preset[field] = str(value) # Ensure all values are strings
            cleaned_presets_data.append(cleaned_preset)

        with open(presets_csv_path, 'w', newline='', encoding='utf-8') as csvfile:
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writeheader()
            writer.writerows(cleaned_presets_data)
        
        debug_log(f"Successfully overwrote PRESETS.CSV at: {presets_csv_path} with {len(cleaned_presets_data)} entries.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        return True
    except Exception as e:
        _print(f"❌ An unexpected error occurred overwriting presets: {e}. What a mess!")
        debug_log(f"An unexpected error occurred overwriting presets to {presets_csv_path}: {e}.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        return False


#####################################
### File: OPEN-AIR 2\workers\Presets\utils_preset_query_and_load.py
#####################################
# utils/utils_preset_query_and_load.py
#
# This module provides utility functions for querying available presets from the
# connected instrument and loading selected presets (both device and user-defined).
# It abstracts the low-level SCPI commands for preset management and integrates
# with the GUI's state to update settings.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.173331.1
# UPDATED: The load_selected_preset_logic now correctly uses the YakSet and YakDo functions
#          to set all the instrument's values from a preset, ensuring a complete and
#          reliable state update.

import pyvisa
import time
import inspect
import os
from datetime import datetime
import csv
import pandas as pd

from display.debug_logic import debug_log, log_visa_command
from display.console_logic import console_log
from Instrument.connection.instrument_logic import query_current_settings_logic
from yak.Yakety_Yak import YakGet, YakSet, YakDo, query_safe, write_safe
from ref.ref_frequency_bands import MHZ_TO_HZ as MHZ_TO_HZ_CONVERSION

# --- Versioning ---
w = 20250821
x_str = '173331'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = f"{os.path.basename(__file__)}"


def query_device_presets_logic(app_instance, console_print_func):
    """
    Queries the connected instrument for available presets and returns their names.
    This function is specifically for device-stored presets (e.g., from :MMEMory:CATalog:STATe?).

    Inputs:
        app_instance (App): The main application instance.
        console_print_func (function): Function to print messages to the GUI console.
    Outputs:
        list: A list of preset names (strings) found on the instrument.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log("Querying device presets from instrument...",
                file=current_file,
                version=current_version,
                function=current_function)

    if not app_instance.inst:
        console_print_func("❌ No instrument connected. Cannot query device presets.")
        debug_log("No instrument connected. Aborting device preset query.",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return []

    if hasattr(app_instance, 'connected_instrument_model') and \
       app_instance.connected_instrument_model.get() != "N9342CN":
        console_print_func("⚠️ Device is not N9342CN. Cannot query device presets (feature limited to N9342CN).")
        debug_log("Device is not N9342CN. Aborting device preset query.",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return []

    try:
        response = query_safe(app_instance.inst, ":MMEMory:CATalog:STATe?", console_print_func)
        if response:
            preset_names = [name.strip().strip('"') for name in response.split(',') if name.strip()]
            console_print_func(f"✅ Found {len(preset_names)} device presets.")
            debug_log(f"Device presets found: {preset_names}.",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return preset_names
        else:
            console_print_func("ℹ️ No device presets found or query failed.")
            debug_log("No device presets found or query returned empty response.",
                        file=current_file,
                        version=current_version,
                        function=current_function)
            return []
    except Exception as e:
        console_print_func(f"❌ Error querying device presets: {e}. This is a disaster!")
        debug_log(f"Error querying device presets: {e}. Fucking hell!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return []


def load_selected_preset_logic(app_instance, selected_preset_name, console_print_func, is_device_preset=True, preset_data_dict=None):
    """
    Loads a selected preset (either from device or local CSV) onto the instrument
    and updates the GUI's settings variables.

    Inputs:
        app_instance (App): The main application instance.
        selected_preset_name (str): The name of the preset to load.
        console_print_func (function): Function to print messages to the GUI console.
        is_device_preset (bool): True if loading a device preset, False for a local user preset.
        preset_data_dict (dict, optional): For local presets, the dictionary containing
                                           the preset's data. Not used for device presets.

    Outputs:
        bool: True if load was successful, False otherwise.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Attempting to load preset: '{selected_preset_name}'. Is Device Preset: {is_device_preset}.",
                file=current_file,
                version=current_version,
                function=current_function)

    try:
        if is_device_preset:
            if not app_instance.inst:
                console_print_func("❌ No instrument connected. Cannot load device preset.")
                debug_log("No instrument connected. Aborting device preset load.",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return False

            if hasattr(app_instance, 'connected_instrument_model') and \
               app_instance.connected_instrument_model.get() != "N9342CN":
                console_print_func("⚠️ Device is not N9342CN. Cannot load device presets (feature limited to N9342CN).")
                debug_log("Device is not N9342CN. Aborting device preset load.",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return False

            load_command = f":MMEMory:LOAD:STATe \"{selected_preset_name}\""
            if write_safe(app_instance.inst, load_command, console_print_func):
                console_print_func(f"✅ Device preset '{selected_preset_name}' loaded to instrument.")
                debug_log(f"Device preset '{selected_preset_name}' loaded to instrument.",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                
                settings = query_current_settings_logic(app_instance, console_print_func)
                
                if settings:
                    center_freq_hz = settings.get('center_freq_hz', 0.0)
                    span_hz = settings.get('span_hz', 0.0)
                    rbw_hz = settings.get('rbw_hz', 0.0)

                    app_instance.center_freq_mhz_var.set(center_freq_hz / MHZ_TO_HZ_CONVERSION)
                    app_instance.span_freq_mhz_var.set(span_hz / MHZ_TO_HZ_CONVERSION)
                    app_instance.rbw_mhz_var.set(rbw_hz / MHZ_TO_HZ_CONVERSION)
                    
                    console_print_func(f"GUI settings updated from device preset: Center Freq={center_freq_hz / MHZ_TO_HZ_CONVERSION:.3f} MHz, Span={span_hz / MHZ_TO_HZ_CONVERSION:.3f} MHz, RBW={rbw_hz / 1000:.1f} kHz. Looking good!")
                    debug_log(f"GUI settings updated from loaded device preset.",
                                file=current_file,
                                version=current_version,
                                function=current_function)
                    return True
                else:
                    console_print_func("❌ Failed to query settings after loading device preset. This is frustrating!")
                    debug_log("Failed to query settings after loading device preset. What a pain!",
                                file=current_file,
                                version=current_version,
                                function=current_function)
                    return False
            else:
                console_print_func(f"❌ Failed to load device preset '{selected_preset_name}'. This is frustrating!")
                debug_log(f"Failed to load device preset '{selected_preset_name}'. What a pain!",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return False
        else:
            if preset_data_dict:
                from Presets.utils_push_preset import push_preset_logic
                return push_preset_logic(app_instance, console_print_func, preset_data_dict)
            else:
                console_print_func(f"❌ Failed to load local preset '{selected_preset_name}'. Preset data not provided.")
                debug_log(f"Failed to load local preset '{selected_preset_name}'. Preset data dictionary is missing.",
                            file=current_file,
                            version=current_version,
                            function=current_function)
                return False

    except Exception as e:
        console_print_func(f"❌ An unexpected error occurred in load_selected_preset_logic: {e}. This is a disaster!")
        debug_log(f"An unexpected error occurred in load_selected_preset_logic: {e}. Fucking hell!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return False


def query_current_instrument_settings_for_preset(inst, console_print_func=None):
    """
    Function Description:
    Queries and returns the current Center Frequency, Span, and RBW from the instrument.

    Inputs:
        inst (pyvisa.resources.Resource): The connected VISA instrument object.
        console_print_func (function, optional): Function to print to the GUI console.
                                               Defaults to console_log if None.
    Outputs:
        tuple: (center_freq_mhz, span_mhz, rbw_hz) or (None, None, None) on failure.
    """
    console_print_func = console_print_func if console_print_func else console_log
    current_function = inspect.currentframe().f_code.co_name
    debug_log("Querying current instrument settings... Let's see what's happening!",
                file=current_file,
                version=current_version,
                function=current_function)

    if not inst:
        debug_log("No instrument connected to query settings. Fucking useless!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        console_print_func("⚠️ Warning: No instrument connected. Cannot query settings. Connect the damn thing first!")
        return None, None, None

    center_freq_hz = None
    span_hz = None
    rbw_hz = None

    try:
        center_freq_str = query_safe(inst, ":SENSe:FREQuency:CENTer?", console_print_func)
        if center_freq_str:
            center_freq_hz = float(center_freq_str)

        span_str = query_safe(inst, ":SENSe:FREQuency:SPAN?", console_print_func)
        if span_str:
            span_hz = float(span_str)

        rbw_str = query_safe(inst, ":SENSe:BANDwidth:RESolution?", console_print_func)
        if rbw_str:
            rbw_hz = float(rbw_str)

        center_freq_mhz = center_freq_hz / 1_000_000 if center_freq_hz is not None else None
        span_mhz = span_hz / 1_000_000 if span_hz is not None else None

        debug_log(f"Queried settings: Center Freq: {center_freq_mhz:.3f} MHz, Span: {span_mhz:.3f} MHz, RBW: {rbw_hz} Hz. Got the info!",
                    file=current_file,
                    version=current_version,
                    function=current_function)

        console_print_func(f"✅ Queried settings: C: {center_freq_mhz:.3f} MHz, SP: {span_mhz:.3f} MHz, RBW: {rbw_hz / 1000:.1f} kHz. Details acquired!")

        return center_freq_mhz, span_mhz, rbw_hz

    except Exception as e:
        debug_log(f"❌ Error querying current instrument settings: {e}. What a mess!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        console_print_func(f"❌ Error querying current instrument settings: {e}. This is a disaster!")
        return None, None, None

#####################################
### File: OPEN-AIR 2\workers\Presets\utils_presets_editor.py
#####################################
# tabs/Presets/utils_presets_editor.py
#
# This file provides utility functions and classes for managing user-defined
# presets. It handles loading, saving, importing, exporting, and manipulating
# presets data in a decoupled way from the GUI elements.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250814.162500.1 (REBUILT: Extracted all logic from PresetEditorTab to separate data from the GUI.)

current_version = "20250814.162500.1"
current_version_hash = 20250814 * 162500 * 1

import inspect
import os
import csv
from datetime import datetime
import shutil
import pandas as pd
import numpy as np

from display.debug_logic import debug_log
from display.console_logic import console_log
from .utils_preset_csv_process import (
    get_presets_csv_path,
    load_user_presets_from_csv,
    overwrite_user_presets_csv
)
from Instrument.connection.instrument_logic import query_current_settings_logic
from ref.ref_file_paths import PRESETS_FILE_PATH

class PresetEditorLogic:
    def __init__(self, app_instance, console_print_func, columns):
        self.app_instance = app_instance
        self.console_print_func = console_print_func
        self.columns = columns
        self.presets_data = []
        self.has_unsaved_changes = False

    def load_presets(self):
        """Loads presets from the CSV file into memory."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log("Loading presets from CSV into memory.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        self.presets_data = load_user_presets_from_csv(PRESETS_FILE_PATH, self.console_print_func)
        self.has_unsaved_changes = False

    def save_presets(self):
        """Saves the current presets in memory to the CSV file."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log("Saving all presets from memory to PRESETS.CSV.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        fieldnames_for_save = [col.split(' ')[0] for col in self.columns]
        if overwrite_user_presets_csv(self.app_instance.CONFIG_FILE_PATH, self.presets_data, self.console_print_func, fieldnames=fieldnames_for_save):
            self.has_unsaved_changes = False
            return True
        return False

    def add_current_settings(self):
        """Queries current instrument settings and adds them as a new preset."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log("Attempting to add current settings.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)

        if not self.app_instance.inst:
            self.console_print_func("❌ No instrument connected. Cannot get current settings. Connect first!")
            return False

        current_settings = query_current_settings_logic(self.app_instance, self.console_print_func)
        if current_settings:
            timestamp_filename = datetime.now().strftime('%Y%m%d_%H%M%S')
            timestamp_nickname = datetime.now().strftime('%Y%m%d %H%M')

            center_freq_mhz = current_settings.get('center_freq_mhz')
            span_mhz = current_settings.get('span_mhz')
            start_freq_mhz = center_freq_mhz - (span_mhz / 2) if center_freq_mhz is not None and span_mhz is not None else ''
            stop_freq_mhz = center_freq_mhz + (span_mhz / 2) if center_freq_mhz is not None and span_mhz is not None else ''

            new_preset = {
                'Filename': f"USER_{timestamp_filename}.STA",
                'NickName': f"Device {timestamp_nickname}",
                'Start': f"{start_freq_mhz:.3f}" if isinstance(start_freq_mhz, (int, float)) else '',
                'Stop': f"{stop_freq_mhz:.3f}" if isinstance(stop_freq_mhz, (int, float)) else '',
                'Center': f"{center_freq_mhz:.3f}" if isinstance(center_freq_mhz, (int, float)) else '',
                'Span': f"{span_mhz:.3f}" if isinstance(span_mhz, (int, float)) else '',
                'RBW': f"{current_settings.get('rbw_hz'):.0f}" if isinstance(current_settings.get('rbw_hz'), (int, float)) else '',
                'VBW': f"{current_settings.get('vbw_hz'):.0f}" if isinstance(current_settings.get('vbw_hz'), (int, float)) else '',
                'RefLevel': f"{current_settings.get('ref_level_dbm'):.1f}" if isinstance(current_settings.get('ref_level_dbm'), (int, float)) else '',
                'Attenuation': f"{current_settings.get('attenuation_db'):.0f}" if isinstance(current_settings.get('attenuation_db'), (int, float)) else '',
                'MaxHold': 'ON' if current_settings.get('maxhold_enabled') else 'OFF',
                'HighSens': 'ON' if current_settings.get('high_sensitivity_on') else 'OFF',
                'PreAmp': 'ON' if current_settings.get('preamp_on') else 'OFF',
                'Trace1Mode': current_settings.get('trace1_mode', ''),
                'Trace2Mode': current_settings.get('trace2_mode', ''),
                'Trace3Mode': current_settings.get('trace3_mode', ''),
                'Trace4Mode': current_settings.get('trace4_mode', ''),
                'Marker1Max': 'WRITE' if current_settings.get('marker1_calc_max') else '',
                'Marker2Max': 'WRITE' if current_settings.get('marker2_calc_max') else '',
                'Marker3Max': 'WRITE' if current_settings.get('marker3_calc_max') else '',
                'Marker4Max': 'WRITE' if current_settings.get('marker4_calc_max') else '',
                'Marker5Max': 'WRITE' if current_settings.get('marker5_calc_max') else '',
                'Marker6Max': 'WRITE' if current_settings.get('marker6_calc_max') else '',
            }
            self.presets_data.append(new_preset)
            self.has_unsaved_changes = True
            self.console_print_func("✅ Current instrument settings added as a new preset. Remember to save your changes!")
            return True
        else:
            self.console_print_func("❌ Failed to query all current settings from instrument. Some values were missing.")
            return False

    def add_new_empty_row(self):
        """Adds a new empty row to the presets list with default values."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log("Adding new empty row.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)

        new_empty_preset = {col.split(' ')[0]: '' for col in self.columns}
        new_empty_preset['Filename'] = f"NEW_{datetime.now().strftime('%Y%m%d_%H%M%S')}.STA"
        new_empty_preset['NickName'] = "New Preset"
        new_empty_preset['Start'] = "100.0"
        new_empty_preset['Stop'] = "200.0"
        new_empty_preset['Center'] = "150.0"
        new_empty_preset['Span'] = "100.0"
        new_empty_preset['RBW'] = "100000.0"
        self.presets_data.append(new_empty_preset)
        self.has_unsaved_changes = True
        self.console_print_func("✅ New empty row added. Remember to save your changes!")
        return True

    def delete_presets(self, selected_filenames):
        """Deletes selected presets from the list."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Deleting presets: {selected_filenames}.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        initial_len = len(self.presets_data)
        self.presets_data = [p for p in self.presets_data if p.get('Filename') not in selected_filenames]
        deleted_count = initial_len - len(self.presets_data)
        
        if deleted_count > 0:
            self.has_unsaved_changes = True
            self.console_print_func(f"✅ Deleted {deleted_count} preset(s). Automatically saving changes...")
            return True
        return False
        
    def update_preset_value(self, filename, column_name, new_value):
        """Updates a single value in a preset."""
        current_function = inspect.currentframe().f_code.co_name
        for preset in self.presets_data:
            if preset.get('Filename') == filename:
                if str(preset.get(column_name, '')) != new_value:
                    preset[column_name] = new_value
                    self.has_unsaved_changes = True
                    self.console_print_func(f"✅ Updated '{column_name}' for '{preset.get('NickName', filename)}' to '{new_value}'. Automatically saving changes!")
                    return True
        return False

    def import_presets(self, file_path):
        """Imports presets from a CSV file, replacing current data."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Importing presets from {file_path}.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        try:
            df_imported = pd.read_csv(file_path)
            imported_presets = df_imported.to_dict(orient='records')
            
            for preset in imported_presets:
                for key, value in preset.items():
                    if pd.isna(value):
                        preset[key] = ''
                    elif isinstance(value, (float, np.float64)) and value.is_integer():
                        preset[key] = str(int(value))
                    else:
                        preset[key] = str(value)
            
            self.presets_data = imported_presets
            self.has_unsaved_changes = True
            self.console_print_func(f"✅ Successfully imported {len(imported_presets)} presets. Automatically saving changes...")
            return True
        except Exception as e:
            self.console_print_func(f"❌ Error importing presets: {e}. Check file format.")
            return False

    def export_presets(self, file_path):
        """Exports the current presets data to a new CSV file."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Exporting presets to {file_path}.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)

        if not self.presets_data:
            self.console_print_func("⚠️ No presets to export. Add some first!")
            return False

        try:
            fieldnames = [col.split(' ')[0] for col in self.columns]
            with open(file_path, 'w', newline='', encoding='utf-8') as csvfile:
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                writer.writeheader()
                for preset in self.presets_data:
                    row_to_write = {field: preset.get(field, '') for field in fieldnames}
                    writer.writerow(row_to_write)
            self.console_print_func(f"✅ Successfully exported {len(self.presets_data)} presets to {os.path.basename(file_path)}.")
            return True
        except Exception as e:
            self.console_print_func(f"❌ Error exporting presets: {e}. This is a disaster!")
            return False
            
    def move_preset_up(self, filename):
        """Moves a preset one position up."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Moving preset '{filename}' up.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        for i, p in enumerate(self.presets_data):
            if p.get('Filename') == filename:
                if i > 0:
                    self.presets_data[i-1], self.presets_data[i] = self.presets_data[i], self.presets_data[i-1]
                    self.has_unsaved_changes = True
                    return True
                break
        return False

    def move_preset_down(self, filename):
        """Moves a preset one position down."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Moving preset '{filename}' down.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)

        for i, p in enumerate(self.presets_data):
            if p.get('Filename') == filename:
                if i < len(self.presets_data) - 1:
                    self.presets_data[i], self.presets_data[i+1] = self.presets_data[i+1], self.presets_data[i]
                    self.has_unsaved_changes = True
                    return True
                break
        return False


#####################################
### File: OPEN-AIR 2\workers\Presets\utils_push_preset.py
#####################################
# tabs/Presets/utils_push_preset.py
#
# This file contains the logic for pushing saved preset settings to the connected instrument.
# It retrieves settings from the application instance and sends the appropriate SCPI commands.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.173331.1
# UPDATED: The push_preset_logic now correctly uses YakSet and YakDo with proper command types
#          and includes all missing preset variables and trace configurations.

import os
import inspect
import re

from display.debug_logic import debug_log
from display.console_logic import console_log

from yak.Yakety_Yak import YakSet, YakDo
from ref.ref_frequency_bands import MHZ_TO_HZ

# --- Versioning ---
w = 20250821
x_str = '173331'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = f"{os.path.basename(__file__)}"


def push_preset_logic(app_instance, console_print_func, preset_data):
    """
    Function Description:
    Applies the current settings from the GUI (or a provided preset_data dictionary)
    to the connected instrument using the Yak command protocol.

    Inputs:
    - app_instance: The main application instance, used to access Tkinter variables and retrieve settings.
    - console_print_func: A function to print messages to the GUI console.
    - preset_data (dict): A dictionary containing the preset settings to apply.
                          Keys should match the CSV headers (e.g., 'Center', 'Span', 'RBW').

    Process:
    1. Logs the start of applying settings.
    2. Checks if an instrument is connected.
    3. Retrieves settings from the provided preset_data dictionary.
    4. Converts frequency values (Center, Span) from MHz to Hz for SCPI commands.
    5. Sends SCPI commands to the instrument using YakSet and YakDo.
    6. Handles model-specific commands (e.g., for N9340B/N9342CN).
    7. Logs success or failure.

    Outputs:
    - True if settings are applied successfully, False otherwise.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Applying settings to instrument with the Yak Attack! Version: {current_version}",
                file=current_file,
                version=current_version,
                function=current_function)

    if not app_instance.inst:
        console_print_func("❌ No instrument connected. Please connect to an instrument first. What are you doing?!")
        debug_log("No instrument connected. Cannot apply settings.",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return False

    success = True
    try:
        center_freq_mhz_str = preset_data.get('Center', '').strip()
        center_freq_hz = float(center_freq_mhz_str) * MHZ_TO_HZ if center_freq_mhz_str else None

        span_mhz_str = preset_data.get('Span', '').strip()
        span_hz = float(span_mhz_str) * MHZ_TO_HZ if span_mhz_str else None

        rbw_hz_str = preset_data.get('RBW', '').strip()
        rbw_hz = float(rbw_hz_str) if rbw_hz_str else None

        vbw_hz_str = preset_data.get('VBW', '').strip()
        vbw_hz = float(vbw_hz_str) if vbw_hz_str else None

        ref_level_str = preset_data.get('RefLevel', '').strip()
        reference_level_dbm = ref_level_str if ref_level_str else None

        attenuation_str = preset_data.get('Attenuation', '').strip()
        attenuation_db = int(attenuation_str) if attenuation_str else None

        maxhold_str = preset_data.get('MaxHold', '').strip()
        maxhold_enabled = maxhold_str.upper() == 'ON' if maxhold_str else None

        high_sensitivity_str = preset_data.get('HighSens', '').strip()
        high_sensitivity_on = high_sensitivity_str.upper() == 'ON' if high_sensitivity_str else None

        preamp_str = preset_data.get('PreAmp', '').strip()
        preamp_on = preamp_str.upper() == 'ON' if preamp_str else None

        trace1_mode = preset_data.get('Trace1Mode', '').strip()
        trace2_mode = preset_data.get('Trace2Mode', '').strip()
        trace3_mode = preset_data.get('Trace3Mode', '').strip()
        trace4_mode = preset_data.get('Trace4Mode', '').strip()

        marker1_max = preset_data.get('Marker1Max', '').strip()
        marker2_max = preset_data.get('Marker2Max', '').strip()
        marker3_max = preset_data.get('Marker3Max', '').strip()
        marker4_max = preset_data.get('Marker4Max', '').strip()
        marker5_max = preset_data.get('Marker5Max', '').strip()
        marker6_max = preset_data.get('Marker6Max', '').strip()

        console_print_func("💬 Applying settings to instrument using Yak commands...")

        if center_freq_hz is not None:
            if YakSet(app_instance, "FREQUENCY/CENTER", str(int(center_freq_hz)), console_print_func) == "FAILED": success = False
            debug_log(f"Applied Center Frequency: {int(center_freq_hz)} Hz.", file=current_file, version=current_version, function=current_function)
        if span_hz is not None:
            if YakSet(app_instance, "FREQUENCY/SPAN", str(int(span_hz)), console_print_func) == "FAILED": success = False
            debug_log(f"Applied Span Frequency: {int(span_hz)} Hz.", file=current_file, version=current_version, function=current_function)
        if attenuation_db is not None:
            if YakSet(app_instance, "AMPLITUDE/POWER/ATTENUATION", str(attenuation_db), console_print_func) == "FAILED": success = False
            debug_log(f"Applied Attenuation: {attenuation_db} dB.", file=current_file, version=current_version, function=current_function)

        if rbw_hz is not None:
            if YakSet(app_instance, "BANDWIDTH/RESOLUTION", str(int(rbw_hz)), console_print_func) == "FAILED": success = False
            debug_log(f"Applied RBW: {int(rbw_hz)} Hz.", file=current_file, version=current_version, function=current_function)
        if vbw_hz is not None:
            if YakSet(app_instance, "BANDWIDTH/VIDEO", str(int(vbw_hz)), console_print_func) == "FAILED": success = False
            debug_log(f"Applied VBW: {int(vbw_hz)} Hz.", file=current_file, version=current_version, function=current_function)

        if reference_level_dbm is not None:
            if YakDo(app_instance, f"AMPLITUDE/REFERENCE LEVEL/{reference_level_dbm}", console_print_func) == "FAILED": success = False
            debug_log(f"Applied Reference Level: {reference_level_dbm} dBm.", file=current_file, version=current_version, function=current_function)

        if high_sensitivity_on is not None:
            if YakSet(app_instance, "AMPLITUDE/POWER/HIGH SENSITIVE", 'ON' if high_sensitivity_on else 'OFF', console_print_func) == "FAILED": success = False
            debug_log(f"Applied High Sensitivity: {'ON' if high_sensitivity_on else 'OFF'}.", file=current_file, version=current_version, function=current_function)
        if preamp_on is not None:
            if YakSet(app_instance, "AMPLITUDE/POWER/GAIN", 'ON' if preamp_on else 'OFF', console_print_func) == "FAILED": success = False
            debug_log(f"Applied Preamp: {'ON' if preamp_on else 'OFF'}.", file=current_file, version=current_version, function=current_function)
        
        if trace1_mode:
            if YakDo(app_instance, f"TRACE/1/MODE/{trace1_mode}", console_print_func) == "FAILED": success = False
            debug_log(f"Applied Trace 1 Mode: {trace1_mode}.", file=current_file, version=current_version, function=current_function)
        if trace2_mode:
            if YakDo(app_instance, f"TRACE/2/MODE/{trace2_mode}", console_print_func) == "FAILED": success = False
            debug_log(f"Applied Trace 2 Mode: {trace2_mode}.", file=current_file, version=current_version, function=current_function)
        if trace3_mode:
            if YakDo(app_instance, f"TRACE/3/MODE/{trace3_mode}", console_print_func) == "FAILED": success = False
            debug_log(f"Applied Trace 3 Mode: {trace3_mode}.", file=current_file, version=current_version, function=current_function)
        if trace4_mode:
            if YakDo(app_instance, f"TRACE/4/MODE/{trace4_mode}", console_print_func) == "FAILED": success = False
            debug_log(f"Applied Trace 4 Mode: {trace4_mode}.", file=current_file, version=current_version, function=current_function)

        if marker1_max:
            if YakSet(app_instance, "MARKER/1/CALCULATE/MAX", 'ON' if marker1_max.upper() == 'WRITE' else 'OFF', console_print_func) == "FAILED": success = False
            debug_log(f"Applied Marker 1 Max: {marker1_max}.", file=current_file, version=current_version, function=current_function)
        if marker2_max:
            if YakSet(app_instance, "MARKER/2/CALCULATE/MAX", 'ON' if marker2_max.upper() == 'WRITE' else 'OFF', console_print_func) == "FAILED": success = False
            debug_log(f"Applied Marker 2 Max: {marker2_max}.", file=current_file, version=current_version, function=current_function)
        if marker3_max:
            if YakSet(app_instance, "MARKER/3/CALCULATE/MAX", 'ON' if marker3_max.upper() == 'WRITE' else 'OFF', console_print_func) == "FAILED": success = False
            debug_log(f"Applied Marker 3 Max: {marker3_max}.", file=current_file, version=current_version, function=current_function)
        if marker4_max:
            if YakSet(app_instance, "MARKER/4/CALCULATE/MAX", 'ON' if marker4_max.upper() == 'WRITE' else 'OFF', console_print_func) == "FAILED": success = False
            debug_log(f"Applied Marker 4 Max: {marker4_max}.", file=current_file, version=current_version, function=current_function)
        if marker5_max:
            if YakSet(app_instance, "MARKER/5/CALCULATE/MAX", 'ON' if marker5_max.upper() == 'WRITE' else 'OFF', console_print_func) == "FAILED": success = False
            debug_log(f"Applied Marker 5 Max: {marker5_max}.", file=current_file, version=current_version, function=current_function)
        if marker6_max:
            if YakSet(app_instance, "MARKER/6/CALCULATE/MAX", 'ON' if marker6_max.upper() == 'WRITE' else 'OFF', console_print_func) == "FAILED": success = False
            debug_log(f"Applied Marker 6 Max: {marker6_max}.", file=current_file, version=current_version, function=current_function)


        if success:
            console_print_func("✅ All settings applied successfully. Boom!")
            debug_log("All settings applied to instrument. Fucking awesome!",
                        file=current_file,
                        version=current_version,
                        function=current_function)
        else:
            console_print_func("❌ Failed to apply all settings. This thing is a pain in the ass!")
            debug_log("Failed to apply all settings.",
                        file=current_file,
                        version=current_version,
                        function=current_function)

        return success
    except ValueError as e:
        console_print_func(f"❌ Invalid setting value: {e}. Please check your inputs. You entered some garbage!")
        debug_log(f"ValueError applying settings: {e}. User entered some crap.",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return False
    except Exception as e:
        console_print_func(f"❌ An unexpected error occurred while applying settings: {e}. This thing is a pain in the ass!")
        debug_log(f"An unexpected error occurred applying settings: {e}. Fucking hell!",
                    file=current_file,
                    version=current_version,
                    function=current_function)
        return False

#####################################
### File: OPEN-AIR 2\workers\Scanning\TAB_SCANNING_PARENT.py
#####################################
# Scanning/TAB_SCANNING_PARENT.py
#
# Version 20250821.222500.1 (Refactored for print statements)

import tkinter as tk
from tkinter import ttk
import inspect
import os

from .tab_scanning_child_scan_configuration import ScanTab
from .tab_scanning_child_scan_meta_data import ScanMetaDataTab
from .tab_scanning_child_bands import BandsTab

current_version = "20250821.222500.1"

class TAB_SCANNING_PARENT(ttk.Frame):
    def __init__(self, parent, app_instance):
        super().__init__(parent)
        self.app_instance = app_instance
        self._create_widgets()

    def _create_widgets(self):
        self.child_notebook = ttk.Notebook(self, style='Scanning.Child.TNotebook')
        self.child_notebook.pack(expand=True, fill="both", padx=5, pady=5)
        self.scan_tab = ScanTab(self.child_notebook, self.app_instance)
        self.bands_tab = BandsTab(self.child_notebook, self.app_instance)
        self.meta_data_tab = ScanMetaDataTab(self.child_notebook, self.app_instance)
        self.child_notebook.add(self.scan_tab, text="Scan Configuration")
        self.child_notebook.add(self.bands_tab, text="Scan Bands")
        self.child_notebook.add(self.meta_data_tab, text="Scan Meta Data")
        self.child_notebook.bind("<<NotebookTabChanged>>", self._on_child_tab_selected)

    def _on_child_tab_selected(self, event):
        print(f"Scanning child tab selected.")
        selected_tab_id = self.child_notebook.select()
        if selected_tab_id:
            widget = self.child_notebook.nametowidget(selected_tab_id)
            if hasattr(widget, '_on_tab_selected'):
                widget._on_tab_selected(event)

    def _on_parent_tab_selected(self, event):
        print(f"Scanning Parent tab selected.")
        selected_tab_id = self.child_notebook.select()
        if selected_tab_id:
            widget = self.child_notebook.nametowidget(selected_tab_id)
            if hasattr(widget, '_on_tab_selected'):
                widget._on_tab_selected(event)

#####################################
### File: OPEN-AIR 2\workers\Scanning\tab_scanning_child_bands.py
#####################################
# tabs/Scanning/tab_scanning_child_bands.py
#
# This file defines the BandsTab, a Tkinter Frame that contains the UI for
# selecting and deselecting frequency bands for a scan. It has been
# refactored to allow multi-state selection (Low, Medium, High importance)
# and now includes a table and a bar chart to visualize the selected bands.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250810.220100.5 (FIXED: Removed redundant save_program_config  call from _on_tab_selected to prevent overwriting saved settings on app startup.)

current_version = "20250810.220100.5"
current_version_hash = 20250810 * 220100 * 5 # Example hash, adjust as needed

import tkinter as tk
from tkinter import ttk
import inspect
import os
import numpy as np
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

from display.debug_logic import debug_log
from display.console_logic import console_log
from settings_and_config.config_manager_save import save_program_config 

class BandsTab(ttk.Frame):
    """
    A Tkinter Frame that provides the user interface for selecting frequency bands to scan.
    """
    def __init__(self, master=None, app_instance=None, console_print_func=None, **kwargs):
        # This function description tells me what this function does
        # Initializes the BandsTab, creating the UI for multi-state band selection,
        # a summary table, and a visual bar chart of the selected bands.
        #
        # Inputs to this function
        #   master (tk.Widget): The parent widget, typically a ttk.Notebook.
        #   app_instance (object): A reference to the main application instance.
        #   console_print_func (function): A function for printing to the console.
        #   **kwargs: Arbitrary keyword arguments.
        #
        # Outputs of this function
        #   None. Initializes the Tkinter frame and its internal state.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Initializing BandsTab...",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func
        self.bands_inner_frame_id = None
        self.band_chart_fig = None
        self.band_chart_ax = None
        self.band_chart_canvas = None

        self._create_widgets()
        # The call to _on_tab_selected here is crucial, but it shouldn't save the config!
        self.after(100, self._on_tab_selected)

        debug_log(f"BandsTab initialized. All the band buttons are ready to be toggled!",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)

    def _create_widgets(self):
        # This function description tells me what this function does
        # Creates and arranges all widgets in the tab, including the control buttons,
        # the frame for the band buttons, the summary table, and the bar chart.
        #
        # Inputs to this function
        #   None.
        #
        # Outputs of this function
        #   None. Populates the tab with GUI elements.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Creating BandsTab widgets.",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)

        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(1, weight=0) # Band buttons frame
        self.grid_rowconfigure(2, weight=1) # Table frame
        self.grid_rowconfigure(3, weight=1) # Chart frame

        # --- Band Selection Buttons ---
        band_button_frame = ttk.Frame(self, style='Dark.TFrame')
        band_button_frame.grid(row=0, column=0, pady=5, padx=10, sticky="ew")
        band_button_frame.grid_columnconfigure(0, weight=1)
        band_button_frame.grid_columnconfigure(1, weight=1)
        
        ttk.Button(band_button_frame, text="Select All", command=self._select_all_bands, style='Blue.TButton').grid(row=0, column=0, padx=5, sticky="ew")
        ttk.Button(band_button_frame, text="Deselect All", command=self._deselect_all_bands, style='Blue.TButton').grid(row=0, column=1, padx=5, sticky="ew")

        # Frame for all Band Buttons
        self.bands_inner_frame = ttk.Frame(self, style='Dark.TFrame')
        self.bands_inner_frame.grid(row=1, column=0, padx=10, pady=5, sticky="nsew")
        self.bands_inner_frame.grid_columnconfigure(0, weight=1)
        self.bands_inner_frame.grid_columnconfigure(1, weight=1)

        # --- Selected Bands Table (Treeview) ---
        table_frame = ttk.Frame(self, style='Dark.TFrame')
        table_frame.grid(row=2, column=0, sticky="nsew", padx=10, pady=5)
        table_frame.grid_columnconfigure(0, weight=1)
        table_frame.grid_rowconfigure(0, weight=1)

        self.band_table = ttk.Treeview(table_frame, columns=("Name", "Start", "Stop", "Level"), show="headings")
        self.band_table.heading("Name", text="Name")
        self.band_table.heading("Start", text="Start (MHz)")
        self.band_table.heading("Stop", text="Stop (MHz)")
        self.band_table.heading("Level", text="Level")
        self.band_table.grid(row=0, column=0, sticky="nsew")
        
        # --- Band Importance Chart (Matplotlib) ---
        chart_frame = ttk.Frame(self, style='Dark.TFrame')
        chart_frame.grid(row=3, column=0, sticky="nsew", padx=10, pady=5)
        chart_frame.grid_columnconfigure(0, weight=1)
        chart_frame.grid_rowconfigure(0, weight=1)

        self.band_chart_fig = Figure(figsize=(5, 3), dpi=100, facecolor='#2b2b2b')
        self.band_chart_ax = self.band_chart_fig.add_subplot(111, facecolor='#1e1e1e')
        self.band_chart_canvas = FigureCanvasTkAgg(self.band_chart_fig, master=chart_frame)
        self.band_chart_canvas.get_tk_widget().grid(row=0, column=0, sticky="nsew")
        
        debug_log(f"BandsTab widgets created.",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)

    def _populate_band_buttons(self):
        # This function description tells me what this function does
        # Populates the scrollable frame with band selection buttons, dynamically
        # creating a button for each band defined in the application's band_vars.
        #
        # Inputs to this function
        #   None.
        #
        # Outputs of this function
        #   None. Populates the `bands_inner_frame` with buttons.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Populating band buttons.",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        for widget in self.bands_inner_frame.winfo_children():
            widget.destroy()
        
        self.bands_inner_frame.grid_columnconfigure(0, weight=1)
        self.bands_inner_frame.grid_columnconfigure(1, weight=1)

        for i, band_item in enumerate(self.app_instance.band_vars):
            band = band_item["band"]
            level = band_item.get("level", 0) # Get level, default to 0
            
            button_text = f"{band['Band Name']}\nStart: {band['Start MHz']:.3f} MHz\nStop: {band['Stop MHz']:.3f} MHz"
            
            btn = ttk.Button(self.bands_inner_frame, text=button_text)
            band_item['widget'] = btn # Store widget reference
            
            btn.configure(command=lambda bi=band_item: self._on_band_button_toggle(bi))
            
            self._update_button_style(btn, level)

            row, col = divmod(i, 2)
            btn.grid(row=row, column=col, sticky="ew", padx=2, pady=2)
            
        debug_log(f"Band buttons populated. Ready to toggle!",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)


    def _update_button_style(self, button, level):
        # This function description tells me what this function does
        # Updates the style of a band button based on its importance level.
        #
        # Inputs to this function
        #   button (ttk.Button): The button widget to style.
        #   level (int): The importance level (0=unselected, 1=low, 2=medium, 3=high).
        #
        # Outputs of this function
        #   None. Modifies the appearance of the button.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Updating button style for level {level}.",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        if level == 1:
            button.configure(style="Band.Low.TButton")
        elif level == 2:
            button.configure(style="Band.Medium.TButton")
        elif level == 3:
            button.configure(style="Band.High.TButton")
        else:
            button.configure(style="Band.TButton")


    def _on_band_button_toggle(self, band_item):
        # This function description tells me what this function does
        # Cycles the importance level of a band when its button is clicked and
        # updates the button's style. It then updates the table, chart, and saves the config.
        #
        # Inputs to this function
        #   band_item (dict): The dictionary containing the band's info, level, and widget.
        #
        # Outputs of this function
        #   None. Updates internal state, saves config, and refreshes the UI.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Toggling band importance. Current level: {band_item.get('level', 0)}",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        current_level = band_item.get("level", 0)
        new_level = (current_level + 1) % 4
        band_item["level"] = new_level
        
        self._update_button_style(band_item["widget"], new_level)
        
        # This is the correct place to save the config, AFTER a user action.
        save_program_config (self.app_instance.config, self.app_instance.CONFIG_FILE_PATH, self.console_print_func, self.app_instance)
        
        self._update_band_table()
        self._update_band_chart()


    def _update_band_table(self):
        # This function description tells me what this function does
        # Updates the Treeview table to display all bands with a non-zero importance level.
        #
        # Inputs to this function
        #   None.
        #
        # Outputs of this function
        #   None. Refreshes the content of the `band_table` Treeview.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Updating band table with selected bands.",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)

        # Clear existing entries
        for item in self.band_table.get_children():
            self.band_table.delete(item)

        importance_map = {1: "Low", 2: "Medium", 3: "High"}
        for band_item in self.app_instance.band_vars:
            level = band_item.get("level", 0)
            if level > 0:
                band = band_item["band"]
                self.band_table.insert("", "end", values=(
                    band['Band Name'],
                    f"{band['Start MHz']:.3f}",
                    f"{band['Stop MHz']:.3f}",
                    importance_map.get(level, "Unknown")
                ))

        self.band_table.update_idletasks()
        console_log("Band importance table updated.", function=current_function)
        
    def _update_band_chart(self):
        # This function description tells me what this function does
        # Creates or updates a Matplotlib bar chart to visually represent the selected
        # bands, their frequency ranges, and their importance levels.
        #
        # Inputs to this function
        #   None.
        #
        # Outputs of this function
        #   None. Renders the chart to the Tkinter canvas.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Updating band chart.",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)

        self.band_chart_ax.clear()
        self.band_chart_ax.set_facecolor('#1e1e1e')
        self.band_chart_ax.tick_params(axis='x', colors='white')
        self.band_chart_ax.tick_params(axis='y', colors='white')
        self.band_chart_ax.spines['bottom'].set_color('white')
        self.band_chart_ax.spines['top'].set_color('white')
        self.band_chart_ax.spines['left'].set_color('white')
        self.band_chart_ax.spines['right'].set_color('white')
        self.band_chart_ax.set_title("Band Importance Levels", color='white')
        self.band_chart_ax.set_xlabel("Frequency (MHz)", color='white')
        self.band_chart_ax.set_ylabel("Importance", color='white')

        # Map importance levels to Y values
        importance_y_map = {0: -10, 1: 25, 2: 50, 3: 100}

        selected_bands = []
        for band_item in self.app_instance.band_vars:
            level = band_item.get("level", 0)
            band = band_item["band"]
            selected_bands.append({
                'name': band['Band Name'],
                'start': band['Start MHz'],
                'stop': band['Stop MHz'],
                'level': level
            })

        if not selected_bands:
            debug_log(f"No bands selected to plot.",
                        file=os.path.basename(__file__),
                        version=current_version,
                        function=current_function)
            self.band_chart_canvas.draw()
            return
            
        min_freq = min(b['start'] for b in selected_bands)
        max_freq = max(b['stop'] for b in selected_bands)
        if min_freq == max_freq:
            min_freq -= 1
            max_freq += 1
        
        self.band_chart_ax.set_xlim(min_freq, max_freq)
        self.band_chart_ax.set_ylim(-20, 110)

        for band in selected_bands:
            color = 'gray'
            if band['level'] == 1:
                color = 'yellow'
            elif band['level'] == 2:
                color = 'orange'
            elif band['level'] == 3:
                color = 'red'
            
            self.band_chart_ax.bar(
                x=(band['start'] + band['stop']) / 2,
                height=importance_y_map.get(band['level'], -10),
                width=band['stop'] - band['start'],
                color=color,
                edgecolor='white'
            )

        self.band_chart_canvas.draw()
        console_log("Band importance chart updated.", function=current_function)


    def _update_all_band_button_styles(self):
        # This function description tells me what this function does
        # Iterates through all band buttons and updates their visual style
        # to match the current state of their associated importance level.
        #
        # Inputs to this function
        #   None.
        #
        # Outputs of this function
        #   None. Modifies the appearance of buttons.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Updating all band button styles.",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        for band_item in self.app_instance.band_vars:
            widget = band_item.get("widget")
            level = band_item.get("level", 0)
            if widget:
                self._update_button_style(widget, level)


    def _select_all_bands(self):
        # This function description tells me what this function does
        # Sets all band importance levels to High (3) and updates the UI.
        # It then saves the new configuration.
        #
        # Inputs to this function
        #   None.
        #
        # Outputs of this function
        #   None. Updates internal state and saves config.
        current_function = inspect.currentframe().f_code.co_name
        console_log("Selecting all bands for scan.", function=current_function)
        debug_log(f"Selecting all bands and saving config.",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        for band_item in self.app_instance.band_vars:
            band_item["level"] = 3 # High importance
        
        self._update_all_band_button_styles()
        save_program_config (self.app_instance.config, self.app_instance.CONFIG_FILE_PATH, self.console_print_func, self.app_instance)
        self._update_band_table()
        self._update_band_chart()


    def _deselect_all_bands(self):
        # This function description tells me what this function does
        # Sets all band importance levels to 0 (unselected) and updates the UI.
        # It then saves the new configuration.
        #
        # Inputs to this function
        #   None.
        #
        # Outputs of this function
        #   None. Updates internal state and saves config.
        current_function = inspect.currentframe().f_code.co_name
        console_log("Deselecting all bands for scan.", function=current_function)
        debug_log(f"Deselecting all bands and saving config.",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        for band_item in self.app_instance.band_vars:
            band_item["level"] = 0 # Unselected
        
        self._update_all_band_button_styles()
        save_program_config (self.app_instance.config, self.app_instance.CONFIG_FILE_PATH, self.console_print_func, self.app_instance)
        self._update_band_table()
        self._update_band_chart()


    def _on_tab_selected(self, event=None):
        # This function description tells me what this function does
        # Is called when the tab is selected. It ensures the UI elements
        # are populated and their styles are updated to reflect the current state.
        #
        # Inputs to this function
        #   event (tkinter.Event, optional): The event object.
        #
        # Outputs of this function
        #   None. Refreshes the UI.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"BandsTab selected. Populating and refreshing all widgets.",
                    file=os.path.basename(__file__),
                    version=current_version,
                    function=current_function)
        
        # We only want to populate the UI here, not save the config.
        # The save action is triggered by the user interacting with the buttons.
        self._populate_band_buttons()
        self._update_all_band_button_styles()
        self._update_band_table()
        self._update_band_chart()


#####################################
### File: OPEN-AIR 2\workers\Scanning\tab_scanning_child_scan_configuration.py
#####################################
# tabs/Scanning/tab_scanning_child_scan_configuration.py
#
# This file defines the ScanTab, a Tkinter Frame that provides a user interface
# for configuring scanner settings such as frequency span, RBW, sweep time, etc.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250815.151740.3
# FIX: Corrected import names and paths after refactoring of preset lists.

current_version = "20250815.151740.3"
current_version_hash = (20250815 * 151740 * 3)

import tkinter as tk
from tkinter import ttk
import inspect
import os
import subprocess
import sys
from tkinter import filedialog


from display.debug_logic import debug_log
from display.console_logic import console_log
from settings_and_config.config_manager_save import save_program_config 

# Import presets that have associated handlers
from ref.ref_scanner_setting_lists import (
    
    PRESET_AMPLITUDE_REFERENCE_LEVEL,
    PRESET_AMPLITUDE_PREAMP_STATE,
    PRESET_AMPLITUDE_HIGH_SENSITIVITY_STATE,
    PRESET_AMPLITUDE_POWER_ATTENUATION,
    PRESET_BANDWIDTH_RBW,
    PRESET_FREQUENCY_SPAN,
    PRESET_TRACE_MODES,
    PRESET_CONTINUOUS_MODE
)

# Import presets for UI only
from ref.ref_scanning_setting import (
    PRESET_SWEEP_TIME,
    PRESET_DISPLAY_GRAPH_QUALITY,
    PRESET_CYCLE_WAIT_TIME,
    PRESET_FREQUENCY_SHIFT,
    PRESET_NUMBER_OF_SCANS,
)


class ScanTab(ttk.Frame):
    """
    The Scan Configuration child tab. Contains all UI elements for setting
    up a scan session.
    """
    def __init__(self, master, app_instance, console_print_func, **kwargs):
        # This function description tells me what this function does
        # Initializes the ScanTab, creating a frame to hold the main scan
        # configuration settings, such as output folder, scan name, and
        # instrument parameters.
        #
        # Inputs to this function
        #   master (tk.Widget): The parent widget, typically a ttk.Notebook.
        #   app_instance (object): A reference to the main application instance.
        #   console_print_func (function): A function to use for console output.
        #   **kwargs: Arbitrary keyword arguments.
        #
        # Outputs of this function
        #   None. Initializes the Tkinter frame and its internal state.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Initializing ScanTab...",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        super().__init__(master, **kwargs)
        self.app_instance = app_instance
        self.console_print_func = console_print_func

        self.setting_widgets = {}
        self._create_widgets()
        self.after(100, self._on_tab_selected)
        
        debug_log(f"ScanTab initialized. Scan configuration widgets are ready.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)


    def _create_widgets(self):
        # This function description tells me what this function does
        # Creates and arranges all widgets in the tab, including the output
        # settings frame and the instrument scan settings frame.
        #
        # Inputs to this function
        #   None.
        #
        # Outputs of this function
        #   None. Populates the tab with GUI elements.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Creating ScanTab widgets.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(2, weight=1)

        # --- Output Settings ---
        output_frame = ttk.LabelFrame(self, text="Output Settings", style='Dark.TLabelframe')
        output_frame.grid(row=0, column=0, padx=10, pady=10, sticky="ew")
        output_frame.grid_columnconfigure(1, weight=1)

        ttk.Label(output_frame, text="Scan Name:").grid(row=0, column=0, padx=5, pady=2, sticky="w")
        ttk.Entry(output_frame, textvariable=self.app_instance.scan_name_var).grid(row=0, column=1, padx=5, pady=2, sticky="ew")

        ttk.Label(output_frame, text="Output Folder:").grid(row=1, column=0, padx=5, pady=2, sticky="w")
        ttk.Entry(output_frame, textvariable=self.app_instance.output_folder_var, state="readonly").grid(row=1, column=1, padx=5, pady=2, sticky="ew")
        ttk.Button(output_frame, text="Browse", command=self._browse_output_folder, style='Blue.TButton').grid(row=1, column=2, padx=5, pady=2)
        ttk.Button(output_frame, text="Open Output Folder", command=self._open_output_folder, style='Blue.TButton').grid(row=2, column=0, columnspan=3, padx=5, pady=5, sticky="ew")

        # --- Scan Settings ---
        settings_frame = ttk.LabelFrame(self, text="Scan Settings", style='Dark.TLabelframe')
        settings_frame.grid(row=1, column=0, padx=10, pady=10, sticky="ew")
        settings_frame.grid_columnconfigure(2, weight=1)

        row_idx = 0
        # self._create_setting_row(settings_frame, row_idx, "graph_quality", "Graph Quality:", self.app_instance.rbw_step_size_hz_var, graph_quality_drop_down, "Hz"); row_idx += 1
        # self._create_setting_row(settings_frame, row_idx, "dwell_time", "DWELL (s):", self.app_instance.maxhold_time_seconds_var, dwell_time_drop_down, "s"); row_idx += 1
        # self._create_setting_row(settings_frame, row_idx, "max_hold_time", "Max Hold Time (s):", self.app_instance.cycle_wait_time_seconds_var, cycle_wait_time_presets, "s"); row_idx += 1
        # self._create_setting_row(settings_frame, row_idx, "scan_rbw", "Scan RBW (Hz):", self.app_instance.scan_rbw_hz_var, rbw_presets, "Hz"); row_idx += 1
        # self._create_setting_row(settings_frame, row_idx, "reference_level", "Reference Level (dBm):", self.app_instance.reference_level_dbm_var, reference_level_drop_down, "dBm"); row_idx += 1
        # self._create_setting_row(settings_frame, row_idx, "frequency_shift", "Frequency Shift (Hz):", self.app_instance.freq_shift_var, frequency_shift_presets, "Hz"); row_idx += 1
        # self._create_setting_row(settings_frame, row_idx, "num_scan_cycles", "Number of Scan Cycles:", self.app_instance.num_scan_cycles_var, number_of_scans_presets, "cycles"); row_idx += 1

        # # Boolean settings
        # ttk.Label(settings_frame, text="High Sensitivity:").grid(row=row_idx, column=0, padx=5, pady=2, sticky="w");
        # hs_combo = ttk.Combobox(settings_frame, values=["Yes", "No"], state="readonly", width=35); hs_combo.grid(row=row_idx, column=1, padx=5, pady=2, sticky="w")
        # hs_combo.bind("<<ComboboxSelected>>", lambda e, v=self.app_instance.high_sensitivity_var: self._on_boolean_combobox_select(e, v)); self.setting_widgets['high_sensitivity'] = {'widget': hs_combo, 'var': self.app_instance.high_sensitivity_var}; row_idx += 1
        #
        # ttk.Label(settings_frame, text="Preamplifier ON:").grid(row=row_idx, column=0, padx=5, pady=2, sticky="w");
        # pa_combo = ttk.Combobox(settings_frame, values=["Yes", "No"], state="readonly", width=35); pa_combo.grid(row=row_idx, column=1, padx=5, pady=2, sticky="w")
        # pa_combo.bind("<<ComboboxSelected>>", lambda e, v=self.app_instance.preamp_on_var: self._on_boolean_combobox_select(e, v)); self.setting_widgets['preamp_on'] = {'widget': pa_combo, 'var': self.app_instance.preamp_on_var}; row_idx += 1
        #
        # # --- ADDED BACK: Simple Entry fields ---
        # ttk.Label(settings_frame, text="Scan RBW Segmentation (Hz):").grid(row=row_idx, column=0, padx=5, pady=2, sticky="w")
        # ttk.Entry(settings_frame, textvariable=self.app_instance.scan_rbw_segmentation_var).grid(row=row_idx, column=1, sticky="ew", columnspan=2, padx=5, pady=2)
        # row_idx += 1
        # ttk.Label(settings_frame, text="Default Focus Width (Hz):").grid(row=row_idx, column=0, padx=5, pady=2, sticky="w")
        # ttk.Entry(settings_frame, textvariable=self.app_instance.desired_default_focus_width_var).grid(row=row_idx, column=1, sticky="ew", columnspan=2, padx=5, pady=2)
        # row_idx += 1

        debug_log(f"ScanTab widgets created.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
    def _create_setting_row(self, parent, row, key, label_text, app_var, data_list, unit=""):
        """Generic function to create and store a labeled combobox row for a setting."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Creating setting row for {key}.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        ttk.Label(parent, text=label_text).grid(row=row, column=0, padx=5, pady=2, sticky="w")
        display_values = [f"{item['value']} {unit}".strip() + f" - {item['label']}" for item in data_list]
        combo = ttk.Combobox(parent, values=display_values, state="readonly", width=35)
        combo.grid(row=row, column=1, padx=5, pady=2, sticky="w")
        description_var = tk.StringVar(self)
        ttk.Label(parent, textvariable=description_var, wraplength=400, justify="left").grid(row=row, column=2, padx=5, pady=2, sticky="w")
        combo.bind("<<ComboboxSelected>>", lambda e, v=app_var, d=data_list, dv=description_var, u=unit: self._on_combobox_select(e, v, d, dv, u))
        self.setting_widgets[key] = {'widget': combo, 'var': app_var, 'data': data_list, 'desc_var': description_var, 'unit': unit}

    def _on_combobox_select(self, event, app_var, data_list, description_var, unit):
        """Generic event handler for our settings comboboxes."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Combobox selected. Updating value and description.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        selected_display = event.widget.get()
        found_item = None
        for item in data_list:
            item_display = f"{item['value']} {unit}".strip() + f" - {item['label']}"
            if selected_display == item_display:
                found_item = item
                break
        if found_item:
            app_var.set(found_item['value'])
            description_var.set(found_item['description'])
            save_program_config (self.app_instance.config, self.app_instance.CONFIG_FILE_PATH, self.console_print_func, self.app_instance)

    def _on_boolean_combobox_select(self, event, app_var):
        """Handler specifically for 'Yes'/'No' comboboxes."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Boolean combobox selected. Updating value.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        is_yes = event.widget.get() == "Yes"
        app_var.set(is_yes)
        save_program_config (self.app_instance.config, self.app_instance.CONFIG_FILE_PATH, self.console_print_func, self.app_instance)

    def _set_combobox_display_from_value(self, key):
        """Helper to find and set the display text and description for a given raw value."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Setting combobox display from value for {key}.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        widget_info = self.setting_widgets.get(key)
        if not widget_info: return
        combo, app_var, data_list, desc_var, unit = widget_info['widget'], widget_info['var'], widget_info['data'], widget_info['desc_var'], widget_info['unit']
        current_value = app_var.get()
        found_item = None
        for item in data_list:
            if isinstance(current_value, float) and abs(float(item['value']) - current_value) < 1e-9:
                found_item = item
                break
            elif str(item['value']) == str(current_value):
                found_item = item
                break
        if found_item:
            display_text = f"{found_item['value']} {unit}".strip() + f" - {found_item['label']}"
            combo.set(display_text)
            desc_var.set(found_item['description'])
        else:
            combo.set(f"{current_value} {unit}".strip() + " - Custom")
            desc_var.set("Custom value not in presets.")

    def _load_settings_into_ui(self):
        """Populates all UI elements with values from the app_instance variables."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Loading settings into UI.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        for key in self.setting_widgets:
            if key in ['high_sensitivity', 'preamp_on']:
                widget_info = self.setting_widgets[key]
                widget_info['widget'].set("Yes" if widget_info['var'].get() else "No")
            else:
                self._set_combobox_display_from_value(key)

    def _browse_output_folder(self):
        # This function description tells me what this function does
        # Opens a file dialog for the user to select an output folder and saves
        # the selected path to the `output_folder_var` in the main application instance.
        #
        # Inputs to this function
        #   None.
        #
        # Outputs of this function
        #   None. Updates a Tkinter variable and saves the config.
        current_function = inspect.currentframe().f_code.co_name
        console_log("Browse for output folder...", self.console_print_func, function=current_function)
        debug_log(f"Opening file dialog to select output folder.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        folder = filedialog.askdirectory()
        if folder:
            self.app_instance.output_folder_var.set(folder)
            save_program_config (self.app_instance.config, self.app_instance.CONFIG_FILE_PATH, self.console_print_func, self.app_instance)

    def _open_output_folder(self):
        # This function description tells me what this function does
        # Opens the currently selected output folder using the default file explorer
        # for the operating system. It handles different OS commands and logs errors.
        #
        # Inputs to this function
        #   None.
        #
        # Outputs of this function
        #   None. Opens a file explorer window.
        current_function = inspect.currentframe().f_code.co_name
        path = self.app_instance.output_folder_var.get()
        debug_log(f"Attempting to open output folder: {path}",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        if os.path.isdir(path):
            try:
                if sys.platform == "win32":
                    os.startfile(path)
                elif sys.platform == "darwin":
                    subprocess.Popen(["open", path])
                else:
                    subprocess.Popen(["xdg-open", path])
                console_log(f"✅ Opened output folder: {path}", self.console_print_func, function=current_function)
            except Exception as e:
                console_log(f"❌ Error opening folder: {e}", self.console_print_func, function=current_function)
        else:
            console_log(f"❌ Folder not found: {path}", self.console_print_func, function=current_function)

    def _on_tab_selected(self, event=None):
        """Called when the tab is selected, ensures UI is synced with config."""
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"ScanTab selected. Refreshing UI from config.",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        
        self._load_settings_into_ui()


#####################################
### File: OPEN-AIR 2\workers\Scanning\tab_scanning_child_scan_meta_data.py
#####################################
# tabs/Scanning/tab_scanning_child_scan_meta_data.py
#
# This file defines the ScanMetaDataTab, a Tkinter Frame that contains the Scan Meta Data settings.
# This includes operator, venue, equipment, and general notes. It provides interactive elements
# like a postal code lookup and dynamic updates for antenna and amplifier descriptions.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250802.0011.3 (Fixed TclError: unknown option "-style_obj" by explicitly filtering it from kwargs.)

current_version = "20250802.0011.3" # this variable should always be defined below the header to make the debugging better
current_version_hash = 20250802 * 11 * 3 # Example hash, adjust as needed

import tkinter as tk
from tkinter import ttk, scrolledtext
import inspect
import os # For os.path.exists and os.makedirs
import subprocess # For opening folders

# Updated imports for new logging functions
from display.debug_logic import debug_log
from display.console_logic import console_log

from settings_and_config.config_manager_save import save_program_config 

# Import new modules for functionality - CORRECTED PATHS
from process_math.google_maps_lookup import get_location_from_google_maps
from ref.ref_antenna_type import antenna_types
from ref.ref_antenna_amplifier_type import antenna_amplifier_types


class ScanMetaDataTab(ttk.Frame):
    """
    A Tkinter Frame that contains the Scan Meta Data settings.
    This includes operator, venue, equipment, and general notes.
    """
    def __init__(self, master=None, app_instance=None, console_print_func=None, style_obj=None, **kwargs):
        # This function description tells me what this function does
        # Initializes the ScanMetaDataTab, setting up the UI frame,
        # linking to the main application instance, and preparing
        # Tkinter variables for meta data fields.
        #
        # Inputs to this function
        #   master (tk.Widget): The parent widget, typically a ttk.Notebook.
        #   app_instance (object): Reference to the main application instance
        #                          to access shared variables and methods.
        #   console_print_func (function): A function to print messages to the
        #                                  application's console output.
        #   style_obj (ttk.Style): The ttk.Style object for applying styles.
        #   **kwargs: Arbitrary keyword arguments passed to the ttk.Frame constructor.
        #
        # Process of this function
        #   1. Calls the superclass constructor (ttk.Frame).
        #   2. Stores references to app_instance, console_print_func, and style_obj.
        #   3. Initializes new Tkinter StringVars for postal code, address, province,
        #      selected antenna type, antenna description, antenna use, antenna mount,
        #      and selected amplifier type, amplifier description, and amplifier use.
        #   4. Calls _create_widgets to build the UI.
        #
        # Outputs of this function
        #   None. Initializes the Tkinter frame and its internal state.
        #
        # (2025-07-30) Change: Initialized new StringVars for regrouped fields, including new amplifier description/use.
        # (20250801.2330.1) Change: Refactored debug_print to use debug_log and console_log.
        # (20250802.0011.1) Change: Added missing widget attributes to allow external configuration.
        # (20250802.0011.2) Change: Fixed TclError by correctly handling style_obj in __init__.
        # (20250802.0011.3) Change: Fixed TclError by explicitly filtering style_obj from kwargs.
        
        # Filter out 'style_obj' from kwargs before passing to super().__init__
        filtered_kwargs = {k: v for k, v in kwargs.items() if k != 'style_obj'}
        super().__init__(master, style='Dark.TFrame', **filtered_kwargs) # Pass style string, and filtered kwargs

        self.app_instance = app_instance
        self.console_print_func = console_print_func if console_print_func else console_log # Use console_log as default
        self.style_obj = style_obj # Store the style object

        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Initializing ScanMetaDataTab. Version: {current_version}. Setting up meta data fields!",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        self._create_widgets()

        debug_log(f"ScanMetaDataTab initialized. Version: {current_version}. Meta data interface ready!",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    def _create_widgets(self):
        # This function description tells me what this function does
        # Creates and arranges the widgets for the Scan Meta Data tab,
        # grouping them into Personnel, Location, Equipment Used, and Notes sections.
        # It includes interactive elements like a postal code lookup button and
        # dropdowns for antenna and amplifier types with dynamic description updates.
        #
        # Inputs to this function
        #   None (operates on self).
        #
        # Process of this function
        #   1. Prints a debug message.
        #   2. Creates main LabelFrames for Personnel, Location, Equipment Used, and Notes.
        #   3. Populates each frame with appropriate Labels, Entry widgets,
        #      Buttons, and Comboboxes, linking them to app_instance variables.
        #   4. Configures grid layouts for each section to ensure proper alignment and resizing.
        #   5. Binds events for the postal code lookup button and Combobox selections
        #      to their respective handler methods.
        #   6. Initializes the notes ScrolledText widget and binds its key release event.
        #
        # Outputs of this function
        #   None. Modifies the Tkinter frame by adding and arranging widgets.
        #
        # (2025-07-30) Change: Made location fields editable; added amplifier description/use fields.
        # (2025-07-30) Change: Made antenna/amplifier description/use fields editable.
        # (20250801.2330.1) Change: Refactored debug_print to use debug_log and console_log.
        # (20250802.0011.1) Change: Assigned widgets to self attributes for external access.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Creating ScanMetaDataTab widgets... Building the meta data input form! Version: {current_version}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        # Main grid configuration for the tab
        self.grid_columnconfigure(0, weight=1)
        self.grid_rowconfigure(0, weight=0) # Personnel
        self.grid_rowconfigure(1, weight=0) # Location
        self.grid_rowconfigure(2, weight=0) # Equipment
        self.grid_rowconfigure(3, weight=1) # Notes (allow to expand)


        # --- Personnel Box ---
        personnel_frame = ttk.LabelFrame(self, text="Personnel", style='Dark.TLabelframe')
        personnel_frame.grid(row=0, column=0, padx=10, pady=5, sticky="ew")
        personnel_frame.grid_columnconfigure(1, weight=1) # Allow entry widgets to expand

        ttk.Label(personnel_frame, text="Operator Name:", style='TLabel').grid(row=0, column=0, padx=5, pady=2, sticky="w")
        self.operator_name_entry = ttk.Entry(personnel_frame, textvariable=self.app_instance.operator_name_var, style='TEntry')
        self.operator_name_entry.grid(row=0, column=1, padx=5, pady=2, sticky="ew")

        ttk.Label(personnel_frame, text="Operator Contact:", style='TLabel').grid(row=1, column=0, padx=5, pady=2, sticky="w")
        self.operator_contact_entry = ttk.Entry(personnel_frame, textvariable=self.app_instance.operator_contact_var, style='TEntry')
        self.operator_contact_entry.grid(row=1, column=1, padx=5, pady=2, sticky="ew")


        # --- Location Box ---
        location_frame = ttk.LabelFrame(self, text="Location", style='Dark.TLabelframe')
        location_frame.grid(row=1, column=0, padx=10, pady=5, sticky="ew")
        location_frame.grid_columnconfigure(1, weight=1) # Allow entry widgets to expand

        ttk.Label(location_frame, text="Venue Name:", style='TLabel').grid(row=0, column=0, padx=5, pady=2, sticky="w")
        self.venue_name_entry = ttk.Entry(location_frame, textvariable=self.app_instance.venue_name_var, style='TEntry')
        self.venue_name_entry.grid(row=0, column=1, padx=5, pady=2, sticky="ew")

        ttk.Label(location_frame, text="Venue Postal Code:", style='TLabel').grid(row=1, column=0, padx=5, pady=2, sticky="w")
        self.postal_code_entry = ttk.Entry(location_frame, textvariable=self.app_instance.venue_postal_code_var, style='TEntry')
        self.postal_code_entry.grid(row=1, column=1, padx=5, pady=2, sticky="ew")
        # Button for calling the postal code lookup function
        self.lookup_location_button = ttk.Button(location_frame, text="Lookup Location", command=self._lookup_postal_code, style='Blue.TButton')
        self.lookup_location_button.grid(row=1, column=2, padx=5, pady=2, sticky="e")

        ttk.Label(location_frame, text="Address Field:", style='TLabel').grid(row=2, column=0, padx=5, pady=2, sticky="w")
        # CHANGED: Removed state='readonly'
        self.address_field_entry = ttk.Entry(location_frame, textvariable=self.app_instance.address_field_var, style='TEntry')
        self.address_field_entry.grid(row=2, column=1, columnspan=2, padx=5, pady=2, sticky="ew")

        ttk.Label(location_frame, text="City:", style='TLabel').grid(row=3, column=0, padx=5, pady=2, sticky="w")
        # CHANGED: Removed state='readonly'
        self.city_entry = ttk.Entry(location_frame, textvariable=self.app_instance.city_var, style='TEntry')
        self.city_entry.grid(row=3, column=1, columnspan=2, padx=5, pady=2, sticky="ew")

        ttk.Label(location_frame, text="Province:", style='TLabel').grid(row=4, column=0, padx=5, pady=2, sticky="w")
        # CHANGED: Removed state='readonly'
        self.province_entry = ttk.Entry(location_frame, textvariable=self.app_instance.province_var, style='TEntry')
        self.province_entry.grid(row=4, column=1, columnspan=2, padx=5, pady=2, sticky="ew")


        # --- Equipment Used Box ---
        equipment_frame = ttk.LabelFrame(self, text="Equipment Used", style='Dark.TLabelframe')
        equipment_frame.grid(row=2, column=0, padx=10, pady=5, sticky="ew")
        equipment_frame.grid_columnconfigure(1, weight=1) # Allow entry/combobox to expand

        ttk.Label(equipment_frame, text="Scanner Type:", style='TLabel').grid(row=0, column=0, padx=5, pady=2, sticky="w")
        # Renamed to equipment_used_entry to match scan_logic.py's expectation
        self.equipment_used_entry = ttk.Entry(equipment_frame, textvariable=self.app_instance.scanner_type_var, style='TEntry')
        self.equipment_used_entry.grid(row=0, column=1, padx=5, pady=2, sticky="ew")

        ttk.Label(equipment_frame, text="Antenna Type:", style='TLabel').grid(row=1, column=0, padx=5, pady=2, sticky="w")
        # Renamed to antenna_type_dropdown to match scan_logic.py's expectation
        self.antenna_type_dropdown = ttk.Combobox(
            equipment_frame,
            textvariable=self.app_instance.selected_antenna_type_var,
            values=[ant["Type"] for ant in antenna_types],
            state="readonly", # This remains readonly as it's a selection from a predefined list
            style='TCombobox'
        )
        self.antenna_type_dropdown.grid(row=1, column=1, padx=5, pady=2, sticky="ew")
        self.antenna_type_dropdown.bind("<<ComboboxSelected>>", self._on_antenna_type_selected)

        ttk.Label(equipment_frame, text="Antenna Description:", style='TLabel').grid(row=2, column=0, padx=5, pady=2, sticky="w")
        # CHANGED: state='readonly' to state='normal'
        self.antenna_description_entry = ttk.Entry(equipment_frame, textvariable=self.app_instance.antenna_description_var, state='normal', style='TEntry')
        self.antenna_description_entry.grid(row=2, column=1, padx=5, pady=2, sticky="ew")

        ttk.Label(equipment_frame, text="Antenna Use:", style='TLabel').grid(row=3, column=0, padx=5, pady=2, sticky="w")
        # CHANGED: state='readonly' to state='normal'
        self.antenna_use_entry = ttk.Entry(equipment_frame, textvariable=self.app_instance.antenna_use_var, state='normal', style='TEntry')
        self.antenna_use_entry.grid(row=3, column=1, padx=5, pady=2, sticky="ew")

        ttk.Label(equipment_frame, text="Antenna Mount:", style='TLabel').grid(row=4, column=0, padx=5, pady=2, sticky="w")
        self.antenna_mount_entry = ttk.Entry(equipment_frame, textvariable=self.app_instance.antenna_mount_var, style='TEntry')
        self.antenna_mount_entry.grid(row=4, column=1, padx=5, pady=2, sticky="ew")

        # Spacer
        ttk.Separator(equipment_frame, orient='horizontal').grid(row=5, column=0, columnspan=2, pady=5, sticky="ew")

        ttk.Label(equipment_frame, text="Antenna Amplifier Type:", style='TLabel').grid(row=6, column=0, padx=5, pady=2, sticky="w")
        # Renamed to antenna_amplifier_dropdown to match scan_logic.py's expectation
        self.antenna_amplifier_dropdown = ttk.Combobox(
            equipment_frame,
            textvariable=self.app_instance.selected_amplifier_type_var,
            values=[amp["Type"] for amp in antenna_amplifier_types],
            state="readonly", # This remains readonly as it's a selection from a predefined list
            style='TCombobox'
        )
        self.antenna_amplifier_dropdown.grid(row=6, column=1, padx=5, pady=2, sticky="ew")
        self.antenna_amplifier_dropdown.bind("<<ComboboxSelected>>", self._on_amplifier_type_selected)

        # NEW: Amplifier Description and Use fields
        ttk.Label(equipment_frame, text="Amplifier Description:", style='TLabel').grid(row=7, column=0, padx=5, pady=2, sticky="w")
        # CHANGED: state='readonly' to state='normal'
        self.amplifier_description_entry = ttk.Entry(equipment_frame, textvariable=self.app_instance.amplifier_description_var, state='normal', style='TEntry')
        self.amplifier_description_entry.grid(row=7, column=1, padx=5, pady=2, sticky="ew")

        ttk.Label(equipment_frame, text="Amplifier Use:", style='TLabel').grid(row=8, column=0, padx=5, pady=2, sticky="w")
        # CHANGED: state='readonly' to state='normal'
        self.amplifier_use_entry = ttk.Entry(equipment_frame, textvariable=self.app_instance.amplifier_use_var, state='normal', style='TEntry')
        self.amplifier_use_entry.grid(row=8, column=1, padx=5, pady=2, sticky="ew")


        # --- Notes ---
        notes_frame = ttk.LabelFrame(self, text="Notes", style='Dark.TLabelframe')
        notes_frame.grid(row=3, column=0, padx=10, pady=5, sticky="nsew")
        notes_frame.grid_columnconfigure(0, weight=1) # Allow notes widget to expand
        notes_frame.grid_rowconfigure(0, weight=1) # Allow notes widget to expand

        # Renamed to notes_text to match scan_logic.py's expectation
        self.notes_text = scrolledtext.ScrolledText(notes_frame, wrap=tk.WORD, width=40, height=5)
        self.notes_text.grid(row=0, column=0, padx=5, pady=2, sticky="nsew")
        self.notes_text.bind("<KeyRelease>", self._on_notes_change)

        debug_log(f"ScanMetaDataTab widgets created. Meta data form is complete! Version: {current_version}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    def _on_notes_change(self, event=None):
        # This function description tells me what this function does
        # Updates the Tkinter notes_var from the ScrolledText widget and saves config.
        #
        # Inputs to this function
        #   event (tkinter.Event, optional): The event object that triggered the call.
        #
        # Process of this function
        #   1. Retrieves the current text from the ScrolledText widget.
        #   2. Sets the `app_instance.notes_var` with the retrieved text.
        #   3. Prints a debug message with the updated notes.
        #   4. Calls `save_program_config ` to persist the changes.
        #
        # Outputs of this function
        #   None. Updates an internal Tkinter variable and saves application configuration.
        #
        # (2025-07-30) Change: No functional change, just updated header.
        # (20250801.2330.1) Change: Refactored debug_print to use debug_log and console_log.
        # (20250802.0011.1) Change: Updated to use self.notes_text.
        """Updates the Tkinter notes_var from the ScrolledText widget and saves config."""
        self.app_instance.notes_var.set(self.notes_text.get("1.0", tk.END).strip())
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Notes updated: {self.app_instance.notes_var.get()}. Version: {current_version}",
                    file=__file__,
                    version=current_version,
                    function=current_function)
        # Corrected call to save_program_config  with all required arguments
        save_program_config (self.app_instance.config, self.app_instance.CONFIG_FILE_PATH, self.console_print_func, self.app_instance)


    def _on_tab_selected(self, event):
        # This function description tells me what this function does
        # Called when this tab is selected in the notebook.
        # This can be used to refresh data or update UI elements specific to this tab.
        #
        # Inputs to this function
        #   event (tkinter.Event): The event object that triggered the call.
        #
        # Process of this function
        #   1. Prints a debug message indicating the tab selection.
        #   2. Ensures the notes widget reflects the current value of `app_instance.notes_var`.
        #   3. Populates the `antenna_type_dropdown` and `antenna_amplifier_dropdown`
        #      with their respective values from `app_instance` if they are set.
        #   4. Triggers the update of antenna description and use based on the current selection.
        #   5. Explicitly populates all other text entry fields from their `app_instance` variables
        #      to ensure they reflect the loaded config values when the tab is selected.
        #
        # Outputs of this function
        #   None. Refreshes the UI elements on tab selection.
        #
        # (2025-07-30) Change: Added logic to refresh comboboxes and associated fields on tab selection.
        # (2025-07-30) Change: Added explicit population of all text entry fields from app_instance variables.
        # (20250801.2330.1) Change: Refactored debug_print to use debug_log and console_log.
        # (20250802.0011.1) Change: Updated to use new widget attribute names.
        """
        Called when this tab is selected in the notebook.
        This can be used to refresh data or update UI elements specific to this tab.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Scan Meta Data Tab selected. Refreshing all fields! Version: {current_version}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        # When the tab is selected, ensure the notes widget reflects the app_instance's variable
        self.notes_text.delete("1.0", tk.END)
        self.notes_text.insert("1.0", self.app_instance.notes_var.get())

        # Explicitly set the values for all Entry widgets from their associated StringVars
        # This is a robust way to ensure the UI is in sync with the model (app_instance variables)
        self.operator_name_entry.config(textvariable=self.app_instance.operator_name_var)
        self.operator_contact_entry.config(textvariable=self.app_instance.operator_contact_var)
        self.venue_name_entry.config(textvariable=self.app_instance.venue_name_var)
        self.postal_code_entry.config(textvariable=self.app_instance.venue_postal_code_var)
        self.address_field_entry.config(textvariable=self.app_instance.address_field_var)
        self.city_entry.config(textvariable=self.app_instance.city_var)
        self.province_entry.config(textvariable=self.app_instance.province_var)
        self.equipment_used_entry.config(textvariable=self.app_instance.scanner_type_var) # Corrected
        self.antenna_mount_entry.config(textvariable=self.app_instance.antenna_mount_var)
        
        # For comboboxes, set their value and then trigger their selection handler
        # This will ensure their associated description/use fields are also updated
        if self.app_instance.selected_antenna_type_var.get():
            self.antenna_type_dropdown.set(self.app_instance.selected_antenna_type_var.get())
            self._on_antenna_type_selected(None) # Trigger update of description/use
        else: # If no antenna type is selected, clear the description/use fields
            self.app_instance.antenna_description_var.set("")
            self.app_instance.antenna_use_var.set("")

        if self.app_instance.selected_amplifier_type_var.get():
            self.antenna_amplifier_dropdown.set(self.app_instance.selected_amplifier_type_var.get())
            self._on_amplifier_type_selected(None) # Trigger update of amplifier description/use
        else: # If no amplifier type is selected, clear the description/use fields
            self.app_instance.amplifier_description_var.set("")
            self.app_instance.amplifier_use_var.set("")

        debug_log(f"Scan Meta Data Tab refreshed. All fields are up-to-date! Version: {current_version}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    def _lookup_postal_code(self):
        # This function description tells me what this function does
        # Initiates a lookup of the venue postal code using the Google Maps Geocoding API.
        # It retrieves the postal code from the associated Tkinter variable,
        # calls the `get_location_from_google_maps` function, and updates the
        # address, city, and province Tkinter variables with the results.
        #
        # Inputs to this function
        #   None (operates on self).
        #
        # Process of this function
        #   1. Prints a debug message.
        #   2. Retrieves the postal code from `app_instance.venue_postal_code_var`.
        #   3. Checks if the postal code is empty. If so, prints a warning and clears fields.
        #   4. Calls `get_location_from_google_maps` with the postal code.
        #   5. Updates `app_instance.address_field_var`, `app_instance.city_var`,
        #      and `app_instance.province_var` with the returned values.
        #   6. Calls `save_program_config ` to persist the updated location data.
        #
        # Outputs of this function
        #   None. Updates Tkinter variables and saves configuration.
        #
        # (2025-07-30) Change: Updated to use `get_location_from_google_maps`.
        # (20250801.2330.1) Change: Refactored debug_print to use debug_log and console_log.
        # (20250802.0011.1) Change: No functional changes.
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Attempting postal code lookup using Google Maps API. Let's find this location! Version: {current_version}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        postal_code = self.app_instance.venue_postal_code_var.get().strip()
        if not postal_code:
            self.console_print_func("⚠️ Please enter a postal code to look up. Don't leave it blank!")
            self.app_instance.address_field_var.set("")
            self.app_instance.city_var.set("")
            self.app_instance.province_var.set("")
            # Corrected call to save_program_config  with all required arguments
            save_program_config (self.app_instance.config, self.app_instance.CONFIG_FILE_PATH, self.console_print_func, self.app_instance)
            debug_log(f"Postal code was empty. Lookup aborted. Version: {current_version}",
                        file=__file__,
                        version=current_version,
                        function=current_function)
            return

        # CHANGED: Call get_location_from_google_maps instead of get_location_from_text
        city, province, street_address = get_location_from_google_maps(postal_code, self.console_print_func)

        self.app_instance.address_field_var.set(street_address if street_address else "") # Changed N/A to empty string
        self.app_instance.city_var.set(city if city else "") # Changed N/A to empty string
        self.app_instance.province_var.set(province if province else "") # Changed N/A to empty string
        
        # Corrected call to save_program_config  with all required arguments
        save_program_config (self.app_instance.config, self.app_instance.CONFIG_FILE_PATH, self.console_print_func, self.app_instance)
        self.console_print_func("✅ Postal code lookup complete and fields updated. Location found!")
        debug_log(f"Postal code lookup complete and fields updated. Version: {current_version}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    def _on_antenna_type_selected(self, event):
        # This function description tells me what this function does
        # Event handler for when an antenna type is selected from the dropdown.
        # It updates the 'Antenna Description' and 'Antenna Use' text boxes
        # based on the selected antenna type's data from `antenna_types`.
        #
        # Inputs to this function
        #   event (tkinter.Event): The event object that triggered the call.
        #
        # Process of this function
        #   1. Prints a debug message.
        #   2. Retrieves the currently selected antenna type from `selected_antenna_type_var`.
        #   3. Iterates through the `antenna_types` list to find a matching entry.
        #   4. If a match is found, updates `antenna_description_var` and `antenna_use_var`
        #      with the corresponding description and use.
        #   5. If no match is found, clears the description and use fields.
        #   6. Calls `save_program_config ` to persist the selected antenna type.
        #
        # Outputs of this function
        #   None. Updates Tkinter variables and saves configuration.
        #
        # (2025-07-30) Change: No functional change, just updated header.
        # (20250801.2330.1) Change: Refactored debug_print to use debug_log and console_log.
        # (20250802.0011.1) Change: No functional changes.
        """
        Event handler for when an antenna type is selected from the dropdown.
        It updates the 'Antenna Description' and 'Antenna Use' text boxes
        based on the selected antenna type's data from `antenna_types`.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Antenna type selected. Updating description and use! Version: {current_version}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        selected_type = self.app_instance.selected_antenna_type_var.get()
        found_antenna = next((ant for ant in antenna_types if ant["Type"] == selected_type), None)

        if found_antenna:
            self.app_instance.antenna_description_var.set(found_antenna["Description"])
            self.app_instance.antenna_use_var.set(found_antenna["Use"])
            debug_log(f"Updated antenna description and use for: {selected_type}. Details loaded!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        else:
            self.app_instance.antenna_description_var.set("")
            self.app_instance.antenna_use_var.set("")
            debug_log(f"No description/use found for selected antenna type: {selected_type}. Fields cleared!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        
        # Corrected call to save_program_config  with all required arguments
        save_program_config (self.app_instance.config, self.app_instance.CONFIG_FILE_PATH, self.console_print_func, self.app_instance)
        debug_log(f"Antenna type updated and config saved. Version: {current_version}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


    def _on_amplifier_type_selected(self, event):
        # This function description tells me what this function does
        # Event handler for when an amplifier type is selected from the dropdown.
        # It updates the `app_instance.antenna_amplifier_var` to reflect the
        # selected amplifier type, and also populates the `Amplifier Description`
        # and `Amplifier Use` text boxes based on the selected type's data.
        #
        # Inputs to this function
        #   event (tkinter.Event): The event object that triggered the call.
        #
        # Process of this function
        #   1. Prints a debug message.
        #   2. Retrieves the currently selected amplifier type from `selected_amplifier_type_var`.
        #   3. Sets the `app_instance.antenna_amplifier_var` with the selected type.
        #   4. Iterates through the `antenna_amplifier_types` list to find a matching entry.
        #   5. If a match is found, updates `amplifier_description_var` and `amplifier_use_var`
        #      with the corresponding description and use.
        #   6. If no match is found, clears the description and use fields.
        #   7. Calls `save_program_config ` to persist the selected amplifier type and its details.
        #
        # Outputs of this function
        #   None. Updates Tkinter variables and saves configuration.
        #
        # (2025-07-30) Change: Populated amplifier description and use fields, and updated header.
        # (20250801.2330.1) Change: Refactored debug_print to use debug_log and console_log.
        # (20250802.0011.1) Change: No functional changes.
        """
        Event handler for when an amplifier type is selected from the dropdown.
        It updates the `app_instance.antenna_amplifier_var` to reflect the
        selected amplifier type, and also populates the `Amplifier Description`
        and `Amplifier Use` text boxes based on the selected type's data.
        """
        current_function = inspect.currentframe().f_code.co_name
        debug_log(f"Amplifier type selected. Getting details for this amplifier! Version: {current_version}",
                    file=__file__,
                    version=current_version,
                    function=current_function)

        selected_type = self.app_instance.selected_amplifier_type_var.get()
        # The original antenna_amplifier_var was an Entry, now it's effectively linked to the Combobox selection
        self.app_instance.antenna_amplifier_var.set(selected_type)
        
        # NEW: Populate amplifier description and use
        found_amplifier = next((amp for amp in antenna_amplifier_types if amp["Type"] == selected_type), None)

        if found_amplifier:
            self.app_instance.amplifier_description_var.set(found_amplifier["Description"])
            self.app_instance.amplifier_use_var.set(found_amplifier["Use"])
            debug_log(f"Updated amplifier description and use for: {selected_type}. Details loaded!",
                        file=__file__,
                        version=current_version,
                        function=current_function)
        else:
            self.app_instance.amplifier_description_var.set("")
            self.app_instance.amplifier_use_var.set("")
            debug_log(f"No description/use found for selected amplifier type: {selected_type}. Fields cleared!",
                        file=__file__,
                        version=current_version,
                        function=current_function)

        # Corrected call to save_program_config  with all required arguments
        save_program_config (self.app_instance.config, self.app_instance.CONFIG_FILE_PATH, self.console_print_func, self.app_instance)
        debug_log(f"Updated antenna amplifier to: {selected_type}. Config saved! Version: {current_version}",
                    file=__file__,
                    version=current_version,
                    function=current_function)


#####################################
### File: OPEN-AIR 2\workers\Scanning\utils_scan_instrument.py
#####################################
# tabs/Scanning/utils_scan_instrument.py
#
# Core logic for controlling the spectrum analyzer to perform frequency sweeps.
# Handles instrument communication, trace data acquisition, and saving to CSV.
# This module also contains the logic for initiating and running the scan thread.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250813.160010.1

import pyvisa
import time
import numpy as np
import re
import datetime
import os
import inspect
import threading
import pandas as pd

from display.debug_logic import debug_log, log_visa_command
from display.console_logic import console_log
from process_math.scan_stitch import stitch_and_save_scan_data
from src.connection_status_logic import update_connection_status_logic

from utils.utils_csv_writer import write_scan_data_to_csv
from ref.ref_frequency_bands import MHZ_TO_HZ, VBW_RBW_RATIO

current_version = "20250813.160010.1"
current_version_hash = (20250813 * 160010 * 1)

def initiate_scan_thread(app_instance, console_print_func, stop_event, pause_event, update_progress_func):
    """
    Function Description:
    Initiates the spectrum scan in a separate thread. This is the main entry point
    called by the Orchestrator GUI to start the scanning process.
    """
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Entering {current_function}", file=os.path.basename(__file__), version=current_version, function=current_function)
    
    if app_instance.scan_thread and app_instance.scan_thread.is_alive():
        console_print_func("⚠️ Process already running.")
        return False

    if not app_instance.is_connected.get():
        console_print_func("❌ Instrument not connected. Cannot start.")
        return False

    selected_bands = [band_item["band"] for band_item in app_instance.band_vars if band_item["level"] > 0]
    if not selected_bands:
        console_print_func("⚠️ No bands selected for scan.")
        return False

    stop_event.clear()
    pause_event.clear()
    app_instance.is_paused_by_user = False

    app_instance.scan_thread = threading.Thread(
        target=_scan_thread_target,
        args=(app_instance, selected_bands, stop_event, pause_event, console_print_func, update_progress_func)
    )
    app_instance.scan_thread.daemon = True
    app_instance.scan_thread.start()
    debug_log(f"Scan thread started successfully.", file=os.path.basename(__file__), version=current_version, function=current_function)
    return True

def _scan_thread_target(app_instance, selected_bands, stop_event, pause_event, console_print_func, update_progress_func):
    """
    The main function executed in the scanning thread. It orchestrates the scan process.
    """
    current_function = inspect.currentframe().f_code.co_name
    console_print_func("--- Initiating Spectrum Scan ---")
    try:
      #  from Instrument.utils_instrument_initialization import initialize_instrument_logic
        
        raw_scan_data, markers_data = scan_bands(
            app_instance_ref=app_instance,
            inst=app_instance.inst,
            selected_bands=selected_bands,
            rbw_hz=float(app_instance.scan_rbw_hz_var.get()),
            ref_level_dbm=float(app_instance.reference_level_dbm_var.get()),
            freq_shift_hz=float(app_instance.freq_shift_hz_var.get()),
            maxhold_enabled=bool(app_instance.maxhold_enabled_var.get()),
            high_sensitivity=app_instance.high_sensitivity_var.get(),
            preamp_on=app_instance.preamp_on_var.get(),
            rbw_step_size_hz=float(app_instance.rbw_step_size_hz_var.get()),
            max_hold_time_seconds=float(app_instance.maxhold_time_seconds_var.get()),
            scan_name=app_instance.scan_name_var.get(),
            output_folder=app_instance.output_folder_var.get(),
            stop_event=stop_event,
            pause_event=pause_event,
            log_visa_commands_enabled=app_instance.log_visa_commands_enabled_var.get(),
            general_debug_enabled=app_instance.general_debug_enabled_var.get(),
            app_console_update_func=console_print_func,
           # initialize_instrument_func=initialize_instrument_logic
        )

        if not stop_event.is_set():
            console_print_func("\n--- Stitching and saving scan data ---")
            stitch_and_save_scan_data(
                raw_scan_data_for_current_sweep=raw_scan_data,
                output_folder=app_instance.output_folder_var.get(),
                scan_name=app_instance.scan_name_var.get(),
                operator_name=app_instance.operator_name_var.get(),
                venue_name=app_instance.venue_name_var.get(),
                equipment_used=app_instance.scanner_type_var.get(),
                notes=app_instance.notes_var.get(),
                postal_code=app_instance.venue_postal_code_var.get(),
                latitude="N/A", # Placeholder
                longitude="N/A", # Placeholder
                antenna_type=app_instance.selected_antenna_type_var.get(),
                antenna_amplifier=app_instance.selected_amplifier_type_var.get(),
                console_print_func=console_print_func
            )
            console_print_func("--- Scan process finished. ---")
        else:
            console_print_func("--- Scan process stopped by user. ---")

    except Exception as e:
        console_print_func(f"❌ An error occurred during scan: {e}")
        debug_log(f"Error in scan thread target: {e}",
                    file=os.path.basename(__file__), function="_scan_thread_target")
    finally:
        # Update button states via the orchestrator_gui attribute
        app_instance.orchestrator_gui.is_running = False
        app_instance.orchestrator_gui.is_paused = False
        app_instance.after(0, lambda: app_instance.orchestrator_gui._update_button_states())
        app_instance.after(0, lambda: update_connection_status_logic(app_instance, app_instance.is_connected.get(), False, console_print_func))

def write_safe(inst, command, app_instance_ref, app_console_update_func):
    """Safely writes a SCPI command to the instrument."""
    # ... (function content is unchanged)
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Attempting to write command: {command}",
                file=f"{os.path.basename(__file__)} - {current_version}",
                version=current_version,
                function=current_function)
    if not inst:
        app_instance_ref.after(0, lambda: app_console_update_func("⚠️ Warning: Instrument not connected. Cannot write command. What the hell?!"))
        debug_log("Instrument not connected. Fucking useless!",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        return False
    try:
        inst.write(command)
        log_visa_command(command, "SENT")
        return True
    except Exception as e:
        app_instance_ref.after(0, lambda: app_console_update_func(f"❌ Error writing command '{command}': {e}. This thing is a pain in the ass!"))
        debug_log(f"Error writing command '{command}': {e}. What a mess!",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        return False

def query_safe(inst, command, app_instance_ref, app_console_update_func):
    """Safely queries the instrument and returns the response."""
    # ... (function content is unchanged)
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Attempting to query command: {command}",
                file=f"{os.path.basename(__file__)} - {current_version}",
                version=current_version,
                function=current_function)
    if not inst:
        app_instance_ref.after(0, lambda: app_console_update_func("⚠️ Warning: Instrument not connected. Cannot query command. What the hell?!"))
        debug_log("Instrument not connected. Fucking useless!",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        return None
    try:
        response = inst.query(command).strip()
        log_visa_command(command, "SENT")
        log_visa_command(response, "RECEIVED")
        return response
    except Exception as e:
        app_instance_ref.after(0, lambda: app_console_update_func(f"❌ Error querying command '{command}': {e}. This goddamn thing is broken!"))
        debug_log(f"Error querying command '{command}': {e}. What a pain!",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        return None


def configure_instrument_for_scan(inst, center_freq_hz, span_hz, rbw_hz, ref_level_dbm,
                                  freq_shift_hz, high_sensitivity_on, preamp_on,
                                  app_instance_ref, app_console_update_func):
    """Configures the spectrum analyzer with specified settings for a scan segment."""
    # ... (function content is unchanged)
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Configuring instrument for scan. Center: {center_freq_hz/MHZ_TO_HZ:.3f} MHz, Span: {span_hz/MHZ_TO_HZ:.3f} MHz, RBW: {rbw_hz} Hz. Let's get this machine ready!",
                file=f"{os.path.basename(__file__)} - {current_version}",
                version=current_version,
                function=current_function)

    if not inst:
        app_instance_ref.after(0, lambda: app_console_update_func("⚠️ Warning: Instrument not connected. Cannot configure for scan. Connect the damn thing first!"))
        debug_log("Instrument not connected for configuration. Fucking useless!",
                    file=f"{os.path.basename(__file__)} - {current_version}",
                    version=current_version,
                    function=current_function)
        return False

    success = True
    if not write_safe(inst, "*RST", app_instance_ref, app_console_update_func): success = False
    time.sleep(0.1)
    if not write_safe(inst, ":SENSe:AVERage:COUNt 1", app_instance_ref, app_console_update_func): success = False
    if not write_safe(inst, ":SENSe:SWEep:POINts 1001", app_instance_ref, app_console_update_func): success = False
    if not write_safe(inst, f":SENSe:FREQuency:CENTer {center_freq_hz}", app_instance_ref, app_console_update_func): success = False
    time.sleep(0.05)
    if not write_safe(inst, f":SENSe:FREQuency:SPAN {span_hz}", app_instance_ref, app_console_update_func): success = False
    time.sleep(0.05)
    if not write_safe(inst, f":SENSe:BANDwidth:RESolution {rbw_hz}", app_instance_ref, app_console_update_func): success = False
    time.sleep(0.05)
    if not write_safe(inst, f":DISPlay:WINDow:TRACe:Y:RLEVel {ref_level_dbm}DBM", app_instance_ref, app_console_update_func): success = False
    time.sleep(0.05)
    if not write_safe(inst, f":SENSe:FREQuency:RFShift {freq_shift_hz}", app_instance_ref, app_console_update_func): success = False
    time.sleep(0.05)
    high_sensitivity_cmd = ":SENSe:POWer:RF:HSENs ON" if high_sensitivity_on else ":SENSe:POWer:RF:HSENs OFF"
    if not write_safe(inst, high_sensitivity_cmd, app_instance_ref, app_console_update_func): success = False
    time.sleep(0.05)
    preamp_cmd = ":SENSe:POWer:RF:GAIN ON" if preamp_on else ":SENSe:POWer:RF:GAIN OFF"
    if not write_safe(inst, preamp_cmd, app_instance_ref, app_console_update_func): success = False
    time.sleep(0.05)

    if success:
        app_instance_ref.after(0, lambda: app_console_update_func("✅ Instrument configured successfully for scan. Ready for data!"))
    else:
        app_instance_ref.after(0, lambda: app_console_update_func("❌ Failed to fully configure instrument for scan. This is a disaster!"))
    return success

def perform_single_sweep(inst, app_instance_ref, app_console_update_func):
    """Triggers a single sweep and retrieves trace data."""
    # ... (function content is unchanged)
    current_function = inspect.currentframe().f_code.co_name
    debug_log("Performing single sweep... Getting that juicy data!",
                file=f"{os.path.basename(__file__)} - {current_version}",
                version=current_version,
                function=current_function)

    if not inst:
        app_instance_ref.after(0, lambda: app_console_update_func("⚠️ Warning: Instrument not connected. Cannot perform sweep. Connect the damn thing first!"))
        return None, None

    try:
        if not write_safe(inst, ":INITiate:CONTinuous OFF", app_instance_ref, app_console_update_func): return None, None
        time.sleep(0.1)
        if not write_safe(inst, ":INITiate:IMMediate; *WAI", app_instance_ref, app_console_update_func): return None, None
        time.sleep(0.5)

        freq_response = query_safe(inst, ":TRACe:X:VALues?", app_instance_ref, app_console_update_func)
        if freq_response is None:
            app_instance_ref.after(0, lambda: app_console_update_func("❌ Failed to query frequency data. This is a disaster!"))
            return None, None
        frequencies_hz = [float(f) for f in freq_response.split(',')]

        trace_response = query_safe(inst, ":TRACe:DATA? TRACE1", app_instance_ref, app_console_update_func)
        if trace_response is None:
            app_instance_ref.after(0, lambda: app_console_update_func("❌ Failed to query trace data. This is frustrating!"))
            return None, None
        power_dbm = [float(p) for p in trace_response.split(',')]

        if len(frequencies_hz) != len(power_dbm):
            app_instance_ref.after(0, lambda: app_console_update_func("❌ Mismatch between frequency and power data points. Data corrupted!"))
            return None, None

        app_instance_ref.after(0, lambda: app_console_update_func(f"✅ Single sweep complete. Collected {len(frequencies_hz)} data points. Success!"))
        return frequencies_hz, power_dbm

    except Exception as e:
        app_instance_ref.after(0, lambda: app_console_update_func(f"❌ Error during single sweep: {e}. This is a disaster!"))
        return None, None

def perform_segment_sweep(inst, segment_start_freq_hz, segment_stop_freq_hz, maxhold_enabled, max_hold_time, app_instance_ref, pause_event, stop_event, segment_counter, total_segments_in_band, band_name, app_console_update_func, current_segment_start_freq_hz):
    """Performs a single frequency sweep segment on the instrument and retrieves data."""
    # ... (function content is unchanged, but I must add the missing `current_segment_start_freq_hz` to the signature)
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Entering {current_function} function. Segment {segment_counter}/{total_segments_in_band}",
                file=f"{os.path.basename(__file__)} - {current_version}",
                version=current_version,
                function=current_function)

    while pause_event.is_set():
        app_instance_ref.after(0, lambda: app_console_update_func("Scan Paused. Click Resume to continue."))
        time.sleep(0.1)
        if stop_event.is_set():
            app_instance_ref.after(0, lambda: app_console_update_func(f"Scan for {band_name} interrupted during pause in max hold for segment {segment_counter}."))
            return []
    if stop_event.is_set():
        app_instance_ref.after(0, lambda: app_console_update_func(f"Scan for {band_name} interrupted during segment {segment_counter}."))
        return []

    if not write_safe(inst, f":SENS:FREQ:STAR {segment_start_freq_hz};:SENS:FREQ:STOP {segment_stop_freq_hz}", app_instance_ref, app_console_update_func):
        app_instance_ref.after(0, lambda: app_console_update_func(f"❌ Error: Failed to set frequency range for segment {segment_counter}."))
        return []

    if not write_safe(inst, ":TRAC1:MODE BLANk;:TRAC2:MODE BLANk;:TRAC3:MODE BLANk", app_instance_ref, app_console_update_func):
        app_instance_ref.after(0, lambda: app_console_update_func(f"❌ Error: Failed to blank traces for segment {segment_counter}."))
    if maxhold_enabled:
        if not write_safe(inst, ":TRAC2:MODE MAXHold;", app_instance_ref, app_console_update_func):
            app_instance_ref.after(0, lambda: app_console_update_func(f"❌ Error: Failed to set Max Hold mode for segment {segment_counter}."))

    app_instance_ref.after(0, lambda: app_console_update_func("💬 Initiating single sweep for segment..."))
    if not write_safe(inst, ":INITiate:CONTinuous OFF", app_instance_ref, app_console_update_func): return []
    if not write_safe(inst, ":INITiate:IMMediate; *WAI", app_instance_ref, app_console_update_func): return []
    
    if maxhold_enabled and max_hold_time > 0:
        for _ in range(int(max_hold_time * 10)):
            while pause_event.is_set():
                app_instance_ref.after(0, lambda: app_console_update_func("Scan Paused. Click Resume to continue."))
                time.sleep(0.1)
            if stop_event.is_set():
                app_instance_ref.after(0, lambda: app_console_update_func(f"Scan for {band_name} interrupted during pause in max hold for segment {segment_counter}."))
                return []
            if stop_event.is_set():
                app_instance_ref.after(0, lambda: app_console_update_func(f"Scan for {band_name} interrupted during max hold for segment {segment_counter}."))
                return []
            if _ % 10 == 0:
                sec_remaining = int(max_hold_time - (_ / 10))
            time.sleep(0.1)

    if stop_event.is_set():
        app_instance_ref.after(0, lambda: app_console_update_func(f"Scan for {band_name} interrupted after max hold for segment {segment_counter}."))
        return []

    progress_percentage = (segment_counter / total_segments_in_band)
    bar_length = 20
    filled_length = int(round(bar_length * progress_percentage))
    progressbar = '█' * filled_length + '-' * (bar_length - filled_length)
    progress_message = f"{progressbar}🔍 Span:📊{(segment_stop_freq_hz - segment_start_freq_hz)/MHZ_TO_HZ:.3f} MHz--📈{current_segment_start_freq_hz/MHZ_TO_HZ:.3f} MHz to 📉{segment_stop_freq_hz/MHZ_TO_HZ:.3f} MHz   ✅{segment_counter} of {total_segments_in_band} "
    app_instance_ref.after(0, lambda msg=progress_message: app_console_update_func(msg))
    
    segment_raw_data = []
    # (rest of the logic from original file...)
    try:
        instrument_model = app_instance_ref.connected_instrument_model.get()
        if instrument_model == "N9340B":
            trace_data_str = query_safe(inst, ":TRAC2:DATA?", app_instance_ref, app_console_update_func)
        else: # Default/N9342CN
            trace_data_str = query_safe(inst, ":TRACe:DATA? TRACe2", app_instance_ref, app_console_update_func)

        if trace_data_str is None or not trace_data_str.strip():
            app_instance_ref.after(0, lambda: app_console_update_func("🚫 No valid trace data string received for this segment."))
            return []

        match = re.match(r'#\d+\d+(.*)', trace_data_str)
        data_part = match.group(1) if match else trace_data_str

        if data_part:
            amplitudes_dbm = [float(val) for val in data_part.split(',') if val.strip()]
            num_points = len(amplitudes_dbm)
            if num_points > 1:
                frequencies_hz = np.linspace(segment_start_freq_hz, segment_stop_freq_hz, num_points)
                if len(amplitudes_dbm) == len(frequencies_hz):
                    segment_raw_data.extend(zip(frequencies_hz, amplitudes_dbm))
    except Exception as e:
        app_instance_ref.after(0, lambda: app_console_update_func(f"🚨 Error in segment sweep: {e}"))
        return []
    
    return segment_raw_data


def scan_bands(app_instance_ref, inst, selected_bands, rbw_hz, ref_level_dbm, freq_shift_hz, maxhold_enabled, high_sensitivity, preamp_on, rbw_step_size_hz, max_hold_time_seconds, scan_name, output_folder, stop_event, pause_event, log_visa_commands_enabled, general_debug_enabled, app_console_update_func, initialize_instrument_func):
    """Orchestrates a full frequency scan across multiple specified bands."""
    # ... (function content is unchanged)
    current_function = inspect.currentframe().f_code.co_name
    debug_log(f"Entering {current_function} function. Starting scan_bands.",
                file=f"{os.path.basename(__file__)} - {current_version}",
                version=current_version,
                function=current_function)

    overall_start_freq_hz = min(band["Start MHz"] for band in selected_bands) * MHZ_TO_HZ
    overall_stop_freq_hz = max(band["Stop MHz"] for band in selected_bands) * MHZ_TO_HZ
    
    app_instance_ref.after(0, lambda: app_console_update_func(f"Scanning from {overall_start_freq_hz / MHZ_TO_HZ:.3f} MHz to {overall_stop_freq_hz / MHZ_TO_HZ:.3f} MHz..."))

  #  if not initialize_instrument_logic(
        #inst,
       # model_match=app_instance_ref.connected_instrument_model.get(),
       # ref_level_dbm=ref_level_dbm,
      #  high_sensitivity_on=high_sensitivity,
     #   preamp_on=preamp_on,
    #    rbw_config_val=rbw_hz,
   #     vbw_config_val=rbw_hz * VBW_RBW_RATIO,
  #      app_instance_ref=app_instance_ref,
 #       console_print_func=app_console_update_func
#    ):
        #app_instance_ref.after(0, lambda: app_console_update_func("❌ Error: Failed to initialize instrument for scan. Aborting."))
        #return -1, None, None

    # (rest of setup commands...)

    timestamp_hm = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    csv_filename_current_cycle = os.path.join(output_folder, f"{scan_name}_RBW{int(rbw_hz/1000)}K_HOLD{int(max_hold_time_seconds)}_Offset{int(freq_shift_hz)}_{timestamp_hm}.csv")

    raw_scan_data_for_current_sweep = []
    last_successful_band_index = -1
    markers_data_from_scan = []

    app_instance_ref.after(0, lambda: app_console_update_func("\n--- 📡 Starting Band Scan ---"))

    for i, band in enumerate(selected_bands):
        if stop_event.is_set():
            break

        band_name = band["Band Name"]
        band_start_freq_hz = (band["Start MHz"] * MHZ_TO_HZ) + freq_shift_hz
        band_stop_freq_hz = (band["Stop MHz"] * MHZ_TO_HZ) + freq_shift_hz

        app_instance_ref.after(0, lambda: app_console_update_func(f"\n📈 Processing Band: {band_name}"))

        # (segment calculation logic...)
        full_band_span_hz = band_stop_freq_hz - band_start_freq_hz
        total_segments_in_band = 1
        if full_band_span_hz > 0:
            expected_sweep_points = 461 if "N9340B" in app_instance_ref.connected_instrument_model.get() else 501
            total_segments_in_band = int(np.ceil(full_band_span_hz / (rbw_step_size_hz * (expected_sweep_points - 1))))
        
        if total_segments_in_band <= 0: total_segments_in_band = 1
        optimal_segment_span_hz = full_band_span_hz / total_segments_in_band

        current_segment_start_freq_hz = band_start_freq_hz
        segment_counter = 0

        while current_segment_start_freq_hz < band_stop_freq_hz:
            segment_counter += 1
            segment_stop_freq_hz_current = current_segment_start_freq_hz + optimal_segment_span_hz
            if segment_stop_freq_hz_current > band_stop_freq_hz:
                segment_stop_freq_hz_current = band_stop_freq_hz
            
            segment_raw_data = perform_segment_sweep(
                inst,
                current_segment_start_freq_hz,
                segment_stop_freq_hz_current,
                maxhold_enabled,
                max_hold_time_seconds,
                app_instance_ref,
                pause_event,
                stop_event,
                segment_counter,
                total_segments_in_band,
                band_name,
                app_console_update_func,
                current_segment_start_freq_hz
            )

            if stop_event.is_set():
                break

            if segment_raw_data:
                raw_scan_data_for_current_sweep.extend(segment_raw_data)
                
                # Write to CSV
                csv_data_to_write = [(f / MHZ_TO_HZ, amp) for f, amp in segment_raw_data]
                write_scan_data_to_csv(
                    csv_filename_current_cycle,
                    header=None,
                    data=csv_data_to_write,
                    app_instance_ref=app_instance_ref,
                    append_mode=True,
                    console_print_func=app_console_update_func
                )
            
            current_segment_start_freq_hz = segment_stop_freq_hz_current
            last_successful_band_index = i

        if stop_event.is_set():
            break

    app_instance_ref.after(0, lambda: app_console_update_func("\n--- 🎉 Band Scan Data Collection Complete! ---"))
    return last_successful_band_index, raw_scan_data_for_current_sweep, markers_data_from_scan

#####################################
### File: OPEN-AIR 2\workers\zones_groups_devices\tab_markers_child_zone_groups_devices.py
#####################################
# tabs/Markers/showtime/zones_groups_devices/tab_markers_child_zone_groups_devices.py
#
# [This file defines the ZoneGroupsDevicesFrame, which dynamically loads
# and displays data from the MARKERS.CSV file.]
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.110500.1
# REFACTORED: This file has been refactored to serve exclusively as a UI component.
#             The event handler functions have been moved to their own dedicated
#             utility files, thereby eliminating circular dependencies.
# UPDATED: The class now correctly uses `partial` to call the external handler functions.

import tkinter as tk
from tkinter import ttk
from functools import partial
import os
import inspect
from datetime import datetime

# Import utility functions from their dedicated files
from .utils_files_markers_zone_groups_devices import load_and_structure_markers_data
from .utils_button_volume_level import create_signal_level_indicator

# Import the specific selection handlers for each button type
from .utils_display_showtime_zones import on_zone_selected
from .utils_display_showtime_groups import on_group_selected
from .utils_display_showtime_devices import on_device_selected
from .utils_display_showtime_all import on_all_markers_selected

from display.debug_logic import debug_log
from display.console_logic import console_log
from src.program_style import COLOR_PALETTE


# --- Versioning ---
w = 20250824
x_str = '110500'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"


class ZoneGroupsDevicesFrame(ttk.Frame):
    def __init__(self, parent_frame, showtime_tab_instance):
        # [Initializes the frame, restoring the original grid layout and scrollable device list.]
        super().__init__(parent_frame, style='TFrame')
        self.showtime_tab_instance = showtime_tab_instance
        self.structured_data = None
        self.grid(row=0, column=0, sticky="nsew")

        # Widget references for active selections, now correctly on the Frame instance
        self.active_zone_button = None
        self.active_group_button = None

        self._create_layout()

    def _create_layout(self):
        # [Creates the main layout with zones, groups, and the scrollable device frame.]
        self.columnconfigure(0, weight=1)
        self.rowconfigure(2, weight=1) # Allow device frame to expand
        
        self.zones_frame = ttk.LabelFrame(self, text="Zones", style='TLabelframe')
        self.zones_frame.grid(row=0, column=0, sticky="ew", padx=10, pady=5)
        
        self.groups_frame = ttk.LabelFrame(self, text="Groups", style='TLabelframe')
        self.groups_frame.grid(row=1, column=0, sticky="ew", padx=10, pady=5)
        
        self._create_device_frame(self)

    def _create_device_frame(self, parent):
        # [Creates the scrollable canvas for the device buttons.]
        self.devices_outer_frame = ttk.LabelFrame(parent, text="Devices", style='TLabelframe')
        self.devices_outer_frame.grid(row=2, column=0, sticky="nsew", padx=10, pady=5)
        self.devices_outer_frame.grid_rowconfigure(0, weight=1)
        self.devices_outer_frame.grid_columnconfigure(0, weight=1)
        
        self.canvas = tk.Canvas(self.devices_outer_frame, borderwidth=0, highlightthickness=0, bg=COLOR_PALETTE['background'])
        scrollbar = ttk.Scrollbar(self.devices_outer_frame, orient="vertical", command=self.canvas.yview)
        self.devices_scrollable_frame = ttk.Frame(self.canvas, style='Dark.TFrame')
        self.devices_scrollable_frame.bind("<Configure>", lambda e: self.canvas.configure(scrollregion=self.canvas.bbox("all")))
        
        self.canvas.create_window((0, 0), window=self.devices_scrollable_frame, anchor="nw")
        self.canvas.configure(yscrollcommand=scrollbar.set)
        
        self.canvas.grid(row=0, column=0, sticky="nsew")
        scrollbar.grid(row=0, column=1, sticky="ns")

    def load_and_display_data(self):
        # [Main entry point to load data and fully rebuild the UI.]
        self.structured_data = load_and_structure_markers_data()
        self._make_zone_buttons()
        self._make_group_buttons()
        self._make_device_buttons()
        
        all_devices = self._get_all_devices_in_zone(self.structured_data, None)
        self._get_min_max_freq_and_update_title(frame_widget=self.zones_frame, devices=all_devices, title_prefix="ALL DEVICES")
        self.groups_frame.config(text="Groups")
        self.devices_outer_frame.config(text="Devices")

    def _make_zone_buttons(self):
        # [Creates the zone selection buttons in a grid.]
        for widget in self.zones_frame.winfo_children():
            widget.destroy()
        if not self.structured_data:
            ttk.Label(self.zones_frame, text="Could not load MARKERS.CSV").pack(padx=5, pady=5)
            return

        max_columns = 6
        for i, zone_name in enumerate(self.structured_data.keys()):
            row, col = divmod(i, max_columns)
            # Calls the external function from utils_display_showtime_zones.py
            btn = ttk.Button(self.zones_frame, text=zone_name, style='ControlButton.Inactive.TButton', command=partial(on_zone_selected, self, zone_name))
            btn.grid(row=row, column=col, padx=2, pady=2, sticky="ew")
            self.zones_frame.columnconfigure(col, weight=1)

    def _make_group_buttons(self):
        # [Creates group buttons, dynamically showing/hiding the frame.]
        for widget in self.groups_frame.winfo_children():
            widget.destroy()
        self.groups_frame.grid_remove() # Hide by default

        if not self.showtime_tab_instance.selected_zone or not self.structured_data:
            return

        groups = self.structured_data.get(self.showtime_tab_instance.selected_zone, {})
        # Show frame only if there are meaningful groups to select
        if len(groups) > 1 or (len(groups) == 1 and next(iter(groups)) not in ['Ungrouped', 'No Group']):
            self.groups_frame.grid()
        else:
            return

        max_columns = 6
        for i, group_name in enumerate(groups.keys()):
            row, col = divmod(i, max_columns)
            # Calls the external function from utils_display_showtime_groups.py
            btn = ttk.Button(self.groups_frame, text=group_name, style='ControlButton.Inactive.TButton', command=partial(on_group_selected, self, group_name))
            btn.grid(row=row, column=col, padx=2, pady=2, sticky="ew")
            self.groups_frame.columnconfigure(col, weight=1)

    def _make_device_buttons(self):
        # [Creates the detailed, multi-line device buttons in the scrollable frame.]
        for widget in self.devices_scrollable_frame.winfo_children():
            widget.destroy()
        self.showtime_tab_instance.device_buttons.clear()

        devices_to_display = self._get_devices_to_display()
        self.devices_outer_frame.config(text=f"Devices ({len(devices_to_display)})")

        max_cols = 4
        for col in range(max_cols):
            self.devices_scrollable_frame.grid_columnconfigure(col, weight=1)
            
        for i, device in enumerate(devices_to_display):
            name = device.get('NAME', 'N/A')
            device_type = device.get('DEVICE', 'N/A')
            center = device.get('CENTER', 'N/A')
            peak = device.get('PEAK', -120.0)
            
            progress_bar = create_signal_level_indicator(peak)
            btn_text = f"{name}\n{device_type}\n{center} MHz\n{peak} dBm\n{progress_bar}"
            
            # Calls the external function from utils_display_showtime_devices.py
            btn = ttk.Button(self.devices_scrollable_frame, text=btn_text, style='DeviceButton.Inactive.TButton', command=partial(on_device_selected, self, device))
            self.showtime_tab_instance.device_buttons[id(device)] = btn
            
            row, col = divmod(i, max_cols)
            btn.grid(row=row, column=col, padx=5, pady=2, sticky="ew")

    def _get_devices_to_display(self):
        # [Helper to determine which list of devices to show based on selection.]
        if self.showtime_tab_instance.selected_zone:
            zone_data = self.structured_data.get(self.showtime_tab_instance.selected_zone, {})
            if self.showtime_tab_instance.selected_group:
                return zone_data.get(self.showtime_tab_instance.selected_group, [])
            else:
                return self._get_all_devices_in_zone(self.structured_data, self.showtime_tab_instance.selected_zone)
        return self._get_all_devices_in_zone(self.structured_data, None)

    def _get_min_max_freq_and_update_title(self, frame_widget, devices, title_prefix):
        # [Calculates min/max frequency and updates a frame's title.]
        freqs = [float(d['CENTER']) for d in devices if isinstance(d.get('CENTER'), (int, float))]
        if freqs:
            min_freq, max_freq = min(freqs), max(freqs)
            new_title = f"{title_prefix} ({len(devices)}) - MIN: {min_freq:.3f} MHz - MAX: {max_freq:.3f} MHz"
        else:
            new_title = f"{title_prefix} ({len(devices)})"
        frame_widget.config(text=new_title)
        
    def _get_all_devices_in_zone(self, structured_data, zone_name):
        # [Helper to flatten all devices from all groups within a zone, or all zones.]
        devices = []
        if structured_data and zone_name: # A specific zone
            for group_devices in structured_data.get(zone_name, {}).values():
                devices.extend(group_devices)
        elif structured_data: # All zones
            for zone in structured_data.values():
                for group_devices in zone.values():
                    devices.extend(group_devices)
        return devices

#####################################
### File: OPEN-AIR 2\workers\zones_groups_devices\utils_button_volume_level.py
#####################################
# tabs/Markers/showtime/util_button_volume_level.py
#
# This file provides a standalone utility function to generate a Unicode text-based
# progress bar for a given value within a specified range.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
#
#
# Version 20250822.103000.1
# UPDATED: The function now handles NaN values gracefully by returning an empty bar.
# UPDATED: File header and versioning adhere to new standards.
# UPDATED: All debug messages now include the correct emoji prefixes.

import inspect
import os
from datetime import datetime
import math # Import the math module to check for NaN

from display.debug_logic import debug_log

# --- Versioning ---
w = 20250822
x_str = '103000'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 1
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"

def create_signal_level_indicator(value, min_val=-120, max_val=0, width=24):
    """
    Generates a Unicode text-based progress bar for a given peak value.

    Args:
        value (float): The current value to represent in the progress bar.
        min_val (int): The minimum value of the range (e.g., -120 dBm).
        max_val (int): The maximum value of the range (e.g., 0 dBm).
        width (int): The width of the progress bar in characters.

    Returns:
        str: A string representing the Unicode progress bar, e.g., '[█████████        ]'.
    """
    current_function = inspect.currentframe().f_code.co_name
 #   debug_log(f"🛠️ 🟢 Entering {current_function} with value: {value}", file=current_file, version=current_version, function=current_function)
    try:
        # Check if the value is NaN or None and handle it gracefully
        if value is None or (isinstance(value, float) and math.isnan(value)):
            debug_log(f"🛠️ 🟡 Value is NaN or None. Returning empty bar.", file=current_file, version=current_version, function=current_function)
            return f"[{' ' * width}]"

        value = float(value)
        if value < min_val:
            value = min_val
        if value > max_val:
            value = max_val
        
        percentage = (value - min_val) / (max_val - min_val)
        filled_length = int(width * percentage)
        
        bar = '█' * filled_length
        empty = ' ' * (width - filled_length)
#        debug_log(f"🛠️ 🟢 Exiting {current_function}. Generated bar: [{bar}{empty}]", file=current_file, version=current_version, function=current_function)
        return f"[{bar}{empty}]"
    except (ValueError, TypeError) as e:
        debug_log(f"🛠️ ❌ Error in {current_function}: {e}. Returning empty bar. Fucking useless!", file=current_file, version=current_version, function=current_function)
        return f"[{' ' * width}]"


#####################################
### File: OPEN-AIR 2\workers\zones_groups_devices\utils_display_showtime_all.py
#####################################
# tabs/Markers/showtime/zones_groups_devices/utils_display_showtime_all.py
#
# This module provides the backend logic for handling the "All Markers" view.
# It manages the selection of all markers and delegates to shared utility
# functions for updating the display and instrument's span.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.110500.6
# REFACTORED: Created a new file for the "All Markers" view to improve modularity.
# UPDATED: Imports now point to the new shared utility file.
# FIXED: The function now correctly gets all devices and calls the appropriate
#        span utility function.

import os
import inspect
from tkinter import ttk
import pandas as pd
import numpy as np

from display.debug_logic import debug_log
from display.console_logic import console_log

# Import shared utility functions
from Markers.showtime.controls.utils_showtime_zone_zoom import set_span_to_all_markers, set_span_to_group

from .utils_display_showtime_shared import _update_zone_zoom_tab, _save_showtime_state_to_config


# --- Versioning ---
w = 20250824
x_str = '110500'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 6
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"


def on_all_markers_selected(zgd_frame_instance):
    # [Handles the logic for selecting and viewing all markers.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"🛠️🟢 Entering {current_function}", file=current_file, version=current_version, function=current_function)

    showtime_tab = zgd_frame_instance.showtime_tab_instance
    
    console_log(f"EVENT: All markers selected. Displaying all devices...", "INFO")
    
    # Reset all active selections
    if zgd_frame_instance.active_zone_button and zgd_frame_instance.active_zone_button.winfo_exists():
        zgd_frame_instance.active_zone_button.config(style='ControlButton.Inactive.TButton')
        zgd_frame_instance.active_zone_button = None
    if zgd_frame_instance.active_group_button and zgd_frame_instance.active_group_button.winfo_exists():
        zgd_frame_instance.active_group_button.config(style='ControlButton.Inactive.TButton')
        zgd_frame_instance.active_group_button = None
    if showtime_tab.active_device_button and showtime_tab.active_device_button.winfo_exists():
        showtime_tab.active_device_button.config(style='DeviceButton.Inactive.TButton')
    showtime_tab.active_device_button = None
    
    # 📝 Write Data: Update selected state variables.
    debug_log(message=f"🛠️📝 Writing to state: Setting selection to all markers.", file=current_file, version=current_version, function=current_function)
    showtime_tab.selected_zone = None
    showtime_tab.selected_group = None
    showtime_tab.selected_device_info = None
    showtime_tab.last_selected_type = 'all markers'
    
    all_devices = zgd_frame_instance._get_all_devices_in_zone(zgd_frame_instance.structured_data, None)
    
    if all_devices:
        freqs = [float(d['CENTER']) for d in all_devices if isinstance(d.get('CENTER'), (int, float))]
        min_freq = min(freqs) if freqs else 0.0
        max_freq = max(freqs) if freqs else 0.0
        device_count = len(all_devices)

        showtime_tab.selected_zone_info = {
            'min_freq': min_freq,
            'max_freq': max_freq,
            'device_count': device_count
        }
        showtime_tab.selected_group_info = {}
        
        zgd_frame_instance._get_min_max_freq_and_update_title(frame_widget=zgd_frame_instance.zones_frame, devices=all_devices, title_prefix="All Devices")
        zgd_frame_instance._make_group_buttons()
        zgd_frame_instance._make_device_buttons()
        
    # Call the set_span_to_all_markers utility function to trigger the update
    from Markers.showtime.controls.utils_showtime_zone_zoom import set_span_to_all_markers
    set_span_to_all_markers(showtime_tab_instance=showtime_tab, zone_zoom_tab=showtime_tab.controls_frame.zone_zoom_tab)

    _save_showtime_state_to_config(showtime_tab)

    debug_log(message=f"🛠️🟢 Exiting {current_function}", file=current_file, version=current_version, function=current_function)



  


    
def no_zone_grou_device_selected(zgd_frame_instance):
    # [Handles the logic for when no zone, group, or device is selected.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"🛠️🟢 Entering {current_function}", file=current_file, version=current_version, function=current_function)
    
    console_log(f"EVENT: No zone, group, or device selected. Displaying all devices. ")
    
    # Access and update parent's state variables directly
    showtime_tab = zgd_frame_instance.showtime_tab_instance
    # 📝 Write Data: Reset selected state variables.
    debug_log(message=f"🛠️📝 Writing to state: Resetting selected state variables.", file=current_file, version=current_version, function=current_function)
    showtime_tab.selected_zone = None
    showtime_tab.selected_group = None
    showtime_tab.selected_device_info = None
    showtime_tab.last_selected_type = None

    if zgd_frame_instance.active_zone_button and zgd_frame_instance.active_zone_button.winfo_exists():
        zgd_frame_instance.active_zone_button.config(style='ControlButton.Inactive.TButton')
        zgd_frame_instance.active_zone_button = None
        
    if zgd_frame_instance.active_group_button and zgd_frame_instance.active_group_button.winfo_exists():
        zgd_frame_instance.active_group_button.config(style='ControlButton.Inactive.TButton')
        zgd_frame_instance.active_group_button = None
        
    if showtime_tab.active_device_button and showtime_tab.active_device_button.winfo_exists():
        showtime_tab.active_device_button.config(style='DeviceButton.Inactive.TButton')
    showtime_tab.active_device_button = None
    
    # FIXED: Revert the view to the parent group when a device is deselected.
    set_span_to_group(showtime_tab_instance=showtime_tab, zone_zoom_tab=showtime_tab.controls_frame.zone_zoom_tab)
    _update_zone_zoom_tab(zgd_frame_instance)
    _save_showtime_state_to_config(showtime_tab)
    
    if hasattr(showtime_tab.controls_frame, 'switch_to_tab'):
        showtime_tab.controls_frame.switch_to_tab("Zone Zoom")
        
    debug_log(message=f"🛠️🟢 Exiting {current_function}", file=current_file, version=current_version, function=current_function)
  

#####################################
### File: OPEN-AIR 2\workers\zones_groups_devices\utils_display_showtime_devices.py
#####################################
# tabs/Markers/showtime/zones_groups_devices/utils_display_showtime_devices.py
#
# This module provides the backend logic for handling Device-level button clicks.
# It manages the selection and deselection of devices, updates the UI to reflect
# the current state, and communicates directly with the instrument to set the
# center frequency and span. It delegates to shared utility functions for saving
# the state and updating the instrument's view.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.110500.6
# REFACTORED: Extracted device-specific logic from the main utility file.
# UPDATED: Corrected imports to resolve circular dependencies.
# FIXED: The logic for selecting a device now correctly sets the instrument's
#        center frequency and span based on the device's frequency.

import os
import inspect
import pandas as pd
import numpy as np
import math

from display.debug_logic import debug_log
from display.console_logic import console_log

# Import shared utility functions
from Markers.showtime.controls.utils_showtime_zone_zoom import set_span_to_group
from .utils_display_showtime_shared import _update_zone_zoom_tab, _save_showtime_state_to_config
from yak.utils_yakbeg_handler import handle_freq_center_span_beg


# --- Versioning ---
w = 20250824
x_str = '110500'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 6
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"


def on_device_deselected(zgd_frame_instance):
    # [Handles the logic for when a device is deselected.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"🛠️🟢 Entering {current_function}", file=current_file, version=current_version, function=current_function)
    
    showtime_tab = zgd_frame_instance.showtime_tab_instance
    # 📝 Write Data: Reset selected state variables.
    debug_log(message=f"🛠️📝 Writing to state: Resetting selected device.", file=current_file, version=current_version, function=current_function)
    showtime_tab.selected_device_info = None
    showtime_tab.last_selected_type = 'group'

    if showtime_tab.active_device_button and showtime_tab.active_device_button.winfo_exists():
        showtime_tab.active_device_button.config(style='DeviceButton.Inactive.TButton')
    showtime_tab.active_device_button = None
    
    # FIXED: Revert the view to the parent group when a device is deselected.
    set_span_to_group(showtime_tab_instance=showtime_tab, zone_zoom_tab=showtime_tab.controls_frame.zone_zoom_tab)
    _update_zone_zoom_tab(zgd_frame_instance)
    _save_showtime_state_to_config(showtime_tab)
    
    if hasattr(showtime_tab.controls_frame, 'switch_to_tab'):
        showtime_tab.controls_frame.switch_to_tab("Zone Zoom")
        
    debug_log(message=f"🛠️🟢 Exiting {current_function}", file=current_file, version=current_version, function=current_function)


def on_device_selected(zgd_frame_instance, device_info):
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"🛠️🟢 Entering {current_function} for device object: {device_info}", file=current_file, version=current_version, function=current_function)

    showtime_tab = zgd_frame_instance.showtime_tab_instance
    device_name = device_info.get('NAME', 'N/A')

    if isinstance(device_name, float) and np.isnan(device_name):
        device_name = 'nan'
    
    if showtime_tab.selected_device_info and id(showtime_tab.selected_device_info) == id(device_info):
        console_log(f"EVENT: Device '{device_name}' deselected.")
        from .utils_display_showtime_groups import on_group_deselected # Correctly moved here
        on_device_deselected(zgd_frame_instance)
        debug_log(message=f"🛠️🟢 Exiting {current_function} after deselecting device.", file=current_file, version=current_version, function=current_function)
        return

    # 📝 Write Data: Update selected state variables.
    debug_log(message=f"🛠️📝 Writing to state: Storing selected device info.", file=current_file, version=current_version, function=current_function)
    showtime_tab.selected_device_info = device_info
    showtime_tab.last_selected_type = 'device'

    selected_button = showtime_tab.device_buttons.get(id(device_info))
    
    if showtime_tab.active_device_button and showtime_tab.active_device_button.winfo_exists():
        showtime_tab.active_device_button.config(style='DeviceButton.Inactive.TButton')

    if selected_button:
        selected_button.config(style='DeviceButton.Active.TButton')
        showtime_tab.active_device_button = selected_button
        console_log(f"✅ EVENT: Device '{device_name}' selected. 🎵")
    
    if device_info:
        freq = device_info.get('CENTER', 'N/A')
        if freq != 'N/A':
            zgd_frame_instance.devices_outer_frame.config(text=f"Devices - {device_name} - {freq:.3f} MHz")
            console_log(f"✅ Displaying device '{device_name}' at frequency {freq:.3f} MHz.")
            if hasattr(showtime_tab.controls_frame, 'switch_to_tab'):
                showtime_tab.controls_frame.switch_to_tab("Span")
        else:
            zgd_frame_instance.devices_outer_frame.config(text=f"Devices - {device_name} - N/A")
            console_log(f"⚠️ Device '{device_name}' has no valid frequency.")
    else:
        zgd_frame_instance.devices_outer_frame.config(text="Devices")
        console_log(f"❌ Device info not found. The device has vanished into thin air!")

    _update_zone_zoom_tab(zgd_frame_instance)
    
    # NEW: Set the instrument's center frequency and span based on the state.
    center_freq_mhz = device_info.get('CENTER')
    # 📖 Read Data: Get the current span from the state.
    span_str = showtime_tab.span_var.get()
    if 'M' in span_str:
        span_mhz = float(span_str.replace('M', ''))
    else:
        span_mhz = float(span_str)

    if center_freq_mhz is not None and isinstance(center_freq_mhz, (float, int)):
        debug_log(message=f"🛠️📤 Outbound: Setting instrument center frequency to {center_freq_mhz} MHz and span to {span_mhz} MHz.", file=current_file, version=current_version, function=current_function)
        
        # Convert to Hz for the handler function
        center_freq_hz = int(center_freq_mhz * 1_000_000)
        span_hz = int(span_mhz * 1_000_000)
        
        handle_freq_center_span_beg(app_instance=showtime_tab.app_instance, 
                                 center_freq=center_freq_hz, 
                                 span_freq=span_hz,
                                 console_print_func=showtime_tab.console_print_func)
    else:
        console_log("❌ Cannot set instrument center frequency. Invalid device center frequency.")
        debug_log(message=f"🛠️❌ Invalid center frequency for device: {center_freq_mhz}. Cannot set instrument.", 
                  file=current_file, 
                  version=current_version, 
                  function=current_function)

    _save_showtime_state_to_config(showtime_tab)

    debug_log(message=f"🛠️🟢 Exiting {current_function}", file=current_file, version=current_version, function=current_function)

#####################################
### File: OPEN-AIR 2\workers\zones_groups_devices\utils_display_showtime_groups.py
#####################################
# tabs/Markers/showtime/zones_groups_devices/utils_display_showtime_groups.py
#
# This module provides the backend logic for handling Group-level button clicks.
# It manages the selection and deselection of groups, handles single-device
# auto-selection, and delegates to shared utility functions for saving
# the state and updating the instrument's view.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.110500.6
# REFACTORED: Extracted group-specific logic from the main utility file.
# UPDATED: Corrected imports to resolve circular dependencies.
# FIXED: The logic for selecting a group now correctly checks for single devices and auto-selects them.
# FIXED: Moved `on_group_deselected` to the shared utility file to break a circular import.

import os
import inspect
import math
from tkinter import ttk
import pandas as pd
import numpy as np

from display.debug_logic import debug_log
from display.console_logic import console_log

# Import shared utility functions
from Markers.showtime.controls.utils_showtime_zone_zoom import set_span_to_group
from .utils_display_showtime_shared import _update_zone_zoom_tab, _save_showtime_state_to_config


# --- Versioning ---
w = 20250824
x_str = '110500'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 6
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"


def on_group_selected(zgd_frame_instance, group_name):
    
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"🛠️🟢 Entering {current_function} for group: {group_name}", file=current_file, version=current_version, function=current_function)

    showtime_tab = zgd_frame_instance.showtime_tab_instance
    devices_in_group = zgd_frame_instance.structured_data.get(showtime_tab.selected_zone, {}).get(group_name, [])

    if len(devices_in_group) == 1:
        console_log(f"EVENT: Group '{group_name}' contains one device. Auto-selecting device...", "INFO")
        # 📝 Write Data: Update selected state variables.
        debug_log(message=f"🛠️📝 Writing to state: Updating selected group and resetting device.", file=current_file, version=current_version, function=current_function)
        showtime_tab.selected_group = group_name
        zgd_frame_instance._make_device_buttons()
        # Lazily import on_device_selected to break circular import
        from .utils_display_showtime_devices import on_device_selected 
        on_device_selected(zgd_frame_instance, devices_in_group[0])
        
        for widget in zgd_frame_instance.groups_frame.winfo_children():
            if widget.cget("text") == group_name:
                if zgd_frame_instance.active_group_button and zgd_frame_instance.active_group_button.winfo_exists():
                    zgd_frame_instance.active_group_button.config(style='ControlButton.Inactive.TButton')
                widget.config(style='ControlButton.Active.TButton')
                zgd_frame_instance.active_group_button = widget
                break
        return

    if showtime_tab.selected_group == group_name:
        console_log(f"EVENT: Group '{group_name}' deselected. Reverting to show all devices in Zone '{showtime_tab.selected_zone}'.", "INFO")
        on_group_deselected(zgd_frame_instance)
        return

    for widget in zgd_frame_instance.groups_frame.winfo_children():
        if widget.cget("text") == group_name:
            selected_button = widget
            break
    else:
        selected_button = None

    console_log(f"EVENT: Group '{group_name}' selected in Zone '{showtime_tab.selected_zone}'. Loading devices... ⚙️")
    if zgd_frame_instance.active_group_button and zgd_frame_instance.active_group_button.winfo_exists():
        zgd_frame_instance.active_group_button.config(style='ControlButton.Inactive.TButton')

    # 📝 Write Data: Update selected state variables.
    debug_log(message=f"🛠️📝 Writing to state: Updating selected group and resetting device.", file=current_file, version=current_version, function=current_function)
    showtime_tab.active_device_button = None
    showtime_tab.selected_device_info = None
    showtime_tab.selected_group = group_name
    showtime_tab.last_selected_type = 'group'

    # NEW: Calculate and store group information in state
    freqs = [float(d['CENTER']) for d in devices_in_group if isinstance(d.get('CENTER'), (int, float))]
    
    # FIXED: Check if freqs is not empty before calling min/max
    if freqs:
        min_freq = min(freqs)
        max_freq = max(freqs)
    else:
        min_freq = 0.0
        max_freq = 0.0
        
    showtime_tab.selected_group_info = {
        'min_freq': min_freq,
        'max_freq': max_freq,
        'device_count': len(devices_in_group)
    }
    
    debug_log(message=f"🛠️📦 Stored group info in state: {showtime_tab.selected_group_info}", file=current_file, version=current_version, function=current_function)

    if selected_button:
        selected_button.config(style='ControlButton.Active.TButton')
        zgd_frame_instance.active_group_button = selected_button
    
    devices_in_group_list = zgd_frame_instance.structured_data.get(showtime_tab.selected_zone, {}).get(group_name, [])
    zgd_frame_instance._get_min_max_freq_and_update_title(frame_widget=zgd_frame_instance.groups_frame, devices=devices_in_group_list, title_prefix=f"Group '{group_name}'")

    zgd_frame_instance._make_device_buttons()
    zgd_frame_instance.canvas.yview_moveto(0)
    
    # FIXED: Call the set_span_to_group utility function here to trigger the update
    from Markers.showtime.controls.utils_showtime_zone_zoom import set_span_to_group
    set_span_to_group(showtime_tab_instance=showtime_tab, zone_zoom_tab=showtime_tab.controls_frame.zone_zoom_tab)
    _save_showtime_state_to_config(showtime_tab)

    debug_log(message=f"🛠️🟢 Exiting {current_function}", file=current_file, version=current_version, function=current_function)

def on_group_deselected(zgd_frame_instance):
    # [Handles the logic for when a group is deselected.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"🛠️🟢 Entering {current_function}", file=current_file, version=current_version, function=current_function)
    
    showtime_tab = zgd_frame_instance.showtime_tab_instance

    if zgd_frame_instance.active_group_button and zgd_frame_instance.active_group_button.winfo_exists():
        zgd_frame_instance.active_group_button.config(style='ControlButton.Inactive.TButton')
        zgd_frame_instance.active_group_button = None
        
    # 📝 Write Data: Reset selected state variables.
    debug_log(message=f"🛠️📝 Writing to state: Resetting selected group and related info.", file=current_file, version=current_version, function=current_function)
    showtime_tab.selected_group = None
    showtime_tab.last_selected_type = 'zone'
    showtime_tab.selected_group_info = {
        'min_freq': 0.0,
        'max_freq': 0.0,
        'device_count': 0
    }
    zgd_frame_instance._make_device_buttons()
    
    _update_zone_zoom_tab(zgd_frame_instance)
    _save_showtime_state_to_config(showtime_tab)
    
    if hasattr(showtime_tab.controls_frame, 'switch_to_tab'):
        showtime_tab.controls_frame.switch_to_tab("Zone Zoom")
        
    debug_log(message=f"🛠️🟢 Exiting {current_function}", file=current_file, version=current_version, function=current_function)

def no_zone_grou_device_selected(zgd_frame_instance):
    # [Handles the logic for when no zone, group, or device is selected.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"🛠️🟢 Entering {current_function}", file=current_file, version=current_version, function=current_function)
    
    console_log(f"EVENT: No zone, group, or device selected. Displaying all devices. ")
    
    # Access and update parent's state variables directly
    showtime_tab = zgd_frame_instance.showtime_tab_instance
    # 📝 Write Data: Reset selected state variables.
    debug_log(message=f"🛠️📝 Writing to state: Resetting selected state variables.", file=current_file, version=current_version, function=current_function)
    showtime_tab.selected_zone = None
    showtime_tab.selected_group = None
    showtime_tab.selected_device_info = None
    showtime_tab.last_selected_type = None

    if zgd_frame_instance.active_zone_button and zgd_frame_instance.active_zone_button.winfo_exists():
        zgd_frame_instance.active_zone_button.config(style='ControlButton.Inactive.TButton')
        zgd_frame_instance.active_zone_button = None
        
    if zgd_frame_instance.active_group_button and zgd_frame_instance.active_group_button.winfo_exists():
        zgd_frame_instance.active_group_button.config(style='ControlButton.Inactive.TButton')
        zgd_frame_instance.active_group_button = None
        
    if showtime_tab.active_device_button and showtime_tab.active_device_button.winfo_exists():
        showtime_tab.active_device_button.config(style='DeviceButton.Inactive.TButton')
    showtime_tab.active_device_button = None
    
    # FIXED: Revert the view to the parent group when a device is deselected.
    set_span_to_group(showtime_tab_instance=showtime_tab, zone_zoom_tab=showtime_tab.controls_frame.zone_zoom_tab)
    _update_zone_zoom_tab(zgd_frame_instance)
    _save_showtime_state_to_config(showtime_tab)
    
    if hasattr(showtime_tab.controls_frame, 'switch_to_tab'):
        showtime_tab.controls_frame.switch_to_tab("Zone Zoom")
        
    debug_log(message=f"🛠️🟢 Exiting {current_function}", file=current_file, version=current_version, function=current_function)

#####################################
### File: OPEN-AIR 2\workers\zones_groups_devices\utils_display_showtime_shared.py
#####################################
# tabs/Markers/showtime/zones_groups_devices/utils_display_showtime_shared.py
#
# This file provides shared utility functions for the Showtime tab's UI and state management.
# It contains logic that is common to handling selections at the zone, group, and device level,
# including saving the entire Showtime state to the config file and updating the zone-zoom display.
# By centralizing this code, it prevents duplication and ensures consistent behavior across
# all selection handlers.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.110500.6
# REFACTORED: Consolidated all truly shared functions into this single file.
# FIXED: The save function has been made more robust with checks for None values.
# FIXED: All references to shared state variables are now robustly handled.
# FIXED: Moved `on_group_deselected` to this file to break a circular import.

import os
import inspect
import math
from tkinter import ttk
import pandas as pd
import numpy as np
import threading

from display.debug_logic import debug_log
from display.console_logic import console_log
from settings_and_config.config_manager_save import save_program_config

# Import shared utility functions
from Markers.showtime.controls.utils_showtime_zone_zoom import _buffer_start_stop_frequencies, set_span_to_group


# --- Versioning ---
w = 20250824
x_str = '110500'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 6
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"


def _save_showtime_state_to_config(showtime_tab):
    # [Internal function to save all Showtime state variables to the config.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"🛠️📝 Writing Showtime state to configuration.", file=current_file, version=current_version, function=current_function)
    
    # Check if the parent tab exists before trying to save its state
    if not hasattr(showtime_tab, 'app_instance'):
        debug_log("❌ Cannot save config. ShowtimeParentTab instance does not have 'app_instance' attribute.", file=current_file, version=current_version, function=current_function)
        return
        
    try:
        config = showtime_tab.app_instance.config
        
        if not config.has_section('MarkerTab'):
            config.add_section('MarkerTab')
            
        # Save all the state variables to the config file
        config.set('MarkerTab', 'span_hz', str(showtime_tab.span_var.get()))
        config.set('MarkerTab', 'rbw_hz', str(showtime_tab.rbw_var.get()))
        config.set('MarkerTab', 'trace_live', str(showtime_tab.trace_modes['live'].get()))
        config.set('MarkerTab', 'trace_max_hold', str(showtime_tab.trace_modes['max'].get()))
        config.set('MarkerTab', 'trace_min_hold', str(showtime_tab.trace_modes['min'].get()))
        config.set('MarkerTab', 'buffer_mhz', str(showtime_tab.buffer_var.get()))
        config.set('MarkerTab', 'poke_mhz', str(showtime_tab.poke_freq_var.get()))
        
        config.set('MarkerTab', 'buffered_start_var', str(showtime_tab.buffered_start_var.get()))
        config.set('MarkerTab', 'buffered_stop_var', str(showtime_tab.buffered_stop_var.get()))
        
        # Save selection state with robust checks
        config.set('MarkerTab', 'zone_selected', 'true' if showtime_tab.selected_zone else 'false')
        config.set('MarkerTab', 'zone_zoom_button_selected_name', showtime_tab.selected_zone if showtime_tab.selected_zone else '')
        
        config.set('MarkerTab', 'group_selected', 'true' if showtime_tab.selected_group else 'false')
        config.set('MarkerTab', 'group_zoom_button_selected', 'true' if showtime_tab.selected_group else 'false')

        # We need to save device info as a string or a set of strings, not a dictionary directly
        if showtime_tab.selected_device_info:
            config.set('MarkerTab', 'device_selected_name', str(showtime_tab.selected_device_info.get('NAME', '')))
            config.set('MarkerTab', 'device_selected_device_type', str(showtime_tab.selected_device_info.get('DEVICE', '')))
            config.set('MarkerTab', 'device_selected_center', str(showtime_tab.selected_device_info.get('CENTER', '')))
        else:
            config.set('MarkerTab', 'device_selected_name', '')
            config.set('MarkerTab', 'device_selected_device_type', '')
            config.set('MarkerTab', 'device_selected_center', '')
            
        # The info dictionaries need to be saved as strings.
        config.set('MarkerTab', 'zone_zoom_label_left_var', showtime_tab.zone_zoom_label_left_var.get())
        config.set('MarkerTab', 'zone_zoom_label_center_var', showtime_tab.zone_zoom_label_center_var.get())
        config.set('MarkerTab', 'zone_zoom_label_right_var', showtime_tab.zone_zoom_label_right_var.get())

        config.set('MarkerTab', 'zone_zoom_start', str(showtime_tab.buffered_start_var.get()))
        config.set('MarkerTab', 'zone_zoom_stop', str(showtime_tab.buffered_stop_var.get()))
        config.set('MarkerTab', 'group_zoom_start', str(showtime_tab.buffered_start_var.get()))
        config.set('MarkerTab', 'group_zoom_stop', str(showtime_tab.buffered_stop_var.get()))
        
        # FIXED: Corrected the way device counts are retrieved with safe defaults, preventing crashes if state is None
        zone_info = showtime_tab.selected_zone_info if hasattr(showtime_tab, 'selected_zone_info') and showtime_tab.selected_zone_info else {}
        group_info = showtime_tab.selected_group_info if hasattr(showtime_tab, 'selected_group_info') and showtime_tab.selected_group_info else {}
        
        config.set('MarkerTab', 'zone_device_count', str(zone_info.get('device_count', 0)))
        
        # FIXED: The previous line was incorrect, trying to get `keys()` from a potentially empty dict
        zone_groups = showtime_tab.structured_data.get(showtime_tab.selected_zone, {}) if showtime_tab.structured_data and showtime_tab.selected_zone else {}
        config.set('MarkerTab', 'zone_group_count', str(len(zone_groups.keys()) if showtime_tab.selected_zone else 0))

        config.set('MarkerTab', 'group_device_count', str(group_info.get('device_count', 0)))
        
        
        save_program_config(config=config,
                    file_path=showtime_tab.app_instance.CONFIG_FILE_PATH,
                    console_print_func=showtime_tab.console_print_func,
                    app_instance=showtime_tab.app_instance)
        
        debug_log(message=f"🛠️ ✅ Showtime state successfully written to config.", file=current_file, version=current_version, function=current_function)

    except Exception as e:
        console_log(f"❌ Error saving Showtime state to config: {e}. Fucking useless!", "ERROR")
        debug_log(message=f"🛠️❌ Failed to save Showtime state. Error: {e}", file=current_file, version=current_version, function=current_function)


def _update_zone_zoom_tab(zgd_frame_instance):
    # [A helper function to update the ZoneZoomTab with the current selection details.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"🛠️🟢 Entering {current_function}", file=current_file, version=current_version, function=current_function)
    
    showtime_tab = zgd_frame_instance.showtime_tab_instance
    try:
        # --- NEW LOGIC: Calculate buffered frequencies based on current selection state ---
        current_type = showtime_tab.last_selected_type
        buffer_mhz = float(showtime_tab.buffer_var.get())
        
        start_freq_mhz = 0.0
        stop_freq_mhz = 0.0
        
        if current_type == 'zone':
            zone_info = showtime_tab.selected_zone_info
            start_freq_mhz = zone_info.get('min_freq', 0.0)
            stop_freq_mhz = zone_info.get('max_freq', 0.0)
        elif current_type == 'group':
            group_info = showtime_tab.selected_group_info
            start_freq_mhz = group_info.get('min_freq', 0.0)
            stop_freq_mhz = group_info.get('max_freq', 0.0)
        elif current_type == 'device':
            device_info = showtime_tab.selected_device_info
            if device_info:
                center_freq = device_info.get('CENTER', 0.0)
                span_str = showtime_tab.span_var.get()
                if 'M' in span_str:
                    span_mhz = float(span_str.replace('M', ''))
                else:
                    span_mhz = float(span_str)
                # FIXED: Calculate start/stop correctly for a device without buffer
                start_freq_mhz = center_freq - (span_mhz / 2)
                stop_freq_mhz = center_freq + (span_mhz / 2)
        else: # All markers
            all_devices = zgd_frame_instance._get_all_devices_in_zone(zgd_frame_instance.structured_data, None)
            freqs = [float(d['CENTER']) for d in all_devices if isinstance(d.get('CENTER'), (int, float))]
            if freqs:
                start_freq_mhz = min(freqs)
                stop_freq_mhz = max(freqs)

        # Calculate and write buffered frequencies to state. This fixes the main bug.
        buffered_start_freq_mhz, buffered_stop_freq_mhz = _buffer_start_stop_frequencies(start_freq_mhz, stop_freq_mhz, buffer_mhz)
        debug_log(message=f"🛠️📝 Writing state: buffered_start_var = {buffered_start_freq_mhz}, buffered_stop_var = {buffered_stop_freq_mhz}", file=current_file, version=current_version, function=current_function)
        showtime_tab.buffered_start_var.set(buffered_start_freq_mhz)
        showtime_tab.buffered_stop_var.set(buffered_stop_freq_mhz)

        # --- Update Labels based on the correct values from state ---
        buffered_start_freq = showtime_tab.buffered_start_var.get()
        buffered_stop_freq = showtime_tab.buffered_stop_var.get()

        if current_type == 'zone':
            zone_info = showtime_tab.selected_zone_info
            count = zone_info.get('device_count', 0)
            
            debug_log(message=f"🛠️📝 Writing to state: Updating zone_zoom labels.", file=current_file, version=current_version, function=current_function)
            showtime_tab.zone_zoom_label_left_var.set(f"Zone ({count} Devices)")
            showtime_tab.zone_zoom_label_center_var.set(f"Name: {showtime_tab.selected_zone}")
            showtime_tab.zone_zoom_label_right_var.set(f"Start: {buffered_start_freq:.3f} MHz\nStop: {buffered_stop_freq:.3f} MHz")
        elif current_type == 'group':
            group_info = showtime_tab.selected_group_info
            count = group_info.get('device_count', 0)
            
            debug_log(message=f"🛠️📝 Writing to state: Updating zone_zoom labels.", file=current_file, version=current_version, function=current_function)
            showtime_tab.zone_zoom_label_left_var.set(f"Group ({count} Devices)")
            showtime_tab.zone_zoom_label_center_var.set(f"Name: {showtime_tab.selected_group}")
            showtime_tab.zone_zoom_label_right_var.set(f"Start: {buffered_start_freq:.3f} MHz\nStop: {buffered_stop_freq:.3f} MHz")
        elif current_type == 'device':
            device_info = showtime_tab.selected_device_info
            if device_info:
                debug_log(message=f"🛠️📝 Writing to state: Updating zone_zoom labels.", file=current_file, version=current_version, function=current_function)
                showtime_tab.zone_zoom_label_left_var.set(f"Device: {device_info.get('NAME')}")
                showtime_tab.zone_zoom_label_center_var.set(f"Name: {device_info.get('NAME')}")
                showtime_tab.zone_zoom_label_right_var.set(f"Center: {device_info.get('CENTER'):.3f} MHz\nStart: {buffered_start_freq:.3f} MHz\nStop: {buffered_stop_freq:.3f} MHz")
            else:
                debug_log(message=f"🛠️📝 Writing to state: No device info available, clearing labels.", file=current_file, version=current_version, function=current_function)
                showtime_tab.zone_zoom_label_left_var.set("No Device Selected")
                showtime_tab.zone_zoom_label_center_var.set("N/A")
                showtime_tab.zone_zoom_label_right_var.set("N/A")
        else: # All markers
            all_devices = zgd_frame_instance._get_all_devices_in_zone(zgd_frame_instance.structured_data, None)
            count = len(all_devices) if all_devices else 0
            
            debug_log(message=f"🛠️📝 Writing to state: Updating zone_zoom labels.", file=current_file, version=current_version, function=current_function)
            showtime_tab.zone_zoom_label_left_var.set("All Markers")
            showtime_tab.zone_zoom_label_center_var.set(f"({count} Devices)")
            showtime_tab.zone_zoom_label_right_var.set(f"Start: {buffered_start_freq:.3f} MHz\nStop: {buffered_stop_freq:.3f} MHz")

        showtime_tab.controls_frame.zone_zoom_tab._sync_ui_from_state()
        
        _save_showtime_state_to_config(showtime_tab)

    except Exception as e:
        debug_log(message=f"🛠️❌ Error in _update_zone_zoom_tab: {e}", file=current_file, version=current_version, function=current_function)
    
    debug_log(message=f"🛠️🟢 Exiting {current_function}", file=current_file, version=current_version, function=current_function)

def get_current_view_details(zgd_frame_instance):
    # [Returns a dictionary with the start, stop, center, and span frequencies for the current view.]
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"🛠️🟢 Entering {current_function}", file=current_file, version=current_version, function=current_function)

    start_freq = None
    stop_freq = None
    
    # Access state from the parent ShowtimeTab instance
    showtime_tab = zgd_frame_instance.showtime_tab_instance

    if showtime_tab.selected_device_info:
        center_freq = showtime_tab.selected_device_info.get('CENTER')
        if center_freq:
            # Check for 'M' in span_var and convert appropriately
            span_str = showtime_tab.span_var.get()
            if 'M' in span_str:
                span = float(span_str.replace('M', ''))
            else:
                span = float(span_str)
            start_freq = center_freq - (span / 2)
            stop_freq = center_freq + (span / 2)
    
    elif showtime_tab.selected_zone or showtime_tab.selected_group:
        devices = []
        if showtime_tab.selected_group:
            devices = zgd_frame_instance.structured_data.get(showtime_tab.selected_zone, {}).get(showtime_tab.selected_group, [])
        elif showtime_tab.selected_zone:
            for group_name in showtime_tab.structured_data.get(showtime_tab.selected_zone, {}).keys():
                devices.extend(showtime_tab.structured_data.get(showtime_tab.selected_zone, {}).get(group_name, []))
        
        freqs = [float(d.get('CENTER')) for d in devices if d.get('CENTER') and isinstance(d.get('CENTER'), (int, float))]
        if freqs:
            start_freq = min(freqs)
            stop_freq = max(freqs)
    
    else:
        all_devices = zgd_frame_instance._get_all_devices_in_zone(zgd_frame_instance.structured_data, None)
        freqs = [float(d.get('CENTER')) for d in all_devices if isinstance(d.get('CENTER'), (int, float))]
        if freqs:
            start_freq = min(freqs)
            stop_freq = max(freqs)
            
    if start_freq is not None and stop_freq is not None:
        center = (start_freq + stop_freq) / 2
        span = stop_freq - start_freq
        return {"start": start_freq, "stop": stop_freq, "center": center, "span": span}
    
    debug_log(message=f"🛠️🟢 Exiting {current_function}", file=current_file, version=current_version, function=current_function)
    return None

#####################################
### File: OPEN-AIR 2\workers\zones_groups_devices\utils_display_showtime_zones.py
#####################################
# tabs/Markers/showtime/zones_groups_devices/utils_display_showtime_zones.py
#
# This module provides the backend logic for handling Zone-level button clicks.
# It manages the selection and deselection of zones, updates the UI to reflect
# the current state, and delegates to shared utility functions for saving
# the state and updating the instrument's view.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250824.110500.6
# REFACTORED: Extracted zone-specific logic from the main utility file.
# FIXED: The logic for selecting and deselecting a zone is now self-contained.
# UPDATED: Corrected import statements to resolve circular dependencies.
# FIXED: Moved `on_group_deselected` to the shared utility file to break a circular import.

import os
import inspect
import math
from tkinter import ttk
import pandas as pd
import numpy as np

from display.debug_logic import debug_log
from display.console_logic import console_log

# Import shared utility functions
from Markers.showtime.controls.utils_showtime_zone_zoom import set_span_to_zone
# FIXED: Updated the import statement to reflect the new location of no_zone_grou_device_selected.
from .utils_display_showtime_shared import _update_zone_zoom_tab, _save_showtime_state_to_config
from .utils_display_showtime_all import no_zone_grou_device_selected


# --- Versioning ---
w = 20250824
x_str = '110500'
x = int(x_str) if not x_str.startswith('0') else int(x_str[1:])
y = 6
current_version = f"Version {w}.{x_str}.{y}"
current_version_hash = (w * x * y)
current_file = file=f"{os.path.basename(__file__)}"


def on_zone_selected(zgd_frame_instance, zone_name):
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"🛠️🟢 Entering {current_function} for zone: {zone_name}", file=current_file, version=current_version, function=current_function)

    showtime_tab = zgd_frame_instance.showtime_tab_instance

    for widget in zgd_frame_instance.zones_frame.winfo_children():
        if widget.cget("text") == zone_name:
            selected_button = widget
            break
    else:
        selected_button = None

    if showtime_tab.selected_zone == zone_name:
        no_zone_grou_device_selected(zgd_frame_instance)
    else:
        console_log(f"EVENT: Zone '{zone_name}' selected. Loading groups and devices... 🚀")
        if zgd_frame_instance.active_zone_button and zgd_frame_instance.active_zone_button.winfo_exists():
            zgd_frame_instance.active_zone_button.config(style='ControlButton.Inactive.TButton')
        if zgd_frame_instance.active_group_button and zgd_frame_instance.active_group_button.winfo_exists():
            zgd_frame_instance.active_group_button.config(style='ControlButton.Inactive.TButton')
            zgd_frame_instance.active_group_button = None
        
        # 📝 Write Data: Update selected state variables.
        debug_log(message=f"🛠️📝 Writing to state: Updating selected zone and resetting group/device.", file=current_file, version=current_version, function=current_function)
        showtime_tab.active_device_button = None
        showtime_tab.selected_device_info = None
        showtime_tab.selected_zone = zone_name
        showtime_tab.selected_group = None
        showtime_tab.last_selected_type = 'zone'

        # NEW: Calculate and store zone information in state
        all_devices_in_zone = zgd_frame_instance._get_all_devices_in_zone(zgd_frame_instance.structured_data, showtime_tab.selected_zone)
        freqs = [float(d['CENTER']) for d in all_devices_in_zone if isinstance(d.get('CENTER'), (int, float))]
        
        # FIXED: Check if freqs is not empty before calling min/max
        if freqs:
            min_freq = min(freqs)
            max_freq = max(freqs)
        else:
            min_freq = 0.0
            max_freq = 0.0

        showtime_tab.selected_zone_info = {
            'min_freq': min_freq,
            'max_freq': max_freq,
            'device_count': len(all_devices_in_zone)
        }
        
        debug_log(message=f"🛠️📦 Stored zone info in state: {showtime_tab.selected_zone_info}", file=current_file, version=current_version, function=current_function)

        if selected_button:
            selected_button.config(style='ControlButton.Active.TButton')
            zgd_frame_instance.active_zone_button = selected_button
        
        zgd_frame_instance._get_min_max_freq_and_update_title(frame_widget=zgd_frame_instance.zones_frame, devices=all_devices_in_zone, title_prefix=f"Zone '{zone_name}'")

        zgd_frame_instance._get_min_max_freq_and_update_title(frame_widget=zgd_frame_instance.groups_frame, devices=[], title_prefix=f"Groups in Zone '{showtime_tab.selected_zone}'" if showtime_tab.selected_zone else "Groups")

        zgd_frame_instance._make_group_buttons()
        zgd_frame_instance.canvas.yview_moveto(0)
        
        # FIXED: Call the set_span_to_zone utility function here to trigger the update
        set_span_to_zone(showtime_tab_instance=showtime_tab, zone_zoom_tab=showtime_tab.controls_frame.zone_zoom_tab)
        _save_showtime_state_to_config(showtime_tab)

    debug_log(message=f"🛠️🟢 Exiting {current_function}", file=current_file, version=current_version, function=current_function)

#####################################
### File: OPEN-AIR 2\workers\zones_groups_devices\utils_files_markers_zone_groups_devices.py
#####################################
# tabs.Markers/showtime/utils_markers_files_zone_groups_devices.py
#
# This new utility file centralizes all logic for parsing the MARKERS.CSV file,
# structuring the data into zones, groups, and devices, and providing helper
# functions for the UI, like the progress bar.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no change to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.210000.1
# FIXED: Replaced inplace operations on DataFrame slices to remove FutureWarning messages.
# NEW: Added debug logging for reads and writes of file data.

import os
import inspect
import pandas as pd
import numpy as np

from display.debug_logic import debug_log
from display.console_logic import console_log
from ref.ref_file_paths import MARKERS_FILE_PATH



def load_and_structure_markers_data():
    # The main function to load, parse, and structure data from MARKERS.CSV.
    current_function = inspect.currentframe().f_code.co_name
    debug_log(message=f"Entering {current_function}. Time to wrangle that CSV data! 📂", file=f"{os.path.basename(__file__)}", version="20250821.210000.1", function=current_function)

    if not os.path.exists(MARKERS_FILE_PATH):
        console_log(f"❌ MARKERS.CSV not found at path: {MARKERS_FILE_PATH}", "ERROR")
        debug_log(message=f"Marker CSV not found. What a disaster!", file=f"{os.path.basename(__file__)}", version="20250821.210000.1", function=current_function)
        return None
    try:
        # 📂 Read File: Reading the marker CSV data.
        debug_log(message=f"📂 Read File: Reading marker data from {MARKERS_FILE_PATH}", file=f"{os.path.basename(__file__)}", version="20250821.210000.1", function=current_function)
        df = pd.read_csv(MARKERS_FILE_PATH)
        
        # --- Data Cleaning and Structuring ---
        df.columns = [col.upper().strip() for col in df.columns]
        
        # Define potential column names and map them to our desired names
        column_mapping = {
            'ZONE': 'ZONE',
            'GROUP': 'GROUP',
            'NAME': 'NAME',
            'DEVICE': 'DEVICE',
            'FREQ CENTER (MHZ)': 'CENTER',
            'FREQ': 'CENTER', # Alternate name for center frequency
            'PEAK (DBM)': 'PEAK',
            'PEAK': 'PEAK' # Alternate name for peak
        }
        
        # Rename columns based on the mapping
        df.rename(columns=column_mapping, inplace=True)

        # Ensure essential columns exist, fill missing with defaults
        for col in ['ZONE', 'GROUP', 'NAME', 'DEVICE', 'CENTER', 'PEAK']:
            if col not in df.columns:
                df[col] = 'N/A' if col != 'PEAK' else -120

        # FIXED: Corrected the fillna operations to avoid FutureWarning in pandas 3.0
        # Replaces df['GROUP'].fillna('Ungrouped', inplace=True)
        df.loc[:, 'GROUP'] = df['GROUP'].fillna('Ungrouped')
        # Replaces df['ZONE'].fillna('Unzoned', inplace=True)
        df.loc[:, 'ZONE'] = df['ZONE'].fillna('Unzoned')

        # --- Hierarchical Structuring ---
        structured_data = {}
        for zone_name, zone_df in df.groupby('ZONE'):
            zone_dict = {}
            for group_name, group_df in zone_df.groupby('GROUP'):
                device_list = []
                for index, row in group_df.iterrows():
                    device_list.append({
                        'NAME': row['NAME'],
                        'DEVICE': row['DEVICE'],
                        'CENTER': row['CENTER'],
                        'PEAK': row['PEAK']
                    })
                zone_dict[group_name] = device_list
            structured_data[zone_name] = zone_dict
        
        # 📊 Processed Data: Log the result of the data transformation.
        console_log(f"✅ Successfully loaded and structured {len(df)} devices into {len(structured_data)} zones.", "SUCCESS")
        debug_log(message=f"📊 Processed Data: Successfully loaded and structured {len(df)} devices into {len(structured_data)} zones. We got the data! 🎣", file=f"{os.path.basename(__file__)}", version="20250821.210000.1", function=current_function)
        return structured_data

    except Exception as e:
        console_log(f"❌ Failed to parse MARKERS.CSV. Error: {e}", "ERROR")
        debug_log(message=f"Full traceback for CSV parsing error: {e}. This bugger is being problematic!", file=f"{os.path.basename(__file__)}", version="20250821.210000.1", function=current_function)
        return None

