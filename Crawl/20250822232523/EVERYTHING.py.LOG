# └── OPEN-AIR 2/
#├── DATA/
#├── configuration/
#├── device_interfacing/
#├── display/
#├── utils/
#├── debug.log (Lines: 3366)
#└── main.py (Lines: 158)
#        |   -> Import: configuration.logging
#        |   -> Import: datetime
#        |   -> Import: display.gui_display
#        |   -> Import: inspect
#        |   -> Import: os
#        |   -> Import: pathlib
#        |   -> Import: sys
#        |   -> Function: action_check_configuration()
#        |   -> Function: action_check_dependancies()
#        |   -> Function: action_open_display()
#        |   -> Function: main()
#└── configuration/
#    └── logging.py (Lines: 72)
#            |   -> Import: datetime
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Function: console_log(message)
#            |   -> Function: debug_log(message, file, version, function, console_print_func)
#└── DATA/
#└── device_interfacing/
#└── display/
#    ├── left_60/
#    ├── right_40/
#    ├── styling/
#    ├── debug.log (Lines: 0)
#    └── gui_display.py (Lines: 588)
#            |   -> Import: configuration.logging
#            |   -> Import: datetime
#            |   -> Import: display.styling.style
#            |   -> Import: importlib.util
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: pathlib
#            |   -> Import: sys
#            |   -> Import: tkinter
#            |   -> Import: utils.mqtt_controller_util
#            |   -> Class: Application
#            |   -> Function: __init__(self)
#            |   -> Function: _apply_styles(self, theme_name)
#            |   -> Function: _build_child_container(self, path, parent_widget)
#            |   -> Function: _build_from_directory(self, path, parent_widget)
#            |   -> Function: _on_tab_change(self, event)
#            |   -> Function: _re_attach_tab(self, frame)
#            |   -> Function: _tear_off_tab(self, event)
#    └── left_60/
#        └── top_100/
#        └── top_100/
#            ├── tab_1_instrument/
#            ├── tab_2_markers/
#            ├── tab_3_presets/
#            ├── tab_4_intermod/
#            ├── tab_5_sweeping/
#            ├── tab_6_graphing/
#            └── tab_7_exepriment/
#            └── tab_1_instrument/
#                ├── sub_tab_1_connection/
#                ├── sub_tab_2_settings/
#                └── sub_tab_3_translator/
#                └── sub_tab_1_connection/
#                    └── gui_connection.py (Lines: 325)
#                            |   -> Import: configuration.logging
#                            |   -> Import: datetime
#                            |   -> Import: inspect
#                            |   -> Import: json
#                            |   -> Import: os
#                            |   -> Import: paho.mqtt.client
#                            |   -> Import: pathlib
#                            |   -> Import: sys
#                            |   -> Import: tkinter
#                            |   -> Import: utils.mqtt_controller_util
#                            |   -> Class: BaseGUIFrame
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _on_mqtt_message(self, topic, payload)
#                            |   -> Function: _on_mqtt_message_direct(self, client, userdata, msg)
#                            |   -> Function: _publish_custom_message(self)
#                            |   -> Function: _publish_version_message(self)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#                └── sub_tab_2_settings/
#                    └── gui_settings.py (Lines: 325)
#                            |   -> Import: configuration.logging
#                            |   -> Import: datetime
#                            |   -> Import: inspect
#                            |   -> Import: json
#                            |   -> Import: os
#                            |   -> Import: paho.mqtt.client
#                            |   -> Import: pathlib
#                            |   -> Import: sys
#                            |   -> Import: tkinter
#                            |   -> Import: utils.mqtt_controller_util
#                            |   -> Class: BaseGUIFrame
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _on_mqtt_message(self, topic, payload)
#                            |   -> Function: _on_mqtt_message_direct(self, client, userdata, msg)
#                            |   -> Function: _publish_custom_message(self)
#                            |   -> Function: _publish_version_message(self)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#                └── sub_tab_3_translator/
#                    └── gui_translator.py (Lines: 325)
#                            |   -> Import: configuration.logging
#                            |   -> Import: datetime
#                            |   -> Import: inspect
#                            |   -> Import: json
#                            |   -> Import: os
#                            |   -> Import: paho.mqtt.client
#                            |   -> Import: pathlib
#                            |   -> Import: sys
#                            |   -> Import: tkinter
#                            |   -> Import: utils.mqtt_controller_util
#                            |   -> Class: BaseGUIFrame
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _on_mqtt_message(self, topic, payload)
#                            |   -> Function: _on_mqtt_message_direct(self, client, userdata, msg)
#                            |   -> Function: _publish_custom_message(self)
#                            |   -> Function: _publish_version_message(self)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#            └── tab_2_markers/
#                ├── sub_tab_1_showtime/
#                └── sub_tab_2_editor/
#                └── sub_tab_1_showtime/
#                    └── gui_child_1_showtime.py (Lines: 321)
#                            |   -> Import: configuration.logging
#                            |   -> Import: datetime
#                            |   -> Import: inspect
#                            |   -> Import: json
#                            |   -> Import: os
#                            |   -> Import: paho.mqtt.client
#                            |   -> Import: pathlib
#                            |   -> Import: sys
#                            |   -> Import: tkinter
#                            |   -> Import: utils.mqtt_controller_util
#                            |   -> Class: BaseGUIFrame
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _on_mqtt_message(self, topic, payload)
#                            |   -> Function: _on_mqtt_message_direct(self, client, userdata, msg)
#                            |   -> Function: _publish_custom_message(self)
#                            |   -> Function: _publish_version_message(self)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#                └── sub_tab_2_editor/
#                    └── gui_child_2_editor.py (Lines: 321)
#                            |   -> Import: configuration.logging
#                            |   -> Import: datetime
#                            |   -> Import: inspect
#                            |   -> Import: json
#                            |   -> Import: os
#                            |   -> Import: paho.mqtt.client
#                            |   -> Import: pathlib
#                            |   -> Import: sys
#                            |   -> Import: tkinter
#                            |   -> Import: utils.mqtt_controller_util
#                            |   -> Class: BaseGUIFrame
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _on_mqtt_message(self, topic, payload)
#                            |   -> Function: _on_mqtt_message_direct(self, client, userdata, msg)
#                            |   -> Function: _publish_custom_message(self)
#                            |   -> Function: _publish_version_message(self)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#            └── tab_3_presets/
#                ├── sub_tab_1_pusher/
#                ├── sub_tab_2_editor/
#                └── sub_tab_3_collector/
#                └── sub_tab_1_pusher/
#                    └── gui_child_1_pusher.py (Lines: 321)
#                            |   -> Import: configuration.logging
#                            |   -> Import: datetime
#                            |   -> Import: inspect
#                            |   -> Import: json
#                            |   -> Import: os
#                            |   -> Import: paho.mqtt.client
#                            |   -> Import: pathlib
#                            |   -> Import: sys
#                            |   -> Import: tkinter
#                            |   -> Import: utils.mqtt_controller_util
#                            |   -> Class: BaseGUIFrame
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _on_mqtt_message(self, topic, payload)
#                            |   -> Function: _on_mqtt_message_direct(self, client, userdata, msg)
#                            |   -> Function: _publish_custom_message(self)
#                            |   -> Function: _publish_version_message(self)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#                └── sub_tab_2_editor/
#                    └── gui_child_2_editor.py (Lines: 321)
#                            |   -> Import: configuration.logging
#                            |   -> Import: datetime
#                            |   -> Import: inspect
#                            |   -> Import: json
#                            |   -> Import: os
#                            |   -> Import: paho.mqtt.client
#                            |   -> Import: pathlib
#                            |   -> Import: sys
#                            |   -> Import: tkinter
#                            |   -> Import: utils.mqtt_controller_util
#                            |   -> Class: BaseGUIFrame
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _on_mqtt_message(self, topic, payload)
#                            |   -> Function: _on_mqtt_message_direct(self, client, userdata, msg)
#                            |   -> Function: _publish_custom_message(self)
#                            |   -> Function: _publish_version_message(self)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#                └── sub_tab_3_collector/
#                    └── gui_child_3_collector.py (Lines: 321)
#                            |   -> Import: configuration.logging
#                            |   -> Import: datetime
#                            |   -> Import: inspect
#                            |   -> Import: json
#                            |   -> Import: os
#                            |   -> Import: paho.mqtt.client
#                            |   -> Import: pathlib
#                            |   -> Import: sys
#                            |   -> Import: tkinter
#                            |   -> Import: utils.mqtt_controller_util
#                            |   -> Class: BaseGUIFrame
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _on_mqtt_message(self, topic, payload)
#                            |   -> Function: _on_mqtt_message_direct(self, client, userdata, msg)
#                            |   -> Function: _publish_custom_message(self)
#                            |   -> Function: _publish_version_message(self)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#            └── tab_4_intermod/
#                ├── sub_tab_1_calculator/
#                └── sub_tab_2_future/
#                └── sub_tab_1_calculator/
#                    └── gui_child_1_calculator.py (Lines: 303)
#                            |   -> Import: configuration.logging
#                            |   -> Import: datetime
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: sys
#                            |   -> Import: tkinter
#                            |   -> Import: utils.mqtt_controller_util
#                            |   -> Class: BaseGUIFrame
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _on_mqtt_message(self, client, userdata, msg)
#                            |   -> Function: _publish_custom_message(self)
#                            |   -> Function: _publish_version_message(self)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#                └── sub_tab_2_future/
#                    ├── gui_1_top.py (Lines: 303)
#                            |   -> Import: configuration.logging
#                            |   -> Import: datetime
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: sys
#                            |   -> Import: tkinter
#                            |   -> Import: utils.mqtt_controller_util
#                            |   -> Class: BaseGUIFrame
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _on_mqtt_message(self, client, userdata, msg)
#                            |   -> Function: _publish_custom_message(self)
#                            |   -> Function: _publish_version_message(self)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#                    ├── gui_2_bottom copy.py (Lines: 303)
#                            |   -> Import: configuration.logging
#                            |   -> Import: datetime
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: sys
#                            |   -> Import: tkinter
#                            |   -> Import: utils.mqtt_controller_util
#                            |   -> Class: BaseGUIFrame
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _on_mqtt_message(self, client, userdata, msg)
#                            |   -> Function: _publish_custom_message(self)
#                            |   -> Function: _publish_version_message(self)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#                    └── gui_44_last.py (Lines: 303)
#                            |   -> Import: configuration.logging
#                            |   -> Import: datetime
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: sys
#                            |   -> Import: tkinter
#                            |   -> Import: utils.mqtt_controller_util
#                            |   -> Class: BaseGUIFrame
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _on_mqtt_message(self, client, userdata, msg)
#                            |   -> Function: _publish_custom_message(self)
#                            |   -> Function: _publish_version_message(self)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#            └── tab_5_sweeping/
#                ├── sub_tab_1_single/
#                └── sub_tab_2_statistical/
#                └── sub_tab_1_single/
#                    └── gui_child_1_single.py (Lines: 303)
#                            |   -> Import: configuration.logging
#                            |   -> Import: datetime
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: sys
#                            |   -> Import: tkinter
#                            |   -> Import: utils.mqtt_controller_util
#                            |   -> Class: BaseGUIFrame
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _on_mqtt_message(self, client, userdata, msg)
#                            |   -> Function: _publish_custom_message(self)
#                            |   -> Function: _publish_version_message(self)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#                └── sub_tab_2_statistical/
#                    └── gui_child_2_statistical.py (Lines: 303)
#                            |   -> Import: configuration.logging
#                            |   -> Import: datetime
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: sys
#                            |   -> Import: tkinter
#                            |   -> Import: utils.mqtt_controller_util
#                            |   -> Class: BaseGUIFrame
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _on_mqtt_message(self, client, userdata, msg)
#                            |   -> Function: _publish_custom_message(self)
#                            |   -> Function: _publish_version_message(self)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#            └── tab_6_graphing/
#                └── sub_tab_1_from_file/
#                └── sub_tab_1_from_file/
#                    └── gui_child1_from_file.py (Lines: 303)
#                            |   -> Import: configuration.logging
#                            |   -> Import: datetime
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: sys
#                            |   -> Import: tkinter
#                            |   -> Import: utils.mqtt_controller_util
#                            |   -> Class: BaseGUIFrame
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _on_mqtt_message(self, client, userdata, msg)
#                            |   -> Function: _publish_custom_message(self)
#                            |   -> Function: _publish_version_message(self)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#            └── tab_7_exepriment/
#                └── sub_tab_1_mosquitto/
#                └── sub_tab_1_mosquitto/
#                    └── gui_7_experiment.py (Lines: 303)
#                            |   -> Import: configuration.logging
#                            |   -> Import: datetime
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: sys
#                            |   -> Import: tkinter
#                            |   -> Import: utils.mqtt_controller_util
#                            |   -> Class: BaseGUIFrame
#                            |   -> Function: __init__(self, parent, mqtt_util)
#                            |   -> Function: _on_mqtt_message(self, client, userdata, msg)
#                            |   -> Function: _publish_custom_message(self)
#                            |   -> Function: _publish_version_message(self)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#    └── right_40/
#        ├── bottom_90/
#        └── top_10/
#        └── bottom_90/
#            ├── tab_1_scan/
#            ├── tab_2_monitors/
#            ├── tab_3_debug/
#            ├── tab_4_conductor/
#            └── tab_5_configuration/
#            └── tab_1_scan/
#                └── gui_tab_1_scan.py (Lines: 303)
#                        |   -> Import: configuration.logging
#                        |   -> Import: datetime
#                        |   -> Import: inspect
#                        |   -> Import: os
#                        |   -> Import: pathlib
#                        |   -> Import: sys
#                        |   -> Import: tkinter
#                        |   -> Import: utils.mqtt_controller_util
#                        |   -> Class: BaseGUIFrame
#                        |   -> Function: __init__(self, parent, mqtt_util)
#                        |   -> Function: _on_mqtt_message(self, client, userdata, msg)
#                        |   -> Function: _publish_custom_message(self)
#                        |   -> Function: _publish_version_message(self)
#                        |   -> Function: debug_button_press(self)
#                        |   -> Function: log_button_press(self)
#            └── tab_2_monitors/
#                └── gui_tab_2_monitors.py (Lines: 303)
#                        |   -> Import: configuration.logging
#                        |   -> Import: datetime
#                        |   -> Import: inspect
#                        |   -> Import: os
#                        |   -> Import: pathlib
#                        |   -> Import: sys
#                        |   -> Import: tkinter
#                        |   -> Import: utils.mqtt_controller_util
#                        |   -> Class: BaseGUIFrame
#                        |   -> Function: __init__(self, parent, mqtt_util)
#                        |   -> Function: _on_mqtt_message(self, client, userdata, msg)
#                        |   -> Function: _publish_custom_message(self)
#                        |   -> Function: _publish_version_message(self)
#                        |   -> Function: debug_button_press(self)
#                        |   -> Function: log_button_press(self)
#            └── tab_3_debug/
#                └── gui_tab_3_debug.py (Lines: 303)
#                        |   -> Import: configuration.logging
#                        |   -> Import: datetime
#                        |   -> Import: inspect
#                        |   -> Import: os
#                        |   -> Import: pathlib
#                        |   -> Import: sys
#                        |   -> Import: tkinter
#                        |   -> Import: utils.mqtt_controller_util
#                        |   -> Class: BaseGUIFrame
#                        |   -> Function: __init__(self, parent, mqtt_util)
#                        |   -> Function: _on_mqtt_message(self, client, userdata, msg)
#                        |   -> Function: _publish_custom_message(self)
#                        |   -> Function: _publish_version_message(self)
#                        |   -> Function: debug_button_press(self)
#                        |   -> Function: log_button_press(self)
#            └── tab_4_conductor/
#                └── gui_child_1_mqtt_conductor.py (Lines: 275)
#                        |   -> Import: configuration.logging
#                        |   -> Import: datetime
#                        |   -> Import: inspect
#                        |   -> Import: os
#                        |   -> Import: styling.style
#                        |   -> Import: tkinter
#                        |   -> Import: utils.mqtt_controller_util
#                        |   -> Class: MqttConductorFrame
#                        |   -> Function: __init__(self, parent)
#                        |   -> Function: _apply_styles(self, theme_name)
#                        |   -> Function: create_widgets(self)
#                        |   -> Function: log_to_gui(self, message)
#                        |   -> Function: log_to_table(self, topic, message)
#                        |   -> Function: update_slider_label(self)
#            └── tab_5_configuration/
#                └── gui_tab_5_configuration.py (Lines: 320)
#                        |   -> Import: configuration.logging
#                        |   -> Import: datetime
#                        |   -> Import: inspect
#                        |   -> Import: os
#                        |   -> Import: pathlib
#                        |   -> Import: sys
#                        |   -> Import: tkinter
#                        |   -> Import: utils.mqtt_controller_util
#                        |   -> Class: BaseGUIFrame
#                        |   -> Function: __init__(self, parent, mqtt_util)
#                        |   -> Function: _on_mqtt_message(self, client, userdata, msg)
#                        |   -> Function: _publish_custom_message(self)
#                        |   -> Function: _publish_version_message(self)
#                        |   -> Function: debug_button_press(self)
#                        |   -> Function: log_button_press(self)
#        └── top_10/
#            └── gui_right_side.py (Lines: 201)
#                    |   -> Import: configuration.logging
#                    |   -> Import: datetime
#                    |   -> Import: inspect
#                    |   -> Import: os
#                    |   -> Import: tkinter
#                    |   -> Class: Start_stop
#                    |   -> Function: __init__(self, parent)
#                    |   -> Function: debug_button_press(self)
#                    |   -> Function: log_button_press(self)
#    └── styling/
#        └── style.py (Lines: 117)
#                |   -> Import: os
#└── utils/
#    └── mqtt_controller_util.py (Lines: 324)
#            |   -> Import: configuration.logging
#            |   -> Import: datetime
#            |   -> Import: inspect
#            |   -> Import: json
#            |   -> Import: os
#            |   -> Import: paho.mqtt.client
#            |   -> Import: pathlib
#            |   -> Import: subprocess
#            |   -> Import: sys
#            |   -> Import: threading
#            |   -> Class: MqttControllerUtility
#            |   -> Function: __init__(self, print_to_gui_func, log_treeview_func)
#            |   -> Function: add_subscriber(self, topic_filter, callback_func)
#            |   -> Function: check_status(self)
#            |   -> Function: connect_mqtt(self)
#            |   -> Function: on_connect(self, client, userdata, flags, rc)
#            |   -> Function: on_message(self, client, userdata, msg)
#            |   -> Function: publish_message(self, topic, subtopic, value)
#            |   -> Function: show_topics(self)
#            |   -> Function: start_mosquitto(self)
#            |   -> Function: stop_mosquitto(self)


--------------------------------------------------

# ====================================================================================
# EVERYTHING.py.LOG
# This file contains the complete content of all Python, CSV, and INI files found during the crawl.
# Each file's content is separated by its path and a dashed line.
#
# Log started at: 2025-08-22 23:25:23
# ====================================================================================

#####################################
### File: OPEN-AIR 2\main.py
#####################################
# main.py
#
# This file serves as the main entry point for the application, orchestrating startup checks and GUI launch.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.222400.1

import os
import inspect
import datetime
import sys
import pathlib

# Add the project's root directory to the system path to allow for imports from
# all sub-folders (e.g., 'configuration' and 'display'). This is a robust way to handle imports.
try:
    project_root = str(pathlib.Path(__file__).resolve().parent)
    if project_root not in sys.path:
        sys.path.append(project_root)
except Exception as e:
    # Fallback in case of an issue with pathlib
    print(f"Error adding project root to sys.path: {e}")

# This block ensures the console can handle UTF-8 characters, preventing encoding errors.
if os.name == 'nt':
    try:
        sys.stdout.reconfigure(encoding='utf-8')
        sys.stderr.reconfigure(encoding='utf-8')
    except AttributeError:
        # Fallback for older Python versions that don't have reconfigure
        pass

# Import core application modules
from configuration.logging import console_log, debug_log
from display.gui_display import Application


# --- Global Scope Variables ---
CURRENT_DATE = datetime.datetime.now().strftime("%Y%m%d")
CURRENT_TIME = datetime.datetime.now().strftime("%H%M%S")
# Note: For hashing, any leading zero in the hour is dropped (e.g., 083015 becomes 83015).
CURRENT_TIME_HASH = int(datetime.datetime.now().strftime("%H%M%S"))
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
current_file = f"{os.path.basename(__file__)}"


def action_check_dependancies():
    # Checks for required system and library dependencies.
    current_function_name = inspect.currentframe().f_code.co_name
    debug_log(
        message=f"🖥️🟢 Ah, good, we're entering '{current_function_name}'! Let's examine the raw materials, shall we?",
        file=current_file,
        version=current_version,
        function=current_function_name,
        console_print_func=console_log
    )

    try:
        # --- Function logic goes here ---
        # Placeholder for dependency checking logic
        console_log("✅ A most glorious success! Dependencies are in order.")
        return True

    except Exception as e:
        console_log(f"❌ Error in {current_function_name}: {e}")
        debug_log(
            message=f"🖥️🔴 Heavens to Betsy! We've hit a snag in the dependencies! The error be: {e}",
            file=current_file,
            version=current_version,
            function=current_function_name,
            console_print_func=console_log
        )
        return False

def action_check_configuration():
    # Validates the application's configuration files.
    current_function_name = inspect.currentframe().f_code.co_name
    debug_log(
        message=f"🖥️🟢 Ahem, commencing the configuration validation experiment in '{current_function_name}'.",
        file=current_file,
        version=current_version,
        function=current_function_name,
        console_print_func=console_log
    )

    try:
        # --- Function logic goes here ---
        # Placeholder for configuration validation
        console_log("✅ Excellent! The configuration is quite, quite brilliant.")
        return True

    except Exception as e:
        console_log(f"❌ Error in {current_function_name}: {e}")
        debug_log(
            message=f"🖥️🔴 By Jove! The configuration is in shambles! The error be: {e}",
            file=current_file,
            version=current_version,
            function=current_function_name,
            console_print_func=console_log
        )
        return False

def action_open_display():
    # Initializes and opens the main graphical user interface.
    current_function_name = inspect.currentframe().f_code.co_name
    debug_log(
        message=f"🖥️🟢 The final step! Activating the main display in '{current_function_name}'!",
        file=current_file,
        version=current_version,
        function=current_function_name,
        console_print_func=console_log
    )

    try:
        # --- Function logic goes here ---
        app = Application()
        app.mainloop()
        console_log("✅ The grand spectacle begins! GUI is now open.")
        return True

    except Exception as e:
        console_log(f"❌ Error in {current_function_name}: {e}")
        debug_log(
            message=f"🖥️🔴 Blast and barnacles! The display has failed to materialize! The error be: {e}",
            file=current_file,
            version=current_version,
            function=current_function_name,
            console_print_func=console_log
        )
        return False

def main():
    """The main execution function for the application."""
    console_log(f"🚀 Launch sequence initiated for version {current_version}.")

    if action_check_dependancies():
        if action_check_configuration():
            action_open_display()
        else:
            console_log("❌ Halting startup due to configuration errors.")
    else:
        console_log("❌ Halting startup due to missing dependencies.")


if __name__ == "__main__":
    main()

#####################################
### File: OPEN-AIR 2\configuration\logging.py
#####################################
# configuration/logging.py
#
# A simple utility file to provide standardized debugging functions for the application.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.215200.1

import os
import inspect
import datetime

# --- Global Scope Variables ---
# ⏰ As requested, the version is now hardcoded to the time this file was generated.
# The version strings and numbers below are static and will not change at runtime.
current_version = "20250822.215200.1"
# The hash calculation drops the leading zero from the hour, but 21 has no leading zero.
current_version_hash = (20250822 * 215200 * 1)
current_file = f"{os.path.basename(__file__)}"

# --- Logging Toggles ---
LOG_TO_TERMINAL = True
LOG_TO_FILE = True
FILE_LOG_PATH = "debug.log"


def console_log(message: str):
    """
    Prints a message to the console if the toggle is enabled.
    """
    current_function_name = inspect.currentframe().f_code.co_name

    try:
        if LOG_TO_TERMINAL:
            print(message)

    except Exception as e:
        if LOG_TO_TERMINAL:
            print(f"❌ Error in {current_function_name}: {e}")

def debug_log(message: str, file: str, version: str, function: str, console_print_func):
    """
    Prints a detailed debug message with a 'mad scientist' personality,
    directing output based on the global toggles.
    """
    current_function_name = inspect.currentframe().f_code.co_name
    
    try:
        # Re-formatting the message to better match the 'mad scientist' persona
        log_message = f"💡📝{message} | {file} | {version} Function: {function}"

        # --- Function logic goes here ---
        if LOG_TO_TERMINAL:
            console_print_func(log_message)

        if LOG_TO_FILE:
            # We explicitly open the log file with UTF-8 encoding to support emojis
            with open(FILE_LOG_PATH, "a", encoding="utf-8") as log_file:
                log_file.write(log_message + "\n")

    except Exception as e:
        if LOG_TO_TERMINAL:
            console_print_func(f"❌ Error in {current_function_name}: {e}")


#####################################
### File: OPEN-AIR 2\display\gui_display.py
#####################################
# display/gui_display.py
#
# A script that dynamically builds the application's Tkinter GUI based on the
# predefined directory structure. It acts as the "orchestrator," recursively
# traversing a folder hierarchy to construct the user interface, now with
# support for "tear-off" tabs that can become their own windows.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.230500.2

# 📚 Python's standard library modules are our trusty sidekicks!
# os: Provides a way to interact with the operating system, like getting file names.
import os
# inspect: Allows us to "look inside" live objects, which is crucial for dynamic introspection.
import inspect
# datetime: Handles dates and times, used here for our versioning system.
import datetime
# tkinter: The foundational GUI toolkit for Python.
import tkinter as tk
# ttk: The "themed Tkinter" module, providing a more modern, stylable set of widgets.
from tkinter import ttk
# importlib.util: A powerful module for dynamic, programmatic importing of Python files.
import importlib.util
# sys: Provides access to system-specific parameters and functions, including the module search path.
import sys
# pathlib: A modern, object-oriented way to handle filesystem paths, making our code cleaner and more robust.
import pathlib

# --- Module Imports ---
# We no longer need to add the parent directory to the path as this is handled in main.py
from display.styling.style import THEMES, DEFAULT_THEME
from configuration.logging import debug_log, console_log
from utils.mqtt_controller_util import MqttControllerUtility


# --- Global Scope Variables ---
# ⏰ As requested, the version is now hardcoded to the time this file was generated.
# The version strings and numbers below are static and will not change at runtime.
# This represents the date (YYYYMMDD) of file creation.
CURRENT_DATE = 20250822
# This represents the time (HHMMSS) of file creation.
CURRENT_TIME = 230500
# This is a numeric hash of the time, useful for unique IDs.
CURRENT_TIME_HASH = 230500
# Our project's current revision number, which is manually incremented.
REVISION_NUMBER = 2
# Assembling the full version string as per the protocol (W.X.Y).
current_version = "20250822.230500.2"
# Creating a unique integer hash for the current version for internal tracking.
current_version_hash = (CURRENT_DATE * CURRENT_TIME_HASH * REVISION_NUMBER)
# Getting the name of the current file to use in our logs, ensuring it's always accurate.
current_file = f"{os.path.basename(__file__)}"


class Application(tk.Tk):
    """
    The main application class that orchestrates the GUI build process.
    
    This class inherits from `tk.Tk`, making it the root of our application's GUI.
    It's responsible for setting up the main window and kicking off the dynamic
    GUI construction based on the folder structure. It now manages the state
    of detached tabs.
    """
    def __init__(self):
        """
        The constructor for our main application.
        
        It sets up the main window, applies styling, and starts the recursive
        process of building the GUI. It's the first function called upon app launch.
        """
        # We grab the name of the current function for our debug logs.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # 🚀 A celebratory log message to mark the start of our journey!
        debug_log(
            message="🖥️ 🟢 The grand orchestrator is waking up! Let's get this GUI built!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        # --- NEW: State management dictionaries for tear-off tabs ---
        # We need a way to track which frames belong to which notebooks.
        self._notebooks = {}
        self._frames_by_path = {}
        self._detached_windows = {}
        # We'll store the name of the last selected tab for logging purposes.
        self.last_selected_tab_name = None

        try:
            # We must first call the parent class's constructor to initialize the Tkinter window.
            super().__init__()
            # Setting the title of our application window, which appears in the title bar.
            self.title("OPEN-AIR 2")
            # Defining the initial size of the window in pixels.
            self.geometry("1000x700")

            # --- NEW: Apply the selected theme ---
            # We call a helper method to apply our chosen theme and store the color palette.
            self.theme_colors = self._apply_styles(theme_name=DEFAULT_THEME)

            # --- NEW: Initialize a single MQTT utility instance here (Orchestration Layer) ---
            self.mqtt_util = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
            self.mqtt_util.connect_mqtt()

            # 🏗️ Let the dynamic building begin! We call our recursive builder function,
            # starting from the directory where this script resides.
            self._build_from_directory(path=pathlib.Path(__file__).parent, parent_widget=self)
            
            # 🎉 A final cheer for a job well done!
            console_log("✅ Celebration of success! The application's core has been built.")

        except Exception as e:
            # 🆘 Oh no, an error! We catch it here to prevent the app from crashing.
            console_log(f"❌ Error in {current_function_name}: {e}")
            # We log the detailed error message for easier debugging.
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the entire application using ttk.Style.
        
        This method configures the look and feel of various `ttk` widgets based on
        the color and style information loaded from our `style` module.
        
        Args:
            theme_name (str): The name of the theme to apply.
            
        Returns:
            dict: The dictionary of colors from the applied theme.
        """
        # We grab the colors from our theme dictionary, defaulting to 'dark' if the theme isn't found.
        colors = THEMES.get(theme_name, THEMES["dark"])
        
        style = ttk.Style(self)
        style.theme_use("clam")

        # --- Configure widget styles ---
        # We configure the default style for all widgets ('.').
        # UPDATED: We use values from our theme for padding and borderwidth, making our styles consistent.
        style.configure('.',
                        background=colors["bg"],
                        foreground=colors["fg"],
                        font=('Helvetica', 10),
                        padding=colors["padding"],
                        borderwidth=colors["border_width"])

        # Specific configurations for `TFrame` widgets.
        style.configure('TFrame',
                        background=colors["bg"])

        # Specific configurations for `TNotebook` widgets (the container for our tabs).
        style.configure('TNotebook',
                        background=colors["primary"],
                        borderwidth=0)
        
        # This is a 'map' configuration, which defines how a widget's style changes
        # based on its state (e.g., 'selected' or not).
        style.map('TNotebook.Tab',
                  background=[('selected', colors["accent"]), ('!selected', colors["secondary"])],
                  foreground=[('selected', colors["text"]), ('!selected', colors["fg"])])

        # UPDATED: Applying padding from the theme to notebook tabs.
        # We calculate the tab padding based on our base padding value from the theme.
        tab_padding = [colors["padding"] * 10, colors["padding"] * 5]
        style.configure('TNotebook.Tab',
                        padding=tab_padding,
                        font=('Helvetica', 11, 'bold'),
                        borderwidth=0)

        # UPDATED: Applying padding and border_width from the theme to buttons.
        # We make the buttons' padding and border more prominent.
        style.configure('TButton',
                        background=colors["accent"],
                        foreground=colors["text"],
                        padding=colors["padding"] * 5,
                        relief=colors["relief"],
                        borderwidth=colors["border_width"] * 2)
        
        style.map('TButton',
                  background=[('active', colors["secondary"])])

        # --- Configure the main window background ---
        # We apply the main background color to the root window itself.
        self.configure(background=colors["bg"])
        
        # We return the color dictionary so other methods can access the theme's colors.
        return colors


    def _build_from_directory(self, path: pathlib.Path, parent_widget):
        """
        Recursively builds the GUI based on folder structure, supporting percentage-based layouts.
        
        This is the heart of the dynamic builder. It inspects a directory and decides
        what kind of Tkinter widget to create based on the folder naming convention.
        
        Args:
            path (pathlib.Path): The path to the current directory being processed.
            parent_widget: The Tkinter widget that will be the parent for new widgets.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        try:
            # We first get all the subdirectories and sort them for a consistent build order.
            sub_dirs = sorted([d for d in path.iterdir() if d.is_dir()])
            
            # We identify directories that define a layout (e.g., 'left_50', 'top_30').
            layout_dirs = [d for d in sub_dirs if d.name.split('_')[0] in ['left', 'right', 'top', 'bottom']]
            
            # If we find layout directories, we process them first. This is a top-down approach.
            if layout_dirs:
                # We check if the layout is horizontal or vertical.
                is_horizontal = any(d.name.startswith('left_') or d.name.startswith('right_') for d in layout_dirs)
                is_vertical = any(d.name.startswith('top_') or d.name.startswith('bottom_') for d in layout_dirs)

                # We log an error if a developer tries to mix horizontal and vertical layouts.
                if is_horizontal and is_vertical:
                    console_log(f"❌ Layout Error: Cannot mix horizontal and vertical layouts in '{path}'.")
                    return

                # We define a strict sort order to ensure 'left' is before 'right', 'top' before 'bottom', etc.
                sort_order = ['left', 'top', 'right', 'bottom']
                # We sort the layout directories according to our defined order.
                sorted_layout_dirs = sorted(layout_dirs, key=lambda d: sort_order.index(d.name.split('_')[0]))
                
                # --- Horizontal Layout Processing ---
                if is_horizontal:
                    # We keep track of the current horizontal position (relx).
                    current_relx = 0.0
                    for sub_dir in sorted_layout_dirs:
                        # We only process 'left' and 'right' directories in this block.
                        if sub_dir.name.split('_')[0] not in ['left', 'right']: continue
                        try:
                            # We parse the percentage from the folder name (e.g., 'left_50' gives us 50).
                            percentage = int(sub_dir.name.split('_')[1])
                            # We convert the percentage to a relative width.
                            rel_width = percentage / 100.0
                            # We create a new `ttk.Frame`, which is stylable.
                            # UPDATED: We use the theme's border and relief settings.
                            new_frame = ttk.Frame(parent_widget, borderwidth=self.theme_colors["border_width"], relief=self.theme_colors["relief"])
                            # We use `.place()` to position the frame with relative coordinates and size.
                            new_frame.place(relx=current_relx, rely=0, relwidth=rel_width, relheight=1.0)
                            # 🔄 We recursively call this function to build the contents of the new frame.
                            self._build_from_directory(path=sub_dir, parent_widget=new_frame)
                            # We update the horizontal position for the next frame.
                            current_relx += rel_width
                        except (IndexError, ValueError):
                            # A helpful warning if the folder name is not formatted correctly.
                            console_log(f"⚠️ Warning: Could not parse percentage from folder name '{sub_dir.name}'.")
                
                # --- Vertical Layout Processing ---
                elif is_vertical:
                    # We keep track of the current vertical position (rely).
                    current_rely = 0.0
                    for sub_dir in sorted_layout_dirs:
                        # We only process 'top' and 'bottom' directories in this block.
                        if sub_dir.name.split('_')[0] not in ['top', 'bottom']: continue
                        try:
                            # We parse the percentage from the folder name.
                            percentage = int(sub_dir.name.split('_')[1])
                            # We convert the percentage to a relative height.
                            rel_height = percentage / 100.0
                            # We create a new `ttk.Frame`.
                            # UPDATED: We use the theme's border and relief settings.
                            new_frame = ttk.Frame(parent_widget, borderwidth=self.theme_colors["border_width"], relief=self.theme_colors["relief"])
                            # We use `.place()` to position the frame with relative coordinates and size.
                            new_frame.place(relx=0, rely=current_rely, relwidth=1.0, relheight=rel_height)
                            # 🔄 We recursively call this function to build the contents of the new frame.
                            self._build_from_directory(path=sub_dir, parent_widget=new_frame)
                            # We update the vertical position for the next frame.
                            current_rely += rel_height
                        except (IndexError, ValueError):
                            # A helpful warning if the folder name is not formatted correctly.
                            console_log(f"⚠️ Warning: Could not parse percentage from folder name '{sub_dir.name}'.")
                # If we've processed a layout, we stop here.
                return

            # We check for directories that are meant to be a tab container.
            is_tab_container = any(d.name.startswith("tab_") or d.name.startswith("sub_tab_") for d in sub_dirs)
            if is_tab_container:
                # If it's a tab container, we create a `ttk.Notebook` widget.
                notebook = ttk.Notebook(parent_widget)
                # We use `.pack()` to make the notebook fill the entire parent widget.
                notebook.pack(fill=tk.BOTH, expand=True)
                
                # --- NEW: We register this notebook for tear-off functionality.
                notebook.bind('<Control-Button-1>', self._tear_off_tab)
                # 🛠️ We bind a new event to handle tab change logging.
                notebook.bind('<<NotebookTabChanged>>', self._on_tab_change)
                
                tab_dirs = [d for d in sub_dirs if d.name.startswith("tab_") or d.name.startswith("sub_tab_")]
                for tab_dir in tab_dirs:
                    # We create a new frame for each tab's content.
                    tab_frame = ttk.Frame(notebook)
                    
                    # --- NEW: We store a reference to this frame.
                    self._frames_by_path[tab_dir] = tab_frame
                    
                    # We parse the folder name to create a user-friendly display name for the tab.
                    # e.g., 'tab_1_main_page' becomes 'Main Page'.
                    parts = tab_dir.name.split('_')
                    start_index = next((i for i, part in enumerate(parts) if part.isdigit()), -1)
                    display_name = " ".join(parts[start_index + 1:]).title() if start_index != -1 else tab_dir.name
                    # We add the new frame as a tab to the notebook.
                    notebook.add(tab_frame, text=display_name)
                    # 🔄 We recursively build the contents of this new tab.
                    self._build_from_directory(path=tab_dir, parent_widget=tab_frame)
                # If we've processed tabs, we stop here.
                return

            # If no layout or tab directories were found, we look for child components.
            for sub_dir in sub_dirs:
                # We identify directories that contain a child component (e.g., 'child_1_button_panel').
                if sub_dir.name.startswith("child_"):
                    self._build_child_container(path=sub_dir, parent_widget=parent_widget)

            # We also look for direct Python files that define GUI components (e.g., 'gui_1_button_panel.py').
            py_files = [f for f in path.iterdir() if f.is_file() and f.name.startswith("gui_") and f.suffix == '.py']
            for py_file in py_files:
                self._build_child_container(path=py_file, parent_widget=parent_widget)

        except Exception as e:
            # Another safety net for errors during the recursive build process.
            console_log(f"❌ Error in {current_function_name} for path {path}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _build_child_container(self, path: pathlib.Path, parent_widget):
        """
        Dynamically imports and instantiates a GUI component from a Python file.
        
        This method is responsible for finding a Python file that defines a GUI component,
        importing it into memory, and then creating an instance of the component to
        add to the application's GUI hierarchy.
        
        Args:
            path (pathlib.Path): The path to the directory or file containing the component.
            parent_widget: The Tkinter widget that will be the parent for the new component.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        try:
            # We determine if the path is a directory or a direct file.
            if path.is_dir():
                # If it's a directory, we search for the 'gui_*.py' file inside it.
                gui_file = next(f for f in path.iterdir() if f.is_file() and f.name.startswith("gui_") and f.suffix == '.py')
            else:
                # If it's a file, we use the path directly.
                gui_file = path

            # 🪄 This is the magical part where we dynamically import the module.
            # We get the name of the module from the file's stem (e.g., 'gui_1_button_panel').
            module_name = gui_file.stem
            # We create a 'spec' which tells Python how to load our module.
            spec = importlib.util.spec_from_file_location(module_name, gui_file)
            # We create the module object from the spec.
            module = importlib.util.module_from_spec(spec)
            # We add our new module to the system's modules dictionary to make it accessible.
            sys.modules[module_name] = module
            # We execute the module, which runs its code and defines its functions and classes.
            spec.loader.exec_module(module)

            # --- 🎯 REFACTORED: The "hardcoded part" you wanted to change! ---
            # We now iterate through all members (classes, functions, etc.) of the imported module.
            for name, obj in inspect.getmembers(module):
                # First, we check if the member is a class.
                if inspect.isclass(obj):
                    # We check if this class is a subclass of `ttk.Frame`.
                    # This is much more flexible than hardcoding a specific class name like "GUIFrame"!
                    if issubclass(obj, ttk.Frame):
                        # If we find a matching class, we instantiate it with the `parent_widget`.
                        # We pass the shared mqtt_util instance here!
                        frame_instance = obj(parent_widget, mqtt_util=self.mqtt_util)
                        # We pack the new frame to make it visible and fill its parent.
                        frame_instance.pack(fill=tk.BOTH, expand=True)
                        # We've found our class and built the frame, so we can break the loop and return.
                        return

                # We also check for functions that build the GUI.
                # This provides backward compatibility with the old naming convention.
                elif inspect.isfunction(obj):
                    # We check if the function's name matches our known component-building function.
                    if name == "create_yo_button_frame":
                        obj(parent_widget)
                        return # We've found and run the function, so we're done here.
            # 🚨 If we get here, it means we couldn't find a valid class or function in the imported module.
            raise AttributeError(f"Module '{module_name}' needs a class that inherits from 'ttk.Frame' or a 'create_yo_button_frame' function.")

        except Exception as e:
            # A final safety net for any errors during the import or execution of a child component.
            console_log(f"❌ Error importing or executing module at {path}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _tear_off_tab(self, event):
        """
        Tears a tab off of its Notebook and places it into a new Toplevel window.
        
        This method is triggered by a <Control-Button-1> event on a tab.
        It moves the selected tab's frame from the Notebook to its own new window.
        
        Args:
            event: The Tkinter event object.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        try:
            # We determine which notebook widget was clicked.
            notebook = event.widget
            # We use the event coordinates to find the tab that was clicked.
            tab_id = notebook.identify(event.x, event.y)
            if not tab_id:
                return # No tab was clicked, so we do nothing.
            # 🎯 FIX: We need to use the `id` of the widget, not its text label.
            # This is the unique internal identifier for the tab's content frame.
            frame_id = notebook.tab(tab_id, "id")
            
            # We get the title of the tab to use for the new window.
            tab_title = notebook.tab(tab_id, "text")
            
            # If the frame is already detached, we do nothing.
            if frame_id in self._detached_windows:
                console_log(f"⚠️ Tab '{tab_title}' is already in a detached window.")
                return

            # We create a new top-level window.
            new_window = tk.Toplevel(self)
            new_window.title(tab_title)
            
            # We move the frame from the notebook to the new window.
            notebook.hide(tab_id)
            frame_id.pack(in_=new_window, fill=tk.BOTH, expand=True)
            
            # We store a reference to the detached window.
            self._detached_windows[frame_id] = {
                "window": new_window,
                "notebook": notebook,
                "tab_title": tab_title
            }
            
            # We bind the new window's close button to our re-attachment function.
            new_window.protocol("WM_DELETE_WINDOW", lambda: self._re_attach_tab(frame_id))

            console_log(f"✅ Celebration of success! Tab '{tab_title}' has been detached and is now a new window.")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _re_attach_tab(self, frame):
        """
        Re-attaches a detached frame back to its original Notebook.
        
        This method is called when the user closes the detached Toplevel window.
        It moves the frame back to its original notebook and destroys the window.
        
        Args:
            frame: The Tkinter frame object that was detached.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        try:
            if frame not in self._detached_windows:
                return # Frame is not detached, so we do nothing.
            # We retrieve the notebook and title from our state dictionary.
            state = self._detached_windows[frame]
            notebook = state["notebook"]
            tab_title = state["tab_title"]
            window = state["window"]
            
            # We re-parent the frame back to its original notebook.
            frame.pack_forget()
            frame.pack(in_=notebook, fill=tk.BOTH, expand=True)
            
            # We add the tab back to the notebook at the same position.
            notebook.add(frame, text=tab_title)
            
            # We clean up our state dictionary and destroy the Toplevel window.
            del self._detached_windows[frame]
            window.destroy()
            
            console_log(f"✅ Celebration of success! Tab '{tab_title}' has been re-attached.")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            
    def _on_tab_change(self, event):
        """
        Logs a debug message when a tab is selected or deselected.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🔍🔵 Entering '{current_function_name}' to log a tab change.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            notebook = event.widget
            newly_selected_tab_id = notebook.select()
            newly_selected_tab_name = notebook.tab(newly_selected_tab_id, "text")

            if self.last_selected_tab_name:
                debug_log(
                    message=f"📘🔴 Tab '{self.last_selected_tab_name}' deselected!",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

            debug_log(
                message=f"📘🟢 Tab '{newly_selected_tab_name}' selected!",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            
            self.last_selected_tab_name = newly_selected_tab_name
            
            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


# 🏃 This is the standard entry point for a Python script.
# The code inside this block only runs when the script is executed directly.
if __name__ == "__main__":
    # A friendly message to signal the start of the application.
    console_log("--- Initializing the Dynamic GUI Builder ---")
    
    # We create an instance of our main Application class.
    app = Application()
    # This call starts the Tkinter event loop, which handles all user interactions and keeps the window open.
    app.mainloop()
    # Once the mainloop exits (e.g., the user closes the window), this message is printed.
    console_log("--- Application closed. ---")

#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_1_instrument\sub_tab_1_connection\gui_connection.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version accepts a shared MQTT connection and message handling to prevent log spam.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.233000.13

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from configuration.logging import debug_log, console_log
from utils.mqtt_controller_util import MqttControllerUtility

# --- Global Scope Variables ---
CURRENT_DATE = 20250822
CURRENT_TIME = 233000
CURRENT_TIME_HASH = 233000
REVISION_NUMBER = 13
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class is now designed as a self-contained "island" that manages its own MQTT state.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # Create a label for the frame
            frame_label = tk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = tk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame)
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = tk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)
            
            # We now register our callback with the central utility instead of overwriting the client's callback.
            # We will subscribe to all topics within the immediate parent directory.
            parent_folder = os.path.dirname(self.current_file)
            subscription_topic = f"{parent_folder}/#"
            self.mqtt_util.add_subscriber(topic_filter=subscription_topic, callback_func=self._on_mqtt_message)


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            message_content = json.loads(payload)["value"]
            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


    def _on_mqtt_message_direct(self, client, userdata, msg):
        # A separate handler for the direct client.
        self._on_mqtt_message(topic=msg.topic, payload=msg.payload.decode())


    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # The standalone entry point is now simplified to just create the component.
    app_frame = BaseGUIFrame(parent=root)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_1_instrument\sub_tab_2_settings\gui_settings.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version accepts a shared MQTT connection and message handling to prevent log spam.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.233000.13

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from configuration.logging import debug_log, console_log
from utils.mqtt_controller_util import MqttControllerUtility

# --- Global Scope Variables ---
CURRENT_DATE = 20250822
CURRENT_TIME = 233000
CURRENT_TIME_HASH = 233000
REVISION_NUMBER = 13
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class is now designed as a self-contained "island" that manages its own MQTT state.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # Create a label for the frame
            frame_label = tk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = tk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame)
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = tk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)
            
            # We now register our callback with the central utility instead of overwriting the client's callback.
            # We will subscribe to all topics within the immediate parent directory.
            parent_folder = os.path.dirname(self.current_file)
            subscription_topic = f"{parent_folder}/#"
            self.mqtt_util.add_subscriber(topic_filter=subscription_topic, callback_func=self._on_mqtt_message)


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            message_content = json.loads(payload)["value"]
            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


    def _on_mqtt_message_direct(self, client, userdata, msg):
        # A separate handler for the direct client.
        self._on_mqtt_message(topic=msg.topic, payload=msg.payload.decode())


    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # The standalone entry point is now simplified to just create the component.
    app_frame = BaseGUIFrame(parent=root)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_1_instrument\sub_tab_3_translator\gui_translator.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version accepts a shared MQTT connection and message handling to prevent log spam.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.233000.13

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from configuration.logging import debug_log, console_log
from utils.mqtt_controller_util import MqttControllerUtility

# --- Global Scope Variables ---
CURRENT_DATE = 20250822
CURRENT_TIME = 233000
CURRENT_TIME_HASH = 233000
REVISION_NUMBER = 13
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class is now designed as a self-contained "island" that manages its own MQTT state.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # Create a label for the frame
            frame_label = tk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = tk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame)
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = tk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)
            
            # We now register our callback with the central utility instead of overwriting the client's callback.
            # We will subscribe to all topics within the immediate parent directory.
            parent_folder = os.path.dirname(self.current_file)
            subscription_topic = f"{parent_folder}/#"
            self.mqtt_util.add_subscriber(topic_filter=subscription_topic, callback_func=self._on_mqtt_message)


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            message_content = json.loads(payload)["value"]
            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


    def _on_mqtt_message_direct(self, client, userdata, msg):
        # A separate handler for the direct client.
        self._on_mqtt_message(topic=msg.topic, payload=msg.payload.decode())


    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # The standalone entry point is now simplified to just create the component.
    app_frame = BaseGUIFrame(parent=root)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_2_markers\sub_tab_1_showtime\gui_child_1_showtime.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version accepts a shared MQTT connection and message handling to prevent log spam.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.232500.12

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from configuration.logging import debug_log, console_log
from utils.mqtt_controller_util import MqttControllerUtility

# --- Global Scope Variables ---
CURRENT_DATE = 20250822
CURRENT_TIME = 232500
CURRENT_TIME_HASH = 232500
REVISION_NUMBER = 12
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class is now designed as a self-contained "island" that manages its own MQTT state.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # Create a label for the frame
            frame_label = tk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = tk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame)
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = tk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)

            # We now register our callback with the central utility instead of overwriting the client's callback.
            self.mqtt_util.add_subscriber(topic_filter=self.current_file + "/#", callback_func=self._on_mqtt_message)


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            message_content = json.loads(payload)["value"]
            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message_direct(self, client, userdata, msg):
        # A separate handler for the direct client.
        self._on_mqtt_message(topic=msg.topic, payload=msg.payload.decode())


    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # The standalone entry point is now simplified to just create the component.
    app_frame = BaseGUIFrame(parent=root)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_2_markers\sub_tab_2_editor\gui_child_2_editor.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version accepts a shared MQTT connection and message handling to prevent log spam.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.232500.12

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from configuration.logging import debug_log, console_log
from utils.mqtt_controller_util import MqttControllerUtility

# --- Global Scope Variables ---
CURRENT_DATE = 20250822
CURRENT_TIME = 232500
CURRENT_TIME_HASH = 232500
REVISION_NUMBER = 12
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class is now designed as a self-contained "island" that manages its own MQTT state.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # Create a label for the frame
            frame_label = tk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = tk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame)
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = tk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)

            # We now register our callback with the central utility instead of overwriting the client's callback.
            self.mqtt_util.add_subscriber(topic_filter=self.current_file + "/#", callback_func=self._on_mqtt_message)


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            message_content = json.loads(payload)["value"]
            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message_direct(self, client, userdata, msg):
        # A separate handler for the direct client.
        self._on_mqtt_message(topic=msg.topic, payload=msg.payload.decode())


    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # The standalone entry point is now simplified to just create the component.
    app_frame = BaseGUIFrame(parent=root)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_3_presets\sub_tab_1_pusher\gui_child_1_pusher.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version accepts a shared MQTT connection and message handling to prevent log spam.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.232500.12

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from configuration.logging import debug_log, console_log
from utils.mqtt_controller_util import MqttControllerUtility

# --- Global Scope Variables ---
CURRENT_DATE = 20250822
CURRENT_TIME = 232500
CURRENT_TIME_HASH = 232500
REVISION_NUMBER = 12
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class is now designed as a self-contained "island" that manages its own MQTT state.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # Create a label for the frame
            frame_label = tk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = tk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame)
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = tk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)

            # We now register our callback with the central utility instead of overwriting the client's callback.
            self.mqtt_util.add_subscriber(topic_filter=self.current_file + "/#", callback_func=self._on_mqtt_message)


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            message_content = json.loads(payload)["value"]
            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message_direct(self, client, userdata, msg):
        # A separate handler for the direct client.
        self._on_mqtt_message(topic=msg.topic, payload=msg.payload.decode())


    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # The standalone entry point is now simplified to just create the component.
    app_frame = BaseGUIFrame(parent=root)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_3_presets\sub_tab_2_editor\gui_child_2_editor.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version accepts a shared MQTT connection and message handling to prevent log spam.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.232500.12

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from configuration.logging import debug_log, console_log
from utils.mqtt_controller_util import MqttControllerUtility

# --- Global Scope Variables ---
CURRENT_DATE = 20250822
CURRENT_TIME = 232500
CURRENT_TIME_HASH = 232500
REVISION_NUMBER = 12
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class is now designed as a self-contained "island" that manages its own MQTT state.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # Create a label for the frame
            frame_label = tk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = tk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame)
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = tk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)

            # We now register our callback with the central utility instead of overwriting the client's callback.
            self.mqtt_util.add_subscriber(topic_filter=self.current_file + "/#", callback_func=self._on_mqtt_message)


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            message_content = json.loads(payload)["value"]
            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message_direct(self, client, userdata, msg):
        # A separate handler for the direct client.
        self._on_mqtt_message(topic=msg.topic, payload=msg.payload.decode())


    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # The standalone entry point is now simplified to just create the component.
    app_frame = BaseGUIFrame(parent=root)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_3_presets\sub_tab_3_collector\gui_child_3_collector.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components, re-written to work with the centralized orchestrator.
# This version accepts a shared MQTT connection and message handling to prevent log spam.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.232500.12

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys
import json
import paho.mqtt.client as mqtt

# --- Module Imports ---
from configuration.logging import debug_log, console_log
from utils.mqtt_controller_util import MqttControllerUtility

# --- Global Scope Variables ---
CURRENT_DATE = 20250822
CURRENT_TIME = 232500
CURRENT_TIME_HASH = 232500
REVISION_NUMBER = 12
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class is now designed as a self-contained "island" that manages its own MQTT state.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # Create a label for the frame
            frame_label = tk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = tk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame)
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = tk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)

            # We now register our callback with the central utility instead of overwriting the client's callback.
            self.mqtt_util.add_subscriber(topic_filter=self.current_file + "/#", callback_func=self._on_mqtt_message)


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, topic, payload):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            message_content = json.loads(payload)["value"]
            self.subscriptions_table.insert('', 'end', values=(topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message_direct(self, client, userdata, msg):
        # A separate handler for the direct client.
        self._on_mqtt_message(topic=msg.topic, payload=msg.payload.decode())


    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # The standalone entry point is now simplified to just create the component.
    app_frame = BaseGUIFrame(parent=root)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_4_intermod\sub_tab_1_calculator\gui_child_1_calculator.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components to promote code reuse and adhere to the GUI layer principles.
# This revision fixes a bug and adds MQTT messaging functionality to demonstrate communication with the utility layer.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.230600.8

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys

# --- Module Imports ---
from configuration.logging import debug_log, console_log
from utils.mqtt_controller_util import MqttControllerUtility

# --- Global Scope Variables ---
CURRENT_DATE = 20250822
CURRENT_TIME = 230600
CURRENT_TIME_HASH = 230600
REVISION_NUMBER = 8
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class adheres to the "GUI" layer principles of the protocol.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # Create a label for the frame
            frame_label = tk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = tk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame)
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = tk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)
            
            # We must assign the on_message callback to our custom handler
            self.mqtt_util.mqtt_client.on_message = self._on_mqtt_message

            # We subscribe to the wildcard topic from the entry box
            self.mqtt_util.mqtt_client.subscribe(self.current_file + "/#")


            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, client, userdata, msg):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{msg.topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            self.mqtt_topic_var.set(f"Last Message: {msg.topic} -> {msg.payload.decode()}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()

#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_4_intermod\sub_tab_2_future\gui_1_top.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components to promote code reuse and adhere to the GUI layer principles.
# This revision fixes a bug and adds MQTT messaging functionality to demonstrate communication with the utility layer.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.230600.8

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys

# --- Module Imports ---
from configuration.logging import debug_log, console_log
from utils.mqtt_controller_util import MqttControllerUtility

# --- Global Scope Variables ---
CURRENT_DATE = 20250822
CURRENT_TIME = 230600
CURRENT_TIME_HASH = 230600
REVISION_NUMBER = 8
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class adheres to the "GUI" layer principles of the protocol.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # Create a label for the frame
            frame_label = tk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = tk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame)
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = tk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)
            
            # We must assign the on_message callback to our custom handler
            self.mqtt_util.mqtt_client.on_message = self._on_mqtt_message

            # We subscribe to the wildcard topic from the entry box
            self.mqtt_util.mqtt_client.subscribe(self.current_file + "/#")


            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, client, userdata, msg):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{msg.topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            self.mqtt_topic_var.set(f"Last Message: {msg.topic} -> {msg.payload.decode()}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()

#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_4_intermod\sub_tab_2_future\gui_2_bottom copy.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components to promote code reuse and adhere to the GUI layer principles.
# This revision fixes a bug and adds MQTT messaging functionality to demonstrate communication with the utility layer.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.230600.8

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys

# --- Module Imports ---
from configuration.logging import debug_log, console_log
from utils.mqtt_controller_util import MqttControllerUtility

# --- Global Scope Variables ---
CURRENT_DATE = 20250822
CURRENT_TIME = 230600
CURRENT_TIME_HASH = 230600
REVISION_NUMBER = 8
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class adheres to the "GUI" layer principles of the protocol.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # Create a label for the frame
            frame_label = tk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = tk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame)
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = tk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)
            
            # We must assign the on_message callback to our custom handler
            self.mqtt_util.mqtt_client.on_message = self._on_mqtt_message

            # We subscribe to the wildcard topic from the entry box
            self.mqtt_util.mqtt_client.subscribe(self.current_file + "/#")


            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, client, userdata, msg):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{msg.topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            self.mqtt_topic_var.set(f"Last Message: {msg.topic} -> {msg.payload.decode()}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()

#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_4_intermod\sub_tab_2_future\gui_44_last.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components to promote code reuse and adhere to the GUI layer principles.
# This revision fixes a bug and adds MQTT messaging functionality to demonstrate communication with the utility layer.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.230600.8

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys

# --- Module Imports ---
from configuration.logging import debug_log, console_log
from utils.mqtt_controller_util import MqttControllerUtility

# --- Global Scope Variables ---
CURRENT_DATE = 20250822
CURRENT_TIME = 230600
CURRENT_TIME_HASH = 230600
REVISION_NUMBER = 8
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class adheres to the "GUI" layer principles of the protocol.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # Create a label for the frame
            frame_label = tk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = tk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame)
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = tk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)
            
            # We must assign the on_message callback to our custom handler
            self.mqtt_util.mqtt_client.on_message = self._on_mqtt_message

            # We subscribe to the wildcard topic from the entry box
            self.mqtt_util.mqtt_client.subscribe(self.current_file + "/#")


            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, client, userdata, msg):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{msg.topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            self.mqtt_topic_var.set(f"Last Message: {msg.topic} -> {msg.payload.decode()}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()

#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_5_sweeping\sub_tab_1_single\gui_child_1_single.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components to promote code reuse and adhere to the GUI layer principles.
# This revision fixes a bug and adds MQTT messaging functionality to demonstrate communication with the utility layer.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.230600.8

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys

# --- Module Imports ---
from configuration.logging import debug_log, console_log
from utils.mqtt_controller_util import MqttControllerUtility

# --- Global Scope Variables ---
CURRENT_DATE = 20250822
CURRENT_TIME = 230600
CURRENT_TIME_HASH = 230600
REVISION_NUMBER = 8
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class adheres to the "GUI" layer principles of the protocol.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # Create a label for the frame
            frame_label = tk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = tk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame)
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = tk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)
            
            # We must assign the on_message callback to our custom handler
            self.mqtt_util.mqtt_client.on_message = self._on_mqtt_message

            # We subscribe to the wildcard topic from the entry box
            self.mqtt_util.mqtt_client.subscribe(self.current_file + "/#")


            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, client, userdata, msg):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{msg.topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            self.mqtt_topic_var.set(f"Last Message: {msg.topic} -> {msg.payload.decode()}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()

#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_5_sweeping\sub_tab_2_statistical\gui_child_2_statistical.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components to promote code reuse and adhere to the GUI layer principles.
# This revision fixes a bug and adds MQTT messaging functionality to demonstrate communication with the utility layer.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.230600.8

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys

# --- Module Imports ---
from configuration.logging import debug_log, console_log
from utils.mqtt_controller_util import MqttControllerUtility

# --- Global Scope Variables ---
CURRENT_DATE = 20250822
CURRENT_TIME = 230600
CURRENT_TIME_HASH = 230600
REVISION_NUMBER = 8
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class adheres to the "GUI" layer principles of the protocol.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # Create a label for the frame
            frame_label = tk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = tk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame)
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = tk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)
            
            # We must assign the on_message callback to our custom handler
            self.mqtt_util.mqtt_client.on_message = self._on_mqtt_message

            # We subscribe to the wildcard topic from the entry box
            self.mqtt_util.mqtt_client.subscribe(self.current_file + "/#")


            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, client, userdata, msg):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{msg.topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            self.mqtt_topic_var.set(f"Last Message: {msg.topic} -> {msg.payload.decode()}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()

#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_6_graphing\sub_tab_1_from_file\gui_child1_from_file.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components to promote code reuse and adhere to the GUI layer principles.
# This revision fixes a bug and adds MQTT messaging functionality to demonstrate communication with the utility layer.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.230600.8

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys

# --- Module Imports ---
from configuration.logging import debug_log, console_log
from utils.mqtt_controller_util import MqttControllerUtility

# --- Global Scope Variables ---
CURRENT_DATE = 20250822
CURRENT_TIME = 230600
CURRENT_TIME_HASH = 230600
REVISION_NUMBER = 8
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class adheres to the "GUI" layer principles of the protocol.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # Create a label for the frame
            frame_label = tk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = tk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame)
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = tk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)
            
            # We must assign the on_message callback to our custom handler
            self.mqtt_util.mqtt_client.on_message = self._on_mqtt_message

            # We subscribe to the wildcard topic from the entry box
            self.mqtt_util.mqtt_client.subscribe(self.current_file + "/#")


            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, client, userdata, msg):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{msg.topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            self.mqtt_topic_var.set(f"Last Message: {msg.topic} -> {msg.payload.decode()}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()

#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_7_exepriment\sub_tab_1_mosquitto\gui_7_experiment.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components to promote code reuse and adhere to the GUI layer principles.
# This revision fixes a bug and adds MQTT messaging functionality to demonstrate communication with the utility layer.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.230600.8

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys

# --- Module Imports ---
from configuration.logging import debug_log, console_log
from utils.mqtt_controller_util import MqttControllerUtility

# --- Global Scope Variables ---
CURRENT_DATE = 20250822
CURRENT_TIME = 230600
CURRENT_TIME_HASH = 230600
REVISION_NUMBER = 8
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class adheres to the "GUI" layer principles of the protocol.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # Create a label for the frame
            frame_label = tk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = tk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame)
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = tk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)
            
            # We must assign the on_message callback to our custom handler
            self.mqtt_util.mqtt_client.on_message = self._on_mqtt_message

            # We subscribe to the wildcard topic from the entry box
            self.mqtt_util.mqtt_client.subscribe(self.current_file + "/#")


            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, client, userdata, msg):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{msg.topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            self.mqtt_topic_var.set(f"Last Message: {msg.topic} -> {msg.payload.decode()}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()

#####################################
### File: OPEN-AIR 2\display\right_40\bottom_90\tab_1_scan\gui_tab_1_scan.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components to promote code reuse and adhere to the GUI layer principles.
# This revision fixes a bug and adds MQTT messaging functionality to demonstrate communication with the utility layer.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.230600.8

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys

# --- Module Imports ---
from configuration.logging import debug_log, console_log
from utils.mqtt_controller_util import MqttControllerUtility

# --- Global Scope Variables ---
CURRENT_DATE = 20250822
CURRENT_TIME = 230600
CURRENT_TIME_HASH = 230600
REVISION_NUMBER = 8
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class adheres to the "GUI" layer principles of the protocol.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # Create a label for the frame
            frame_label = tk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = tk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame)
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = tk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)
            
            # We must assign the on_message callback to our custom handler
            self.mqtt_util.mqtt_client.on_message = self._on_mqtt_message

            # We subscribe to the wildcard topic from the entry box
            self.mqtt_util.mqtt_client.subscribe(self.current_file + "/#")


            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, client, userdata, msg):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{msg.topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            self.mqtt_topic_var.set(f"Last Message: {msg.topic} -> {msg.payload.decode()}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()

#####################################
### File: OPEN-AIR 2\display\right_40\bottom_90\tab_2_monitors\gui_tab_2_monitors.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components to promote code reuse and adhere to the GUI layer principles.
# This revision fixes a bug and adds MQTT messaging functionality to demonstrate communication with the utility layer.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.230600.8

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys

# --- Module Imports ---
from configuration.logging import debug_log, console_log
from utils.mqtt_controller_util import MqttControllerUtility

# --- Global Scope Variables ---
CURRENT_DATE = 20250822
CURRENT_TIME = 230600
CURRENT_TIME_HASH = 230600
REVISION_NUMBER = 8
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class adheres to the "GUI" layer principles of the protocol.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # Create a label for the frame
            frame_label = tk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = tk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame)
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = tk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)
            
            # We must assign the on_message callback to our custom handler
            self.mqtt_util.mqtt_client.on_message = self._on_mqtt_message

            # We subscribe to the wildcard topic from the entry box
            self.mqtt_util.mqtt_client.subscribe(self.current_file + "/#")


            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, client, userdata, msg):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{msg.topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            self.mqtt_topic_var.set(f"Last Message: {msg.topic} -> {msg.payload.decode()}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()

#####################################
### File: OPEN-AIR 2\display\right_40\bottom_90\tab_3_debug\gui_tab_3_debug.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components to promote code reuse and adhere to the GUI layer principles.
# This revision fixes a bug and adds MQTT messaging functionality to demonstrate communication with the utility layer.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.230600.8

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys

# --- Module Imports ---
from configuration.logging import debug_log, console_log
from utils.mqtt_controller_util import MqttControllerUtility

# --- Global Scope Variables ---
CURRENT_DATE = 20250822
CURRENT_TIME = 230600
CURRENT_TIME_HASH = 230600
REVISION_NUMBER = 8
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class adheres to the "GUI" layer principles of the protocol.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # Create a label for the frame
            frame_label = tk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = tk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame)
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = tk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)
            
            # We must assign the on_message callback to our custom handler
            self.mqtt_util.mqtt_client.on_message = self._on_mqtt_message

            # We subscribe to the wildcard topic from the entry box
            self.mqtt_util.mqtt_client.subscribe(self.current_file + "/#")


            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, client, userdata, msg):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{msg.topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            self.mqtt_topic_var.set(f"Last Message: {msg.topic} -> {msg.payload.decode()}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()

#####################################
### File: OPEN-AIR 2\display\right_40\bottom_90\tab_4_conductor\gui_child_1_mqtt_conductor.py
#####################################
# tabs/conductor/gui_mqtt_conductor.py
#
# This file defines a GUI component for managing and testing an MQTT broker and client.
# It adheres to the GUI layer principles of the protocol.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250823.220700.8

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk, scrolledtext
# The following import is removed as path manipulation should be centralized in the main application file.
# import sys
# import pathlib

# --- Module Imports ---
# Now that the path is set by the main app, we can confidently import our logging module!
from configuration.logging import debug_log, console_log
from styling.style import THEMES, DEFAULT_THEME
from utils.mqtt_controller_util import MqttControllerUtility

# --- Global Scope Variables ---
current_version = "20250823.220700.8"
# The hash calculation drops the leading zero from the hour, but 21 has no leading zero.
current_version_hash = (20250823 * 220700 * 8)
current_file = f"{os.path.basename(__file__)}"

# --- Constant Variables (No Magic Numbers) ---
# Text for UI elements
PUBLISH_FRAME_TEXT = "Publish Message"
TOPIC_LABEL_TEXT = "Topic:"
SUBTOPIC_LABEL_TEXT = "Subtopic:"
SLIDER_LABEL_TEXT = "Value:"
PUBLISH_BUTTON_TEXT = "Publish"
SUBSCRIPTIONS_FRAME_TEXT = "Live Subscriptions"
SUBSCRIPTIONS_TOPIC_COL_TEXT = "Topic"
SUBSCRIPTIONS_MESSAGE_COL_TEXT = "Message"

class MqttConductorFrame(ttk.Frame):
    """
    A GUI frame for controlling and monitoring a local MQTT broker.
    It adheres to the "GUI" layer principles of your protocol.
    """
    def __init__(self, parent, *args, **kwargs):
        """
        Initializes the MQTT Conductor Frame.

        Args:
            parent: The parent widget for this frame.
        """
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message=f"🐐🟢 Initializing the '{self.__class__.__name__}' GUI frame.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)

            # We must apply styles before creating widgets to avoid errors.
            self.theme_colors = self._apply_styles(theme_name=DEFAULT_THEME)

            self.create_widgets() # This must be called first to create self.log_text

            # Now that log_to_gui and log_to_table are available, we can set our utility functions
            self._print_to_gui_console = self.log_to_gui
            self._log_to_treeview = self.log_to_table
            
            self.mqtt_util = MqttControllerUtility(
                print_to_gui_func=self._print_to_gui_console,
                log_treeview_func=self._log_to_treeview
            )
            
            # The pack call is handled by the parent widget, as per the design of the main app.
            self.pack(pady=10, padx=10, fill=tk.BOTH, expand=True)

            self.mqtt_util.connect_mqtt()

            # Now that everything is set up, log the success.
            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        
        Args:
            theme_name (str): The name of the theme to apply.
        """
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name

        debug_log(
            message=f"🐐🟢 Entering '{current_function_name}' to apply styling.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # --- Function logic goes here ---
            # Correcting the function call to use positional arguments.
            colors = THEMES.get(theme_name, THEMES["dark"])
            style = ttk.Style(self)
            style.theme_use("clam")
            
            style.configure('TFrame', background=colors["bg"])
            style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
            style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])
            style.configure('TButton', background=colors["accent"], foreground=colors["text"])
            style.configure('TEntry', fieldbackground=colors["primary"], foreground=colors["fg"])
            style.configure('ScrolledText', background=colors["primary"], foreground=colors["fg"])
            style.configure('Treeview', background=colors["primary"], foreground=colors["fg"], fieldbackground=colors["bg"])
            style.configure('Treeview.Heading', font=("Arial", 12, "bold"))

            console_log("✅ Celebration of success!")
            return colors
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            return THEMES["dark"]

    def create_widgets(self):
        """
        Creates all the UI widgets for the tab.
        """
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message=f"🐐🟢 Entering '{current_function_name}' to create widgets.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            # Main button frame for broker controls
            button_frame = ttk.Frame(master=self)
            button_frame.pack(pady=10, padx=10, fill=tk.X)
            for i in range(5):
                button_frame.columnconfigure(index=i, weight=1)

            # Broker control buttons
            self.start_btn = ttk.Button(master=button_frame, text="Start Mosquitto", command=self.mqtt_util.start_mosquitto)
            self.start_btn.grid(row=0, column=0, padx=5, sticky="ew")

            self.stop_btn = ttk.Button(master=button_frame, text="Stop Mosquitto", command=self.mqtt_util.stop_mosquitto)
            self.stop_btn.grid(row=0, column=1, padx=5, sticky="ew")

            self.status_btn = ttk.Button(master=button_frame, text="Check Status", command=self.mqtt_util.check_status)
            self.status_btn.grid(row=0, column=2, padx=5, sticky="ew")

            # MQTT client controls
            self.connect_btn = ttk.Button(master=button_frame, text="Connect MQTT", command=self.mqtt_util.connect_mqtt)
            self.connect_btn.grid(row=0, column=3, padx=5, sticky="ew")

            self.topics_btn = ttk.Button(master=button_frame, text="Show Topics", command=self.mqtt_util.show_topics)
            self.topics_btn.grid(row=0, column=4, padx=5, sticky="ew")

            # Publish frame with new elements
            self.pub_frame = ttk.LabelFrame(master=self, text=PUBLISH_FRAME_TEXT)
            self.pub_frame.pack(pady=10, padx=10, fill=tk.X, expand=False)
            self.pub_frame.columnconfigure(index=1, weight=1)
            self.pub_frame.columnconfigure(index=3, weight=1)
            self.pub_frame.columnconfigure(index=5, weight=1)

            self.topic_label = ttk.Label(master=self.pub_frame, text=TOPIC_LABEL_TEXT)
            self.topic_label.grid(row=0, column=0, padx=5, pady=5, sticky="e")
            self.topic_entry = ttk.Entry(master=self.pub_frame)
            self.topic_entry.grid(row=0, column=1, padx=5, pady=5, sticky="ew")

            self.subtopic_label = ttk.Label(master=self.pub_frame, text=SUBTOPIC_LABEL_TEXT)
            self.subtopic_label.grid(row=0, column=2, padx=5, pady=5, sticky="e")
            self.subtopic_var = tk.StringVar(self)
            self.subtopic_dropdown = ttk.Combobox(master=self.pub_frame, textvariable=self.subtopic_var, values=["TEST 1", "TEST 2", "TEST 3"])
            self.subtopic_dropdown.grid(row=0, column=3, padx=5, pady=5, sticky="ew")
            self.subtopic_dropdown.set("TEST 1")

            self.slider_label = ttk.Label(master=self.pub_frame, text=SLIDER_LABEL_TEXT)
            self.slider_label.grid(row=1, column=0, padx=5, pady=5, sticky="e")
            self.slider_var = tk.DoubleVar()
            self.slider = ttk.Scale(master=self.pub_frame, from_=1, to=100, orient=tk.HORIZONTAL, variable=self.slider_var, command=lambda x: self.update_slider_label())
            self.slider.grid(row=1, column=1, columnspan=3, padx=5, pady=5, sticky="ew")
            self.slider_value_label = ttk.Label(master=self.pub_frame, text="50.0")
            self.slider_value_label.grid(row=1, column=4, padx=5, pady=5, sticky="w")
            self.slider.set(50)

            self.pub_btn = ttk.Button(master=self.pub_frame, text=PUBLISH_BUTTON_TEXT, command=lambda: self.mqtt_util.publish_message(
                topic=self.topic_entry.get(),
                subtopic=self.subtopic_var.get(),
                value=self.slider_var.get()
            ))
            self.pub_btn.grid(row=0, column=4, padx=5, sticky="ew")
            self.pub_btn.configure(command=lambda: self.mqtt_util.publish_message(topic=self.topic_entry.get(), subtopic=self.subtopic_var.get(), value=self.slider_var.get()))

            # Live Subscriptions Table
            self.subscriptions_frame = ttk.LabelFrame(master=self, text=SUBSCRIPTIONS_FRAME_TEXT)
            self.subscriptions_frame.pack(pady=10, padx=10, fill=tk.BOTH, expand=True)

            self.subscriptions_table = ttk.Treeview(master=self.subscriptions_frame, columns=(SUBSCRIPTIONS_TOPIC_COL_TEXT, SUBSCRIPTIONS_MESSAGE_COL_TEXT), show="headings")
            self.subscriptions_table.heading(SUBSCRIPTIONS_TOPIC_COL_TEXT, text=SUBSCRIPTIONS_TOPIC_COL_TEXT)
            self.subscriptions_table.heading(SUBSCRIPTIONS_MESSAGE_COL_TEXT, text=SUBSCRIPTIONS_MESSAGE_COL_TEXT)
            self.subscriptions_table.pack(fill=tk.BOTH, expand=True)

            # Log display
            self.log_text = scrolledtext.ScrolledText(master=self, wrap=tk.WORD, width=80, height=10, background=self.theme_colors['primary'], foreground=self.theme_colors['fg'])
            self.log_text.pack(pady=10, padx=10, fill=tk.BOTH, expand=True)

            console_log("✅ Celebration of success!")
            
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_to_gui(self, message):
        """
        Logs a message to the GUI's scrolled text box.
        """
        self.log_text.insert(tk.END, message + "\n")
        self.log_text.see(tk.END)

    def update_slider_label(self):
        """
        Updates the label next to the slider with the current value.
        """
        self.slider_value_label.configure(text=f"{self.slider_var.get():.1f}")
        
    def log_to_table(self, topic, message):
        """
        Logs a message to the Treeview table.
        """
        self.subscriptions_table.insert(parent="", index="end", values=(topic, message))
        self.subscriptions_table.see(self.subscriptions_table.get_children()[-1])


#####################################
### File: OPEN-AIR 2\display\right_40\bottom_90\tab_5_configuration\gui_tab_5_configuration.py
#####################################
# display/base_gui_component.py
#
# A base class for common GUI components to promote code reuse and adhere to the GUI layer principles.
# This revision adds MQTT messaging functionality to demonstrate communication with the utility layer.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.231200.9

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys

# --- Module Imports ---
from configuration.logging import debug_log, console_log
from utils.mqtt_controller_util import MqttControllerUtility

# --- Global Scope Variables ---
CURRENT_DATE = 20250822
CURRENT_TIME = 231200
CURRENT_TIME_HASH = 231200
REVISION_NUMBER = 9
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
# Dynamically get the file path relative to the project root
current_file_path = pathlib.Path(__file__).resolve()
project_root = current_file_path.parent.parent.parent
current_file = str(current_file_path.relative_to(project_root)).replace("\\", "/")


class BaseGUIFrame(ttk.Frame):
    """
    A reusable base class for GUI frames with common button-driven logging and MQTT functionality.
    This class adheres to the "GUI" layer principles of the protocol.
    """
    def __init__(self, parent, mqtt_util, *args, **kwargs):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="🖥️🟢 Initializing a new GUI frame from the base class. The blueprint is in hand!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            self.pack(fill=tk.BOTH, expand=True)

            # Fix for the bug: Assign global variables as instance attributes
            self.current_file = current_file
            self.current_version = current_version
            self.current_version_hash = current_version_hash

            # We now accept a shared MQTT utility instance from the orchestrator.
            self.mqtt_util = mqtt_util

            # Create a label for the frame
            frame_label = tk.Label(self, text=f"Application Frame: {self.__class__.__name__}", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            # --- New MQTT Section ---
            mqtt_frame = ttk.LabelFrame(self, text="MQTT Controls")
            mqtt_frame.pack(fill=tk.X, padx=10, pady=10)

            # Button 3: Publish Version
            self.publish_version_button = tk.Button(
                mqtt_frame,
                text="Publish Version",
                command=self._publish_version_message
            )
            self.publish_version_button.pack(side=tk.LEFT, padx=5, pady=5)

            # Custom MQTT Publish
            self.custom_topic_entry = ttk.Entry(mqtt_frame)
            self.custom_topic_entry.insert(0, f"Custom Message")
            self.custom_topic_entry.pack(side=tk.LEFT, padx=5, pady=5, fill=tk.X, expand=True)
            
            self.publish_custom_button = tk.Button(
                mqtt_frame,
                text="Publish Custom",
                command=self._publish_custom_message
            )
            self.publish_custom_button.pack(side=tk.LEFT, padx=5, pady=5)
            
            # Subscription label
            self.mqtt_topic_var = tk.StringVar(value="Waiting for MQTT message...")
            self.subscription_label = ttk.Label(mqtt_frame, textvariable=self.mqtt_topic_var)
            self.subscription_label.pack(side=tk.LEFT, padx=5, pady=5)
            
            # We must assign the on_message callback to our custom handler
            self.mqtt_util.mqtt_client.on_message = self._on_mqtt_message

            # We subscribe to the wildcard topic from the entry box
            self.mqtt_util.mqtt_client.subscribe(self.current_file + "/#")


            # --- New MQTT Message Log Table ---
            self.subscriptions_table_frame = ttk.Frame(self)
            self.subscriptions_table_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
            
            self.subscriptions_table = ttk.Treeview(self.subscriptions_table_frame, columns=("Topic", "Message Content"), show="headings")
            self.subscriptions_table.heading("Topic", text="Topic")
            self.subscriptions_table.heading("Message Content", text="Message Content")
            self.subscriptions_table.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

            table_scrollbar = ttk.Scrollbar(self.subscriptions_table_frame, orient=tk.VERTICAL, command=self.subscriptions_table.yview)
            self.subscriptions_table.configure(yscrollcommand=table_scrollbar.set)
            table_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            
            
            # --- New Status Bar at the bottom ---
            status_bar = ttk.Frame(self, relief=tk.SUNKEN, borderwidth=1)
            status_bar.pack(side=tk.BOTTOM, fill=tk.X, expand=False)
            
            # Extract folder and file name from the dynamic path
            file_parts = self.current_file.rsplit('/', 1)
            file_folder = file_parts[0] if len(file_parts) > 1 else ""
            file_name = file_parts[-1]

            status_text = f"Version: {self.current_version} | Folder: {file_folder} | File: {file_name}"
            status_label = ttk.Label(status_bar, text=status_text, anchor='w')
            status_label.pack(side=tk.LEFT, fill=tk.X, expand=True)

            console_log("✅ Celebration of success!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log(f"Left button was clicked in {self.current_file}. Initiating a standard log entry.")
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log(f"✅ Debug entry recorded successfully in {self.current_file}!")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_version_message(self):
        # Publishes the file's version to MQTT.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish the version.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is now the file path itself, and the subtopic is "version"
            topic = self.current_file
            message = self.current_version
            self.mqtt_util.publish_message(topic=topic, subtopic="version", value=message)
            console_log("✅ Version message published successfully!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_mqtt_message(self, client, userdata, msg):
        # Callback for when an MQTT message is received.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🔵 Received MQTT message on topic '{msg.topic}'.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            message_content = msg.payload.decode()
            self.subscriptions_table.insert('', 'end', values=(msg.topic, message_content))
            self.subscriptions_table.yview_moveto(1) # Scroll to the bottom
            self.mqtt_topic_var.set(f"Last Message: {msg.topic} -> {message_content}")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _publish_custom_message(self):
        # Publishes a custom message from the wildcard text box.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🖥️🟢 Entering '{current_function_name}' to publish a custom message.",
            file=self.current_file,
            version=self.current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # The topic is the file path, and the subtopic is "textbox"
            topic = self.current_file
            subtopic = "textbox"
            message = self.custom_topic_entry.get()
            self.mqtt_util.publish_message(topic=topic, subtopic=subtopic, value=message)
            console_log(f"✅ Custom message published successfully to '{topic}/{subtopic}'!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=self.current_file,
                version=self.current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    root = tk.Tk()
    root.title("Base Component Test")
    
    # We now must manually create and pass the MQTT utility instance for the standalone test.
    mqtt_utility = MqttControllerUtility(print_to_gui_func=console_log, log_treeview_func=lambda *args: None)
    mqtt_utility.connect_mqtt()

    app_frame = BaseGUIFrame(parent=root, mqtt_util=mqtt_utility)
    
    root.mainloop()

#####################################
### File: OPEN-AIR 2\display\right_40\top_10\gui_right_side.py
#####################################
# app/main_prototype_tkinter.py
#
# A standalone Tkinter GUI prototype demonstrating button-driven logging. This file
# serves as a test bed for the core application framework and logging protocol.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.190800.1

# 📚 Importing our necessary Python modules to build the application.
import os
import inspect
import datetime
import tkinter as tk
# We'll use the ttk version of Frame for better styling consistency.
from tkinter import ttk

# We assume this is imported from a central logging utility, as per the protocol.
from configuration.logging import debug_log, console_log

# --- Global Scope Variables ---
# ⏰ As requested, the version is now hardcoded to the time this file was generated.
# The following variables are static and will not change at runtime.
# W: This represents the date (YYYYMMDD) of file creation.
CURRENT_DATE = 20250822
# X: This represents the time (HHMMSS) of file creation.
CURRENT_TIME = 190800
# A numeric hash of the time, useful for unique IDs.
CURRENT_TIME_HASH = 190800
# Y: Our project's current revision number for this file.
REVISION_NUMBER = 1
# Assembling the full version string as per the protocol (W.X.Y).
current_version = "20250822.190800.1"
# Creating a unique integer hash for the current version for internal tracking.
current_version_hash = (CURRENT_DATE * CURRENT_TIME_HASH * REVISION_NUMBER)
# Getting the name of the current file to use in our logs, ensuring it's always accurate.
current_file = f"{os.path.basename(__file__)}"


class Start_stop(ttk.Frame):
    """
    A class that simulates a GUI frame with two buttons.
    
    It adheres to the "GUI" layer principles of your protocol, handling display and
    user interaction, but delegating any core logic to other components (simulated here
    by the log and debug functions).
    """
    def __init__(self, parent):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # 🟢 We log the entry into the function with the "mad scientist" personality.
        debug_log(
            message="🖥️🟢 Initializing the GUI frame. The framework is taking shape!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            # We call the parent class's constructor, passing in the parent widget.
            super().__init__(parent)
            # We use pack() to arrange the frame within its parent widget.
            self.pack(padx=20, pady=20)
            
            # Create a label for the frame to give it a clear purpose and title.
            frame_label = tk.Label(self, text="Application Frame", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            # 💡 We pass arguments by name, as required by the protocol.
            self.log_button = tk.Button(
                master=self,
                text="Log",
                command=self.log_button_press
            )
            # We pack the button on the left side of the frame.
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            # 💡 We pass arguments by name, as required by the protocol.
            self.debug_button = tk.Button(
                master=self,
                text="Debug",
                command=self.debug_button_press
            )
            # We pack the button on the left side of the frame, next to the first button.
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            # ✅ A celebratory log message for a successful initialization!
            console_log("✅ Celebration of success!")

        except Exception as e:
            # ❌ If an error occurs, we catch it here to prevent the application from crashing.
            console_log(f"❌ Error in {current_function_name}: {e}")
            # We log a detailed error message with our "mad scientist" personality.
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        # This function is triggered when the "Log" button is clicked.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # 🟢 Entry log with the appropriate emoji prefix.
        debug_log(
            message="🖥️🟢 Entering 'log_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log("Left button was clicked. Initiating a standard log entry.")
            
            # ✅ Success!
            console_log("✅ Log entry recorded successfully!")

        except Exception as e:
            # ❌ Error handling for this specific function.
            console_log(f"❌ Error in {current_function_name}: {e}")
            # Detailed debug log with the error message.
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        # This function is triggered when the "Debug" button is clicked.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # 🟢 Entry log with the appropriate emoji prefix.
        debug_log(
            message="🖥️🟢 Entering 'debug_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            # 🔍🔵 We add a specific debug log to show a deeper inspection is taking place.
            debug_log(
                message="🔍🔵 The right button was clicked! Time for a deeper inspection!",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            
            # ✅ Success!
            console_log("✅ Debug entry recorded successfully!")

        except Exception as e:
            # ❌ Error handling for this specific function.
            console_log(f"❌ Error in {current_function_name}: {e}")
            # Detailed debug log with the error message.
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

# 🏃 This is the standard entry point for a Python script.
# The code inside this block only runs when the script is executed directly.
if __name__ == "__main__":
    # We create the root window of the application.
    root = tk.Tk()
    root.title("Logging Prototype")
    
    # We create an instance of our Start_stop class and pass the root window as the parent.
    # We pass the argument by name as required.
    app_frame = Start_stop(parent=root)
    
    # This call starts the Tkinter event loop, which listens for user actions and keeps the window open.
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\styling\style.py
#####################################
# styling/style.py
#
# Defines the color palettes for different UI themes, providing a centralized
# source for application-wide style configurations.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.210500.1

# 📚 Standard library import for the global variables.
import os

# --- Global Scope Variables ---
# W: The date of the chat session in YYYYMMDD format.
CURRENT_DATE = 20250822
# X: The time of the chat session in HHMMSS format.
CURRENT_TIME = 210500
# A numeric hash of the time, useful for unique IDs.
CURRENT_TIME_HASH = 210500
# Y: The revision number within the current session.
REVISION_NUMBER = 1
# Assembling the full version string as per the protocol (W.X.Y).
current_version = "20250822.210500.1"
# Creating a unique integer hash for the current version for internal tracking.
current_version_hash = (CURRENT_DATE * CURRENT_TIME_HASH * REVISION_NUMBER)
# Getting the name of the current file to use in our logs.
current_file = f"{os.path.basename(__file__)}"

# 🎨 THEMES is a dictionary that holds all our color palettes.
THEMES = {
    # 🌑 The "dark" theme, inspired by dark IDE color schemes.
    "dark": {
        # "bg" (background): The main, default background color for the application.
        "bg": "#2b2b2b",
        # "fg" (foreground): The main, default text color for most elements.
        "fg": "#dcdcdc",
        # "primary": The background color for major containers and frames.
        "primary": "#3c3f41",
        # "secondary": A slightly lighter background color for nested containers or inactive tabs.
        "secondary": "#4e5254",
        # "accent": A bright color used for interactive elements like buttons and selected tabs.
        "accent": "#007acc",
        # "text": The color for text that appears on an accent color background.
        "text": "#ffffff",
        # "border": The color of borders around widgets and containers.
        "border": "#555555",
        # "relief": The style of the border, 'solid' works well with dark themes.
        "relief": "solid",
        # "border_width": The width of the border in pixels.
        "border_width": 1,
        # "padding": A base value for spacing around widgets.
        "padding": 1,
        # "tab_content_padding": Padding specifically for the content inside a tab.
        "tab_content_padding": 1,
        # "accent_colors": A list of colors for a dynamic accent palette, for use in graphs or custom widgets.
        "accent_colors": [
            "#996633",  # 1. Brown
            "#c75450",  # 2. Red
            "#d18616",  # 3. Orange
            "#dcdcaa",  # 4. Yellow
            "#6a9955",  # 5. Green
            "#007acc",  # 6. Blue
            "#6464a3",  # 7. Violet
            "#ce9178",  # 8. Tan
            "#b5cea8",  # 9. Gray-Green
        ]
    },
    # 🌞 The "light" theme, providing a high-contrast alternative.
    "light": {
        # "bg" (background): A light gray background for the overall application.
        "bg": "#f0f0f0",
        # "fg" (foreground): Black text for high readability.
        "fg": "#000000",
        # "primary": A clean white background for main content areas.
        "primary": "#ffffff",
        # "secondary": A lighter gray for minor elements or inactive tabs.
        "secondary": "#e0e0e0",
        # "accent": A vibrant blue for interactive elements.
        "accent": "#0078d7",
        # "text": A standard black for text on the accent color.
        "text": "#000000",
        # "border": A neutral gray for borders.
        "border": "#ababab",
        # "relief": The border style, 'groove' gives a slightly indented, classic look.
        "relief": "groove",
        # "border_width": The width of the border.
        "border_width": 1,
        # "padding": A base value for spacing.
        "padding": 1,
        # "tab_content_padding": Padding for content inside a tab.
        "tab_content_padding": 1,
        # "accent_colors": A separate list of vibrant colors for graphs and dynamic elements in the light theme.
        "accent_colors": [
            "#A0522D",  # 1. Brown (Sienna)
            "#D22B2B",  # 2. Red (Firebrick)
            "#FF8C00",  # 3. Orange (DarkOrange)
            "#FFD700",  # 4. Yellow (Gold)
            "#228B22",  # 5. Green (ForestGreen)
            "#4169E1",  # 6. Blue (RoyalBlue)
            "#8A2BE2",  # 7. Violet (BlueViolet)
            "#D2691E",  # 8. Tan (Chocolate)
            "#556B2F",  # 9. Gray-Green (DarkOliveGreen)
        ]
    }
}

# 🛠️ The default theme to use. This can be changed here to easily switch the entire application's style.
DEFAULT_THEME = "dark"


#####################################
### File: OPEN-AIR 2\utils\mqtt_controller_util.py
#####################################
# utils/mqtt_controller_util.py
#
# A utility module to handle the logic for interfacing with an external MQTT broker.
# This version refactors the client to centrally manage subscriptions and dispatch messages.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.231500.2

import os
import inspect
import datetime
import paho.mqtt.client as mqtt
import subprocess
import threading
import json
import pathlib
import sys

# --- Module Imports ---
# Path manipulation is now handled by main.py
from configuration.logging import debug_log, console_log

# --- Global Scope Variables (as per your instructions) ---
current_version = "20250822.231500.2"
# The hash calculation drops the leading zero from the hour, but 21 has no leading zero.
current_version_hash = (20250822 * 231500 * 2)
current_file = f"{os.path.basename(__file__)}"

# --- Constant Variables (No Magic Numbers) ---
# MQTT Broker settings
BROKER_ADDRESS = "localhost"
BROKER_PORT = 1883
BROKER_TIMEOUT = 60
# Logging messages and colors
BROKER_RUNNING_MSG = "Broker is running"
BROKER_NOT_RUNNING_MSG = "Broker is not running"
BROKER_ALREADY_RUNNING_MSG = "Mosquitto is already running!"
FAILED_TO_START_BROKER_MSG = "Failed to start mosquitto process: "
BROKER_STOPPED_MSG = "Broker stopped"
NOT_CONNECTED_MSG = "Not connected to broker."
NO_TOPIC_OR_VALUE_MSG = "Please enter a topic and a value."


class MqttControllerUtility:
    """
    Manages all communication logic for the MQTT broker and client.
    This class is the central point for all functions to push a message or subscribe to messages.
    It adheres to the "Utilities" layer principles of your protocol.
    """
    def __init__(self, print_to_gui_func, log_treeview_func):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message=f"🛠️🟢 Initializing the '{self.__class__.__name__}' utility class. Powering up the flux capacitor!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=print_to_gui_func
        )
    
        try:
            # --- Function logic goes here ---
            self.mosquitto_process = None
            self.mqtt_client = None
            self._print_to_gui_console = print_to_gui_func
            self._log_to_treeview = log_treeview_func
            self.topics_seen = set()
            self._subscribers = {} # A new dictionary to hold subscribers and their callbacks

            console_log("✅ Celebration of success!")
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self._print_to_gui_console
            )
            
    def add_subscriber(self, topic_filter: str, callback_func):
        """Adds a callback function to be triggered for a specific topic filter."""
        self._subscribers[topic_filter] = callback_func
        # This is the single place we subscribe to a topic.
        self.mqtt_client.subscribe(topic_filter)
        debug_log(
            message=f"🛠️🟢 New subscriber added for topic filter: '{topic_filter}'.",
            file=current_file,
            version=current_version,
            function="add_subscriber",
            console_print_func=self._print_to_gui_console
        )


    # --- Broker and MQTT Methods ---
    def start_mosquitto(self):
        """Starts the Mosquitto broker process if it's not already running."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🛠️🟢 Entering '{current_function_name}' to start the broker.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=self._print_to_gui_console
        )
        try:
            if self.mosquitto_process and self.mosquitto_process.poll() is None:
                console_log(f"⚠️ {BROKER_ALREADY_RUNNING_MSG}")
                return
            
            self.mosquitto_process = subprocess.Popen(args=["mosquitto"])
            console_log("✅ Broker started successfully!")
            
        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {FAILED_TO_START_BROKER_MSG}{e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self._print_to_gui_console
            )

    def stop_mosquitto(self):
        """Stops the Mosquitto broker process if it's running."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🛠️🟢 Entering '{current_function_name}' to stop the broker.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=self._print_to_gui_console
        )
        try:
            if self.mosquitto_process and self.mosquitto_process.poll() is None:
                self.mosquitto_process.terminate()
                self.mosquitto_process = None
                console_log(f"✅ {BROKER_STOPPED_MSG}")
            else:
                console_log(f"⚠️ {BROKER_NOT_RUNNING_MSG}")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self._print_to_gui_console
            )

    def check_status(self):
        """Checks and reports the status of the Mosquitto broker."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🛠️🟢 Entering '{current_function_name}' to check broker status.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=self._print_to_gui_console
        )
        try:
            if self.mosquitto_process and self.mosquitto_process.poll() is None:
                console_log(f"✅ {BROKER_RUNNING_MSG}")
            else:
                console_log(f"❌ {BROKER_NOT_RUNNING_MSG}")

        except Exception as e:
            console_log(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self._print_to_gui_console
            )

    def on_connect(self, client, userdata, flags, rc):
        """Callback for when the MQTT client connects to the broker."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🛠️🔵 MQTT client connected with rc={rc}. Subscribing to all topics!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=self._print_to_gui_console
        )
        # We subscribe to a wildcard topic once to catch everything.
        client.subscribe("#")
        self._print_to_gui_console(f"Connected to broker with rc={rc}")

    def on_message(self, client, userdata, msg):
        """Callback for when an MQTT message is received."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # We process the message payload here for all listeners
        topic = msg.topic
        payload = msg.payload.decode()
        self.topics_seen.add(topic)
        
        # Now we dispatch the message to all registered subscribers.
        for topic_filter, callback_func in self._subscribers.items():
            # The paho-mqtt library provides a topic_matches_sub function to check for wildcards.
            if mqtt.topic_matches_sub(topic_filter, topic):
                debug_log(
                    message=f"🛠️🔵 Dispatching message to subscriber for topic '{topic_filter}'.",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.on_message",
                    console_print_func=self._print_to_gui_console
                )
                callback_func(topic, payload)


    def connect_mqtt(self):
        """Connects the MQTT client to the broker in a separate thread."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🛠️🟢 Entering '{current_function_name}' to connect MQTT client.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=self._print_to_gui_console
        )
        try:
            self.mqtt_client = mqtt.Client()
            self.mqtt_client.on_connect = self.on_connect
            self.mqtt_client.on_message = self.on_message
            self.mqtt_client.connect(host=BROKER_ADDRESS, port=BROKER_PORT, keepalive=BROKER_TIMEOUT)
            
            thread = threading.Thread(target=self.mqtt_client.loop_forever, daemon=True)
            thread.start()
            self._print_to_gui_console("✅ MQTT client connection initiated in a background thread.")

        except Exception as e:
            self._print_to_gui_console(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self._print_to_gui_console
            )

    def show_topics(self):
        """Displays a list of all topics seen by the MQTT client."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🛠️🟢 Entering '{current_function_name}' to display topics.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=self._print_to_gui_console
        )
        try:
            if self.topics_seen:
                topics_str = "\n".join(sorted(self.topics_seen))
                self._print_to_gui_console(f"Observed Topics:\n{topics_str}")
            else:
                self._print_to_gui_console("⚠️ No topics observed yet.")

        except Exception as e:
            self._print_to_gui_console(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self._print_to_gui_console
            )

    def publish_message(self, topic: str, subtopic: str, value):
        """Publishes a message to a topic via the MQTT client."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"🛠️🟢 Entering '{current_function_name}' to publish a message.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=self._print_to_gui_console
        )
        try:
            if not topic or not subtopic:
                self._print_to_gui_console(f"❌ {NO_TOPIC_OR_VALUE_MSG}")
                return

            full_topic = f"{topic}/{subtopic}"
            payload = json.dumps({"value": value})

            if self.mqtt_client:
                self.mqtt_client.publish(full_topic, payload)
                self._print_to_gui_console(f"Published to {full_topic}: {payload}")
                console_log(f"✅ Published message to topic '{full_topic}'.")
            else:
                self._print_to_gui_console(f"❌ {NOT_CONNECTED_MSG}")

        except Exception as e:
            self._print_to_gui_console(f"❌ Error in {current_function_name}: {e}")
            debug_log(
                message=f"❌🔴 Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self._print_to_gui_console
            )

