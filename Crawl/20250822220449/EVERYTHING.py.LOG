# ‚îî‚îÄ‚îÄ OPEN-AIR 2/
#‚îú‚îÄ‚îÄ DATA/
#‚îú‚îÄ‚îÄ configuration/
#‚îú‚îÄ‚îÄ device_interfacing/
#‚îú‚îÄ‚îÄ display/
#‚îú‚îÄ‚îÄ utils/
#‚îú‚îÄ‚îÄ debug.log (Lines: 0)
#‚îî‚îÄ‚îÄ main.py (Lines: 145)
#        |   -> Import: configuration.logging
#        |   -> Import: datetime
#        |   -> Import: display.gui_display
#        |   -> Import: inspect
#        |   -> Import: os
#        |   -> Import: pathlib
#        |   -> Import: sys
#        |   -> Function: action_check_configuration()
#        |   -> Function: action_check_dependancies()
#        |   -> Function: action_open_display()
#        |   -> Function: main()
#‚îî‚îÄ‚îÄ configuration/
#    ‚îî‚îÄ‚îÄ logging.py (Lines: 72)
#            |   -> Import: datetime
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Function: console_log(message)
#            |   -> Function: debug_log(message, file, version, function, console_print_func)
#‚îî‚îÄ‚îÄ DATA/
#‚îî‚îÄ‚îÄ device_interfacing/
#‚îî‚îÄ‚îÄ display/
#    ‚îú‚îÄ‚îÄ left_60/
#    ‚îú‚îÄ‚îÄ right_40/
#    ‚îú‚îÄ‚îÄ styling/
#    ‚îú‚îÄ‚îÄ debug.log (Lines: 0)
#    ‚îî‚îÄ‚îÄ gui_display.py (Lines: 591)
#            |   -> Import: configuration.logging
#            |   -> Import: datetime
#            |   -> Import: importlib.util
#            |   -> Import: inspect
#            |   -> Import: os
#            |   -> Import: pathlib
#            |   -> Import: styling.style
#            |   -> Import: sys
#            |   -> Import: tkinter
#            |   -> Class: Application
#            |   -> Function: __init__(self)
#            |   -> Function: _apply_styles(self, theme_name)
#            |   -> Function: _build_child_container(self, path, parent_widget)
#            |   -> Function: _build_from_directory(self, path, parent_widget)
#            |   -> Function: _on_tab_change(self, event)
#            |   -> Function: _re_attach_tab(self, frame)
#            |   -> Function: _tear_off_tab(self, event)
#    ‚îî‚îÄ‚îÄ left_60/
#        ‚îî‚îÄ‚îÄ top_100/
#        ‚îî‚îÄ‚îÄ top_100/
#            ‚îú‚îÄ‚îÄ tab_1_instrument/
#            ‚îú‚îÄ‚îÄ tab_2_markers/
#            ‚îú‚îÄ‚îÄ tab_3_presets/
#            ‚îú‚îÄ‚îÄ tab_4_intermod/
#            ‚îú‚îÄ‚îÄ tab_5_sweeping/
#            ‚îú‚îÄ‚îÄ tab_6_graphing/
#            ‚îî‚îÄ‚îÄ tab_7_exepriment/
#            ‚îî‚îÄ‚îÄ tab_1_instrument/
#                ‚îú‚îÄ‚îÄ sub_tab_1_connection/
#                ‚îú‚îÄ‚îÄ sub_tab_2_settings/
#                ‚îú‚îÄ‚îÄ sub_tab_3_translator/
#                ‚îî‚îÄ‚îÄ gui_tab_1_instrument.py (Lines: 0)
#                        - No functions, classes, or imports found.
#                ‚îî‚îÄ‚îÄ sub_tab_1_connection/
#                    ‚îî‚îÄ‚îÄ gui_child_1_connection.py (Lines: 158)
#                            |   -> Import: configuration.logging
#                            |   -> Import: datetime
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: tkinter
#                            |   -> Class: GUIFrame
#                            |   -> Function: __init__(self, parent)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#                ‚îî‚îÄ‚îÄ sub_tab_2_settings/
#                    ‚îú‚îÄ‚îÄ sub_tab_1_frequency/
#                    ‚îú‚îÄ‚îÄ sub_tab_2_Resolution/
#                    ‚îú‚îÄ‚îÄ sub_tab_3_Amplitude/
#                    ‚îú‚îÄ‚îÄ sub_tab_4_Trace Mode/
#                    ‚îî‚îÄ‚îÄ gui_child_2_settings.py (Lines: 58)
#                            |   -> Import: datetime
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: tkinter
#                            |   -> Function: create_yo_button_frame(parent_widget)
#                    ‚îî‚îÄ‚îÄ sub_tab_1_frequency/
#                        ‚îî‚îÄ‚îÄ gui_child_2_settings.py (Lines: 95)
#                                |   -> Import: datetime
#                                |   -> Import: inspect
#                                |   -> Import: os
#                                |   -> Import: styling.style
#                                |   -> Import: tabs.conductor.gui_mqtt_conductor
#                                |   -> Import: tkinter
#                                |   -> Class: App
#                                |   -> Function: __init__(self)
#                                |   -> Function: console_log(message)
#                                |   -> Function: debug_log(message, file, version, function, console_print_func)
#                    ‚îî‚îÄ‚îÄ sub_tab_2_Resolution/
#                        ‚îî‚îÄ‚îÄ gui_child_2_resolution.py (Lines: 95)
#                                |   -> Import: datetime
#                                |   -> Import: inspect
#                                |   -> Import: os
#                                |   -> Import: styling.style
#                                |   -> Import: tabs.conductor.gui_mqtt_conductor
#                                |   -> Import: tkinter
#                                |   -> Class: App
#                                |   -> Function: __init__(self)
#                                |   -> Function: console_log(message)
#                                |   -> Function: debug_log(message, file, version, function, console_print_func)
#                    ‚îî‚îÄ‚îÄ sub_tab_3_Amplitude/
#                        ‚îî‚îÄ‚îÄ gui_child_3_amplitude.py (Lines: 94)
#                                |   -> Import: datetime
#                                |   -> Import: inspect
#                                |   -> Import: os
#                                |   -> Import: styling.style
#                                |   -> Import: tkinter
#                                |   -> Class: App
#                                |   -> Function: __init__(self)
#                                |   -> Function: console_log(message)
#                                |   -> Function: debug_log(message, file, version, function, console_print_func)
#                    ‚îî‚îÄ‚îÄ sub_tab_4_Trace Mode/
#                        ‚îî‚îÄ‚îÄ gui_child_4_trace.py (Lines: 95)
#                                |   -> Import: datetime
#                                |   -> Import: inspect
#                                |   -> Import: os
#                                |   -> Import: styling.style
#                                |   -> Import: tabs.conductor.gui_mqtt_conductor
#                                |   -> Import: tkinter
#                                |   -> Class: App
#                                |   -> Function: __init__(self)
#                                |   -> Function: console_log(message)
#                                |   -> Function: debug_log(message, file, version, function, console_print_func)
#                ‚îî‚îÄ‚îÄ sub_tab_3_translator/
#                    ‚îî‚îÄ‚îÄ gui_child_3_translator.py (Lines: 845)
#                            |   -> Import: configuration.logging
#                            |   -> Import: datetime
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: pathlib
#                            |   -> Import: styling.style
#                            |   -> Import: sys
#                            |   -> Import: tkinter
#                            |   -> Class: Translatorframe
#                            |   -> Function: __init__(self, parent)
#                            |   -> Function: _add_new_row(self)
#                            |   -> Function: _apply_styles(self, theme_name)
#                            |   -> Function: _delete_selected_row(self)
#                            |   -> Function: _edit_cell(self, item, col_index)
#                            |   -> Function: _on_do_command(self, command)
#                            |   -> Function: _on_double_click(self, event)
#                            |   -> Function: _on_execute_command(self, command)
#                            |   -> Function: _on_query_command(self, command)
#                            |   -> Function: _on_set_command(self, command)
#                            |   -> Function: _on_treeview_focus(self, event)
#                            |   -> Function: _on_treeview_select(self, event)
#                            |   -> Function: _save_data_dummy(self)
#                            |   -> Function: _set_ui_initial_state(self)
#                            |   -> Function: _sort_treeview(self, tv, col)
#                            |   -> Function: bind_events(self)
#                            |   -> Function: create_visa_interpreter_tab(parent_widget)
#                            |   -> Function: create_widgets(self)
#                            |   -> Function: load_data_to_treeview(self)
#                            |   -> Function: on_entry_change(e)
#                            |   -> Function: setup_layout(self)
#            ‚îî‚îÄ‚îÄ tab_2_markers/
#                ‚îú‚îÄ‚îÄ sub_tab_1_showtime/
#                ‚îú‚îÄ‚îÄ sub_tab_2_editor/
#                ‚îî‚îÄ‚îÄ gui_left_side.py (Lines: 0)
#                        - No functions, classes, or imports found.
#                ‚îî‚îÄ‚îÄ sub_tab_1_showtime/
#                    ‚îî‚îÄ‚îÄ gui_child_1_showtime.py (Lines: 158)
#                            |   -> Import: configuration.logging
#                            |   -> Import: datetime
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: tkinter
#                            |   -> Class: GUIFrame
#                            |   -> Function: __init__(self, parent)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#                ‚îî‚îÄ‚îÄ sub_tab_2_editor/
#                    ‚îî‚îÄ‚îÄ gui_child_2_editor.py (Lines: 158)
#                            |   -> Import: configuration.logging
#                            |   -> Import: datetime
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: tkinter
#                            |   -> Class: GUIFrame
#                            |   -> Function: __init__(self, parent)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#            ‚îî‚îÄ‚îÄ tab_3_presets/
#                ‚îú‚îÄ‚îÄ sub_tab_1_pusher/
#                ‚îú‚îÄ‚îÄ sub_tab_2_editor/
#                ‚îú‚îÄ‚îÄ sub_tab_3_collector/
#                ‚îî‚îÄ‚îÄ gui_tab_3_presets.py (Lines: 58)
#                        |   -> Import: datetime
#                        |   -> Import: inspect
#                        |   -> Import: os
#                        |   -> Import: tkinter
#                        |   -> Function: create_yo_button_frame(parent_widget)
#                ‚îî‚îÄ‚îÄ sub_tab_1_pusher/
#                    ‚îî‚îÄ‚îÄ gui_child_1_pusher.py (Lines: 158)
#                            |   -> Import: configuration.logging
#                            |   -> Import: datetime
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: tkinter
#                            |   -> Class: GUIFrame
#                            |   -> Function: __init__(self, parent)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#                ‚îî‚îÄ‚îÄ sub_tab_2_editor/
#                    ‚îî‚îÄ‚îÄ gui_child_2_editor.py (Lines: 158)
#                            |   -> Import: configuration.logging
#                            |   -> Import: datetime
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: tkinter
#                            |   -> Class: GUIFrame
#                            |   -> Function: __init__(self, parent)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#                ‚îî‚îÄ‚îÄ sub_tab_3_collector/
#                    ‚îî‚îÄ‚îÄ gui_child_3_collector.py (Lines: 158)
#                            |   -> Import: configuration.logging
#                            |   -> Import: datetime
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: tkinter
#                            |   -> Class: GUIFrame
#                            |   -> Function: __init__(self, parent)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#            ‚îî‚îÄ‚îÄ tab_4_intermod/
#                ‚îú‚îÄ‚îÄ sub_tab_1_calculator/
#                ‚îú‚îÄ‚îÄ sub_tab_2_future/
#                ‚îî‚îÄ‚îÄ gui_tab_4_intermod.py (Lines: 0)
#                        - No functions, classes, or imports found.
#                ‚îî‚îÄ‚îÄ sub_tab_1_calculator/
#                    ‚îî‚îÄ‚îÄ gui_child_1_calculator.py (Lines: 158)
#                            |   -> Import: configuration.logging
#                            |   -> Import: datetime
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: tkinter
#                            |   -> Class: GUIFrame
#                            |   -> Function: __init__(self, parent)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#                ‚îî‚îÄ‚îÄ sub_tab_2_future/
#                    ‚îú‚îÄ‚îÄ gui_1_top.py (Lines: 158)
#                            |   -> Import: configuration.logging
#                            |   -> Import: datetime
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: tkinter
#                            |   -> Class: GUIFrame
#                            |   -> Function: __init__(self, parent)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#                    ‚îú‚îÄ‚îÄ gui_2_bottom copy.py (Lines: 158)
#                            |   -> Import: configuration.logging
#                            |   -> Import: datetime
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: tkinter
#                            |   -> Class: GUIFrame
#                            |   -> Function: __init__(self, parent)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#                    ‚îî‚îÄ‚îÄ gui_44_last.py (Lines: 158)
#                            |   -> Import: configuration.logging
#                            |   -> Import: datetime
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: tkinter
#                            |   -> Class: GUIFrame
#                            |   -> Function: __init__(self, parent)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#            ‚îî‚îÄ‚îÄ tab_5_sweeping/
#                ‚îú‚îÄ‚îÄ sub_tab_1_single/
#                ‚îú‚îÄ‚îÄ sub_tab_2_statistical/
#                ‚îî‚îÄ‚îÄ tab_5_sweeping.py (Lines: 0)
#                        - No functions, classes, or imports found.
#                ‚îî‚îÄ‚îÄ sub_tab_1_single/
#                    ‚îî‚îÄ‚îÄ gui_child_1_single.py (Lines: 158)
#                            |   -> Import: configuration.logging
#                            |   -> Import: datetime
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: tkinter
#                            |   -> Class: GUIFrame
#                            |   -> Function: __init__(self, parent)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#                ‚îî‚îÄ‚îÄ sub_tab_2_statistical/
#                    ‚îî‚îÄ‚îÄ gui_child_2_statistical.py (Lines: 158)
#                            |   -> Import: configuration.logging
#                            |   -> Import: datetime
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: tkinter
#                            |   -> Class: GUIFrame
#                            |   -> Function: __init__(self, parent)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#            ‚îî‚îÄ‚îÄ tab_6_graphing/
#                ‚îú‚îÄ‚îÄ sub_tab_1_from_file/
#                ‚îî‚îÄ‚îÄ gui_tab_6_graphing.py (Lines: 0)
#                        - No functions, classes, or imports found.
#                ‚îî‚îÄ‚îÄ sub_tab_1_from_file/
#                    ‚îî‚îÄ‚îÄ gui_child1_from_file.py (Lines: 158)
#                            |   -> Import: configuration.logging
#                            |   -> Import: datetime
#                            |   -> Import: inspect
#                            |   -> Import: os
#                            |   -> Import: tkinter
#                            |   -> Class: GUIFrame
#                            |   -> Function: __init__(self, parent)
#                            |   -> Function: debug_button_press(self)
#                            |   -> Function: log_button_press(self)
#            ‚îî‚îÄ‚îÄ tab_7_exepriment/
#                ‚îú‚îÄ‚îÄ sub_tab_1_mosquitto/
#                ‚îî‚îÄ‚îÄ gui_7_experiment.py (Lines: 158)
#                        |   -> Import: configuration.logging
#                        |   -> Import: datetime
#                        |   -> Import: inspect
#                        |   -> Import: os
#                        |   -> Import: tkinter
#                        |   -> Class: GUIFrame
#                        |   -> Function: __init__(self, parent)
#                        |   -> Function: debug_button_press(self)
#                        |   -> Function: log_button_press(self)
#                ‚îî‚îÄ‚îÄ sub_tab_1_mosquitto/
#    ‚îî‚îÄ‚îÄ right_40/
#        ‚îú‚îÄ‚îÄ bottom_90/
#        ‚îî‚îÄ‚îÄ top_10/
#        ‚îî‚îÄ‚îÄ bottom_90/
#            ‚îú‚îÄ‚îÄ tab_1_scan/
#            ‚îú‚îÄ‚îÄ tab_2_monitors/
#            ‚îú‚îÄ‚îÄ tab_3_debug/
#            ‚îú‚îÄ‚îÄ tab_4_conductor/
#            ‚îî‚îÄ‚îÄ tab_5_configuration/
#            ‚îî‚îÄ‚îÄ tab_1_scan/
#                ‚îî‚îÄ‚îÄ gui_tab_1_scan.py (Lines: 158)
#                        |   -> Import: configuration.logging
#                        |   -> Import: datetime
#                        |   -> Import: inspect
#                        |   -> Import: os
#                        |   -> Import: tkinter
#                        |   -> Class: GUIFrame
#                        |   -> Function: __init__(self, parent)
#                        |   -> Function: debug_button_press(self)
#                        |   -> Function: log_button_press(self)
#            ‚îî‚îÄ‚îÄ tab_2_monitors/
#                ‚îî‚îÄ‚îÄ gui_tab_2_monitors.py (Lines: 158)
#                        |   -> Import: configuration.logging
#                        |   -> Import: datetime
#                        |   -> Import: inspect
#                        |   -> Import: os
#                        |   -> Import: tkinter
#                        |   -> Class: GUIFrame
#                        |   -> Function: __init__(self, parent)
#                        |   -> Function: debug_button_press(self)
#                        |   -> Function: log_button_press(self)
#            ‚îî‚îÄ‚îÄ tab_3_debug/
#                ‚îî‚îÄ‚îÄ gui_tab_3_debug.py (Lines: 158)
#                        |   -> Import: configuration.logging
#                        |   -> Import: datetime
#                        |   -> Import: inspect
#                        |   -> Import: os
#                        |   -> Import: tkinter
#                        |   -> Class: GUIFrame
#                        |   -> Function: __init__(self, parent)
#                        |   -> Function: debug_button_press(self)
#                        |   -> Function: log_button_press(self)
#            ‚îî‚îÄ‚îÄ tab_4_conductor/
#                ‚îî‚îÄ‚îÄ gui_1_mqtt_conductor.py (Lines: 275)
#                        |   -> Import: configuration.logging
#                        |   -> Import: datetime
#                        |   -> Import: inspect
#                        |   -> Import: os
#                        |   -> Import: styling.style
#                        |   -> Import: tkinter
#                        |   -> Import: utils.mqtt_controller_util
#                        |   -> Class: MqttConductorFrame
#                        |   -> Function: __init__(self, parent)
#                        |   -> Function: _apply_styles(self, theme_name)
#                        |   -> Function: create_widgets(self)
#                        |   -> Function: log_to_gui(self, message)
#                        |   -> Function: log_to_table(self, topic, message)
#                        |   -> Function: update_slider_label(self)
#            ‚îî‚îÄ‚îÄ tab_5_configuration/
#                ‚îî‚îÄ‚îÄ gui_tab_5_configuration.py (Lines: 0)
#                        - No functions, classes, or imports found.
#        ‚îî‚îÄ‚îÄ top_10/
#            ‚îî‚îÄ‚îÄ gui_right_side.py (Lines: 201)
#                    |   -> Import: configuration.logging
#                    |   -> Import: datetime
#                    |   -> Import: inspect
#                    |   -> Import: os
#                    |   -> Import: tkinter
#                    |   -> Class: Start_stop
#                    |   -> Function: __init__(self, parent)
#                    |   -> Function: debug_button_press(self)
#                    |   -> Function: log_button_press(self)
#    ‚îî‚îÄ‚îÄ styling/
#        ‚îî‚îÄ‚îÄ style.py (Lines: 117)
#                |   -> Import: os
#‚îî‚îÄ‚îÄ utils/
#    ‚îî‚îÄ‚îÄ mqtt_controller_util.py (Lines: 303)
#            |   -> Import: configuration.logging
#            |   -> Import: datetime
#            |   -> Import: inspect
#            |   -> Import: json
#            |   -> Import: os
#            |   -> Import: paho.mqtt.client
#            |   -> Import: pathlib
#            |   -> Import: subprocess
#            |   -> Import: sys
#            |   -> Import: threading
#            |   -> Class: MqttControllerUtility
#            |   -> Function: __init__(self, print_to_gui_func, log_treeview_func)
#            |   -> Function: check_status(self)
#            |   -> Function: connect_mqtt(self)
#            |   -> Function: on_connect(self, client, userdata, flags, rc)
#            |   -> Function: on_message(self, client, userdata, msg)
#            |   -> Function: publish_message(self, topic, subtopic, value)
#            |   -> Function: show_topics(self)
#            |   -> Function: start_mosquitto(self)
#            |   -> Function: stop_mosquitto(self)


--------------------------------------------------

# ====================================================================================
# EVERYTHING.py.LOG
# This file contains the complete content of all Python, CSV, and INI files found during the crawl.
# Each file's content is separated by its path and a dashed line.
#
# Log started at: 2025-08-22 22:04:49
# ====================================================================================

#####################################
### File: OPEN-AIR 2\main.py
#####################################
# main.py
#
# This file serves as the main entry point for the application, orchestrating startup checks and GUI launch.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.235900.1

import os
import inspect
import datetime
import sys
import pathlib

# Add the project's root directory to the system path to allow for imports from
# all sub-folders (e.g., 'configuration' and 'display').
if str(pathlib.Path(__file__).resolve().parent) not in sys.path:
    sys.path.append(str(pathlib.Path(__file__).resolve().parent))

# Import core application modules
from configuration.logging import console_log, debug_log
from display.gui_display import Application


# --- Global Scope Variables ---
CURRENT_DATE = datetime.datetime.now().strftime("%Y%m%d")
CURRENT_TIME = datetime.datetime.now().strftime("%H%M%S")
# Note: For hashing, any leading zero in the hour is dropped (e.g., 083015 becomes 83015).
CURRENT_TIME_HASH = int(datetime.datetime.now().strftime("%H%M%S"))
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
current_file = f"{os.path.basename(__file__)}"


def action_check_dependancies():
    # Checks for required system and library dependencies.
    current_function_name = inspect.currentframe().f_code.co_name
    debug_log(
        message=f"üñ•Ô∏èüü¢ Ah, good, we're entering '{current_function_name}'! Let's examine the raw materials, shall we?",
        file=current_file,
        version=current_version,
        function=current_function_name,
        console_print_func=console_log
    )

    try:
        # --- Function logic goes here ---
        # Placeholder for dependency checking logic
        console_log("‚úÖ A most glorious success! Dependencies are in order.")
        return True

    except Exception as e:
        console_log(f"‚ùå Error in {current_function_name}: {e}")
        debug_log(
            message=f"üñ•Ô∏èüî¥ Heavens to Betsy! We've hit a snag in the dependencies! The error be: {e}",
            file=current_file,
            version=current_version,
            function=current_function_name,
            console_print_func=console_log
        )
        return False

def action_check_configuration():
    # Validates the application's configuration files.
    current_function_name = inspect.currentframe().f_code.co_name
    debug_log(
        message=f"üñ•Ô∏èüü¢ Ahem, commencing the configuration validation experiment in '{current_function_name}'.",
        file=current_file,
        version=current_version,
        function=current_function_name,
        console_print_func=console_log
    )

    try:
        # --- Function logic goes here ---
        # Placeholder for configuration validation
        console_log("‚úÖ Excellent! The configuration is quite, quite brilliant.")
        return True

    except Exception as e:
        console_log(f"‚ùå Error in {current_function_name}: {e}")
        debug_log(
            message=f"üñ•Ô∏èüî¥ By Jove! The configuration is in shambles! The error be: {e}",
            file=current_file,
            version=current_version,
            function=current_function_name,
            console_print_func=console_log
        )
        return False

def action_open_display():
    # Initializes and opens the main graphical user interface.
    current_function_name = inspect.currentframe().f_code.co_name
    debug_log(
        message=f"üñ•Ô∏èüü¢ The final step! Activating the main display in '{current_function_name}'!",
        file=current_file,
        version=current_version,
        function=current_function_name,
        console_print_func=console_log
    )

    try:
        # --- Function logic goes here ---
        app = Application()
        app.mainloop()
        console_log("‚úÖ The grand spectacle begins! GUI is now open.")
        return True

    except Exception as e:
        console_log(f"‚ùå Error in {current_function_name}: {e}")
        debug_log(
            message=f"üñ•Ô∏èüî¥ Blast and barnacles! The display has failed to materialize! The error be: {e}",
            file=current_file,
            version=current_version,
            function=current_function_name,
            console_print_func=console_log
        )
        return False

def main():
    """The main execution function for the application."""
    console_log(f"üöÄ Launch sequence initiated for version {current_version}.")

    if action_check_dependancies():
        if action_check_configuration():
            action_open_display()
        else:
            console_log("‚ùå Halting startup due to configuration errors.")
    else:
        console_log("‚ùå Halting startup due to missing dependencies.")


if __name__ == "__main__":
    main()



#####################################
### File: OPEN-AIR 2\configuration\logging.py
#####################################
# configuration/logging.py
#
# A simple utility file to provide standardized debugging functions for the application.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.215200.1

import os
import inspect
import datetime

# --- Global Scope Variables ---
# ‚è∞ As requested, the version is now hardcoded to the time this file was generated.
# The version strings and numbers below are static and will not change at runtime.
current_version = "20250822.215200.1"
# The hash calculation drops the leading zero from the hour, but 21 has no leading zero.
current_version_hash = (20250822 * 215200 * 1)
current_file = f"{os.path.basename(__file__)}"

# --- Logging Toggles ---
LOG_TO_TERMINAL = True
LOG_TO_FILE = True
FILE_LOG_PATH = "debug.log"


def console_log(message: str):
    """
    Prints a message to the console if the toggle is enabled.
    """
    current_function_name = inspect.currentframe().f_code.co_name

    try:
        if LOG_TO_TERMINAL:
            print(message)

    except Exception as e:
        if LOG_TO_TERMINAL:
            print(f"‚ùå Error in {current_function_name}: {e}")

def debug_log(message: str, file: str, version: str, function: str, console_print_func):
    """
    Prints a detailed debug message with a 'mad scientist' personality,
    directing output based on the global toggles.
    """
    current_function_name = inspect.currentframe().f_code.co_name
    
    try:
        # Re-formatting the message to better match the 'mad scientist' persona
        log_message = f"üí°üìù{message} | {file} | {version} | {function}"

        # --- Function logic goes here ---
        if LOG_TO_TERMINAL:
            console_print_func(log_message)

        if LOG_TO_FILE:
            with open(FILE_LOG_PATH, "a") as log_file:
                log_file.write(log_message + "\n")

    except Exception as e:
        if LOG_TO_TERMINAL:
            console_print_func(f"‚ùå Error in {current_function_name}: {e}")
            console_print_func(f"Arrr, the code be capsized! The error be: {e}")


#####################################
### File: OPEN-AIR 2\display\gui_display.py
#####################################
# display/gui_display.py
#
# A script that dynamically builds the application's Tkinter GUI based on the
# predefined directory structure. It acts as the "orchestrator," recursively
# traversing a folder hierarchy to construct the user interface, now with
# support for "tear-off" tabs that can become their own windows.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.212000.1

# üìö Python's standard library modules are our trusty sidekicks!
# os: Provides a way to interact with the operating system, like getting file names.
import os
# inspect: Allows us to "look inside" live objects, which is crucial for dynamic introspection.
import inspect
# datetime: Handles dates and times, used here for our versioning system.
import datetime
# tkinter: The foundational GUI toolkit for Python.
import tkinter as tk
# ttk: The "themed Tkinter" module, providing a more modern, stylable set of widgets.
from tkinter import ttk
# importlib.util: A powerful module for dynamic, programmatic importing of Python files.
import importlib.util
# sys: Provides access to system-specific parameters and functions, including the module search path.
import sys
# pathlib: A modern, object-oriented way to handle filesystem paths, making our code cleaner and more robust.
import pathlib

# --- Module Imports ---
# üè° We need to add the parent directory to the path so our code can find the 'styling'
# and 'configuration' modules, as they are siblings to the 'display' directory.
if str(pathlib.Path(__file__).resolve().parent.parent) not in sys.path:
    # Appending the absolute path of the directory that contains this script's folder.
    sys.path.append(str(pathlib.Path(__file__).resolve().parent.parent))

# Now that the path is set, we can confidently import our theme and logging data!
from .styling.style import THEMES, DEFAULT_THEME
from configuration.logging import debug_log, console_log


# --- Global Scope Variables ---
# ‚è∞ As requested, the version is now hardcoded to the time this file was generated.
# The version strings and numbers below are static and will not change at runtime.
# This represents the date (YYYYMMDD) of file creation.
CURRENT_DATE = 20250822
# This represents the time (HHMMSS) of file creation.
CURRENT_TIME = 212000
# This is a numeric hash of the time, useful for unique IDs.
CURRENT_TIME_HASH = 212000
# Our project's current revision number, which is manually incremented.
REVISION_NUMBER = 1
# Assembling the full version string as per the protocol (W.X.Y).
current_version = "20250822.212000.1"
# Creating a unique integer hash for the current version for internal tracking.
current_version_hash = (CURRENT_DATE * CURRENT_TIME_HASH * REVISION_NUMBER)
# Getting the name of the current file to use in our logs, ensuring it's always accurate.
current_file = f"{os.path.basename(__file__)}"


class Application(tk.Tk):
    """
    The main application class that orchestrates the GUI build process.
    
    This class inherits from `tk.Tk`, making it the root of our application's GUI.
    It's responsible for setting up the main window and kicking off the dynamic
    GUI construction based on the folder structure. It now manages the state
    of detached tabs.
    """
    def __init__(self):
        """
        The constructor for our main application.
        
        It sets up the main window, applies styling, and starts the recursive
        process of building the GUI. It's the first function called upon app launch.
        """
        # We grab the name of the current function for our debug logs.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # üöÄ A celebratory log message to mark the start of our journey!
        debug_log(
            message="üñ•Ô∏èüü¢ The grand orchestrator is waking up! Let's get this GUI built!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        # --- NEW: State management dictionaries for tear-off tabs ---
        # We need a way to track which frames belong to which notebooks.
        self._notebooks = {}
        self._frames_by_path = {}
        self._detached_windows = {}
        # We'll store the name of the last selected tab for logging purposes.
        self.last_selected_tab_name = None

        try:
            # We must first call the parent class's constructor to initialize the Tkinter window.
            super().__init__()
            # Setting the title of our application window, which appears in the title bar.
            self.title("OPEN-AIR 2")
            # Defining the initial size of the window in pixels.
            self.geometry("1000x700")

            # --- NEW: Apply the selected theme ---
            # We call a helper method to apply our chosen theme and store the color palette.
            self.theme_colors = self._apply_styles(theme_name=DEFAULT_THEME)

            # üèóÔ∏è Let the dynamic building begin! We call our recursive builder function,
            # starting from the directory where this script resides.
            self._build_from_directory(path=pathlib.Path(__file__).parent, parent_widget=self)
            
            # üéâ A final cheer for a job well done!
            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            # üÜò Oh no, an error! We catch it here to prevent the app from crashing.
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            # We log the detailed error message for easier debugging.
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the entire application using ttk.Style.
        
        This method configures the look and feel of various `ttk` widgets based on
        the color and style information loaded from our `style` module.
        
        Args:
            theme_name (str): The name of the theme to apply.
            
        Returns:
            dict: The dictionary of colors from the applied theme.
        """
        # We grab the colors from our theme dictionary, defaulting to 'dark' if the theme isn't found.
        colors = THEMES.get(theme_name, THEMES["dark"])
        
        style = ttk.Style(self)
        style.theme_use("clam")

        # --- Configure widget styles ---
        # We configure the default style for all widgets ('.').
        # UPDATED: We use values from our theme for padding and borderwidth, making our styles consistent.
        style.configure('.',
                        background=colors["bg"],
                        foreground=colors["fg"],
                        font=('Helvetica', 10),
                        padding=colors["padding"],
                        borderwidth=colors["border_width"])

        # Specific configurations for `TFrame` widgets.
        style.configure('TFrame',
                        background=colors["bg"])

        # Specific configurations for `TNotebook` widgets (the container for our tabs).
        style.configure('TNotebook',
                        background=colors["primary"],
                        borderwidth=0)
        
        # This is a 'map' configuration, which defines how a widget's style changes
        # based on its state (e.g., 'selected' or not).
        style.map('TNotebook.Tab',
                  background=[('selected', colors["accent"]), ('!selected', colors["secondary"])],
                  foreground=[('selected', colors["text"]), ('!selected', colors["fg"])])

        # UPDATED: Applying padding from the theme to notebook tabs.
        # We calculate the tab padding based on our base padding value from the theme.
        tab_padding = [colors["padding"] * 10, colors["padding"] * 5]
        style.configure('TNotebook.Tab',
                        padding=tab_padding,
                        font=('Helvetica', 11, 'bold'),
                        borderwidth=0)

        # UPDATED: Applying padding and border_width from the theme to buttons.
        # We make the buttons' padding and border more prominent.
        style.configure('TButton',
                        background=colors["accent"],
                        foreground=colors["text"],
                        padding=colors["padding"] * 5,
                        relief=colors["relief"],
                        borderwidth=colors["border_width"] * 2)
        
        style.map('TButton',
                  background=[('active', colors["secondary"])])

        # --- Configure the main window background ---
        # We apply the main background color to the root window itself.
        self.configure(background=colors["bg"])
        
        # We return the color dictionary so other methods can access the theme's colors.
        return colors


    def _build_from_directory(self, path: pathlib.Path, parent_widget):
        """
        Recursively builds the GUI based on folder structure, supporting percentage-based layouts.
        
        This is the heart of the dynamic builder. It inspects a directory and decides
        what kind of Tkinter widget to create based on the folder naming convention.
        
        Args:
            path (pathlib.Path): The path to the current directory being processed.
            parent_widget: The Tkinter widget that will be the parent for new widgets.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        try:
            # We first get all the subdirectories and sort them for a consistent build order.
            sub_dirs = sorted([d for d in path.iterdir() if d.is_dir()])
            
            # We identify directories that define a layout (e.g., 'left_50', 'top_30').
            layout_dirs = [d for d in sub_dirs if d.name.split('_')[0] in ['left', 'right', 'top', 'bottom']]
            
            # If we find layout directories, we process them first. This is a top-down approach.
            if layout_dirs:
                # We check if the layout is horizontal or vertical.
                is_horizontal = any(d.name.startswith('left_') or d.name.startswith('right_') for d in layout_dirs)
                is_vertical = any(d.name.startswith('top_') or d.name.startswith('bottom_') for d in layout_dirs)

                # We log an error if a developer tries to mix horizontal and vertical layouts.
                if is_horizontal and is_vertical:
                    console_log(f"‚ùå Layout Error: Cannot mix horizontal and vertical layouts in '{path}'.")
                    return

                # We define a strict sort order to ensure 'left' is before 'right', 'top' before 'bottom', etc.
                sort_order = ['left', 'top', 'right', 'bottom']
                # We sort the layout directories according to our defined order.
                sorted_layout_dirs = sorted(layout_dirs, key=lambda d: sort_order.index(d.name.split('_')[0]))
                
                # --- Horizontal Layout Processing ---
                if is_horizontal:
                    # We keep track of the current horizontal position (relx).
                    current_relx = 0.0
                    for sub_dir in sorted_layout_dirs:
                        # We only process 'left' and 'right' directories in this block.
                        if sub_dir.name.split('_')[0] not in ['left', 'right']: continue
                        try:
                            # We parse the percentage from the folder name (e.g., 'left_50' gives us 50).
                            percentage = int(sub_dir.name.split('_')[1])
                            # We convert the percentage to a relative width.
                            rel_width = percentage / 100.0
                            # We create a new `ttk.Frame`, which is stylable.
                            # UPDATED: We use the theme's border and relief settings.
                            new_frame = ttk.Frame(parent_widget, borderwidth=self.theme_colors["border_width"], relief=self.theme_colors["relief"])
                            # We use `.place()` to position the frame with relative coordinates and size.
                            new_frame.place(relx=current_relx, rely=0, relwidth=rel_width, relheight=1.0)
                            # üîÑ We recursively call this function to build the contents of the new frame.
                            self._build_from_directory(path=sub_dir, parent_widget=new_frame)
                            # We update the horizontal position for the next frame.
                            current_relx += rel_width
                        except (IndexError, ValueError):
                            # A helpful warning if the folder name is not formatted correctly.
                            console_log(f"‚ö†Ô∏è Warning: Could not parse percentage from folder name '{sub_dir.name}'.")
                
                # --- Vertical Layout Processing ---
                elif is_vertical:
                    # We keep track of the current vertical position (rely).
                    current_rely = 0.0
                    for sub_dir in sorted_layout_dirs:
                        # We only process 'top' and 'bottom' directories in this block.
                        if sub_dir.name.split('_')[0] not in ['top', 'bottom']: continue
                        try:
                            # We parse the percentage from the folder name.
                            percentage = int(sub_dir.name.split('_')[1])
                            # We convert the percentage to a relative height.
                            rel_height = percentage / 100.0
                            # We create a new `ttk.Frame`.
                            # UPDATED: We use the theme's border and relief settings.
                            new_frame = ttk.Frame(parent_widget, borderwidth=self.theme_colors["border_width"], relief=self.theme_colors["relief"])
                            # We use `.place()` to position the frame with relative coordinates and size.
                            new_frame.place(relx=0, rely=current_rely, relwidth=1.0, relheight=rel_height)
                            # üîÑ We recursively call this function to build the contents of the new frame.
                            self._build_from_directory(path=sub_dir, parent_widget=new_frame)
                            # We update the vertical position for the next frame.
                            current_rely += rel_height
                        except (IndexError, ValueError):
                            # A helpful warning if the folder name is not formatted correctly.
                            console_log(f"‚ö†Ô∏è Warning: Could not parse percentage from folder name '{sub_dir.name}'.")
                # If we've processed a layout, we stop here.
                return

            # We check for directories that are meant to be a tab container.
            is_tab_container = any(d.name.startswith("tab_") or d.name.startswith("sub_tab_") for d in sub_dirs)
            if is_tab_container:
                # If it's a tab container, we create a `ttk.Notebook` widget.
                notebook = ttk.Notebook(parent_widget)
                # We use `.pack()` to make the notebook fill the entire parent widget.
                notebook.pack(fill=tk.BOTH, expand=True)
                
                # --- NEW: We register this notebook for tear-off functionality.
                notebook.bind('<Control-Button-1>', self._tear_off_tab)
                # üõ†Ô∏è We bind a new event to handle tab change logging.
                notebook.bind('<<NotebookTabChanged>>', self._on_tab_change)
                
                tab_dirs = [d for d in sub_dirs if d.name.startswith("tab_") or d.name.startswith("sub_tab_")]
                for tab_dir in tab_dirs:
                    # We create a new frame for each tab's content.
                    tab_frame = ttk.Frame(notebook)
                    
                    # --- NEW: We store a reference to this frame.
                    self._frames_by_path[tab_dir] = tab_frame
                    
                    # We parse the folder name to create a user-friendly display name for the tab.
                    # e.g., 'tab_1_main_page' becomes 'Main Page'.
                    parts = tab_dir.name.split('_')
                    start_index = next((i for i, part in enumerate(parts) if part.isdigit()), -1)
                    display_name = " ".join(parts[start_index + 1:]).title() if start_index != -1 else tab_dir.name
                    # We add the new frame as a tab to the notebook.
                    notebook.add(tab_frame, text=display_name)
                    # üîÑ We recursively build the contents of this new tab.
                    self._build_from_directory(path=tab_dir, parent_widget=tab_frame)
                # If we've processed tabs, we stop here.
                return

            # If no layout or tab directories were found, we look for child components.
            for sub_dir in sub_dirs:
                # We identify directories that contain a child component (e.g., 'child_1_button_panel').
                if sub_dir.name.startswith("child_"):
                    self._build_child_container(path=sub_dir, parent_widget=parent_widget)

            # We also look for direct Python files that define GUI components (e.g., 'gui_1_button_panel.py').
            py_files = [f for f in path.iterdir() if f.is_file() and f.name.startswith("gui_") and f.suffix == '.py']
            for py_file in py_files:
                self._build_child_container(path=py_file, parent_widget=parent_widget)

        except Exception as e:
            # Another safety net for errors during the recursive build process.
            console_log(f"‚ùå Error in {current_function_name} for path {path}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _build_child_container(self, path: pathlib.Path, parent_widget):
        """
        Dynamically imports and instantiates a GUI component from a Python file.
        
        This method is responsible for finding a Python file that defines a GUI component,
        importing it into memory, and then creating an instance of the component to
        add to the application's GUI hierarchy.
        
        Args:
            path (pathlib.Path): The path to the directory or file containing the component.
            parent_widget: The Tkinter widget that will be the parent for the new component.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        try:
            # We determine if the path is a directory or a direct file.
            if path.is_dir():
                # If it's a directory, we search for the 'gui_*.py' file inside it.
                gui_file = next(f for f in path.iterdir() if f.is_file() and f.name.startswith("gui_") and f.suffix == '.py')
            else:
                # If it's a file, we use the path directly.
                gui_file = path

            # ü™Ñ This is the magical part where we dynamically import the module.
            # We get the name of the module from the file's stem (e.g., 'gui_1_button_panel').
            module_name = gui_file.stem
            # We create a 'spec' which tells Python how to load our module.
            spec = importlib.util.spec_from_file_location(module_name, gui_file)
            # We create the module object from the spec.
            module = importlib.util.module_from_spec(spec)
            # We add our new module to the system's modules dictionary to make it accessible.
            sys.modules[module_name] = module
            # We execute the module, which runs its code and defines its functions and classes.
            spec.loader.exec_module(module)

            # --- üéØ REFACTORED: The "hardcoded part" you wanted to change! ---
            # We now iterate through all members (classes, functions, etc.) of the imported module.
            for name, obj in inspect.getmembers(module):
                # First, we check if the member is a class.
                if inspect.isclass(obj):
                    # We check if this class is a subclass of `ttk.Frame`.
                    # This is much more flexible than hardcoding a specific class name like "GUIFrame"!
                    if issubclass(obj, ttk.Frame):
                        # If we find a matching class, we instantiate it with the `parent_widget`.
                        frame_instance = obj(parent_widget)
                        # We pack the new frame to make it visible and fill its parent.
                        frame_instance.pack(fill=tk.BOTH, expand=True)
                        # We've found our class and built the frame, so we can break the loop and return.
                        return

                # We also check for functions that build the GUI.
                # This provides backward compatibility with the old naming convention.
                elif inspect.isfunction(obj):
                    # We check if the function's name matches our known component-building function.
                    if name == "create_yo_button_frame":
                        obj(parent_widget)
                        return # We've found and run the function, so we're done here.

            # üö® If we get here, it means we couldn't find a valid class or function in the imported module.
            raise AttributeError(f"Module '{module_name}' needs a class that inherits from 'ttk.Frame' or a 'create_yo_button_frame' function.")

        except Exception as e:
            # A final safety net for any errors during the import or execution of a child component.
            console_log(f"‚ùå Error importing or executing module at {path}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _tear_off_tab(self, event):
        """
        Tears a tab off of its Notebook and places it into a new Toplevel window.
        
        This method is triggered by a <Control-Button-1> event on a tab.
        It moves the selected tab's frame from the Notebook to its own new window.
        
        Args:
            event: The Tkinter event object.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        try:
            # We determine which notebook widget was clicked.
            notebook = event.widget
            # We use the event coordinates to find the tab that was clicked.
            tab_id = notebook.identify(event.x, event.y)
            if not tab_id:
                return # No tab was clicked, so we do nothing.
            
            # üéØ FIX: We need to use the `id` of the widget, not its text label.
            # This is the unique internal identifier for the tab's content frame.
            frame_id = notebook.tab(tab_id, "id")
            
            # We get the title of the tab to use for the new window.
            tab_title = notebook.tab(tab_id, "text")
            
            # If the frame is already detached, we do nothing.
            if frame_id in self._detached_windows:
                console_log(f"‚ö†Ô∏è Tab '{tab_title}' is already in a detached window.")
                return

            # We create a new top-level window.
            new_window = tk.Toplevel(self)
            new_window.title(tab_title)
            
            # We move the frame from the notebook to the new window.
            notebook.hide(tab_id)
            frame_id.pack(in_=new_window, fill=tk.BOTH, expand=True)
            
            # We store a reference to the detached window.
            self._detached_windows[frame_id] = {
                "window": new_window,
                "notebook": notebook,
                "tab_title": tab_title
            }
            
            # We bind the new window's close button to our re-attachment function.
            new_window.protocol("WM_DELETE_WINDOW", lambda: self._re_attach_tab(frame_id))

            console_log(f"‚úÖ Celebration of success! Tab '{tab_title}' has been detached.")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _re_attach_tab(self, frame):
        """
        Re-attaches a detached frame back to its original Notebook.
        
        This method is called when the user closes the detached Toplevel window.
        It moves the frame back to its original notebook and destroys the window.
        
        Args:
            frame: The Tkinter frame object that was detached.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        try:
            if frame not in self._detached_windows:
                return # Frame is not detached, so we do nothing.
            
            # We retrieve the notebook and title from our state dictionary.
            state = self._detached_windows[frame]
            notebook = state["notebook"]
            tab_title = state["tab_title"]
            window = state["window"]
            
            # We re-parent the frame back to its original notebook.
            frame.pack_forget()
            frame.pack(in_=notebook, fill=tk.BOTH, expand=True)
            
            # We add the tab back to the notebook at the same position.
            notebook.add(frame, text=tab_title)
            
            # We clean up our state dictionary and destroy the Toplevel window.
            del self._detached_windows[frame]
            window.destroy()
            
            console_log(f"‚úÖ Celebration of success! Tab '{tab_title}' has been re-attached.")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            
    def _on_tab_change(self, event):
        """
        Logs a debug message when a tab is selected or deselected.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"üîçüîµ Entering '{current_function_name}' to log a tab change.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            notebook = event.widget
            newly_selected_tab_id = notebook.select()
            newly_selected_tab_name = notebook.tab(newly_selected_tab_id, "text")

            if self.last_selected_tab_name:
                debug_log(
                    message=f"üìòüî¥ Tab '{self.last_selected_tab_name}' deselected!",
                    file=current_file,
                    version=current_version,
                    function=f"{self.__class__.__name__}.{current_function_name}",
                    console_print_func=console_log
                )

            debug_log(
                message=f"üìòüü¢ Tab '{newly_selected_tab_name}' selected!",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            
            self.last_selected_tab_name = newly_selected_tab_name
            
            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


# üèÉ This is the standard entry point for a Python script.
# The code inside this block only runs when the script is executed directly.
if __name__ == "__main__":
    # A friendly message to signal the start of the application.
    console_log("--- Initializing the Dynamic GUI Builder ---")
    
    # We create an instance of our main Application class.
    app = Application()
    # This call starts the Tkinter event loop, which handles all user interactions and keeps the window open.
    app.mainloop()
    # Once the mainloop exits (e.g., the user closes the window), this message is printed.
    console_log("--- Application closed. ---")


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_1_instrument\gui_tab_1_instrument.py
#####################################


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_1_instrument\sub_tab_1_connection\gui_child_1_connection.py
#####################################
# app/main_prototype_tkinter.py
#
# A standalone Tkinter GUI prototype demonstrating button-driven logging.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.234400.1

import os
import inspect
import datetime
import tkinter as tk

# --- Global Scope Variables ---
CURRENT_DATE = datetime.datetime.now().strftime("%Y%m%d")
CURRENT_TIME = datetime.datetime.now().strftime("%H%M%S")
# Note: For hashing, any leading zero in the hour is dropped (e.g., 083015 becomes 83015).
CURRENT_TIME_HASH = int(datetime.datetime.now().strftime("%H%M%S"))
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
current_file = f"{os.path.basename(__file__)}"

from configuration.logging import debug_log, console_log


class GUIFrame(tk.Frame):
    """
    A class that simulates a GUI frame with two buttons.
    It adheres to the "GUI" layer principles of your protocol.
    """
    def __init__(self, parent):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="üñ•Ô∏èüü¢ Initializing the GUI frame. The framework is taking shape!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent)
            self.pack(padx=20, pady=20)
            
            # Create a label for the frame
            frame_label = tk.Label(self, text="Application Frame", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'log_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log("Left button was clicked. Initiating a standard log entry.")
            console_log("‚úÖ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'debug_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="üîçüîµ The right button was clicked! Time for a deeper inspection!",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log("‚úÖ Debug entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

if __name__ == "__main__":
    root = tk.Tk()
    root.title("Logging Prototype")
    
    app_frame = GUIFrame(parent=root)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_1_instrument\sub_tab_2_settings\gui_child_2_settings.py
#####################################
#yo_button_prototype.py
#
# A prototype file that contains a simple GUI element to demonstrate the self-building logic.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250823.003500.1

import os
import inspect
import tkinter as tk
from tkinter import ttk
import datetime



# --- Global Scope Variables ---
CURRENT_DATE = datetime.datetime.now().strftime("%Y%m%d")
CURRENT_TIME = datetime.datetime.now().strftime("%H%M%S")
# Note: For hashing, any leading zero in the hour is dropped (e.g., 083015 becomes 83015).
CURRENT_TIME_HASH = int(datetime.datetime.now().strftime("%H%M%S"))
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
current_file = f"{os.path.basename(__file__)}"

# --- Constant Variables (No Magic Numbers) ---
BUTTON_TEXT = "YO"


def create_yo_button_frame(parent_widget):
    """
    Creates a frame containing a single button labeled "YO".
    """
    # [A brief, one-sentence description of the function's purpose.]
    current_function_name = inspect.currentframe().f_code.co_name

    try:
        # --- Function logic goes here ---
        frame = ttk.Frame(parent_widget, padding="10")
        button = ttk.Button(frame, text=BUTTON_TEXT)
        button.pack()

        
        return frame

    except Exception as e:
        return None



#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_1_instrument\sub_tab_2_settings\sub_tab_1_frequency\gui_child_2_settings.py
#####################################
# app/main_prototype_tkinter.py
#
# A standalone Tkinter GUI prototype demonstrating button-driven logging.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.214100.2

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk, scrolledtext

# --- Global Scope Variables (as per your instructions) ---
current_version = "20250822.214100.2"
# The hash calculation drops the leading zero from the hour, but 21 has no leading zero.
current_version_hash = (20250822 * 214100 * 2)
current_file = f"{os.path.basename(__file__)}"

# Assuming these are imported from a central logging utility as per the protocol.
# from configuration.logging import debug_log, console_log
# For this example, we'll define simple mock functions since the file was not provided.
def debug_log(message, file, version, function, console_print_func):
    """
    A mock debug logging function to adhere to the protocol's signature.
    """
    console_print_func(f"[DEBUG] {message}")

def console_log(message):
    """
    A mock console logging function.
    """
    print(message)

# Mock classes for a clean main file, as per the protocol.
from tabs.conductor.gui_mqtt_conductor import MqttConductorFrame
from styling.style import THEMES, DEFAULT_THEME


class App(tk.Tk):
    """
    The main application class, acting as the Program and Orchestration layer.
    """
    def __init__(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message=f"üñ•Ô∏èüü¢ Initializing the main application window. The grand experiment begins!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__()
            self.title("MQTT Control and Logging Prototype")
            self.geometry("800x600")

            self.style = ttk.Style(self)
            self.style.theme_use("clam")
            
            # Instantiate the main GUI frame as a container
            self.conductor_frame = MqttConductorFrame(parent=self)
            self.conductor_frame.pack(fill=tk.BOTH, expand=True)

            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    app = App()
    app.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_1_instrument\sub_tab_2_settings\sub_tab_2_Resolution\gui_child_2_resolution.py
#####################################
# app/main_prototype_tkinter.py
#
# A standalone Tkinter GUI prototype demonstrating button-driven logging.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.214100.2

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk, scrolledtext

# --- Global Scope Variables (as per your instructions) ---
current_version = "20250822.214100.2"
# The hash calculation drops the leading zero from the hour, but 21 has no leading zero.
current_version_hash = (20250822 * 214100 * 2)
current_file = f"{os.path.basename(__file__)}"

# Assuming these are imported from a central logging utility as per the protocol.
# from configuration.logging import debug_log, console_log
# For this example, we'll define simple mock functions since the file was not provided.
def debug_log(message, file, version, function, console_print_func):
    """
    A mock debug logging function to adhere to the protocol's signature.
    """
    console_print_func(f"[DEBUG] {message}")

def console_log(message):
    """
    A mock console logging function.
    """
    print(message)

# Mock classes for a clean main file, as per the protocol.
from tabs.conductor.gui_mqtt_conductor import MqttConductorFrame
from styling.style import THEMES, DEFAULT_THEME


class App(tk.Tk):
    """
    The main application class, acting as the Program and Orchestration layer.
    """
    def __init__(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message=f"üñ•Ô∏èüü¢ Initializing the main application window. The grand experiment begins!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__()
            self.title("MQTT Control and Logging Prototype")
            self.geometry("800x600")

            self.style = ttk.Style(self)
            self.style.theme_use("clam")
            
            # Instantiate the main GUI frame as a container
            self.conductor_frame = MqttConductorFrame(parent=self)
            self.conductor_frame.pack(fill=tk.BOTH, expand=True)

            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    app = App()
    app.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_1_instrument\sub_tab_2_settings\sub_tab_3_Amplitude\gui_child_3_amplitude.py
#####################################
# app/main_prototype_tkinter.py
#
# A standalone Tkinter GUI prototype demonstrating button-driven logging.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.214100.2

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk, scrolledtext

# --- Global Scope Variables (as per your instructions) ---
current_version = "20250822.214100.2"
# The hash calculation drops the leading zero from the hour, but 21 has no leading zero.
current_version_hash = (20250822 * 214100 * 2)
current_file = f"{os.path.basename(__file__)}"

# Assuming these are imported from a central logging utility as per the protocol.
# from configuration.logging import debug_log, console_log
# For this example, we'll define simple mock functions since the file was not provided.
def debug_log(message, file, version, function, console_print_func):
    """
    A mock debug logging function to adhere to the protocol's signature.
    """
    console_print_func(f"[DEBUG] {message}")

def console_log(message):
    """
    A mock console logging function.
    """
    print(message)

# Mock classes for a clean main file, as per the protocol.
from styling.style import THEMES, DEFAULT_THEME


class App(tk.Tk):
    """
    The main application class, acting as the Program and Orchestration layer.
    """
    def __init__(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message=f"üñ•Ô∏èüü¢ Initializing the main application window. The grand experiment begins!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__()
            self.title("MQTT Control and Logging Prototype")
            self.geometry("800x600")

            self.style = ttk.Style(self)
            self.style.theme_use("clam")
            
            # Instantiate the main GUI frame as a container
            self.conductor_frame = MqttConductorFrame(parent=self)
            self.conductor_frame.pack(fill=tk.BOTH, expand=True)

            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    app = App()
    app.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_1_instrument\sub_tab_2_settings\sub_tab_4_Trace Mode\gui_child_4_trace.py
#####################################
# app/main_prototype_tkinter.py
#
# A standalone Tkinter GUI prototype demonstrating button-driven logging.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.214100.2

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk, scrolledtext

# --- Global Scope Variables (as per your instructions) ---
current_version = "20250822.214100.2"
# The hash calculation drops the leading zero from the hour, but 21 has no leading zero.
current_version_hash = (20250822 * 214100 * 2)
current_file = f"{os.path.basename(__file__)}"

# Assuming these are imported from a central logging utility as per the protocol.
# from configuration.logging import debug_log, console_log
# For this example, we'll define simple mock functions since the file was not provided.
def debug_log(message, file, version, function, console_print_func):
    """
    A mock debug logging function to adhere to the protocol's signature.
    """
    console_print_func(f"[DEBUG] {message}")

def console_log(message):
    """
    A mock console logging function.
    """
    print(message)

# Mock classes for a clean main file, as per the protocol.
from tabs.conductor.gui_mqtt_conductor import MqttConductorFrame
from styling.style import THEMES, DEFAULT_THEME


class App(tk.Tk):
    """
    The main application class, acting as the Program and Orchestration layer.
    """
    def __init__(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message=f"üñ•Ô∏èüü¢ Initializing the main application window. The grand experiment begins!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__()
            self.title("MQTT Control and Logging Prototype")
            self.geometry("800x600")

            self.style = ttk.Style(self)
            self.style.theme_use("clam")
            
            # Instantiate the main GUI frame as a container
            self.conductor_frame = MqttConductorFrame(parent=self)
            self.conductor_frame.pack(fill=tk.BOTH, expand=True)

            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


if __name__ == "__main__":
    app = App()
    app.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_1_instrument\sub_tab_3_translator\gui_child_3_translator.py
#####################################
# tabs/Instrument/tab_instrument_child_visa_interpreter_gui.py
#
# A GUI-only prototype of the VISA Interpreter tab, structured as a self-contained element.
# This file handles the visual layout and user interactions, while delegating any
# business logic to other modules (currently simulated with dummy functions).
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.213500.1

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk
import pathlib
import sys

# --- Module Imports ---
# üìö We need to add the parent directory to the path to import our styling
# and logging modules, as they are located outside of this component's directory.
if str(pathlib.Path(__file__).resolve().parent.parent.parent) not in sys.path:
    sys.path.append(str(pathlib.Path(__file__).resolve().parent.parent.parent))

# Now that the path is set, we can confidently import our logging and theme data.
from configuration.logging import debug_log, console_log
from styling.style import THEMES, DEFAULT_THEME


# --- Global Scope Variables ---
# ‚è∞ As requested, the version is now hardcoded to the time this file was generated.
# The version strings and numbers below are static and will not change at runtime.
# This represents the date (YYYYMMDD) of file creation.
CURRENT_DATE = 20250822
# This represents the time (HHMMSS) of file creation.
CURRENT_TIME = 213500
# This is a numeric hash of the time, useful for unique IDs.
CURRENT_TIME_HASH = 213500
# Our project's current revision number, which is manually incremented.
REVISION_NUMBER = 1
# Assembling the full version string as per the protocol (W.X.Y).
current_version = "20250822.213500.1"
# Creating a unique integer hash for the current version for internal tracking.
current_version_hash = (CURRENT_DATE * CURRENT_TIME_HASH * REVISION_NUMBER)
# Getting the name of the current file to use in our logs, ensuring it's always accurate.
current_file = f"{os.path.basename(__file__)}"


# --- Constant Variables (No Magic Numbers) ---
COLUMNS = ("Manufacturer", "Model", "Command Type", "Action", "VISA Command", "Variable", "Validated")
EDITABLE_COLUMNS = ["VISA Command", "Variable", "Validated"]
STATUS_DISCONNECTED_TEXT = "Status: Disconnected"
STATUS_DISCONNECTED_COLOR = "red"
CONTROL_FRAME_TEXT = "Controls"
COMMAND_LABEL_TEXT = "Command:"
EXECUTE_BUTTON_TEXT = "Execute"
QUERY_BUTTON_TEXT = "Query"
SET_BUTTON_TEXT = "Set"
DO_BUTTON_TEXT = "Do"
LOAD_DATA_BUTTON_TEXT = "Load Data"
ADD_ROW_BUTTON_TEXT = "Add New Row"
SAVE_DATA_BUTTON_TEXT = "Save Data"
DELETE_ROW_BUTTON_TEXT = "Delete Row"
# A style name for our buttons.
BUTTON_STYLE_NAME = 'TButton'
# A constant for our dynamic topic name.
BASE_TOPIC = "visa_interpreter"


class Translatorframe(ttk.Frame):
    """
    This is the GUI-only version of VisaInterpreterTab. It provides the visual
    layout and interactive elements without any external logic for file
    handling, instrument communication, or logging.
    """
    def __init__(self, parent, *args, **kwargs):
        """
        Initializes the Translatorframe, setting up the GUI and data structures.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        # üü¢ We log the entry into the function with the "mad scientist" personality.
        debug_log(
            message=f"üñ•Ô∏èüü¢ Initializing the '{self.__class__.__name__}' GUI frame. The framework is taking shape!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            # We call the parent class's constructor, passing in the parent widget.
            super().__init__(parent, *args, **kwargs)
            self.sort_direction = {}
            self.last_selected_item = None
            
            # We apply the global style from our styling/style.py file
            self._apply_styles(theme_name=DEFAULT_THEME)

            # Dummy data for demonstration purposes
            self.data = [
                ["Tektronix", "MDO3000", "Query", "Read", "*IDN?", "", "True"],
                ["Tektronix", "MDO3000", "Action", "Set", "MEASUrement:IMMed:TYPe FREQuency", "", "False"],
                ["Keysight", "34461A", "Query", "Read", ":MEASure:VOLTage:DC?", "", "True"],
                ["Rohde & Schwarz", "HMC8012", "Action", "Do", "*RST", "", "True"],
            ]

            self.create_widgets()
            self.setup_layout()
            self.bind_events()
            self.load_data_to_treeview()
            self._set_ui_initial_state()

            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            # ‚ùå If an error occurs, we catch it here to prevent the application from crashing.
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            # We log a detailed error message with our "mad scientist" personality.
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            
    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        
        This helper method ensures that all the widgets in this frame use the
        colors and configurations defined in our style.py file.
        """
        # We get the color dictionary from the THEMES defined in style.py
        colors = THEMES.get(theme_name, THEMES["dark"])
        
        style = ttk.Style(self)
        style.theme_use("clam")

        # We configure the default style for all widgets
        style.configure('TFrame', background=colors["bg"])
        style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
        style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])
        
        # Configure the Treeview widget specifically
        style.configure('Treeview',
                        background=colors["primary"],
                        foreground=colors["fg"],
                        fieldbackground=colors["primary"],
                        bordercolor=colors["border"])
        
        # Configure the Treeview heading
        style.configure('Treeview.Heading',
                        background=colors["secondary"],
                        foreground=colors["fg"],
                        relief=colors["relief"],
                        borderwidth=colors["border_width"])

        # Configure the Entry widget
        style.configure('TEntry',
                        fieldbackground=colors["primary"],
                        foreground=colors["fg"],
                        bordercolor=colors["border"])
                        
    def _set_ui_initial_state(self):
        """
        Sets the initial disabled/disconnected state of the UI controls.
        """
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # üü¢ Entry log with the appropriate emoji prefix.
        debug_log(
            message=f"üñ•Ô∏èüü¢ Entering '{current_function_name}' to set initial UI state.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            self.status_label.configure(text=STATUS_DISCONNECTED_TEXT, foreground=STATUS_DISCONNECTED_COLOR)
            self.command_entry.config(state=tk.DISABLED)
            self.execute_command_button.config(state=tk.DISABLED)
            self.query_button.config(state=tk.DISABLED)
            self.set_button.config(state=tk.DISABLED)
            self.do_button.config(state=tk.DISABLED)

            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            # ‚ùå Error handling for this specific function.
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            # Detailed debug log with the error message.
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def load_data_to_treeview(self):
        """
        Loads data from the internal list into the Treeview widget.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        # üü¢ Entry log with the appropriate emoji prefix.
        debug_log(
            message=f"üñ•Ô∏èüü¢ Entering '{current_function_name}' to load data.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            for item in self.treeview.get_children():
                self.treeview.delete(item)
            
            for row in self.data:
                self.treeview.insert('', 'end', values=row)

            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def create_widgets(self):
        """
        Creates all the UI widgets for the tab.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message=f"üñ•Ô∏èüü¢ Entering '{current_function_name}' to create widgets.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            self.columnconfigure(0, weight=1)
            self.rowconfigure(0, weight=1)
            self.rowconfigure(1, weight=0)

            main_frame = ttk.Frame(self)
            main_frame.grid(row=0, column=0, sticky="nsew", padx=10, pady=10)
            main_frame.columnconfigure(0, weight=1)
            main_frame.rowconfigure(0, weight=1)

            tree_frame = ttk.Frame(main_frame)
            tree_frame.grid(row=0, column=0, sticky="nsew")
            tree_frame.rowconfigure(0, weight=1)
            tree_frame.columnconfigure(0, weight=1)

            self.treeview = ttk.Treeview(tree_frame, columns=COLUMNS, show="headings")
            self.treeview.pack(side="left", fill="both", expand=True)

            for col in COLUMNS:
                # We use named arguments for the command, as per the protocol.
                self.treeview.heading(col, text=col, command=lambda c=col: self._sort_treeview(tv=self.treeview, col=c))
                self.treeview.column(col, anchor="w", width=100)
                self.sort_direction[col] = 'asc'

            scrollbar = ttk.Scrollbar(tree_frame, orient="vertical", command=self.treeview.yview)
            self.treeview.configure(yscrollcommand=scrollbar.set)
            scrollbar.pack(side="right", fill="y")
            
            control_frame = ttk.LabelFrame(self, text=CONTROL_FRAME_TEXT)
            control_frame.grid(row=1, column=0, sticky="ew", padx=10, pady=5)
            control_frame.columnconfigure(1, weight=1)

            self.status_label = ttk.Label(control_frame, text=STATUS_DISCONNECTED_TEXT, foreground=STATUS_DISCONNECTED_COLOR)
            self.status_label.grid(row=0, column=0, columnspan=2, sticky="ew", padx=5, pady=2)

            ttk.Label(control_frame, text=COMMAND_LABEL_TEXT).grid(row=1, column=0, sticky="w", padx=5, pady=2)
            self.command_entry = ttk.Entry(control_frame)
            self.command_entry.grid(row=1, column=1, sticky="ew", padx=5, pady=2)
            # We use named arguments for the command, as per the protocol.
            self.command_entry.bind('<Return>', lambda e: self._on_execute_command(command=self.command_entry.get().strip()))

            button_frame = ttk.Frame(control_frame)
            button_frame.grid(row=2, column=0, columnspan=2, sticky="ew", padx=5, pady=5)
            for i in range(4): button_frame.columnconfigure(i, weight=1)

            # We use named arguments for the command, as per the protocol.
            self.execute_command_button = ttk.Button(button_frame, text=EXECUTE_BUTTON_TEXT, command=lambda: self._on_execute_command(command=self.command_entry.get().strip()))
            self.execute_command_button.grid(row=0, column=0, sticky="ew", padx=2, pady=2)

            # We use named arguments for the command, as per the protocol.
            self.query_button = ttk.Button(button_frame, text=QUERY_BUTTON_TEXT, command=lambda: self._on_query_command(command=self.command_entry.get().strip()))
            self.query_button.grid(row=0, column=1, sticky="ew", padx=2, pady=2)
            
            # We use named arguments for the command, as per the protocol.
            self.set_button = ttk.Button(button_frame, text=SET_BUTTON_TEXT, command=lambda: self._on_set_command(command=self.command_entry.get().strip()))
            self.set_button.grid(row=0, column=2, sticky="ew", padx=2, pady=2)
            
            # We use named arguments for the command, as per the protocol.
            self.do_button = ttk.Button(button_frame, text=DO_BUTTON_TEXT, command=lambda: self._on_do_command(command=self.command_entry.get().strip()))
            self.do_button.grid(row=0, column=3, sticky="ew", padx=2, pady=2)

            action_frame = ttk.Frame(control_frame)
            action_frame.grid(row=3, column=0, columnspan=2, sticky="ew", padx=5, pady=5)
            for i in range(4): action_frame.columnconfigure(i, weight=1)

            # We use named arguments for the command, as per the protocol.
            ttk.Button(action_frame, text=LOAD_DATA_BUTTON_TEXT, command=self.load_data_to_treeview).grid(row=0, column=0, sticky="ew", padx=2, pady=2)
            ttk.Button(action_frame, text=ADD_ROW_BUTTON_TEXT, command=self._add_new_row).grid(row=0, column=1, sticky="ew", padx=2, pady=2)
            ttk.Button(action_frame, text=SAVE_DATA_BUTTON_TEXT, command=self._save_data_dummy).grid(row=0, column=2, sticky="ew", padx=2, pady=2)
            ttk.Button(action_frame, text=DELETE_ROW_BUTTON_TEXT, command=self._delete_selected_row).grid(row=0, column=3, sticky="ew", padx=2, pady=2)
            
            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            
    def setup_layout(self):
        """
        Configures the grid layout for the main frame.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message=f"üñ•Ô∏èüü¢ Entering '{current_function_name}' to configure layout.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            self.grid_rowconfigure(0, weight=1)
            self.grid_columnconfigure(0, weight=1)

            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )


    def bind_events(self):
        """
        Binds all the necessary UI events to their handlers.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message=f"üñ•Ô∏èüü¢ Entering '{current_function_name}' to bind events.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            self.treeview.bind("<Double-1>", self._on_double_click)
            self.treeview.bind("<<TreeviewSelect>>", self._on_treeview_select)
            self.treeview.bind("<FocusIn>", self._on_treeview_focus)

            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_treeview_focus(self, event):
        """
        Restores selection when the treeview gains focus.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message=f"üñ•Ô∏èüü¢ Entering '{current_function_name}' to restore focus.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            if not self.treeview.selection() and self.last_selected_item:
                self.treeview.selection_set(self.last_selected_item)
                self.treeview.focus(self.last_selected_item)

            console_log("‚úÖ Celebration of success!")
        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_treeview_select(self, event):
        """
        Handles row selection, updating the command entry box.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message=f"üñ•Ô∏èüü¢ Entering '{current_function_name}' to update command entry.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            selection = self.treeview.selection()
            if selection:
                self.last_selected_item = selection[0]
                values = self.treeview.item(selection[0], 'values')
                if values:
                    self.command_entry.delete(0, tk.END)
                    if len(values) > 4 and values[4] is not None:
                        self.command_entry.insert(0, values[4])

            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _on_double_click(self, event):
        """
        Handles double-click events to enable cell editing.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message=f"üñ•Ô∏èüü¢ Entering '{current_function_name}' to initiate cell edit.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            item = self.treeview.identify_row(event.y)
            col = self.treeview.identify_column(event.x)
            if item and col:
                col_index = int(col.replace('#', '')) - 1
                column_name = self.treeview['columns'][col_index]
                if column_name in EDITABLE_COLUMNS:
                    self._edit_cell(item=item, col_index=col_index)

            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _edit_cell(self, item, col_index):
        """
        Creates an entry widget for editing a treeview cell.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message=f"üñ•Ô∏èüü¢ Entering '{current_function_name}' to display a cell editor.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            x, y, width, height = self.treeview.bbox(item, col_index)
            original_text = self.treeview.item(item, 'values')[col_index]

            entry = ttk.Entry(self.treeview)
            entry.place(x=x, y=y, width=width, height=height, anchor='nw')
            entry.insert(0, original_text)
            entry.focus_set()

            def on_entry_change(e):
                new_values = list(self.treeview.item(item, 'values'))
                new_values[col_index] = entry.get()
                self.treeview.item(item, values=new_values)
                entry.destroy()
                self.last_selected_item = item
                self._save_data_dummy()

            entry.bind("<Return>", on_entry_change)
            entry.bind("<FocusOut>", lambda e: entry.destroy())

            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _add_new_row(self):
        """
        Adds a new, empty row to the Treeview and the internal data list.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message=f"üñ•Ô∏èüü¢ Entering '{current_function_name}' to add a new row.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            new_row = [""] * len(COLUMNS)
            self.data.append(new_row)
            self.treeview.insert('', 'end', values=new_row)
            self._save_data_dummy()

            console_log("‚úÖ Celebration of success!")
        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _delete_selected_row(self):
        """
        Deletes the currently selected row from the Treeview and internal data.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message=f"üñ•Ô∏èüü¢ Entering '{current_function_name}' to delete a row.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            selected_items = self.treeview.selection()
            if not selected_items:
                return
            
            for item in selected_items:
                values = self.treeview.item(item, 'values')
                self.treeview.delete(item)
                # This check is needed because values can be a mix of strings and other types
                if list(values) in self.data:
                    self.data.remove(list(values))
            
            self._save_data_dummy()

            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _save_data_dummy(self):
        """
        This is a dummy function. The actual save logic has been removed.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message=f"üñ•Ô∏èüü¢ Entering '{current_function_name}' to perform dummy save.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            print("GUI Action: Save data (dummy).")
            
            console_log("‚úÖ Celebration of success!")
            
        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _sort_treeview(self, tv, col):
        """
        Sorts the treeview column when a heading is clicked.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message=f"üñ•Ô∏èüü¢ Entering '{current_function_name}' to sort treeview.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            items = list(tv.get_children(''))
            
            direction = self.sort_direction.get(col, 'asc')
            reverse = (direction == 'desc')

            # Simple string sort for GUI-only version
            sorted_items = sorted(items, key=lambda x: tv.set(x, col), reverse=reverse)

            for index, item in enumerate(sorted_items):
                tv.move(item, '', index)

            self.sort_direction[col] = 'asc' if reverse else 'desc'
            
            # Reset other column headers
            for c in COLUMNS:
                tv.heading(c, text=c)
            
            # Update current column header with sort indicator
            indicator = ' ‚ñ≤' if not reverse else ' ‚ñº'
            tv.heading(col, text=col + indicator)

            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            
    def _on_execute_command(self, command):
        """
        Logs a message for a simulated command execution.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message=f"üñ•Ô∏èüü¢ Entering '{current_function_name}' to simulate a command.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # We construct a dynamic topic name using the class name.
            topic = f"{BASE_TOPIC}/{self.__class__.__name__}/{EXECUTE_BUTTON_TEXT.lower()}"
            console_log(f"Simulating publish to topic: '{topic}' with command: {command}")
            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
        
    def _on_query_command(self, command):
        """
        Logs a message for a simulated query command.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message=f"üñ•Ô∏èüü¢ Entering '{current_function_name}' to simulate a query.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        try:
            # We construct a dynamic topic name using the class name.
            topic = f"{BASE_TOPIC}/{self.__class__.__name__}/{QUERY_BUTTON_TEXT.lower()}"
            console_log(f"Simulating publish to topic: '{topic}' with command: {command}")
            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
        
    def _on_set_command(self, command):
        """
        Logs a message for a simulated set command.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message=f"üñ•Ô∏èüü¢ Entering '{current_function_name}' to simulate a set.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # We construct a dynamic topic name using the class name.
            topic = f"{BASE_TOPIC}/{self.__class__.__name__}/{SET_BUTTON_TEXT.lower()}"
            console_log(f"Simulating publish to topic: '{topic}' with command: {command}")
            console_log("‚úÖ Celebration of success!")
            
        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
        
    def _on_do_command(self, command):
        """
        Logs a message for a simulated do command.
        """
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message=f"üñ•Ô∏èüü¢ Entering '{current_function_name}' to simulate a do.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # We construct a dynamic topic name using the class name.
            topic = f"{BASE_TOPIC}/{self.__class__.__name__}/{DO_BUTTON_TEXT.lower()}"
            console_log(f"Simulating publish to topic: '{topic}' with command: {command}")
            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

def create_visa_interpreter_tab(parent_widget):
    """
    Creates and returns an instance of the VisaInterpreterTab frame.
    """
    current_function_name = inspect.currentframe().f_code.co_name

    try:
        # --- Function logic goes here ---
        frame = Translatorframe(parent_widget)
        return frame
    except Exception as e:
        console_log(f"‚ùå Error creating VisaInterpreterTab in {current_function_name}: {e}")
        return None


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_2_markers\gui_left_side.py
#####################################


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_2_markers\sub_tab_1_showtime\gui_child_1_showtime.py
#####################################
# app/main_prototype_tkinter.py
#
# A standalone Tkinter GUI prototype demonstrating button-driven logging.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.234400.1

import os
import inspect
import datetime
import tkinter as tk

# --- Global Scope Variables ---
CURRENT_DATE = datetime.datetime.now().strftime("%Y%m%d")
CURRENT_TIME = datetime.datetime.now().strftime("%H%M%S")
# Note: For hashing, any leading zero in the hour is dropped (e.g., 083015 becomes 83015).
CURRENT_TIME_HASH = int(datetime.datetime.now().strftime("%H%M%S"))
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
current_file = f"{os.path.basename(__file__)}"

from configuration.logging import debug_log, console_log


class GUIFrame(tk.Frame):
    """
    A class that simulates a GUI frame with two buttons.
    It adheres to the "GUI" layer principles of your protocol.
    """
    def __init__(self, parent):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="üñ•Ô∏èüü¢ Initializing the GUI frame. The framework is taking shape!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent)
            self.pack(padx=20, pady=20)
            
            # Create a label for the frame
            frame_label = tk.Label(self, text="Application Frame", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'log_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log("Left button was clicked. Initiating a standard log entry.")
            console_log("‚úÖ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'debug_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="üîçüîµ The right button was clicked! Time for a deeper inspection!",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log("‚úÖ Debug entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

if __name__ == "__main__":
    root = tk.Tk()
    root.title("Logging Prototype")
    
    app_frame = GUIFrame(parent=root)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_2_markers\sub_tab_2_editor\gui_child_2_editor.py
#####################################
# app/main_prototype_tkinter.py
#
# A standalone Tkinter GUI prototype demonstrating button-driven logging.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.234400.1

import os
import inspect
import datetime
import tkinter as tk

# --- Global Scope Variables ---
CURRENT_DATE = datetime.datetime.now().strftime("%Y%m%d")
CURRENT_TIME = datetime.datetime.now().strftime("%H%M%S")
# Note: For hashing, any leading zero in the hour is dropped (e.g., 083015 becomes 83015).
CURRENT_TIME_HASH = int(datetime.datetime.now().strftime("%H%M%S"))
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
current_file = f"{os.path.basename(__file__)}"

from configuration.logging import debug_log, console_log


class GUIFrame(tk.Frame):
    """
    A class that simulates a GUI frame with two buttons.
    It adheres to the "GUI" layer principles of your protocol.
    """
    def __init__(self, parent):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="üñ•Ô∏èüü¢ Initializing the GUI frame. The framework is taking shape!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent)
            self.pack(padx=20, pady=20)
            
            # Create a label for the frame
            frame_label = tk.Label(self, text="Application Frame", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'log_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log("Left button was clicked. Initiating a standard log entry.")
            console_log("‚úÖ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'debug_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="üîçüîµ The right button was clicked! Time for a deeper inspection!",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log("‚úÖ Debug entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

if __name__ == "__main__":
    root = tk.Tk()
    root.title("Logging Prototype")
    
    app_frame = GUIFrame(parent=root)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_3_presets\gui_tab_3_presets.py
#####################################
#yo_button_prototype.py
#
# A prototype file that contains a simple GUI element to demonstrate the self-building logic.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250823.003500.1

import os
import inspect
import tkinter as tk
from tkinter import ttk
import datetime



# --- Global Scope Variables ---
CURRENT_DATE = datetime.datetime.now().strftime("%Y%m%d")
CURRENT_TIME = datetime.datetime.now().strftime("%H%M%S")
# Note: For hashing, any leading zero in the hour is dropped (e.g., 083015 becomes 83015).
CURRENT_TIME_HASH = int(datetime.datetime.now().strftime("%H%M%S"))
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
current_file = f"{os.path.basename(__file__)}"

# --- Constant Variables (No Magic Numbers) ---
BUTTON_TEXT = "YO"


def create_yo_button_frame(parent_widget):
    """
    Creates a frame containing a single button labeled "YO".
    """
    # [A brief, one-sentence description of the function's purpose.]
    current_function_name = inspect.currentframe().f_code.co_name

    try:
        # --- Function logic goes here ---
        frame = ttk.Frame(parent_widget, padding="10")
        button = ttk.Button(frame, text=BUTTON_TEXT)
        button.pack()

        
        return frame

    except Exception as e:
        return None



#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_3_presets\sub_tab_1_pusher\gui_child_1_pusher.py
#####################################
# app/main_prototype_tkinter.py
#
# A standalone Tkinter GUI prototype demonstrating button-driven logging.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.234400.1

import os
import inspect
import datetime
import tkinter as tk

# --- Global Scope Variables ---
CURRENT_DATE = datetime.datetime.now().strftime("%Y%m%d")
CURRENT_TIME = datetime.datetime.now().strftime("%H%M%S")
# Note: For hashing, any leading zero in the hour is dropped (e.g., 083015 becomes 83015).
CURRENT_TIME_HASH = int(datetime.datetime.now().strftime("%H%M%S"))
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
current_file = f"{os.path.basename(__file__)}"

from configuration.logging import debug_log, console_log


class GUIFrame(tk.Frame):
    """
    A class that simulates a GUI frame with two buttons.
    It adheres to the "GUI" layer principles of your protocol.
    """
    def __init__(self, parent):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="üñ•Ô∏èüü¢ Initializing the GUI frame. The framework is taking shape!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent)
            self.pack(padx=20, pady=20)
            
            # Create a label for the frame
            frame_label = tk.Label(self, text="Application Frame", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'log_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log("Left button was clicked. Initiating a standard log entry.")
            console_log("‚úÖ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'debug_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="üîçüîµ The right button was clicked! Time for a deeper inspection!",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log("‚úÖ Debug entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

if __name__ == "__main__":
    root = tk.Tk()
    root.title("Logging Prototype")
    
    app_frame = GUIFrame(parent=root)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_3_presets\sub_tab_2_editor\gui_child_2_editor.py
#####################################
# app/main_prototype_tkinter.py
#
# A standalone Tkinter GUI prototype demonstrating button-driven logging.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.234400.1

import os
import inspect
import datetime
import tkinter as tk

# --- Global Scope Variables ---
CURRENT_DATE = datetime.datetime.now().strftime("%Y%m%d")
CURRENT_TIME = datetime.datetime.now().strftime("%H%M%S")
# Note: For hashing, any leading zero in the hour is dropped (e.g., 083015 becomes 83015).
CURRENT_TIME_HASH = int(datetime.datetime.now().strftime("%H%M%S"))
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
current_file = f"{os.path.basename(__file__)}"

from configuration.logging import debug_log, console_log


class GUIFrame(tk.Frame):
    """
    A class that simulates a GUI frame with two buttons.
    It adheres to the "GUI" layer principles of your protocol.
    """
    def __init__(self, parent):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="üñ•Ô∏èüü¢ Initializing the GUI frame. The framework is taking shape!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent)
            self.pack(padx=20, pady=20)
            
            # Create a label for the frame
            frame_label = tk.Label(self, text="Application Frame", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'log_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log("Left button was clicked. Initiating a standard log entry.")
            console_log("‚úÖ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'debug_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="üîçüîµ The right button was clicked! Time for a deeper inspection!",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log("‚úÖ Debug entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

if __name__ == "__main__":
    root = tk.Tk()
    root.title("Logging Prototype")
    
    app_frame = GUIFrame(parent=root)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_3_presets\sub_tab_3_collector\gui_child_3_collector.py
#####################################
# app/main_prototype_tkinter.py
#
# A standalone Tkinter GUI prototype demonstrating button-driven logging.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.234400.1

import os
import inspect
import datetime
import tkinter as tk

# --- Global Scope Variables ---
CURRENT_DATE = datetime.datetime.now().strftime("%Y%m%d")
CURRENT_TIME = datetime.datetime.now().strftime("%H%M%S")
# Note: For hashing, any leading zero in the hour is dropped (e.g., 083015 becomes 83015).
CURRENT_TIME_HASH = int(datetime.datetime.now().strftime("%H%M%S"))
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
current_file = f"{os.path.basename(__file__)}"

from configuration.logging import debug_log, console_log


class GUIFrame(tk.Frame):
    """
    A class that simulates a GUI frame with two buttons.
    It adheres to the "GUI" layer principles of your protocol.
    """
    def __init__(self, parent):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="üñ•Ô∏èüü¢ Initializing the GUI frame. The framework is taking shape!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent)
            self.pack(padx=20, pady=20)
            
            # Create a label for the frame
            frame_label = tk.Label(self, text="Application Frame", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'log_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log("Left button was clicked. Initiating a standard log entry.")
            console_log("‚úÖ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'debug_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="üîçüîµ The right button was clicked! Time for a deeper inspection!",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log("‚úÖ Debug entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

if __name__ == "__main__":
    root = tk.Tk()
    root.title("Logging Prototype")
    
    app_frame = GUIFrame(parent=root)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_4_intermod\gui_tab_4_intermod.py
#####################################


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_4_intermod\sub_tab_1_calculator\gui_child_1_calculator.py
#####################################
# app/main_prototype_tkinter.py
#
# A standalone Tkinter GUI prototype demonstrating button-driven logging.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.234400.1

import os
import inspect
import datetime
import tkinter as tk

# --- Global Scope Variables ---
CURRENT_DATE = datetime.datetime.now().strftime("%Y%m%d")
CURRENT_TIME = datetime.datetime.now().strftime("%H%M%S")
# Note: For hashing, any leading zero in the hour is dropped (e.g., 083015 becomes 83015).
CURRENT_TIME_HASH = int(datetime.datetime.now().strftime("%H%M%S"))
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
current_file = f"{os.path.basename(__file__)}"

from configuration.logging import debug_log, console_log


class GUIFrame(tk.Frame):
    """
    A class that simulates a GUI frame with two buttons.
    It adheres to the "GUI" layer principles of your protocol.
    """
    def __init__(self, parent):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="üñ•Ô∏èüü¢ Initializing the GUI frame. The framework is taking shape!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent)
            self.pack(padx=20, pady=20)
            
            # Create a label for the frame
            frame_label = tk.Label(self, text="Application Frame", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'log_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log("Left button was clicked. Initiating a standard log entry.")
            console_log("‚úÖ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'debug_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="üîçüîµ The right button was clicked! Time for a deeper inspection!",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log("‚úÖ Debug entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

if __name__ == "__main__":
    root = tk.Tk()
    root.title("Logging Prototype")
    
    app_frame = GUIFrame(parent=root)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_4_intermod\sub_tab_2_future\gui_1_top.py
#####################################
# app/main_prototype_tkinter.py
#
# A standalone Tkinter GUI prototype demonstrating button-driven logging.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.234400.1

import os
import inspect
import datetime
import tkinter as tk

# --- Global Scope Variables ---
CURRENT_DATE = datetime.datetime.now().strftime("%Y%m%d")
CURRENT_TIME = datetime.datetime.now().strftime("%H%M%S")
# Note: For hashing, any leading zero in the hour is dropped (e.g., 083015 becomes 83015).
CURRENT_TIME_HASH = int(datetime.datetime.now().strftime("%H%M%S"))
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
current_file = f"{os.path.basename(__file__)}"

from configuration.logging import debug_log, console_log


class GUIFrame(tk.Frame):
    """
    A class that simulates a GUI frame with two buttons.
    It adheres to the "GUI" layer principles of your protocol.
    """
    def __init__(self, parent):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="üñ•Ô∏èüü¢ Initializing the GUI frame. The framework is taking shape!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent)
            self.pack(padx=20, pady=20)
            
            # Create a label for the frame
            frame_label = tk.Label(self, text="Application Frame", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'log_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log("Left button was clicked. Initiating a standard log entry.")
            console_log("‚úÖ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'debug_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="üîçüîµ The right button was clicked! Time for a deeper inspection!",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log("‚úÖ Debug entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

if __name__ == "__main__":
    root = tk.Tk()
    root.title("Logging Prototype")
    
    app_frame = GUIFrame(parent=root)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_4_intermod\sub_tab_2_future\gui_2_bottom copy.py
#####################################
# app/main_prototype_tkinter.py
#
# A standalone Tkinter GUI prototype demonstrating button-driven logging.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.234400.1

import os
import inspect
import datetime
import tkinter as tk

# --- Global Scope Variables ---
CURRENT_DATE = datetime.datetime.now().strftime("%Y%m%d")
CURRENT_TIME = datetime.datetime.now().strftime("%H%M%S")
# Note: For hashing, any leading zero in the hour is dropped (e.g., 083015 becomes 83015).
CURRENT_TIME_HASH = int(datetime.datetime.now().strftime("%H%M%S"))
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
current_file = f"{os.path.basename(__file__)}"

from configuration.logging import debug_log, console_log


class GUIFrame(tk.Frame):
    """
    A class that simulates a GUI frame with two buttons.
    It adheres to the "GUI" layer principles of your protocol.
    """
    def __init__(self, parent):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="üñ•Ô∏èüü¢ Initializing the GUI frame. The framework is taking shape!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent)
            self.pack(padx=20, pady=20)
            
            # Create a label for the frame
            frame_label = tk.Label(self, text="2 Application Frame", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'log_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log("Left button was clicked. Initiating a standard log entry.")
            console_log("‚úÖ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'debug_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="üîçüîµ The right button was clicked! Time for a deeper inspection!",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log("‚úÖ Debug entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

if __name__ == "__main__":
    root = tk.Tk()
    root.title("Logging Prototype")
    
    app_frame = GUIFrame(parent=root)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_4_intermod\sub_tab_2_future\gui_44_last.py
#####################################
# app/main_prototype_tkinter.py
#
# A standalone Tkinter GUI prototype demonstrating button-driven logging.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.234400.1

import os
import inspect
import datetime
import tkinter as tk

# --- Global Scope Variables ---
CURRENT_DATE = datetime.datetime.now().strftime("%Y%m%d")
CURRENT_TIME = datetime.datetime.now().strftime("%H%M%S")
# Note: For hashing, any leading zero in the hour is dropped (e.g., 083015 becomes 83015).
CURRENT_TIME_HASH = int(datetime.datetime.now().strftime("%H%M%S"))
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
current_file = f"{os.path.basename(__file__)}"

from configuration.logging import debug_log, console_log


class GUIFrame(tk.Frame):
    """
    A class that simulates a GUI frame with two buttons.
    It adheres to the "GUI" layer principles of your protocol.
    """
    def __init__(self, parent):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="üñ•Ô∏èüü¢ Initializing the GUI frame. The framework is taking shape!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent)
            self.pack(padx=20, pady=20)
            
            # Create a label for the frame
            frame_label = tk.Label(self, text="44 Application Frame", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'log_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log("Left button was clicked. Initiating a standard log entry.")
            console_log("‚úÖ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'debug_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="üîçüîµ The right button was clicked! Time for a deeper inspection!",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log("‚úÖ Debug entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

if __name__ == "__main__":
    root = tk.Tk()
    root.title("Logging Prototype")
    
    app_frame = GUIFrame(parent=root)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_5_sweeping\tab_5_sweeping.py
#####################################


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_5_sweeping\sub_tab_1_single\gui_child_1_single.py
#####################################
# app/main_prototype_tkinter.py
#
# A standalone Tkinter GUI prototype demonstrating button-driven logging.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.234400.1

import os
import inspect
import datetime
import tkinter as tk

# --- Global Scope Variables ---
CURRENT_DATE = datetime.datetime.now().strftime("%Y%m%d")
CURRENT_TIME = datetime.datetime.now().strftime("%H%M%S")
# Note: For hashing, any leading zero in the hour is dropped (e.g., 083015 becomes 83015).
CURRENT_TIME_HASH = int(datetime.datetime.now().strftime("%H%M%S"))
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
current_file = f"{os.path.basename(__file__)}"

from configuration.logging import debug_log, console_log


class GUIFrame(tk.Frame):
    """
    A class that simulates a GUI frame with two buttons.
    It adheres to the "GUI" layer principles of your protocol.
    """
    def __init__(self, parent):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="üñ•Ô∏èüü¢ Initializing the GUI frame. The framework is taking shape!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent)
            self.pack(padx=20, pady=20)
            
            # Create a label for the frame
            frame_label = tk.Label(self, text="Application Frame", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'log_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log("Left button was clicked. Initiating a standard log entry.")
            console_log("‚úÖ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'debug_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="üîçüîµ The right button was clicked! Time for a deeper inspection!",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log("‚úÖ Debug entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

if __name__ == "__main__":
    root = tk.Tk()
    root.title("Logging Prototype")
    
    app_frame = GUIFrame(parent=root)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_5_sweeping\sub_tab_2_statistical\gui_child_2_statistical.py
#####################################
# app/main_prototype_tkinter.py
#
# A standalone Tkinter GUI prototype demonstrating button-driven logging.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.234400.1

import os
import inspect
import datetime
import tkinter as tk

# --- Global Scope Variables ---
CURRENT_DATE = datetime.datetime.now().strftime("%Y%m%d")
CURRENT_TIME = datetime.datetime.now().strftime("%H%M%S")
# Note: For hashing, any leading zero in the hour is dropped (e.g., 083015 becomes 83015).
CURRENT_TIME_HASH = int(datetime.datetime.now().strftime("%H%M%S"))
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
current_file = f"{os.path.basename(__file__)}"

from configuration.logging import debug_log, console_log


class GUIFrame(tk.Frame):
    """
    A class that simulates a GUI frame with two buttons.
    It adheres to the "GUI" layer principles of your protocol.
    """
    def __init__(self, parent):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="üñ•Ô∏èüü¢ Initializing the GUI frame. The framework is taking shape!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent)
            self.pack(padx=20, pady=20)
            
            # Create a label for the frame
            frame_label = tk.Label(self, text="Application Frame", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'log_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log("Left button was clicked. Initiating a standard log entry.")
            console_log("‚úÖ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'debug_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="üîçüîµ The right button was clicked! Time for a deeper inspection!",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log("‚úÖ Debug entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

if __name__ == "__main__":
    root = tk.Tk()
    root.title("Logging Prototype")
    
    app_frame = GUIFrame(parent=root)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_6_graphing\gui_tab_6_graphing.py
#####################################


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_6_graphing\sub_tab_1_from_file\gui_child1_from_file.py
#####################################
# app/main_prototype_tkinter.py
#
# A standalone Tkinter GUI prototype demonstrating button-driven logging.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.234400.1

import os
import inspect
import datetime
import tkinter as tk

# --- Global Scope Variables ---
CURRENT_DATE = datetime.datetime.now().strftime("%Y%m%d")
CURRENT_TIME = datetime.datetime.now().strftime("%H%M%S")
# Note: For hashing, any leading zero in the hour is dropped (e.g., 083015 becomes 83015).
CURRENT_TIME_HASH = int(datetime.datetime.now().strftime("%H%M%S"))
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
current_file = f"{os.path.basename(__file__)}"

from configuration.logging import debug_log, console_log


class GUIFrame(tk.Frame):
    """
    A class that simulates a GUI frame with two buttons.
    It adheres to the "GUI" layer principles of your protocol.
    """
    def __init__(self, parent):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="üñ•Ô∏èüü¢ Initializing the GUI frame. The framework is taking shape!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent)
            self.pack(padx=20, pady=20)
            
            # Create a label for the frame
            frame_label = tk.Label(self, text="Application Frame", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'log_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log("Left button was clicked. Initiating a standard log entry.")
            console_log("‚úÖ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'debug_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="üîçüîµ The right button was clicked! Time for a deeper inspection!",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log("‚úÖ Debug entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

if __name__ == "__main__":
    root = tk.Tk()
    root.title("Logging Prototype")
    
    app_frame = GUIFrame(parent=root)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\left_60\top_100\tab_7_exepriment\gui_7_experiment.py
#####################################
# app/main_prototype_tkinter.py
#
# A standalone Tkinter GUI prototype demonstrating button-driven logging.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.234400.1

import os
import inspect
import datetime
import tkinter as tk

# --- Global Scope Variables ---
CURRENT_DATE = datetime.datetime.now().strftime("%Y%m%d")
CURRENT_TIME = datetime.datetime.now().strftime("%H%M%S")
# Note: For hashing, any leading zero in the hour is dropped (e.g., 083015 becomes 83015).
CURRENT_TIME_HASH = int(datetime.datetime.now().strftime("%H%M%S"))
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
current_file = f"{os.path.basename(__file__)}"

from configuration.logging import debug_log, console_log


class GUIFrame(tk.Frame):
    """
    A class that simulates a GUI frame with two buttons.
    It adheres to the "GUI" layer principles of your protocol.
    """
    def __init__(self, parent):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="üñ•Ô∏èüü¢ Initializing the GUI frame. The framework is taking shape!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent)
            self.pack(padx=20, pady=20)
            
            # Create a label for the frame
            frame_label = tk.Label(self, text="Application Frame", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'log_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log("Left button was clicked. Initiating a standard log entry.")
            console_log("‚úÖ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'debug_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="üîçüîµ The right button was clicked! Time for a deeper inspection!",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log("‚úÖ Debug entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

if __name__ == "__main__":
    root = tk.Tk()
    root.title("Logging Prototype")
    
    app_frame = GUIFrame(parent=root)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\right_40\bottom_90\tab_1_scan\gui_tab_1_scan.py
#####################################
# app/main_prototype_tkinter.py
#
# A standalone Tkinter GUI prototype demonstrating button-driven logging.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.234400.1

import os
import inspect
import datetime
import tkinter as tk

# --- Global Scope Variables ---
CURRENT_DATE = datetime.datetime.now().strftime("%Y%m%d")
CURRENT_TIME = datetime.datetime.now().strftime("%H%M%S")
# Note: For hashing, any leading zero in the hour is dropped (e.g., 083015 becomes 83015).
CURRENT_TIME_HASH = int(datetime.datetime.now().strftime("%H%M%S"))
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
current_file = f"{os.path.basename(__file__)}"

from configuration.logging import debug_log, console_log


class GUIFrame(tk.Frame):
    """
    A class that simulates a GUI frame with two buttons.
    It adheres to the "GUI" layer principles of your protocol.
    """
    def __init__(self, parent):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="üñ•Ô∏èüü¢ Initializing the GUI frame. The framework is taking shape!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent)
            self.pack(padx=20, pady=20)
            
            # Create a label for the frame
            frame_label = tk.Label(self, text="Application Frame", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'log_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log("Left button was clicked. Initiating a standard log entry.")
            console_log("‚úÖ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'debug_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="üîçüîµ The right button was clicked! Time for a deeper inspection!",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log("‚úÖ Debug entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

if __name__ == "__main__":
    root = tk.Tk()
    root.title("Logging Prototype")
    
    app_frame = GUIFrame(parent=root)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\right_40\bottom_90\tab_2_monitors\gui_tab_2_monitors.py
#####################################
# app/main_prototype_tkinter.py
#
# A standalone Tkinter GUI prototype demonstrating button-driven logging.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.234400.1

import os
import inspect
import datetime
import tkinter as tk

# --- Global Scope Variables ---
CURRENT_DATE = datetime.datetime.now().strftime("%Y%m%d")
CURRENT_TIME = datetime.datetime.now().strftime("%H%M%S")
# Note: For hashing, any leading zero in the hour is dropped (e.g., 083015 becomes 83015).
CURRENT_TIME_HASH = int(datetime.datetime.now().strftime("%H%M%S"))
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
current_file = f"{os.path.basename(__file__)}"

from configuration.logging import debug_log, console_log


class GUIFrame(tk.Frame):
    """
    A class that simulates a GUI frame with two buttons.
    It adheres to the "GUI" layer principles of your protocol.
    """
    def __init__(self, parent):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="üñ•Ô∏èüü¢ Initializing the GUI frame. The framework is taking shape!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent)
            self.pack(padx=20, pady=20)
            
            # Create a label for the frame
            frame_label = tk.Label(self, text="Application Frame", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'log_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log("Left button was clicked. Initiating a standard log entry.")
            console_log("‚úÖ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'debug_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="üîçüîµ The right button was clicked! Time for a deeper inspection!",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log("‚úÖ Debug entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

if __name__ == "__main__":
    root = tk.Tk()
    root.title("Logging Prototype")
    
    app_frame = GUIFrame(parent=root)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\right_40\bottom_90\tab_3_debug\gui_tab_3_debug.py
#####################################
# app/main_prototype_tkinter.py
#
# A standalone Tkinter GUI prototype demonstrating button-driven logging.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250821.234400.1

import os
import inspect
import datetime
import tkinter as tk

# --- Global Scope Variables ---
CURRENT_DATE = datetime.datetime.now().strftime("%Y%m%d")
CURRENT_TIME = datetime.datetime.now().strftime("%H%M%S")
# Note: For hashing, any leading zero in the hour is dropped (e.g., 083015 becomes 83015).
CURRENT_TIME_HASH = int(datetime.datetime.now().strftime("%H%M%S"))
REVISION_NUMBER = 1
current_version = f"{CURRENT_DATE}.{CURRENT_TIME}.{REVISION_NUMBER}"
current_version_hash = (int(CURRENT_DATE) * CURRENT_TIME_HASH * REVISION_NUMBER)
current_file = f"{os.path.basename(__file__)}"

from configuration.logging import debug_log, console_log


class GUIFrame(tk.Frame):
    """
    A class that simulates a GUI frame with two buttons.
    It adheres to the "GUI" layer principles of your protocol.
    """
    def __init__(self, parent):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message="üñ•Ô∏èüü¢ Initializing the GUI frame. The framework is taking shape!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent)
            self.pack(padx=20, pady=20)
            
            # Create a label for the frame
            frame_label = tk.Label(self, text="Application Frame", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            self.log_button = tk.Button(
                self, 
                text="Log", 
                command=self.log_button_press
            )
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            self.debug_button = tk.Button(
                self, 
                text="Debug", 
                command=self.debug_button_press
            )
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'log_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log("Left button was clicked. Initiating a standard log entry.")
            console_log("‚úÖ Log entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # Entry log
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'debug_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            debug_log(
                message="üîçüîµ The right button was clicked! Time for a deeper inspection!",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            console_log("‚úÖ Debug entry recorded successfully!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

if __name__ == "__main__":
    root = tk.Tk()
    root.title("Logging Prototype")
    
    app_frame = GUIFrame(parent=root)
    
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\right_40\bottom_90\tab_4_conductor\gui_1_mqtt_conductor.py
#####################################
# tabs/conductor/gui_mqtt_conductor.py
#
# This file defines a GUI component for managing and testing an MQTT broker and client.
# It adheres to the GUI layer principles of the protocol.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.215800.6

import os
import inspect
import datetime
import tkinter as tk
from tkinter import ttk, scrolledtext
# The following import is removed as path manipulation should be centralized in the main application file.
# import sys
# import pathlib

# --- Module Imports ---
# Now that the path is set by the main app, we can confidently import our logging module!
from configuration.logging import debug_log, console_log
from styling.style import THEMES, DEFAULT_THEME
from utils.mqtt_controller_util import MqttControllerUtility

# --- Global Scope Variables ---
current_version = "20250822.215800.6"
# The hash calculation drops the leading zero from the hour, but 21 has no leading zero.
current_version_hash = (20250822 * 215800 * 6)
current_file = f"{os.path.basename(__file__)}"

# --- Constant Variables (No Magic Numbers) ---
# Text for UI elements
PUBLISH_FRAME_TEXT = "Publish Message"
TOPIC_LABEL_TEXT = "Topic:"
SUBTOPIC_LABEL_TEXT = "Subtopic:"
SLIDER_LABEL_TEXT = "Value:"
PUBLISH_BUTTON_TEXT = "Publish"
SUBSCRIPTIONS_FRAME_TEXT = "Live Subscriptions"
SUBSCRIPTIONS_TOPIC_COL_TEXT = "Topic"
SUBSCRIPTIONS_MESSAGE_COL_TEXT = "Message"

class MqttConductorFrame(ttk.Frame):
    """
    A GUI frame for controlling and monitoring a local MQTT broker.
    It adheres to the "GUI" layer principles of your protocol.
    """
    def __init__(self, parent, *args, **kwargs):
        """
        Initializes the MQTT Conductor Frame.

        Args:
            parent: The parent widget for this frame.
        """
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # The initial debug_log must use the global console_log since log_to_gui doesn't exist yet.
        debug_log(
            message=f"üêêüü¢ Initializing the '{self.__class__.__name__}' GUI frame.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            super().__init__(parent, *args, **kwargs)
            # The pack call is handled by the parent widget, as per the design of the main app.
            # self.pack(pady=10, padx=10, fill=tk.BOTH, expand=True)

            self.create_widgets() # This must be called first to create self.log_text

            # Now that log_to_gui and log_to_table are available, we can set our utility functions
            self._print_to_gui_console = self.log_to_gui
            self._log_to_treeview = self.log_to_table
            
            # Now we can safely call _apply_styles, which uses a logging function that relies on an existing widget.
            self.theme_colors = self._apply_styles(theme_name=DEFAULT_THEME)

            self.mqtt_util = MqttControllerUtility(
                print_to_gui_func=self._print_to_gui_console,
                log_treeview_func=self._log_to_treeview
            )

            self.mqtt_util.connect_mqtt()

            # Now that everything is set up, log the success.
            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def _apply_styles(self, theme_name: str):
        """
        Applies the specified theme to the GUI elements using ttk.Style.
        
        Args:
            theme_name (str): The name of the theme to apply.
        """
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name

        debug_log(
            message=f"üêêüü¢ Entering '{current_function_name}' to apply styling.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=self.log_to_gui
        )
        try:
            # --- Function logic goes here ---
            # Correcting the function call to use positional arguments.
            colors = THEMES.get(theme_name, THEMES["dark"])
            style = ttk.Style(self)
            style.theme_use("clam")
            
            style.configure('TFrame', background=colors["bg"])
            style.configure('TLabel', background=colors["bg"], foreground=colors["fg"])
            style.configure('TLabelframe', background=colors["bg"], foreground=colors["fg"])
            style.configure('TButton', background=colors["accent"], foreground=colors["text"])
            style.configure('TEntry', fieldbackground=colors["primary"], foreground=colors["fg"])
            style.configure('ScrolledText', background=colors["primary"], foreground=colors["fg"])
            style.configure('Treeview', background=colors["primary"], foreground=colors["fg"], fieldbackground=colors["bg"])
            style.configure('Treeview.Heading', font=("Arial", 12, "bold"))

            self.log_to_gui("‚úÖ Celebration of success!")
            return colors
        except Exception as e:
            self.log_to_gui(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self.log_to_gui
            )
            return THEMES["dark"]

    def create_widgets(self):
        """
        Creates all the UI widgets for the tab.
        """
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message=f"üêêüü¢ Entering '{current_function_name}' to create widgets.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            # Main button frame for broker controls
            button_frame = ttk.Frame(master=self)
            button_frame.pack(pady=10, padx=10, fill=tk.X)
            for i in range(5):
                button_frame.columnconfigure(index=i, weight=1)

            # Broker control buttons
            self.start_btn = ttk.Button(master=button_frame, text="Start Mosquitto", command=self.mqtt_util.start_mosquitto)
            self.start_btn.grid(row=0, column=0, padx=5, sticky="ew")

            self.stop_btn = ttk.Button(master=button_frame, text="Stop Mosquitto", command=self.mqtt_util.stop_mosquitto)
            self.stop_btn.grid(row=0, column=1, padx=5, sticky="ew")

            self.status_btn = ttk.Button(master=button_frame, text="Check Status", command=self.mqtt_util.check_status)
            self.status_btn.grid(row=0, column=2, padx=5, sticky="ew")

            # MQTT client controls
            self.connect_btn = ttk.Button(master=button_frame, text="Connect MQTT", command=self.mqtt_util.connect_mqtt)
            self.connect_btn.grid(row=0, column=3, padx=5, sticky="ew")

            self.topics_btn = ttk.Button(master=button_frame, text="Show Topics", command=self.mqtt_util.show_topics)
            self.topics_btn.grid(row=0, column=4, padx=5, sticky="ew")

            # Publish frame with new elements
            self.pub_frame = ttk.LabelFrame(master=self, text=PUBLISH_FRAME_TEXT)
            self.pub_frame.pack(pady=10, padx=10, fill=tk.X, expand=False)
            self.pub_frame.columnconfigure(index=1, weight=1)
            self.pub_frame.columnconfigure(index=3, weight=1)
            self.pub_frame.columnconfigure(index=5, weight=1)

            self.topic_label = ttk.Label(master=self.pub_frame, text=TOPIC_LABEL_TEXT)
            self.topic_label.grid(row=0, column=0, padx=5, pady=5, sticky="e")
            self.topic_entry = ttk.Entry(master=self.pub_frame)
            self.topic_entry.grid(row=0, column=1, padx=5, pady=5, sticky="ew")

            self.subtopic_label = ttk.Label(master=self.pub_frame, text=SUBTOPIC_LABEL_TEXT)
            self.subtopic_label.grid(row=0, column=2, padx=5, pady=5, sticky="e")
            self.subtopic_var = tk.StringVar(self)
            self.subtopic_dropdown = ttk.Combobox(master=self.pub_frame, textvariable=self.subtopic_var, values=["TEST 1", "TEST 2", "TEST 3"])
            self.subtopic_dropdown.grid(row=0, column=3, padx=5, pady=5, sticky="ew")
            self.subtopic_dropdown.set("TEST 1")

            self.slider_label = ttk.Label(master=self.pub_frame, text=SLIDER_LABEL_TEXT)
            self.slider_label.grid(row=1, column=0, padx=5, pady=5, sticky="e")
            self.slider_var = tk.DoubleVar()
            self.slider = ttk.Scale(master=self.pub_frame, from_=1, to=100, orient=tk.HORIZONTAL, variable=self.slider_var, command=lambda x: self.update_slider_label())
            self.slider.grid(row=1, column=1, columnspan=3, padx=5, pady=5, sticky="ew")
            self.slider_value_label = ttk.Label(master=self.pub_frame, text="50.0")
            self.slider_value_label.grid(row=1, column=4, padx=5, pady=5, sticky="w")
            self.slider.set(50)

            self.pub_btn = ttk.Button(master=self.pub_frame, text=PUBLISH_BUTTON_TEXT, command=lambda: self.mqtt_util.publish_message(
                topic=self.topic_entry.get(),
                subtopic=self.subtopic_var.get(),
                value=self.slider_var.get()
            ))
            self.pub_btn.grid(row=0, column=4, padx=5, sticky="ew")
            self.pub_btn.configure(command=lambda: self.mqtt_util.publish_message(topic=self.topic_entry.get(), subtopic=self.subtopic_var.get(), value=self.slider_var.get()))

            # Live Subscriptions Table
            self.subscriptions_frame = ttk.LabelFrame(master=self, text=SUBSCRIPTIONS_FRAME_TEXT)
            self.subscriptions_frame.pack(pady=10, padx=10, fill=tk.BOTH, expand=True)

            self.subscriptions_table = ttk.Treeview(master=self.subscriptions_frame, columns=(SUBSCRIPTIONS_TOPIC_COL_TEXT, SUBSCRIPTIONS_MESSAGE_COL_TEXT), show="headings")
            self.subscriptions_table.heading(SUBSCRIPTIONS_TOPIC_COL_TEXT, text=SUBSCRIPTIONS_TOPIC_COL_TEXT)
            self.subscriptions_table.heading(SUBSCRIPTIONS_MESSAGE_COL_TEXT, text=SUBSCRIPTIONS_MESSAGE_COL_TEXT)
            self.subscriptions_table.pack(fill=tk.BOTH, expand=True)

            # Log display
            self.log_text = scrolledtext.ScrolledText(master=self, wrap=tk.WORD, width=80, height=10, background=self.theme_colors['primary'], foreground=self.theme_colors['fg'])
            self.log_text.pack(pady=10, padx=10, fill=tk.BOTH, expand=True)

            console_log("‚úÖ Celebration of success!")
            
        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_to_gui(self, message):
        """
        Logs a message to the GUI's scrolled text box.
        """
        self.log_text.insert(tk.END, message + "\n")
        self.log_text.see(tk.END)

    def update_slider_label(self):
        """
        Updates the label next to the slider with the current value.
        """
        self.slider_value_label.configure(text=f"{self.slider_var.get():.1f}")
        
    def log_to_table(self, topic, message):
        """
        Logs a message to the Treeview table.
        """
        self.subscriptions_table.insert(parent="", index="end", values=(topic, message))
        self.subscriptions_table.see(self.subscriptions_table.get_children()[-1])


#####################################
### File: OPEN-AIR 2\display\right_40\bottom_90\tab_5_configuration\gui_tab_5_configuration.py
#####################################


#####################################
### File: OPEN-AIR 2\display\right_40\top_10\gui_right_side.py
#####################################
# app/main_prototype_tkinter.py
#
# A standalone Tkinter GUI prototype demonstrating button-driven logging. This file
# serves as a test bed for the core application framework and logging protocol.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.190800.1

# üìö Importing our necessary Python modules to build the application.
import os
import inspect
import datetime
import tkinter as tk
# We'll use the ttk version of Frame for better styling consistency.
from tkinter import ttk

# We assume this is imported from a central logging utility, as per the protocol.
from configuration.logging import debug_log, console_log

# --- Global Scope Variables ---
# ‚è∞ As requested, the version is now hardcoded to the time this file was generated.
# The following variables are static and will not change at runtime.
# W: This represents the date (YYYYMMDD) of file creation.
CURRENT_DATE = 20250822
# X: This represents the time (HHMMSS) of file creation.
CURRENT_TIME = 190800
# A numeric hash of the time, useful for unique IDs.
CURRENT_TIME_HASH = 190800
# Y: Our project's current revision number for this file.
REVISION_NUMBER = 1
# Assembling the full version string as per the protocol (W.X.Y).
current_version = "20250822.190800.1"
# Creating a unique integer hash for the current version for internal tracking.
current_version_hash = (CURRENT_DATE * CURRENT_TIME_HASH * REVISION_NUMBER)
# Getting the name of the current file to use in our logs, ensuring it's always accurate.
current_file = f"{os.path.basename(__file__)}"


class Start_stop(ttk.Frame):
    """
    A class that simulates a GUI frame with two buttons.
    
    It adheres to the "GUI" layer principles of your protocol, handling display and
    user interaction, but delegating any core logic to other components (simulated here
    by the log and debug functions).
    """
    def __init__(self, parent):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # üü¢ We log the entry into the function with the "mad scientist" personality.
        debug_log(
            message="üñ•Ô∏èüü¢ Initializing the GUI frame. The framework is taking shape!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )
        
        try:
            # --- Function logic goes here ---
            # We call the parent class's constructor, passing in the parent widget.
            super().__init__(parent)
            # We use pack() to arrange the frame within its parent widget.
            self.pack(padx=20, pady=20)
            
            # Create a label for the frame to give it a clear purpose and title.
            frame_label = tk.Label(self, text="Application Frame", font=("Arial", 16))
            frame_label.pack(pady=10)
            
            # Button 1: Log
            # üí° We pass arguments by name, as required by the protocol.
            self.log_button = tk.Button(
                master=self,
                text="Log",
                command=self.log_button_press
            )
            # We pack the button on the left side of the frame.
            self.log_button.pack(side=tk.LEFT, padx=10, pady=10)
            
            # Button 2: Debug
            # üí° We pass arguments by name, as required by the protocol.
            self.debug_button = tk.Button(
                master=self,
                text="Debug",
                command=self.debug_button_press
            )
            # We pack the button on the left side of the frame, next to the first button.
            self.debug_button.pack(side=tk.LEFT, padx=10, pady=10)

            # ‚úÖ A celebratory log message for a successful initialization!
            console_log("‚úÖ Celebration of success!")

        except Exception as e:
            # ‚ùå If an error occurs, we catch it here to prevent the application from crashing.
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            # We log a detailed error message with our "mad scientist" personality.
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def log_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        # This function is triggered when the "Log" button is clicked.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # üü¢ Entry log with the appropriate emoji prefix.
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'log_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            console_log("Left button was clicked. Initiating a standard log entry.")
            
            # ‚úÖ Success!
            console_log("‚úÖ Log entry recorded successfully!")

        except Exception as e:
            # ‚ùå Error handling for this specific function.
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            # Detailed debug log with the error message.
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

    def debug_button_press(self):
        # A brief, one-sentence description of the function's purpose.
        # This function is triggered when the "Debug" button is clicked.
        current_function_name = inspect.currentframe().f_code.co_name
        
        # üü¢ Entry log with the appropriate emoji prefix.
        debug_log(
            message="üñ•Ô∏èüü¢ Entering 'debug_button_press' from the GUI layer.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=console_log
        )

        try:
            # --- Function logic goes here ---
            # üîçüîµ We add a specific debug log to show a deeper inspection is taking place.
            debug_log(
                message="üîçüîµ The right button was clicked! Time for a deeper inspection!",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )
            
            # ‚úÖ Success!
            console_log("‚úÖ Debug entry recorded successfully!")

        except Exception as e:
            # ‚ùå Error handling for this specific function.
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            # Detailed debug log with the error message.
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=console_log
            )

# üèÉ This is the standard entry point for a Python script.
# The code inside this block only runs when the script is executed directly.
if __name__ == "__main__":
    # We create the root window of the application.
    root = tk.Tk()
    root.title("Logging Prototype")
    
    # We create an instance of our Start_stop class and pass the root window as the parent.
    # We pass the argument by name as required.
    app_frame = Start_stop(parent=root)
    
    # This call starts the Tkinter event loop, which listens for user actions and keeps the window open.
    root.mainloop()


#####################################
### File: OPEN-AIR 2\display\styling\style.py
#####################################
# styling/style.py
#
# Defines the color palettes for different UI themes, providing a centralized
# source for application-wide style configurations.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.210500.1

# üìö Standard library import for the global variables.
import os

# --- Global Scope Variables ---
# W: The date of the chat session in YYYYMMDD format.
CURRENT_DATE = 20250822
# X: The time of the chat session in HHMMSS format.
CURRENT_TIME = 210500
# A numeric hash of the time, useful for unique IDs.
CURRENT_TIME_HASH = 210500
# Y: The revision number within the current session.
REVISION_NUMBER = 1
# Assembling the full version string as per the protocol (W.X.Y).
current_version = "20250822.210500.1"
# Creating a unique integer hash for the current version for internal tracking.
current_version_hash = (CURRENT_DATE * CURRENT_TIME_HASH * REVISION_NUMBER)
# Getting the name of the current file to use in our logs.
current_file = f"{os.path.basename(__file__)}"

# üé® THEMES is a dictionary that holds all our color palettes.
THEMES = {
    # üåë The "dark" theme, inspired by dark IDE color schemes.
    "dark": {
        # "bg" (background): The main, default background color for the application.
        "bg": "#2b2b2b",
        # "fg" (foreground): The main, default text color for most elements.
        "fg": "#dcdcdc",
        # "primary": The background color for major containers and frames.
        "primary": "#3c3f41",
        # "secondary": A slightly lighter background color for nested containers or inactive tabs.
        "secondary": "#4e5254",
        # "accent": A bright color used for interactive elements like buttons and selected tabs.
        "accent": "#007acc",
        # "text": The color for text that appears on an accent color background.
        "text": "#ffffff",
        # "border": The color of borders around widgets and containers.
        "border": "#555555",
        # "relief": The style of the border, 'solid' works well with dark themes.
        "relief": "solid",
        # "border_width": The width of the border in pixels.
        "border_width": 1,
        # "padding": A base value for spacing around widgets.
        "padding": 1,
        # "tab_content_padding": Padding specifically for the content inside a tab.
        "tab_content_padding": 1,
        # "accent_colors": A list of colors for a dynamic accent palette, for use in graphs or custom widgets.
        "accent_colors": [
            "#996633",  # 1. Brown
            "#c75450",  # 2. Red
            "#d18616",  # 3. Orange
            "#dcdcaa",  # 4. Yellow
            "#6a9955",  # 5. Green
            "#007acc",  # 6. Blue
            "#6464a3",  # 7. Violet
            "#ce9178",  # 8. Tan
            "#b5cea8",  # 9. Gray-Green
        ]
    },
    # üåû The "light" theme, providing a high-contrast alternative.
    "light": {
        # "bg" (background): A light gray background for the overall application.
        "bg": "#f0f0f0",
        # "fg" (foreground): Black text for high readability.
        "fg": "#000000",
        # "primary": A clean white background for main content areas.
        "primary": "#ffffff",
        # "secondary": A lighter gray for minor elements or inactive tabs.
        "secondary": "#e0e0e0",
        # "accent": A vibrant blue for interactive elements.
        "accent": "#0078d7",
        # "text": A standard black for text on the accent color.
        "text": "#000000",
        # "border": A neutral gray for borders.
        "border": "#ababab",
        # "relief": The border style, 'groove' gives a slightly indented, classic look.
        "relief": "groove",
        # "border_width": The width of the border.
        "border_width": 1,
        # "padding": A base value for spacing.
        "padding": 1,
        # "tab_content_padding": Padding for content inside a tab.
        "tab_content_padding": 1,
        # "accent_colors": A separate list of vibrant colors for graphs and dynamic elements in the light theme.
        "accent_colors": [
            "#A0522D",  # 1. Brown (Sienna)
            "#D22B2B",  # 2. Red (Firebrick)
            "#FF8C00",  # 3. Orange (DarkOrange)
            "#FFD700",  # 4. Yellow (Gold)
            "#228B22",  # 5. Green (ForestGreen)
            "#4169E1",  # 6. Blue (RoyalBlue)
            "#8A2BE2",  # 7. Violet (BlueViolet)
            "#D2691E",  # 8. Tan (Chocolate)
            "#556B2F",  # 9. Gray-Green (DarkOliveGreen)
        ]
    }
}

# üõ†Ô∏è The default theme to use. This can be changed here to easily switch the entire application's style.
DEFAULT_THEME = "dark"


#####################################
### File: OPEN-AIR 2\utils\mqtt_controller_util.py
#####################################
# utils/mqtt_controller_util.py
#
# A utility module to handle the logic for interfacing with an external MQTT broker.
#
# Author: Anthony Peter Kuzub
# Blog: www.Like.audio (Contributor to this project)
#
# Professional services for customizing and tailoring this software to your specific
# application can be negotiated. There is no charge to use, modify, or fork this software.
#
# Build Log: https://like.audio/category/software/spectrum-scanner/
# Source Code: https://github.com/APKaudio/
# Feature Requests can be emailed to i @ like . audio
#
#
# Version 20250822.215400.3

import os
import inspect
import datetime
import paho.mqtt.client as mqtt
import subprocess
import threading
import json
import pathlib
import sys

# --- Module Imports ---
if str(pathlib.Path(__file__).resolve().parent.parent) not in sys.path:
    sys.path.append(str(pathlib.Path(__file__).resolve().parent.parent))

from configuration.logging import debug_log, console_log

# --- Global Scope Variables (as per your instructions) ---
current_version = "20250822.215400.3"
# The hash calculation drops the leading zero from the hour, but 21 has no leading zero.
current_version_hash = (20250822 * 215400 * 3)
current_file = f"{os.path.basename(__file__)}"

# --- Constant Variables (No Magic Numbers) ---
# MQTT Broker settings
BROKER_ADDRESS = "localhost"
BROKER_PORT = 1883
BROKER_TIMEOUT = 60
# Logging messages and colors
BROKER_RUNNING_MSG = "Broker is running"
BROKER_NOT_RUNNING_MSG = "Broker is not running"
BROKER_ALREADY_RUNNING_MSG = "Mosquitto is already running!"
FAILED_TO_START_BROKER_MSG = "Failed to start mosquitto process: "
BROKER_STOPPED_MSG = "Broker stopped"
NOT_CONNECTED_MSG = "Not connected to broker."
NO_TOPIC_OR_VALUE_MSG = "Please enter a topic and a value."


class MqttControllerUtility:
    """
    Manages all communication logic for the MQTT broker and client.
    This class is the central point for all functions to push a message or subscribe to messages.
    It adheres to the "Utilities" layer principles of your protocol.
    """
    def __init__(self, print_to_gui_func, log_treeview_func):
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        
        debug_log(
            message=f"üõ†Ô∏èüü¢ Initializing the '{self.__class__.__name__}' utility class. Powering up the flux capacitor!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=print_to_gui_func
        )
        
        try:
            # --- Function logic goes here ---
            self.mosquitto_process = None
            self.mqtt_client = None
            self._print_to_gui_console = print_to_gui_func
            self._log_to_treeview = log_treeview_func
            self.topics_seen = set()

            console_log("‚úÖ Celebration of success!")
        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self._print_to_gui_console
            )

    # --- Broker and MQTT Methods ---
    def start_mosquitto(self):
        """Starts the Mosquitto broker process if it's not already running."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"üõ†Ô∏èüü¢ Entering '{current_function_name}' to start the broker.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=self._print_to_gui_console
        )
        try:
            if self.mosquitto_process and self.mosquitto_process.poll() is None:
                console_log(f"‚ö†Ô∏è {BROKER_ALREADY_RUNNING_MSG}")
                return
            
            self.mosquitto_process = subprocess.Popen(args=["mosquitto"])
            console_log("‚úÖ Broker started successfully!")
            
        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {FAILED_TO_START_BROKER_MSG}{e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self._print_to_gui_console
            )

    def stop_mosquitto(self):
        """Stops the Mosquitto broker process if it's running."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"üõ†Ô∏èüü¢ Entering '{current_function_name}' to stop the broker.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=self._print_to_gui_console
        )
        try:
            if self.mosquitto_process and self.mosquitto_process.poll() is None:
                self.mosquitto_process.terminate()
                self.mosquitto_process = None
                console_log(f"‚úÖ {BROKER_STOPPED_MSG}")
            else:
                console_log(f"‚ö†Ô∏è {BROKER_NOT_RUNNING_MSG}")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self._print_to_gui_console
            )

    def check_status(self):
        """Checks and reports the status of the Mosquitto broker."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"üõ†Ô∏èüü¢ Entering '{current_function_name}' to check broker status.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=self._print_to_gui_console
        )
        try:
            if self.mosquitto_process and self.mosquitto_process.poll() is None:
                console_log(f"‚úÖ {BROKER_RUNNING_MSG}")
            else:
                console_log(f"‚ùå {BROKER_NOT_RUNNING_MSG}")

        except Exception as e:
            console_log(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self._print_to_gui_console
            )

    def on_connect(self, client, userdata, flags, rc):
        """Callback for when the MQTT client connects to the broker."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"üõ†Ô∏èüîµ MQTT client connected with rc={rc}. Subscribing to all topics!",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=self._print_to_gui_console
        )
        # Subscribe to all topics
        client.subscribe("#")
        self._print_to_gui_console(f"Connected to broker with rc={rc}")

    def on_message(self, client, userdata, msg):
        """Callback for when an MQTT message is received."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"üõ†Ô∏èüîµ Received a message from topic '{msg.topic}'.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=self._print_to_gui_console
        )
        
        topic = msg.topic
        payload = msg.payload.decode()
        self.topics_seen.add(topic)
        self._log_to_treeview(topic=topic, message=payload)

    def connect_mqtt(self):
        """Connects the MQTT client to the broker in a separate thread."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"üõ†Ô∏èüü¢ Entering '{current_function_name}' to connect MQTT client.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=self._print_to_gui_console
        )
        try:
            self.mqtt_client = mqtt.Client()
            self.mqtt_client.on_connect = self.on_connect
            self.mqtt_client.on_message = self.on_message
            self.mqtt_client.connect(host=BROKER_ADDRESS, port=BROKER_PORT, keepalive=BROKER_TIMEOUT)
            
            thread = threading.Thread(target=self.mqtt_client.loop_forever, daemon=True)
            thread.start()
            self._print_to_gui_console("‚úÖ MQTT client connection initiated in a background thread.")

        except Exception as e:
            self._print_to_gui_console(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self._print_to_gui_console
            )

    def show_topics(self):
        """Displays a list of all topics seen by the MQTT client."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"üõ†Ô∏èüü¢ Entering '{current_function_name}' to display topics.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=self._print_to_gui_console
        )
        try:
            if self.topics_seen:
                topics_str = "\n".join(sorted(self.topics_seen))
                self._print_to_gui_console(f"Observed Topics:\n{topics_str}")
            else:
                self._print_to_gui_console("‚ö†Ô∏è No topics observed yet.")

        except Exception as e:
            self._print_to_gui_console(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self._print_to_gui_console
            )

    def publish_message(self, topic: str, subtopic: str, value: float):
        """Publishes a message to a topic via the MQTT client."""
        # A brief, one-sentence description of the function's purpose.
        current_function_name = inspect.currentframe().f_code.co_name
        debug_log(
            message=f"üõ†Ô∏èüü¢ Entering '{current_function_name}' to publish a message.",
            file=current_file,
            version=current_version,
            function=f"{self.__class__.__name__}.{current_function_name}",
            console_print_func=self._print_to_gui_console
        )
        try:
            if not topic or not subtopic:
                self._print_to_gui_console(f"‚ùå {NO_TOPIC_OR_VALUE_MSG}")
                return

            full_topic = f"{topic}/{subtopic}"
            payload = json.dumps({"value": value})

            if self.mqtt_client:
                self.mqtt_client.publish(full_topic, payload)
                self._print_to_gui_console(f"Published to {full_topic}: {payload}")
                console_log(f"‚úÖ Published message to topic '{full_topic}'.")
            else:
                self._print_to_gui_console(f"‚ùå {NOT_CONNECTED_MSG}")

        except Exception as e:
            self._print_to_gui_console(f"‚ùå Error in {current_function_name}: {e}")
            debug_log(
                message=f"‚ùåüî¥ Arrr, the code be capsized! The error be: {e}",
                file=current_file,
                version=current_version,
                function=f"{self.__class__.__name__}.{current_function_name}",
                console_print_func=self._print_to_gui_console
            )


